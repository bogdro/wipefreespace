diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/attrib.h ./include/ntfs/attrib.h
--- ../ntfsprogs-2.0.0/include/ntfs/attrib.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/attrib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,380 +0,0 @@
-/*
- * attrib.h - Exports for attribute handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2004 Anton Altaparmakov
- * Copyright (c) 2004-2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_ATTRIB_H
-#define _NTFS_ATTRIB_H
-
-/* Forward declarations */
-typedef struct _ntfs_attr ntfs_attr;
-typedef struct _ntfs_attr_search_ctx ntfs_attr_search_ctx;
-
-#include "list.h"
-#include "types.h"
-#include "inode.h"
-#include "unistr.h"
-#include "runlist.h"
-#include "volume.h"
-#include "debug.h"
-#include "logging.h"
-#include "crypto.h"
-
-extern ntfschar AT_UNNAMED[];
-
-/**
- * enum ntfs_lcn_special_values - special return values for ntfs_*_vcn_to_lcn()
- *
- * Special return values for ntfs_rl_vcn_to_lcn() and ntfs_attr_vcn_to_lcn().
- *
- * TODO: Describe them.
- */
-typedef enum {
-	LCN_HOLE		= -1,	/* Keep this as highest value or die! */
-	LCN_RL_NOT_MAPPED	= -2,
-	LCN_ENOENT		= -3,
-	LCN_EINVAL		= -4,
-	LCN_EIO			= -5,
-} ntfs_lcn_special_values;
-
-/**
- * struct ntfs_attr_search_ctx - search context used in attribute search functions
- * @mrec:	buffer containing mft record to search
- * @attr:	attribute record in @mrec where to begin/continue search
- * @is_first:	if true lookup_attr() begins search with @attr, else after @attr
- *
- * Structure must be initialized to zero before the first call to one of the
- * attribute search functions. Initialize @mrec to point to the mft record to
- * search, and @attr to point to the first attribute within @mrec (not necessary
- * if calling the _first() functions), and set @is_first to TRUE (not necessary
- * if calling the _first() functions).
- *
- * If @is_first is TRUE, the search begins with @attr. If @is_first is FALSE,
- * the search begins after @attr. This is so that, after the first call to one
- * of the search attribute functions, we can call the function again, without
- * any modification of the search context, to automagically get the next
- * matching attribute.
- */
-struct _ntfs_attr_search_ctx {
-	MFT_RECORD *mrec;
-	ATTR_RECORD *attr;
-	BOOL is_first;
-	ntfs_inode *ntfs_ino;
-	ATTR_LIST_ENTRY *al_entry;
-	ntfs_inode *base_ntfs_ino;
-	MFT_RECORD *base_mrec;
-	ATTR_RECORD *base_attr;
-};
-
-extern void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx);
-extern ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni,
-		MFT_RECORD *mrec);
-extern void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx);
-
-extern int ntfs_attr_lookup(const ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const VCN lowest_vcn, const u8 *val, const u32 val_len,
-		ntfs_attr_search_ctx *ctx);
-
-extern ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,
-		const ATTR_TYPES type);
-
-/**
- * ntfs_attrs_walk - syntactic sugar for walking all attributes in an inode
- * @ctx:	initialised attribute search context
- *
- * Syntactic sugar for walking attributes in an inode.
- *
- * Return 0 on success and -1 on error with errno set to the error code from
- * ntfs_attr_lookup().
- *
- * Example: When you want to enumerate all attributes in an open ntfs inode
- *	    @ni, you can simply do:
- *
- *	int err;
- *	ntfs_attr_search_ctx *ctx = ntfs_attr_get_search_ctx(ni, NULL);
- *	if (!ctx)
- *		// Error code is in errno. Handle this case.
- *	while (!(err = ntfs_attrs_walk(ctx))) {
- *		ATTR_RECORD *attr = ctx->attr;
- *		// attr now contains the next attribute. Do whatever you want
- *		// with it and then just continue with the while loop.
- *	}
- *	if (err && errno != ENOENT)
- *		// Ooops. An error occurred! You should handle this case.
- *	// Now finished with all attributes in the inode.
- */
-static __inline__ int ntfs_attrs_walk(ntfs_attr_search_ctx *ctx)
-{
-	return ntfs_attr_lookup(AT_UNUSED, NULL, 0, CASE_SENSITIVE, 0,
-			NULL, 0, ctx);
-}
-
-/**
- * struct ntfs_attr - ntfs in memory non-resident attribute structure
- * @rl:			if not NULL, the decompressed runlist
- * @ni:			base ntfs inode to which this attribute belongs
- * @type:		attribute type
- * @name:		Unicode name of the attribute
- * @name_len:		length of @name in Unicode characters
- * @state:		NTFS attribute specific flags describing this attribute
- * @allocated_size:	copy from the attribute record
- * @data_size:		copy from the attribute record
- * @initialized_size:	copy from the attribute record
- * @compressed_size:	copy from the attribute record
- * @compression_block_size:		size of a compression block (cb)
- * @compression_block_size_bits:	log2 of the size of a cb
- * @compression_block_clusters:		number of clusters per cb
- * @crypto:		(valid only for encrypted) see description below
- *
- * This structure exists purely to provide a mechanism of caching the runlist
- * of an attribute. If you want to operate on a particular attribute extent,
- * you should not be using this structure at all. If you want to work with a
- * resident attribute, you should not be using this structure at all. As a
- * fail-safe check make sure to test NAttrNonResident() and if it is false, you
- * know you shouldn't be using this structure.
- *
- * If you want to work on a resident attribute or on a specific attribute
- * extent, you should use ntfs_lookup_attr() to retrieve the attribute (extent)
- * record, edit that, and then write back the mft record (or set the
- * corresponding ntfs inode dirty for delayed write back).
- *
- * @rl is the decompressed runlist of the attribute described by this
- * structure. Obviously this only makes sense if the attribute is not resident,
- * i.e. NAttrNonResident() is true. If the runlist hasn't been decompressed yet
- * @rl is NULL, so be prepared to cope with @rl == NULL.
- *
- * @ni is the base ntfs inode of the attribute described by this structure.
- *
- * @type is the attribute type (see layout.h for the definition of ATTR_TYPES),
- * @name and @name_len are the little endian Unicode name and the name length
- * in Unicode characters of the attribute, respectively.
- *
- * @state contains NTFS attribute specific flags describing this attribute
- * structure. See ntfs_attr_state_bits above.
- *
- * @crypto points to private structure of crypto code. You should not access
- * fields of this structure, but you can check whether it is NULL or not. If it
- * is not NULL, then we successfully obtained FEK (File Encryption Key) and
- * ntfs_attr_p{read,write} calls probably would succeed. If it is NULL, then we
- * failed to obtain FEK (do not have corresponding PFX file, wrong password,
- * etc..) or library was compiled without crypto support. Attribute size can be
- * changed without knowledge of FEK, so you can use ntfs_attr_truncate in any
- * case.
- * NOTE: This field valid only if attribute encrypted (eg., NAttrEncrypted
- * returns non-zero).
- */
-struct _ntfs_attr {
-	runlist_element *rl;
-	ntfs_inode *ni;
-	ATTR_TYPES type;
-	ntfschar *name;
-	u32 name_len;
-	unsigned long state;
-	s64 allocated_size;
-	s64 data_size;
-	s64 initialized_size;
-	s64 compressed_size;
-	u32 compression_block_size;
-	u8 compression_block_size_bits;
-	u8 compression_block_clusters;
-	ntfs_crypto_attr *crypto;
-	struct list_head list_entry;
-	int nr_references;
-};
-
-/**
- * enum ntfs_attr_state_bits - bits for the state field in the ntfs_attr
- * structure
- */
-typedef enum {
-	NA_Initialized,		/* 1: structure is initialized. */
-	NA_NonResident,		/* 1: Attribute is not resident. */
-} ntfs_attr_state_bits;
-
-#define  test_nattr_flag(na, flag)	 test_bit(NA_##flag, (na)->state)
-#define   set_nattr_flag(na, flag)	  set_bit(NA_##flag, (na)->state)
-#define clear_nattr_flag(na, flag)	clear_bit(NA_##flag, (na)->state)
-
-#define NAttrInitialized(na)		 test_nattr_flag(na, Initialized)
-#define NAttrSetInitialized(na)		  set_nattr_flag(na, Initialized)
-#define NAttrClearInitialized(na)	clear_nattr_flag(na, Initialized)
-
-#define NAttrNonResident(na)		 test_nattr_flag(na, NonResident)
-#define NAttrSetNonResident(na)		  set_nattr_flag(na, NonResident)
-#define NAttrClearNonResident(na)	clear_nattr_flag(na, NonResident)
-
-#define GenNAttrIno(func_name,flag)					\
-static inline int NAttr##func_name(ntfs_attr *na)			\
-{									\
-	if (na->type == AT_DATA && na->name == AT_UNNAMED)		\
-		return (na->ni->flags & FILE_ATTR_##flag) ? 1 : 0;	\
-	return 0;							\
-}									\
-static inline void NAttrSet##func_name(ntfs_attr *na)			\
-{									\
-	if (na->type == AT_DATA && na->name == AT_UNNAMED)		\
-		na->ni->flags |= FILE_ATTR_##flag;			\
-	else								\
-		ntfs_log_trace("BUG! Should be called only for "	\
-				"unnamed data attribute.\n");		\
-}									\
-static inline void NAttrClear##func_name(ntfs_attr *na)			\
-{									\
-	if (na->type == AT_DATA && na->name == AT_UNNAMED)		\
-		na->ni->flags &= ~FILE_ATTR_##flag;			\
-}
-
-GenNAttrIno(Compressed, COMPRESSED)
-GenNAttrIno(Encrypted, ENCRYPTED)
-GenNAttrIno(Sparse, SPARSE_FILE)
-
-/**
- * union attr_val - Union of all known attribute values
- *
- * For convenience. Used in the attr structure.
- */
-typedef union {
-	u8 _default;	/* Unnamed u8 to serve as default when just using
-			   a_val without specifying any of the below. */
-	STANDARD_INFORMATION std_inf;
-	ATTR_LIST_ENTRY al_entry;
-	FILE_NAME_ATTR filename;
-	OBJECT_ID_ATTR obj_id;
-	SECURITY_DESCRIPTOR_ATTR sec_desc;
-	VOLUME_NAME vol_name;
-	VOLUME_INFORMATION vol_inf;
-	DATA_ATTR data;
-	INDEX_ROOT index_root;
-	INDEX_BLOCK index_blk;
-	BITMAP_ATTR bmp;
-	REPARSE_POINT reparse;
-	EA_INFORMATION ea_inf;
-	EA_ATTR ea;
-	PROPERTY_SET property_set;
-	LOGGED_UTILITY_STREAM logged_util_stream;
-	EFS_ATTR_HEADER efs;
-} attr_val;
-
-extern void ntfs_attr_init(ntfs_attr *na, const BOOL non_resident,
-		const BOOL compressed, const BOOL encrypted, const BOOL sparse,
-		const s64 allocated_size, const s64 data_size,
-		const s64 initialized_size, const s64 compressed_size,
-		const u8 compression_unit);
-
-extern ntfs_attr *ntfs_attr_open(ntfs_inode *ni, const ATTR_TYPES type,
-		ntfschar *name, u32 name_len);
-extern void ntfs_attr_close(ntfs_attr *na);
-
-extern s64 ntfs_attr_pread(ntfs_attr *na, const s64 pos, s64 count,
-		void *b);
-extern s64 ntfs_attr_pwrite(ntfs_attr *na, const s64 pos, s64 count,
-		const void *b);
-
-extern void *ntfs_attr_readall(ntfs_inode *ni, const ATTR_TYPES type,
-			       ntfschar *name, u32 name_len, s64 *data_size);
-
-extern s64 ntfs_attr_mst_pread(ntfs_attr *na, const s64 pos,
-		const s64 bk_cnt, const u32 bk_size, void *dst);
-extern s64 ntfs_attr_mst_pwrite(ntfs_attr *na, const s64 pos,
-		s64 bk_cnt, const u32 bk_size, void *src);
-
-extern int ntfs_attr_map_runlist(ntfs_attr *na, VCN vcn);
-extern int ntfs_attr_map_runlist_range(ntfs_attr *na, VCN from_vcn, VCN to_vcn);
-extern int ntfs_attr_map_whole_runlist(ntfs_attr *na);
-
-extern LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const VCN vcn);
-extern runlist_element *ntfs_attr_find_vcn(ntfs_attr *na, const VCN vcn);
-
-extern int ntfs_attr_size_bounds_check(const ntfs_volume *vol,
-		const ATTR_TYPES type, const s64 size);
-extern int ntfs_attr_can_be_non_resident(const ntfs_volume *vol,
-		const ATTR_TYPES type);
-extern int ntfs_attr_can_be_resident(const ntfs_volume *vol,
-		const ATTR_TYPES type);
-
-extern int ntfs_make_room_for_attr(MFT_RECORD *m, u8 *pos, u32 size);
-
-extern int ntfs_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,
-		ntfschar *name, u8 name_len, u8 *val, u32 size,
-		ATTR_FLAGS flags);
-extern int ntfs_non_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,
-		ntfschar *name, u8 name_len, VCN lowest_vcn, int dataruns_size,
-		ATTR_FLAGS flags);
-extern int ntfs_attr_record_rm(ntfs_attr_search_ctx *ctx);
-
-extern int ntfs_attr_add(ntfs_inode *ni, ATTR_TYPES type,
-		ntfschar *name, u8 name_len, u8 *val, s64 size);
-extern int ntfs_attr_rm(ntfs_attr *na);
-
-extern int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size);
-
-extern int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,
-		const u32 new_size);
-
-extern int ntfs_attr_record_move_to(ntfs_attr_search_ctx *ctx, ntfs_inode *ni);
-extern int ntfs_attr_record_move_away(ntfs_attr_search_ctx *ctx, int extra);
-
-extern int ntfs_attr_update_mapping_pairs(ntfs_attr *na, VCN from_vcn);
-
-extern int __ntfs_attr_truncate(ntfs_attr *na, const s64 newsize, BOOL sparse);
-extern int ntfs_attr_truncate(ntfs_attr *na, const s64 newsize);
-
-extern int ntfs_attr_exist(ntfs_inode *ni, const ATTR_TYPES type,
-		ntfschar *name, u32 name_len);
-
-static __inline__ ntfschar *ntfs_attr_get_name(ATTR_RECORD *attr)
-{
-	return (ntfschar*)((u8*)attr + le16_to_cpu(attr->name_offset));
-}
-
-// FIXME / TODO: Above here the file is cleaned up. (AIA)
-/**
- * get_attribute_value_length - return the length of the value of an attribute
- * @a:	pointer to a buffer containing the attribute record
- *
- * Return the byte size of the attribute value of the attribute @a (as it
- * would be after eventual decompression and filling in of holes if sparse).
- * If we return 0, check errno. If errno is 0 the actual length was 0,
- * otherwise errno describes the error.
- *
- * FIXME: Describe possible errnos.
- */
-s64 ntfs_get_attribute_value_length(const ATTR_RECORD *a);
-
-/**
- * get_attribute_value - return the attribute value of an attribute
- * @vol:	volume on which the attribute is present
- * @a:		attribute to get the value of
- * @b:		destination buffer for the attribute value
- *
- * Make a copy of the attribute value of the attribute @a into the destination
- * buffer @b. Note, that the size of @b has to be at least equal to the value
- * returned by get_attribute_value_length(@a).
- *
- * Return number of bytes copied. If this is zero check errno. If errno is 0
- * then nothing was read due to a zero-length attribute value, otherwise
- * errno describes the error.
- */
-s64 ntfs_get_attribute_value(const ntfs_volume *vol, const ATTR_RECORD *a,
-		u8 *b);
-
-#endif /* defined _NTFS_ATTRIB_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/attrlist.h ./include/ntfs/attrlist.h
--- ../ntfsprogs-2.0.0/include/ntfs/attrlist.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/attrlist.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
- * attrlist.h - Exports for attribute list attribute handling.  Part of the
- *		Linux-NTFS project.
- *
- * Copyright (c) 2004 Anton Altaparmakov
- * Copyright (c) 2004 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_ATTRLIST_H
-#define _NTFS_ATTRLIST_H
-
-#include "attrib.h"
-
-extern int ntfs_attrlist_need(ntfs_inode *ni);
-
-extern int ntfs_attrlist_entry_add(ntfs_inode *ni, ATTR_RECORD *attr);
-extern int ntfs_attrlist_entry_rm(ntfs_attr_search_ctx *ctx);
-
-/**
- * ntfs_attrlist_mark_dirty - set the attribute list dirty
- * @ni:		ntfs inode which base inode contain dirty attribute list
- *
- * Set the attribute list dirty so it is written out later (at the latest at
- * ntfs_inode_close() time).
- *
- * This function cannot fail.
- */
-static __inline__ void ntfs_attrlist_mark_dirty(ntfs_inode *ni)
-{
-	if (ni->nr_extents == -1)
-		NInoAttrListSetDirty(ni->base_ni);
-	else
-		NInoAttrListSetDirty(ni);
-}
-
-#endif /* defined _NTFS_ATTRLIST_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/bitmap.h ./include/ntfs/bitmap.h
--- ../ntfsprogs-2.0.0/include/ntfs/bitmap.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/bitmap.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,134 +0,0 @@
-/*
- * bitmap.h - Exports for bitmap handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2004 Anton Altaparmakov
- * Copyright (c) 2004-2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_BITMAP_H
-#define _NTFS_BITMAP_H
-
-#include "types.h"
-#include "attrib.h"
-
-/*
- * NOTES:
- *
- * - Operations are 8-bit only to ensure the functions work both on little
- *   and big endian machines! So don't make them 32-bit ops!
- * - bitmap starts at bit = 0 and ends at bit = bitmap size - 1.
- * - _Caller_ has to make sure that the bit to operate on is less than the
- *   size of the bitmap.
- */
-
-/**
- * ntfs_bit_set - set a bit in a field of bits
- * @bitmap:	field of bits
- * @bit:	bit to set
- * @new_value:	value to set bit to (0 or 1)
- *
- * Set the bit @bit in the @bitmap to @new_value. Ignore all errors.
- */
-static __inline__ void ntfs_bit_set(u8 *bitmap, const u64 bit,
-		const u8 new_value)
-{
-	if (!bitmap || new_value > 1)
-		return;
-	if (!new_value)
-		bitmap[bit >> 3] &= ~(1 << (bit & 7));
-	else
-		bitmap[bit >> 3] |= (1 << (bit & 7));
-}
-
-/**
- * ntfs_bit_get - get value of a bit in a field of bits
- * @bitmap:	field of bits
- * @bit:	bit to get
- *
- * Get and return the value of the bit @bit in @bitmap (0 or 1).
- * Return -1 on error.
- */
-static __inline__ char ntfs_bit_get(const u8 *bitmap, const u64 bit)
-{
-	if (!bitmap)
-		return -1;
-	return (bitmap[bit >> 3] >> (bit & 7)) & 1;
-}
-
-static __inline__ void ntfs_bit_change(u8 *bitmap, const u64 bit)
-{
-	if (!bitmap)
-		return;
-	bitmap[bit >> 3] ^= 1 << (bit & 7);
-}
-
-/**
- * ntfs_bit_get_and_set - get value of a bit in a field of bits and set it
- * @bitmap:	field of bits
- * @bit:	bit to get/set
- * @new_value:	value to set bit to (0 or 1)
- *
- * Return the value of the bit @bit and set it to @new_value (0 or 1).
- * Return -1 on error.
- */
-static __inline__ char ntfs_bit_get_and_set(u8 *bitmap, const u64 bit,
-		const u8 new_value)
-{
-	register u8 old_bit, shift;
-
-	if (!bitmap || new_value > 1)
-		return -1;
-	shift = bit & 7;
-	old_bit = (bitmap[bit >> 3] >> shift) & 1;
-	if (new_value != old_bit)
-		bitmap[bit >> 3] ^= 1 << shift;
-	return old_bit;
-}
-
-extern int ntfs_bitmap_set_run(ntfs_attr *na, s64 start_bit, s64 count);
-extern int ntfs_bitmap_clear_run(ntfs_attr *na, s64 start_bit, s64 count);
-
-/**
- * ntfs_bitmap_set_bit - set a bit in a bitmap
- * @na:		attribute containing the bitmap
- * @bit:	bit to set
- *
- * Set the @bit in the bitmap described by the attribute @na.
- *
- * On success return 0 and on error return -1 with errno set to the error code.
- */
-static __inline__ int ntfs_bitmap_set_bit(ntfs_attr *na, s64 bit)
-{
-	return ntfs_bitmap_set_run(na, bit, 1);
-}
-
-/**
- * ntfs_bitmap_clear_bit - clear a bit in a bitmap
- * @na:		attribute containing the bitmap
- * @bit:	bit to clear
- *
- * Clear @bit in the bitmap described by the attribute @na.
- *
- * On success return 0 and on error return -1 with errno set to the error code.
- */
-static __inline__ int ntfs_bitmap_clear_bit(ntfs_attr *na, s64 bit)
-{
-	return ntfs_bitmap_clear_run(na, bit, 1);
-}
-
-#endif /* defined _NTFS_BITMAP_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/bootsect.h ./include/ntfs/bootsect.h
--- ../ntfsprogs-2.0.0/include/ntfs/bootsect.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/bootsect.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/*
- * bootsect.h - Exports for bootsector record handling. Part of the Linux-NTFS
- *		project.
- *
- * Copyright (c) 2000-2002 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_BOOTSECT_H
-#define _NTFS_BOOTSECT_H
-
-#include "types.h"
-#include "volume.h"
-#include "layout.h"
-
-/**
- * is_boot_sector_ntfs - check a boot sector for describing an ntfs volume
- * @b:		buffer containing the boot sector
- * @silent:	if 1 don't display progress information
- *
- * This function checks the boot sector in @b for describing a valid ntfs
- * volume. Return TRUE if @b is a valid NTFS boot sector or FALSE otherwise.
- * If silent is FALSE, progress output will be output to stdout. If silent is
- * TRUE no output to stdout will occur. Errors/warnings to stderr will occur
- * disregarding the value of silent (but only if configure was run with
- * --enable-debug).
- */
-extern BOOL ntfs_boot_sector_is_ntfs(NTFS_BOOT_SECTOR *b, BOOL silent);
-extern int ntfs_boot_sector_parse(ntfs_volume *vol,
-		const NTFS_BOOT_SECTOR *bs);
-
-#endif /* defined _NTFS_BOOTSECT_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/collate.h ./include/ntfs/collate.h
--- ../ntfsprogs-2.0.0/include/ntfs/collate.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/collate.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/*
- * collate.h - Defines for NTFS collation handling.  Part of the Linux-NTFS
- *             project.
- *
- * Copyright (c) 2004 Anton Altaparmakov
- * Copyright (c) 2005 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_COLLATE_H
-#define _NTFS_COLLATE_H
-
-#include "types.h"
-#include "volume.h"
-
-#define NTFS_COLLATION_ERROR (-2)
-
-extern BOOL ntfs_is_collation_rule_supported(COLLATION_RULES cr);
-
-extern int ntfs_collate(ntfs_volume *vol, COLLATION_RULES cr,
-		const void *data1, size_t data1_len,
-		const void *data2, size_t data2_len);
-
-#endif /* _NTFS_COLLATE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/compat.h ./include/ntfs/compat.h
--- ../ntfsprogs-2.0.0/include/ntfs/compat.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/*
- * compat.h - Tweaks for Windows compatibility.
- *
- * Copyright (c) 2002 Richard Russon
- * Copyright (c) 2002-2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_COMPAT_H
-#define _NTFS_COMPAT_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef WINDOWS
-
-#ifndef HAVE_FFS
-#define HAVE_FFS
-extern int ffs(int i);
-#endif /* HAVE_FFS */
-
-#define HAVE_STDIO_H		/* mimic config.h */
-#define HAVE_STDARG_H
-
-#define atoll			_atoi64
-#define fdatasync		commit
-#define __inline__		inline
-#define __attribute__(X)	/*nothing*/
-
-#else /* !defined WINDOWS */
-
-#ifndef O_BINARY
-#define O_BINARY		0		/* unix is binary by default */
-#endif
-
-#endif /* defined WINDOWS */
-
-#endif /* defined _NTFS_COMPAT_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/compress.h ./include/ntfs/compress.h
--- ../ntfsprogs-2.0.0/include/ntfs/compress.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/compress.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/*
- * compress.h - Exports for compressed attribute handling. Part of the
- *		Linux-NTFS project.
- *
- * Copyright (c) 2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_COMPRESS_H
-#define _NTFS_COMPRESS_H
-
-#include "types.h"
-#include "attrib.h"
-
-extern s64 ntfs_compressed_attr_pread(ntfs_attr *na, s64 pos, s64 count,
-		void *b);
-
-#endif /* defined _NTFS_COMPRESS_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/crypto.h ./include/ntfs/crypto.h
--- ../ntfsprogs-2.0.0/include/ntfs/crypto.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/crypto.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-/**
- * crypto.h - Exports for dealing with encrypted files.  Part of the
- *            Linux-NTFS project.
- *
- * Copyright (c) 2007 Yura Pakhuchiy
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_CRYPTO_H
-#define _NTFS_CRYPTO_H
-
-extern ntfschar NTFS_EFS[5];
-
-/*
- * This is our Big Secret (TM) structure, so do not allow anyone even read it
- * values. ;-) In fact, it is private because exist only in libntfs version
- * compiled with cryptography support, so users can not depend on it.
- */
-typedef struct _ntfs_crypto_attr ntfs_crypto_attr;
-
-/*
- * These functions should not be used directly. They are called for encrypted
- * attributes from corresponding functions without _crypto_ part.
- */
-
-extern int ntfs_crypto_attr_open(ntfs_attr *na);
-extern void ntfs_crypto_attr_close(ntfs_attr *na);
-
-extern s64 ntfs_crypto_attr_pread(ntfs_attr *na, const s64 pos, s64 count,
-		void *b);
-
-#endif /* _NTFS_CRYPTO_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/debug.h ./include/ntfs/debug.h
--- ../ntfsprogs-2.0.0/include/ntfs/debug.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/debug.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,49 +0,0 @@
-/*
- * debug.h - Debugging output functions. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2002-2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_DEBUG_H
-#define _NTFS_DEBUG_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "logging.h"
-
-struct _runlist_element;
-
-#ifndef DEBUG
-static __inline__ void ntfs_debug_runlist_dump(const struct _runlist_element *rl __attribute__((unused))) {}
-#define NTFS_ON_DEBUG(x)
-#else
-extern void ntfs_debug_runlist_dump(const struct _runlist_element *rl);
-#define NTFS_ON_DEBUG(x) (x)
-#endif
-
-#define NTFS_BUG(msg)							\
-{									\
-	int ___i;							\
-	ntfs_log_critical("Bug in %s(): %s\n", __FUNCTION__, msg);	\
-	ntfs_log_debug("Forcing segmentation fault!");			\
-	___i = ((int*)NULL)[1];						\
-}
-
-#endif /* defined _NTFS_DEBUG_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/device.h ./include/ntfs/device.h
--- ../ntfsprogs-2.0.0/include/ntfs/device.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/device.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-/*
- * device.h - Exports for low level device io. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2006 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_DEVICE_H
-#define _NTFS_DEVICE_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "device_io.h"
-#include "types.h"
-#include "support.h"
-#include "volume.h"
-
-/**
- * enum ntfs_device_state_bits -
- *
- * Defined bits for the state field in the ntfs_device structure.
- */
-typedef enum {
-	ND_Open,	/* 1: Device is open. */
-	ND_ReadOnly,	/* 1: Device is read-only. */
-	ND_Dirty,	/* 1: Device is dirty, needs sync. */
-	ND_Block,	/* 1: Device is a block device. */
-} ntfs_device_state_bits;
-
-#define  test_ndev_flag(nd, flag)	   test_bit(ND_##flag, (nd)->d_state)
-#define   set_ndev_flag(nd, flag)	    set_bit(ND_##flag, (nd)->d_state)
-#define clear_ndev_flag(nd, flag)	  clear_bit(ND_##flag, (nd)->d_state)
-
-#define NDevOpen(nd)		 test_ndev_flag(nd, Open)
-#define NDevSetOpen(nd)		  set_ndev_flag(nd, Open)
-#define NDevClearOpen(nd)	clear_ndev_flag(nd, Open)
-
-#define NDevReadOnly(nd)	 test_ndev_flag(nd, ReadOnly)
-#define NDevSetReadOnly(nd)	  set_ndev_flag(nd, ReadOnly)
-#define NDevClearReadOnly(nd)	clear_ndev_flag(nd, ReadOnly)
-
-#define NDevDirty(nd)		 test_ndev_flag(nd, Dirty)
-#define NDevSetDirty(nd)	  set_ndev_flag(nd, Dirty)
-#define NDevClearDirty(nd)	clear_ndev_flag(nd, Dirty)
-
-#define NDevBlock(nd)		 test_ndev_flag(nd, Block)
-#define NDevSetBlock(nd)	  set_ndev_flag(nd, Block)
-#define NDevClearBlock(nd)	clear_ndev_flag(nd, Block)
-
-/**
- * struct ntfs_device -
- *
- * The ntfs device structure defining all operations needed to access the low
- * level device underlying the ntfs volume.
- */
-struct ntfs_device {
-	struct ntfs_device_operations *d_ops;	/* Device operations. */
-	unsigned long d_state;			/* State of the device. */
-	char *d_name;				/* Name of device. */
-	void *d_private;			/* Private data used by the
-						   device operations. */
-};
-
-struct stat;
-
-/**
- * struct ntfs_device_operations -
- *
- * The ntfs device operations defining all operations that can be performed on
- * the low level device described by an ntfs device structure.
- */
-struct ntfs_device_operations {
-	int (*open)(struct ntfs_device *dev, int flags);
-	int (*close)(struct ntfs_device *dev);
-	s64 (*seek)(struct ntfs_device *dev, s64 offset, int whence);
-	s64 (*read)(struct ntfs_device *dev, void *buf, s64 count);
-	s64 (*write)(struct ntfs_device *dev, const void *buf, s64 count);
-	s64 (*pread)(struct ntfs_device *dev, void *buf, s64 count, s64 offset);
-	s64 (*pwrite)(struct ntfs_device *dev, const void *buf, s64 count,
-			s64 offset);
-	int (*sync)(struct ntfs_device *dev);
-	int (*stat)(struct ntfs_device *dev, struct stat *buf);
-	int (*ioctl)(struct ntfs_device *dev, int request, void *argp);
-};
-
-extern struct ntfs_device *ntfs_device_alloc(const char *name, const long state,
-		struct ntfs_device_operations *dops, void *priv_data);
-extern int ntfs_device_free(struct ntfs_device *dev);
-
-extern s64 ntfs_pread(struct ntfs_device *dev, const s64 pos, s64 count,
-		void *b);
-extern s64 ntfs_pwrite(struct ntfs_device *dev, const s64 pos, s64 count,
-		const void *b);
-
-extern s64 ntfs_mst_pread(struct ntfs_device *dev, const s64 pos, s64 count,
-		const u32 bksize, void *b);
-extern s64 ntfs_mst_pwrite(struct ntfs_device *dev, const s64 pos, s64 count,
-		const u32 bksize, void *b);
-
-extern s64 ntfs_cluster_read(const ntfs_volume *vol, const s64 lcn,
-		const s64 count, void *b);
-extern s64 ntfs_cluster_write(const ntfs_volume *vol, const s64 lcn,
-		const s64 count, const void *b);
-
-extern s64 ntfs_device_size_get(struct ntfs_device *dev, int block_size);
-extern s64 ntfs_device_partition_start_sector_get(struct ntfs_device *dev);
-extern int ntfs_device_heads_get(struct ntfs_device *dev);
-extern int ntfs_device_sectors_per_track_get(struct ntfs_device *dev);
-extern int ntfs_device_sector_size_get(struct ntfs_device *dev);
-extern int ntfs_device_block_size_set(struct ntfs_device *dev, int block_size);
-
-#endif /* defined _NTFS_DEVICE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/device_io.h ./include/ntfs/device_io.h
--- ../ntfsprogs-2.0.0/include/ntfs/device_io.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/device_io.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
- * device_io.h - Exports for default device io. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2006 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_DEVICE_IO_H
-#define _NTFS_DEVICE_IO_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifndef NO_NTFS_DEVICE_DEFAULT_IO_OPS
-
-#ifndef __CYGWIN32__
-
-/* Not on Cygwin; use standard Unix style low level device operations. */
-#define ntfs_device_default_io_ops ntfs_device_unix_io_ops
-
-#else /* __CYGWIN32__ */
-
-#ifndef HDIO_GETGEO
-#	define HDIO_GETGEO	0x301
-/**
- * struct hd_geometry -
- */
-struct hd_geometry {
-	unsigned char heads;
-	unsigned char sectors;
-	unsigned short cylinders;
-	unsigned long start;
-};
-#endif
-#ifndef BLKGETSIZE
-#	define BLKGETSIZE	0x1260
-#endif
-#ifndef BLKSSZGET
-#	define BLKSSZGET	0x1268
-#endif
-#ifndef BLKGETSIZE64
-#	define BLKGETSIZE64	0x80041272
-#endif
-#ifndef BLKBSZSET
-#	define BLKBSZSET	0x40041271
-#endif
-
-/* On Cygwin; use Win32 low level device operations. */
-#define ntfs_device_default_io_ops ntfs_device_win32_io_ops
-
-#endif /* __CYGWIN32__ */
-
-
-/* Forward declaration. */
-struct ntfs_device_operations;
-
-extern struct ntfs_device_operations ntfs_device_default_io_ops;
-
-#endif /* NO_NTFS_DEVICE_DEFAULT_IO_OPS */
-
-#endif /* defined _NTFS_DEVICE_IO_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/dir.h ./include/ntfs/dir.h
--- ../ntfsprogs-2.0.0/include/ntfs/dir.h	2007-09-27 14:27:46.000000000 +0200
+++ ./include/ntfs/dir.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/*
- * dir.h - Exports for directory handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2002 Anton Altaparmakov
- * Copyright (c) 2005-2006 Yura Pakhuchiy
- * Copyright (c) 2004-2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_DIR_H
-#define _NTFS_DIR_H
-
-#include "types.h"
-
-#define PATH_SEP '/'
-
-#ifndef MAX_PATH
-#define MAX_PATH 1024
-#endif
-
-/*
- * We do not have these under DJGPP, so define our version that do not conflict
- * with other S_IFs defined under DJGPP.
- */
-#ifdef DJGPP
-#ifndef S_IFLNK
-#define S_IFLNK  0120000
-#endif
-#ifndef S_ISLNK
-#define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)
-#endif
-#ifndef S_IFSOCK
-#define S_IFSOCK 0140000
-#endif
-#ifndef S_ISSOCK
-#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
-#endif
-#endif
-
-/*
- * The little endian Unicode strings $I30, $SII, $SDH, $O, $Q, $R
- * as a global constant.
- */
-extern ntfschar NTFS_INDEX_I30[5];
-extern ntfschar NTFS_INDEX_SII[5];
-extern ntfschar NTFS_INDEX_SDH[5];
-extern ntfschar NTFS_INDEX_O[3];
-extern ntfschar NTFS_INDEX_Q[3];
-extern ntfschar NTFS_INDEX_R[3];
-
-extern u64 ntfs_inode_lookup_by_name(ntfs_inode *dir_ni,
-		const ntfschar *uname, const int uname_len);
-
-extern u64 ntfs_pathname_to_inode_num(ntfs_volume *vol, ntfs_inode *parent,
-		const char *pathname);
-extern ntfs_inode *ntfs_pathname_to_inode(ntfs_volume *vol, ntfs_inode *parent,
-		const char *pathname);
-
-extern ntfs_inode *ntfs_create(ntfs_inode *dir_ni, ntfschar *name, u8 name_len,
-		dev_t type);
-extern ntfs_inode *ntfs_create_device(ntfs_inode *dir_ni,
-		ntfschar *name, u8 name_len, dev_t type, dev_t dev);
-extern ntfs_inode *ntfs_create_symlink(ntfs_inode *dir_ni,
-		ntfschar *name, u8 name_len, ntfschar *target, u8 target_len);
-
-extern int ntfs_delete(ntfs_inode **pni, ntfs_inode *dir_ni, ntfschar *name,
-		u8 name_len);
-
-extern int ntfs_link(ntfs_inode *ni, ntfs_inode *dir_ni, ntfschar *name,
-		u8 name_len);
-
-/*
- * File types (adapted from include <linux/fs.h>)
- */
-#define NTFS_DT_UNKNOWN		0
-#define NTFS_DT_FIFO		1
-#define NTFS_DT_CHR		2
-#define NTFS_DT_DIR		4
-#define NTFS_DT_BLK		6
-#define NTFS_DT_REG		8
-#define NTFS_DT_LNK		10
-#define NTFS_DT_SOCK		12
-#define NTFS_DT_WHT		14
-
-/*
- * This is the "ntfs_filldir" function type, used by ntfs_readdir() to let
- * the caller specify what kind of dirent layout it wants to have.
- * This allows the caller to read directories into their application or
- * to have different dirent layouts depending on the binary type.
- */
-typedef int (*ntfs_filldir_t)(void *dirent, const ntfschar *name,
-		const int name_len, const int name_type, const s64 pos,
-		const MFT_REF mref, const unsigned dt_type);
-
-extern int ntfs_readdir(ntfs_inode *dir_ni, s64 *pos,
-		void *dirent, ntfs_filldir_t filldir);
-
-#endif /* defined _NTFS_DIR_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/endians.h ./include/ntfs/endians.h
--- ../ntfsprogs-2.0.0/include/ntfs/endians.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/endians.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,248 +0,0 @@
-/*
- * endians.h - Definitions related to handling of byte ordering. Part of the
- *	       Linux-NTFS project.
- *
- * Copyright (c) 2000-2005 Anton Altaparmakov
- * Copyright (c)      2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_ENDIANS_H
-#define _NTFS_ENDIANS_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/*
- * Notes:
- *	We define the conversion functions including typecasts since the
- * defaults don't necessarily perform appropriate typecasts.
- *	Also, using our own functions means that we can change them if it
- * turns out that we do need to use the unaligned access macros on
- * architectures requiring aligned memory accesses...
- */
-
-#ifdef HAVE_ENDIAN_H
-#include <endian.h>
-#endif
-#ifdef HAVE_SYS_ENDIAN_H
-#include <sys/endian.h>
-#endif
-#ifdef HAVE_MACHINE_ENDIAN_H
-#include <machine/endian.h>
-#endif
-#ifdef HAVE_SYS_BYTEORDER_H
-#include <sys/byteorder.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-
-#ifndef __BYTE_ORDER
-#	if defined(_BYTE_ORDER)
-#		define __BYTE_ORDER _BYTE_ORDER
-#		define __LITTLE_ENDIAN _LITTLE_ENDIAN
-#		define __BIG_ENDIAN _BIG_ENDIAN
-#	elif defined(BYTE_ORDER)
-#		define __BYTE_ORDER BYTE_ORDER
-#		define __LITTLE_ENDIAN LITTLE_ENDIAN
-#		define __BIG_ENDIAN BIG_ENDIAN
-#	elif defined(__BYTE_ORDER__)
-#		define __BYTE_ORDER __BYTE_ORDER__
-#		define __LITTLE_ENDIAN __LITTLE_ENDIAN__
-#		define __BIG_ENDIAN __BIG_ENDIAN__
-#	elif (defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)) || \
-			defined(WORDS_LITTLEENDIAN)
-#		define __BYTE_ORDER 1
-#		define __LITTLE_ENDIAN 1
-#		define __BIG_ENDIAN 0
-#	elif (!defined(_LITTLE_ENDIAN) && defined(_BIG_ENDIAN)) || \
-			defined(WORDS_BIGENDIAN)
-#		define __BYTE_ORDER 0
-#		define __LITTLE_ENDIAN 1
-#		define __BIG_ENDIAN 0
-#	else
-#		error "__BYTE_ORDER is not defined."
-#	endif
-#endif
-
-#define __ntfs_bswap_constant_16(x)		\
-	  (u16)((((u16)(x) & 0xff00) >> 8) |	\
-		(((u16)(x) & 0x00ff) << 8))
-
-#define __ntfs_bswap_constant_32(x)			\
-	  (u32)((((u32)(x) & 0xff000000u) >> 24) |	\
-		(((u32)(x) & 0x00ff0000u) >>  8) |	\
-		(((u32)(x) & 0x0000ff00u) <<  8) |	\
-		(((u32)(x) & 0x000000ffu) << 24))
-
-#define __ntfs_bswap_constant_64(x)				\
-	  (u64)((((u64)(x) & 0xff00000000000000ull) >> 56) |	\
-		(((u64)(x) & 0x00ff000000000000ull) >> 40) |	\
-		(((u64)(x) & 0x0000ff0000000000ull) >> 24) |	\
-		(((u64)(x) & 0x000000ff00000000ull) >>  8) |	\
-		(((u64)(x) & 0x00000000ff000000ull) <<  8) |	\
-		(((u64)(x) & 0x0000000000ff0000ull) << 24) |	\
-		(((u64)(x) & 0x000000000000ff00ull) << 40) |	\
-		(((u64)(x) & 0x00000000000000ffull) << 56))
-
-#ifdef HAVE_BYTESWAP_H
-#	include <byteswap.h>
-#else
-#	define bswap_16(x) __ntfs_bswap_constant_16(x)
-#	define bswap_32(x) __ntfs_bswap_constant_32(x)
-#	define bswap_64(x) __ntfs_bswap_constant_64(x)
-#endif
-
-#if defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
-
-#define __le16_to_cpu(x) ((__force u16)(x))
-#define __le32_to_cpu(x) ((__force u32)(x))
-#define __le64_to_cpu(x) ((__force u64)(x))
-
-#define __cpu_to_le16(x) ((__force le16)(x))
-#define __cpu_to_le32(x) ((__force le32)(x))
-#define __cpu_to_le64(x) ((__force le64)(x))
-
-#define __constant_le16_to_cpu(x) ((__force u16)(x))
-#define __constant_le32_to_cpu(x) ((__force u32)(x))
-#define __constant_le64_to_cpu(x) ((__force u64)(x))
-
-#define __constant_cpu_to_le16(x) ((__force le16)(x))
-#define __constant_cpu_to_le32(x) ((__force le32)(x))
-#define __constant_cpu_to_le64(x) ((__force le64)(x))
-
-#elif defined(__BIG_ENDIAN) && (__BYTE_ORDER == __BIG_ENDIAN)
-
-#define __le16_to_cpu(x) bswap_16((__force u16)(x))
-#define __le32_to_cpu(x) bswap_32((__force u16)(x))
-#define __le64_to_cpu(x) bswap_64((__force u16)(x))
-
-#define __cpu_to_le16(x) (__force le16)bswap_16((__force u16)(x))
-#define __cpu_to_le32(x) (__force le32)bswap_32((__force u32)(x))
-#define __cpu_to_le64(x) (__force le64)bswap_64((__force u64)(x))
-
-#define __constant_le16_to_cpu(x) __ntfs_bswap_constant_16((__force u16)(x))
-#define __constant_le32_to_cpu(x) __ntfs_bswap_constant_32((__force u32)(x))
-#define __constant_le64_to_cpu(x) __ntfs_bswap_constant_64((__force u64)(x))
-
-#define __constant_cpu_to_le16(x) \
-	(__force le16)__ntfs_bswap_constant_16((__force u16)(x))
-#define __constant_cpu_to_le32(x) \
-	(__force le32)__ntfs_bswap_constant_32((__force u32)(x))
-#define __constant_cpu_to_le64(x) \
-	(__force le64)__ntfs_bswap_constant_64((__force u64)(x))
-
-#else
-
-#error "You must define __BYTE_ORDER to be __LITTLE_ENDIAN or __BIG_ENDIAN."
-
-#endif
-
-/* Unsigned from LE to CPU conversion. */
-
-#define le16_to_cpu(x)		(u16)__le16_to_cpu((le16)(x))
-#define le32_to_cpu(x)		(u32)__le32_to_cpu((le32)(x))
-#define le64_to_cpu(x)		(u64)__le64_to_cpu((le64)(x))
-
-#define le16_to_cpup(x)		(u16)__le16_to_cpu(*(const le16*)(x))
-#define le32_to_cpup(x)		(u32)__le32_to_cpu(*(const le32*)(x))
-#define le64_to_cpup(x)		(u64)__le64_to_cpu(*(const le64*)(x))
-
-/* Signed from LE to CPU conversion. */
-
-#define sle16_to_cpu(x)		(s16)__le16_to_cpu((sle16)(x))
-#define sle32_to_cpu(x)		(s32)__le32_to_cpu((sle32)(x))
-#define sle64_to_cpu(x)		(s64)__le64_to_cpu((sle64)(x))
-
-#define sle16_to_cpup(x)	(s16)__le16_to_cpu(*(const sle16*)(x))
-#define sle32_to_cpup(x)	(s32)__le32_to_cpu(*(const sle32*)(x))
-#define sle64_to_cpup(x)	(s64)__le64_to_cpu(*(const sle64*)(x))
-
-/* Unsigned from CPU to LE conversion. */
-
-#define cpu_to_le16(x)		(le16)__cpu_to_le16((u16)(x))
-#define cpu_to_le32(x)		(le32)__cpu_to_le32((u32)(x))
-#define cpu_to_le64(x)		(le64)__cpu_to_le64((u64)(x))
-
-#define cpu_to_le16p(x)		(le16)__cpu_to_le16(*(const u16*)(x))
-#define cpu_to_le32p(x)		(le32)__cpu_to_le32(*(const u32*)(x))
-#define cpu_to_le64p(x)		(le64)__cpu_to_le64(*(const u64*)(x))
-
-/* Signed from CPU to LE conversion. */
-
-#define cpu_to_sle16(x)		(__force sle16)__cpu_to_le16((s16)(x))
-#define cpu_to_sle32(x)		(__force sle32)__cpu_to_le32((s32)(x))
-#define cpu_to_sle64(x)		(__force sle64)__cpu_to_le64((s64)(x))
-
-#define cpu_to_sle16p(x)	(__force sle16)__cpu_to_le16(*(const s16*)(x))
-#define cpu_to_sle32p(x)	(__force sle32)__cpu_to_le32(*(const s32*)(x))
-#define cpu_to_sle64p(x)	(__force sle64)__cpu_to_le64(*(const s64*)(x))
-
-/* Constant endianness conversion defines. */
-
-#define const_le16_to_cpu(x)	(u16)__constant_le16_to_cpu((le16)(x))
-#define const_le32_to_cpu(x)	(u32)__constant_le32_to_cpu((le32)(x))
-#define const_le64_to_cpu(x)	(u64)__constant_le64_to_cpu((le64)(x))
-
-#define const_cpu_to_le16(x)	(le16)__constant_cpu_to_le16((u16)(x))
-#define const_cpu_to_le32(x)	(le32)__constant_cpu_to_le32((u32)(x))
-#define const_cpu_to_le64(x)	(le64)__constant_cpu_to_le64((u64)(x))
-
-#ifdef __CHECKER__
-static void ntfs_endian_self_test(void)
-{
-	/* Should not generate warnings. */
-	(le16)cpu_to_le16((u16)1);
-	(le32)cpu_to_le32((u32)1);
-	(le64)cpu_to_le64((u64)1);
-	(sle16)cpu_to_sle16((s16)1);
-	(sle32)cpu_to_sle32((s32)1);
-	(sle64)cpu_to_sle64((s64)1);
-	(u16)le16_to_cpu((__force le16)1);
-	(u32)le32_to_cpu((__force le32)1);
-	(u64)le64_to_cpu((__force le64)1);
-	(s16)sle16_to_cpu((__force sle16)1);
-	(s32)sle32_to_cpu((__force sle32)1);
-	(s64)sle64_to_cpu((__force sle64)1);
-	(le16)const_cpu_to_le16((u16)1);
-	(le32)const_cpu_to_le32((u32)1);
-	(le64)const_cpu_to_le64((u64)1);
-	(u16)const_le16_to_cpu((__force le16)1);
-	(u32)const_le32_to_cpu((__force le32)1);
-	(u64)const_le64_to_cpu((__force le64)1);
-
-	/*
-	 * TODO: Need some how to test that warnings are actually generated,
-	 * but without flooding output with them and vice-versa print warning
-	 * in case if some one warning is not triggered, but should.  (Yura)
-	 *
-	 * I think it can only be done in  a ./configure like script / shell
-	 * script that will compile known good  and known bad code and pipe the
-	 * output from sparse to a file, then  grep the file for the wanted
-	 * warnings/lack thereof and then it would  say "Tests: PASS " or
-	 * "Tests: FAILED" or whatever.  And you can then  hook that into a
-	 * "make test" make target or similar so it is only  done when one
-	 * wants to do it...  (Anton)
-	 *
-	 * Also we can look on sparse self test script.  (Yura)
-	 */
-}
-#endif
-
-#endif /* defined _NTFS_ENDIANS_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/gnome-vfs-method.h ./include/ntfs/gnome-vfs-method.h
--- ../ntfsprogs-2.0.0/include/ntfs/gnome-vfs-method.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/gnome-vfs-method.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/*
- * gnome-vfs-method.h - Export for Gnome-VFS init/shutdown implementation of
- *			interface to libntfs. Par of the Linux-NTFS project.
- *
- * Copyright (c) 2002-2003 Jan Kratochvil <project-captive@jankratochvil.net>
- * Copyright (c) 2000-2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_GNOME_VFS_METHOD_H
-#define _NTFS_GNOME_VFS_METHOD_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <libgnomevfs/gnome-vfs-method.h>
-
-G_BEGIN_DECLS
-
-GnomeVFSMethod *libntfs_gnomevfs_method_init(const gchar *method_name,
-		const gchar *args);
-
-void libntfs_gnomevfs_method_shutdown(void);
-
-G_END_DECLS
-
-#endif /* _NTFS_GNOME_VFS_METHOD_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/gnome-vfs-module.h ./include/ntfs/gnome-vfs-module.h
--- ../ntfsprogs-2.0.0/include/ntfs/gnome-vfs-module.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/gnome-vfs-module.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-/*
- * gnome-vfs-module.h - Exports for Gnome-VFS init/shutdown implementation of
- *			interface to libntfs. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2003 Jan Kratochvil <project-captive@jankratochvil.net>
- * Copyright (c) 2000-2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_GNOME_VFS_MODULE_H
-#define _NTFS_GNOME_VFS_MODULE_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-G_BEGIN_DECLS
-
-G_LOCK_EXTERN(libntfs);
-
-#define libntfs_newn(objp, n)	((objp) = (typeof(objp))g_new(typeof(*(objp)), (n)))
-#define libntfs_new(objp)	(libntfs_newn((objp), 1))
-#define LIBNTFS_MEMZERO(objp)	(memset((objp), 0, sizeof(*(objp))))
-
-G_END_DECLS
-
-#endif /* _NTFS_GNOME_VFS_MODULE_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/index.h ./include/ntfs/index.h
--- ../ntfsprogs-2.0.0/include/ntfs/index.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/index.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/*
- * index.h - Defines for NTFS index handling.  Part of the Linux-NTFS project.
- *
- * Copyright (c)      2004 Anton Altaparmakov
- * Copyright (c) 2004-2005 Richard Russon
- * Copyright (c) 2005-2006 Yura Pakhuchiy
- * Copyright (c)      2006 Szabolcs Szakacsits
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_INDEX_H
-#define _NTFS_INDEX_H
-
-#include "attrib.h"
-#include "types.h"
-#include "layout.h"
-#include "inode.h"
-#include "mft.h"
-
-#define  VCN_INDEX_ROOT_PARENT  ((VCN)-2)
-
-#define  MAX_PARENT_VCN		32
-
-/**
- * struct ntfs_index_context -
- * @ni:			inode containing the @entry described by this context
- * @name:		name of the index described by this context
- * @name_len:		length of the index name
- * @entry:		index entry (points into @ir or @ib)
- * @data:		index entry data (points into @entry)
- * @data_len:		length in bytes of @data
- * @cr:
- * @is_in_root:		TRUE if @entry is in @ir or FALSE if it is in @ib
- * @ir:			index root if @is_in_root or NULL otherwise
- * @actx:		attribute search context if in root or NULL otherwise
- * @ia_na:		opened INDEX_ALLOCATION attribute
- * @ib:			index block if @is_in_root is FALSE or NULL otherwise
- * @ib_vcn:		VCN from which @ib where read from
- * @ib_dirty:		TRUE if index block was changed
- * @parent_pos:		parent entries' positions in the index block
- * @parent_vcn:		entry's parent nodes or VCN_INDEX_ROOT_PARENT for root
- * @max_depth:		number of the parent nodes
- * @pindex:		maximum it's the number of the parent nodes
- * @block_size:		index block size
- * @vcn_size_bits:	VCN size bits for this index block
- *
- * @ni is the inode this context belongs to.
- *
- * @entry is the index entry described by this context.  @data and @data_len
- * are the index entry data and its length in bytes, respectively.  @data
- * simply points into @entry.  This is probably what the user is interested in.
- *
- * If @is_in_root is TRUE, @entry is in the index root attribute @ir described
- * by the attribute search context @actx and inode @ni.  @ib, @ib_vcn and
- * @ib_dirty are undefined in this case.
- *
- * If @is_in_root is FALSE, @entry is in the index allocation attribute and @ib
- * and @ib_vcn point to the index allocation block and VCN where it's placed,
- * respectively. @ir and @actx are NULL in this case. @ia_na is opened
- * INDEX_ALLOCATION attribute. @ib_dirty is TRUE if index block was changed and
- * FALSE otherwise.
- *
- * To obtain a context call ntfs_index_ctx_get().
- *
- * When finished with the @entry and its @data, call ntfs_index_ctx_put() to
- * free the context and other associated resources.
- *
- * If the index entry was modified, call ntfs_index_entry_mark_dirty() before
- * the call to ntfs_index_ctx_put() to ensure that the changes are written
- * to disk.
- */
-typedef struct {
-	ntfs_inode *ni;
-	ntfschar *name;
-	u32 name_len;
-	INDEX_ENTRY *entry;
-	void *data;
-	u16 data_len;
-	COLLATION_RULES cr;
-	BOOL is_in_root;
-	INDEX_ROOT *ir;
-	ntfs_attr_search_ctx *actx;
-	ntfs_attr *ia_na;
-	INDEX_BLOCK *ib;
-	VCN ib_vcn;
-	BOOL ib_dirty;
-	int parent_pos[MAX_PARENT_VCN];
-	VCN parent_vcn[MAX_PARENT_VCN];
-	int max_depth;
-	int pindex;
-	u32 block_size;
-	u8 vcn_size_bits;
-} ntfs_index_context;
-
-extern ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *ni,
-						ntfschar *name, u32 name_len);
-extern void ntfs_index_ctx_put(ntfs_index_context *ictx);
-extern void ntfs_index_ctx_reinit(ntfs_index_context *ictx);
-
-extern int ntfs_index_lookup(const void *key, const int key_len,
-		ntfs_index_context *ictx);
-
-extern int ntfs_index_add_filename(ntfs_inode *ni, FILE_NAME_ATTR *fn,
-		MFT_REF mref);
-extern int ntfs_index_rm(ntfs_index_context *ictx);
-
-extern INDEX_ROOT *ntfs_index_root_get(ntfs_inode *ni, ATTR_RECORD *attr);
-
-extern VCN ntfs_ie_get_vcn(INDEX_ENTRY *ie);
-
-extern char *ntfs_ie_filename_get(INDEX_ENTRY *ie);
-extern void ntfs_ie_filename_dump(INDEX_ENTRY *ie);
-extern void ntfs_ih_filename_dump(INDEX_HEADER *ih);
-
-extern void ntfs_index_entry_mark_dirty(ntfs_index_context *ictx);
-
-#endif /* _NTFS_INDEX_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/inode.h ./include/ntfs/inode.h
--- ../ntfsprogs-2.0.0/include/ntfs/inode.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/inode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,215 +0,0 @@
-/*
- * inode.h - Defines for NTFS inode handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2001,2002 Anton Altaparmakov
- * Copyright (c) 2004-2007 Yura Pakhuchiy
- * Copyright (c) 2004-2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_INODE_H
-#define _NTFS_INODE_H
-
-/* Forward declaration */
-typedef struct _ntfs_inode ntfs_inode;
-
-#include "list.h"
-#include "types.h"
-#include "layout.h"
-#include "support.h"
-#include "volume.h"
-
-/**
- * enum ntfs_inode_state_bits -
- *
- * Defined bits for the state field in the ntfs_inode structure.
- * (f) = files only, (d) = directories only
- */
-typedef enum {
-	NI_Dirty,		/* 1: Mft record needs to be written to disk. */
-
-	/* Below fields only make sense for base inodes. */
-	NI_AttrList,		/* 1: Mft record contains an attribute list. */
-	NI_AttrListDirty,	/* 1: Attribute list needs to be written to the
-				      mft record and then to disk. */
-	NI_FileNameDirty,	/* 1: FILE_NAME attributes need to be updated
-				      in the index. */
-} ntfs_inode_state_bits;
-
-#define  test_nino_flag(ni, flag)	   test_bit(NI_##flag, (ni)->state)
-#define   set_nino_flag(ni, flag)	    set_bit(NI_##flag, (ni)->state)
-#define clear_nino_flag(ni, flag)	  clear_bit(NI_##flag, (ni)->state)
-
-#define test_and_set_nino_flag(ni, flag)	\
-				   test_and_set_bit(NI_##flag, (ni)->state)
-#define test_and_clear_nino_flag(ni, flag)	\
-				 test_and_clear_bit(NI_##flag, (ni)->state)
-
-#define NInoDirty(ni)				  test_nino_flag(ni, Dirty)
-#define NInoSetDirty(ni)			   set_nino_flag(ni, Dirty)
-#define NInoClearDirty(ni)			 clear_nino_flag(ni, Dirty)
-#define NInoTestAndSetDirty(ni)		  test_and_set_nino_flag(ni, Dirty)
-#define NInoTestAndClearDirty(ni)	test_and_clear_nino_flag(ni, Dirty)
-
-#define NInoAttrList(ni)			  test_nino_flag(ni, AttrList)
-#define NInoSetAttrList(ni)			   set_nino_flag(ni, AttrList)
-#define NInoClearAttrList(ni)			 clear_nino_flag(ni, AttrList)
-
-
-#define  test_nino_al_flag(ni, flag)	 test_nino_flag(ni, AttrList##flag)
-#define   set_nino_al_flag(ni, flag)	  set_nino_flag(ni, AttrList##flag)
-#define clear_nino_al_flag(ni, flag)	clear_nino_flag(ni, AttrList##flag)
-
-#define test_and_set_nino_al_flag(ni, flag)	\
-				 test_and_set_nino_flag(ni, AttrList##flag)
-#define test_and_clear_nino_al_flag(ni, flag)	\
-			       test_and_clear_nino_flag(ni, AttrList##flag)
-
-#define NInoAttrListDirty(ni)			    test_nino_al_flag(ni, Dirty)
-#define NInoAttrListSetDirty(ni)		     set_nino_al_flag(ni, Dirty)
-#define NInoAttrListClearDirty(ni)		   clear_nino_al_flag(ni, Dirty)
-#define NInoAttrListTestAndSetDirty(ni)	    test_and_set_nino_al_flag(ni, Dirty)
-#define NInoAttrListTestAndClearDirty(ni) test_and_clear_nino_al_flag(ni, Dirty)
-
-#define NInoFileNameDirty(ni)			\
-					  test_nino_flag(ni, FileNameDirty)
-#define NInoFileNameSetDirty(ni)		\
-					   set_nino_flag(ni, FileNameDirty)
-#define NInoFileNameClearDirty(ni)		\
-					 clear_nino_flag(ni, FileNameDirty)
-#define NInoFileNameTestAndSetDirty(ni)		\
-				  test_and_set_nino_flag(ni, FileNameDirty)
-#define NInoFileNameTestAndClearDirty(ni)	\
-				test_and_clear_nino_flag(ni, FileNameDirty)
-
-/**
- * struct _ntfs_inode - The NTFS in-memory inode structure.
- *
- * It is just used as an extension to the fields already provided in the VFS
- * inode.
- */
-struct _ntfs_inode {
-	u64 mft_no;		/* Inode / mft record number. */
-	MFT_RECORD *mrec;	/* The actual mft record of the inode. */
-	ntfs_volume *vol;	/* Pointer to the ntfs volume of this inode. */
-	unsigned long state;	/* NTFS specific flags describing this inode.
-				   See ntfs_inode_state_bits above. */
-	FILE_ATTR_FLAGS flags;	/* Flags describing the file.
-				   (Copy from STANDARD_INFORMATION) */
-	/*
-	 * Attribute list support (for use by the attribute lookup functions).
-	 * Setup during ntfs_open_inode() for all inodes with attribute lists.
-	 * Only valid if NI_AttrList is set in state.
-	 */
-	u32 attr_list_size;	/* Length of attribute list value in bytes. */
-	u8 *attr_list;		/* Attribute list value itself. */
-	/* Below fields are always valid. */
-	s32 nr_extents;		/* For a base mft record, the number of
-				   attached extent inodes (0 if none), for
-				   extent records this is -1. */
-	union {		/* This union is only used if nr_extents != 0. */
-		ntfs_inode **extent_nis;/* For nr_extents > 0, array of the
-					   ntfs inodes of the extent mft
-					   records belonging to this base
-					   inode which have been loaded. */
-		ntfs_inode *base_ni;	/* For nr_extents == -1, the ntfs
-					   inode of the base mft record. */
-	};
-
-	/* Below fields are valid only for base inode. */
-
-	/*
-	 * These two fields are used to sync filename index and guaranteed to be
-	 * correct, however value in index itself maybe wrong (windows itself
-	 * do not update them properly).
-	 */
-	s64 data_size;		/* Data size of unnamed DATA attribute. */
-	s64 allocated_size;	/* Allocated size stored in the filename
-				   index. (NOTE: Equal to allocated size of
-				   the unnamed data attribute for normal or
-				   encrypted files and to compressed size
-				   of the unnamed data attribute for sparse or
-				   compressed files.) */
-
-	/*
-	 * These four fields are copy of relevant fields from
-	 * STANDARD_INFORMATION attribute and used to sync it and FILE_NAME
-	 * attribute in the index.
-	 */
-	time_t creation_time;
-	time_t last_data_change_time;
-	time_t last_mft_change_time;
-	time_t last_access_time;
-
-	/* These 2 fields are used to keep track of opened inodes. */
-	struct list_head list_entry;	/* Keep pointers to the next/prev list
-					   entry. */
-	int nr_references;		/* How many times this inode was
-					   opened.  We really close inode only
-					   when this reaches zero. */
-
-	struct list_head attr_cache;	/* List of opened attributes. */
-};
-
-extern void __ntfs_inode_add_to_cache(ntfs_inode *ni);
-
-extern ntfs_inode *ntfs_inode_allocate(ntfs_volume *vol);
-
-extern ntfs_inode *ntfs_inode_open(ntfs_volume *vol, const MFT_REF mref);
-
-extern int ntfs_inode_close(ntfs_inode *ni);
-
-extern ntfs_inode *ntfs_extent_inode_open(ntfs_inode *base_ni,
-		const leMFT_REF mref);
-
-extern int ntfs_inode_attach_all_extents(ntfs_inode *ni);
-
-/**
- * ntfs_inode_mark_dirty - set the inode (and its base inode if it exists) dirty
- * @ni:		ntfs inode to set dirty
- *
- * Set the inode @ni dirty so it is written out later (at the latest at
- * ntfs_inode_close() time). If @ni is an extent inode, set the base inode
- * dirty, too.
- *
- * This function cannot fail.
- */
-static __inline__ void ntfs_inode_mark_dirty(ntfs_inode *ni)
-{
-	NInoSetDirty(ni);
-	if (ni->nr_extents == -1)
-		NInoSetDirty(ni->base_ni);
-}
-
-typedef enum {
-	NTFS_UPDATE_ATIME = 1 << 0,
-	NTFS_UPDATE_MTIME = 1 << 1,
-	NTFS_UPDATE_CTIME = 1 << 2,
-} ntfs_time_update_flags;
-
-extern void ntfs_inode_update_times(ntfs_inode *ni,
-		ntfs_time_update_flags mask);
-
-extern int ntfs_inode_sync(ntfs_inode *ni);
-
-extern int ntfs_inode_add_attrlist(ntfs_inode *ni);
-
-extern int ntfs_inode_free_space(ntfs_inode *ni, int size);
-
-extern int ntfs_inode_badclus_bad(u64 mft_no, ATTR_RECORD *a);
-
-#endif /* defined _NTFS_INODE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/layout.h ./include/ntfs/layout.h
--- ../ntfsprogs-2.0.0/include/ntfs/layout.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/layout.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2683 +0,0 @@
-/*
- * layout.h - Ntfs on-disk layout structures.  Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2005 Anton Altaparmakov
- * Copyright (c) 2005-2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_LAYOUT_H
-#define _NTFS_LAYOUT_H
-
-#include "types.h"
-#include "endians.h"
-#include "support.h"
-
-/* The NTFS oem_id "NTFS    " */
-#define NTFS_SB_MAGIC	const_cpu_to_le64(0x202020205346544eULL)
-
-/*
- * Location of boot sector on partition:
- *	The standard NTFS_BOOT_SECTOR is on sector 0 of the partition.
- *	On NT4 and above there is one backup copy of the boot sector to
- *	be found on the last sector of the partition (not normally accessible
- *	from within Windows as the boot sector contained number of sectors
- *	value is one less than the actual value!).
- *	On versions of NT 3.51 and earlier, the backup copy was located at
- *	number of sectors/2 (integer divide), i.e. in the middle of the volume.
- */
-
-/**
- * struct BIOS_PARAMETER_BLOCK - BIOS parameter block (BPB) structure.
- */
-typedef struct {
-	le16 bytes_per_sector;		/* Size of a sector in bytes. */
-	u8  sectors_per_cluster;	/* Size of a cluster in sectors. */
-	le16 reserved_sectors;		/* zero */
-	u8  fats;			/* zero */
-	le16 root_entries;		/* zero */
-	le16 sectors;			/* zero */
-	u8  media_type;			/* 0xf8 = hard disk */
-	le16 sectors_per_fat;		/* zero */
-/*0x0d*/le16 sectors_per_track;		/* Required to boot Windows. */
-/*0x0f*/le16 heads;			/* Required to boot Windows. */
-/*0x11*/le32 hidden_sectors;		/* Offset to the start of the partition
-					   relative to the disk in sectors.
-					   Required to boot Windows. */
-/*0x15*/le32 large_sectors;		/* zero */
-/* sizeof() = 25 (0x19) bytes */
-} __attribute__((__packed__)) BIOS_PARAMETER_BLOCK;
-
-/**
- * struct NTFS_BOOT_SECTOR - NTFS boot sector structure.
- */
-typedef struct {
-	u8  jump[3];			/* Irrelevant (jump to boot up code).*/
-	le64 oem_id;			/* Magic "NTFS    ". */
-/*0x0b*/BIOS_PARAMETER_BLOCK bpb;	/* See BIOS_PARAMETER_BLOCK. */
-	u8 physical_drive;		/* 0x00 floppy, 0x80 hard disk */
-	u8 current_head;		/* zero */
-	u8 extended_boot_signature; 	/* 0x80 */
-	u8 reserved2;			/* zero */
-/*0x28*/sle64 number_of_sectors;	/* Number of sectors in volume. Gives
-					   maximum volume size of 2^63 sectors.
-					   Assuming standard sector size of 512
-					   bytes, the maximum byte size is
-					   approx. 4.7x10^21 bytes. (-; */
-	sle64 mft_lcn;			/* Cluster location of mft data. */
-	sle64 mftmirr_lcn;		/* Cluster location of copy of mft. */
-	s8  clusters_per_mft_record;	/* Mft record size in clusters. */
-	u8  reserved0[3];		/* zero */
-	s8  clusters_per_index_record;	/* Index block size in clusters. */
-	u8  reserved1[3];		/* zero */
-	le64 volume_serial_number;	/* Irrelevant (serial number). */
-	le32 checksum;			/* Boot sector checksum. */
-/*0x54*/u8  bootstrap[426];		/* Irrelevant (boot up code). */
-	le16 end_of_sector_marker;	/* End of boot sector magic. Always is
-					   0xaa55 in little endian. */
-/* sizeof() = 512 (0x200) bytes */
-} __attribute__((__packed__)) NTFS_BOOT_SECTOR;
-
-/**
- * enum NTFS_RECORD_TYPES -
- *
- * Magic identifiers present at the beginning of all ntfs record containing
- * records (like mft records for example).
- */
-typedef enum {
-	/* Found in $MFT/$DATA. */
-	magic_FILE = const_cpu_to_le32(0x454c4946), /* Mft entry. */
-	magic_INDX = const_cpu_to_le32(0x58444e49), /* Index buffer. */
-	magic_HOLE = const_cpu_to_le32(0x454c4f48), /* ? (NTFS 3.0+?) */
-
-	/* Found in $LogFile/$DATA. */
-	magic_RSTR = const_cpu_to_le32(0x52545352), /* Restart page. */
-	magic_RCRD = const_cpu_to_le32(0x44524352), /* Log record page. */
-
-	/* Found in $LogFile/$DATA.  (May be found in $MFT/$DATA, also?) */
-	magic_CHKD = const_cpu_to_le32(0x444b4843), /* Modified by chkdsk. */
-
-	/* Found in all ntfs record containing records. */
-	magic_BAAD = const_cpu_to_le32(0x44414142), /* Failed multi sector
-						       transfer was detected. */
-
-	/*
-	 * Found in $LogFile/$DATA when a page is full or 0xff bytes and is
-	 * thus not initialized.  User has to initialize the page before using
-	 * it.
-	 */
-	magic_empty = const_cpu_to_le32(0xffffffff),/* Record is empty and has
-						       to be initialized before
-						       it can be used. */
-} NTFS_RECORD_TYPES;
-
-/*
- * Generic magic comparison macros. Finally found a use for the ## preprocessor
- * operator! (-8
- */
-
-static inline BOOL __ntfs_is_magic(le32 x, NTFS_RECORD_TYPES r)
-{
-	return (x == (__force le32)r);
-}
-#define ntfs_is_magic(x, m)   __ntfs_is_magic(x, magic_##m)
-
-static inline BOOL __ntfs_is_magicp(le32 *p, NTFS_RECORD_TYPES r)
-{
-	return (*p == (__force le32)r);
-}
-#define ntfs_is_magicp(p, m)  __ntfs_is_magicp(p, magic_##m)
-
-/*
- * Specialised magic comparison macros for the NTFS_RECORD_TYPES defined above.
- */
-#define ntfs_is_file_record(x)	( ntfs_is_magic (x, FILE) )
-#define ntfs_is_file_recordp(p)	( ntfs_is_magicp(p, FILE) )
-#define ntfs_is_mft_record(x)	( ntfs_is_file_record(x) )
-#define ntfs_is_mft_recordp(p)	( ntfs_is_file_recordp(p) )
-#define ntfs_is_indx_record(x)	( ntfs_is_magic (x, INDX) )
-#define ntfs_is_indx_recordp(p)	( ntfs_is_magicp(p, INDX) )
-#define ntfs_is_hole_record(x)	( ntfs_is_magic (x, HOLE) )
-#define ntfs_is_hole_recordp(p)	( ntfs_is_magicp(p, HOLE) )
-
-#define ntfs_is_rstr_record(x)	( ntfs_is_magic (x, RSTR) )
-#define ntfs_is_rstr_recordp(p)	( ntfs_is_magicp(p, RSTR) )
-#define ntfs_is_rcrd_record(x)	( ntfs_is_magic (x, RCRD) )
-#define ntfs_is_rcrd_recordp(p)	( ntfs_is_magicp(p, RCRD) )
-
-#define ntfs_is_chkd_record(x)	( ntfs_is_magic (x, CHKD) )
-#define ntfs_is_chkd_recordp(p)	( ntfs_is_magicp(p, CHKD) )
-
-#define ntfs_is_baad_record(x)	( ntfs_is_magic (x, BAAD) )
-#define ntfs_is_baad_recordp(p)	( ntfs_is_magicp(p, BAAD) )
-
-#define ntfs_is_empty_record(x)		( ntfs_is_magic (x, empty) )
-#define ntfs_is_empty_recordp(p)	( ntfs_is_magicp(p, empty) )
-
-
-#define NTFS_BLOCK_SIZE		512
-#define NTFS_BLOCK_SIZE_BITS	9
-
-/**
- * struct NTFS_RECORD -
- *
- * The Update Sequence Array (USA) is an array of the le16 values which belong
- * to the end of each sector protected by the update sequence record in which
- * this array is contained. Note that the first entry is the Update Sequence
- * Number (USN), a cyclic counter of how many times the protected record has
- * been written to disk. The values 0 and -1 (ie. 0xffff) are not used. All
- * last le16's of each sector have to be equal to the USN (during reading) or
- * are set to it (during writing). If they are not, an incomplete multi sector
- * transfer has occurred when the data was written.
- * The maximum size for the update sequence array is fixed to:
- *	maximum size = usa_ofs + (usa_count * 2) = 510 bytes
- * The 510 bytes comes from the fact that the last le16 in the array has to
- * (obviously) finish before the last le16 of the first 512-byte sector.
- * This formula can be used as a consistency check in that usa_ofs +
- * (usa_count * 2) has to be less than or equal to 510.
- */
-typedef struct {
-	NTFS_RECORD_TYPES magic;/* A four-byte magic identifying the
-				   record type and/or status. */
-	le16 usa_ofs;		/* Offset to the Update Sequence Array (USA)
-				   from the start of the ntfs record. */
-	le16 usa_count;		/* Number of u16 sized entries in the USA
-				   including the Update Sequence Number (USN),
-				   thus the number of fixups is the usa_count
-				   minus 1. */
-} __attribute__((__packed__)) NTFS_RECORD;
-
-/**
- * enum NTFS_SYSTEM_FILES - System files mft record numbers.
- *
- * All these files are always marked as used in the bitmap attribute of the
- * mft; presumably in order to avoid accidental allocation for random other
- * mft records. Also, the sequence number for each of the system files is
- * always equal to their mft record number and it is never modified.
- */
-typedef enum {
-	FILE_MFT	= 0,	/* Master file table (mft). Data attribute
-				   contains the entries and bitmap attribute
-				   records which ones are in use (bit==1). */
-	FILE_MFTMirr	= 1,	/* Mft mirror: copy of first four mft records
-				   in data attribute. If cluster size > 4kiB,
-				   copy of first N mft records, with
-					N = cluster_size / mft_record_size. */
-	FILE_LogFile	= 2,	/* Journalling log in data attribute. */
-	FILE_Volume	= 3,	/* Volume name attribute and volume information
-				   attribute (flags and ntfs version). Windows
-				   refers to this file as volume DASD (Direct
-				   Access Storage Device). */
-	FILE_AttrDef	= 4,	/* Array of attribute definitions in data
-				   attribute. */
-	FILE_root	= 5,	/* Root directory. */
-	FILE_Bitmap	= 6,	/* Allocation bitmap of all clusters (LCNs) in
-				   data attribute. */
-	FILE_Boot	= 7,	/* Boot sector (always at cluster 0) in data
-				   attribute. */
-	FILE_BadClus	= 8,	/* Contains all bad clusters in the non-resident
-				   data attribute. */
-	FILE_Secure	= 9,	/* Shared security descriptors in data attribute
-				   and two indexes into the descriptors.
-				   Appeared in Windows 2000. Before that, this
-				   file was named $Quota but was unused. */
-	FILE_UpCase	= 10,	/* Uppercase equivalents of all 65536 Unicode
-				   characters in data attribute. */
-	FILE_Extend	= 11,	/* Directory containing other system files (eg.
-				   $ObjId, $Quota, $Reparse and $UsnJrnl). This
-				   is new to NTFS 3.0. */
-	FILE_reserved12	= 12,	/* Reserved for future use (records 12-15). */
-	FILE_reserved13	= 13,
-	FILE_reserved14	= 14,
-	FILE_reserved15	= 15,
-	FILE_first_user	= 16,	/* First user file, used as test limit for
-				   whether to allow opening a file or not. */
-} NTFS_SYSTEM_FILES;
-
-/**
- * enum MFT_RECORD_FLAGS -
- *
- * These are the so far known MFT_RECORD_* flags (16-bit) which contain
- * information about the mft record in which they are present.
- *
- * MFT_RECORD_IS_4 exists on all $Extend sub-files.
- * It seems that it marks it is a metadata file with MFT record >24, however,
- * it is unknown if it is limited to metadata files only.
- *
- * MFT_RECORD_IS_VIEW_INDEX exists on every metafile with a non directory
- * index, that means an INDEX_ROOT and an INDEX_ALLOCATION with a name other
- * than "$I30". It is unknown if it is limited to metadata files only.
- */
-typedef enum {
-	MFT_RECORD_IN_USE		= const_cpu_to_le16(0x0001),
-	MFT_RECORD_IS_DIRECTORY		= const_cpu_to_le16(0x0002),
-	MFT_RECORD_IS_4			= const_cpu_to_le16(0x0004),
-	MFT_RECORD_IS_VIEW_INDEX	= const_cpu_to_le16(0x0008),
-	MFT_REC_SPACE_FILLER		= const_cpu_to_le16(0xffff),
-					/* Just to make flags 16-bit. */
-} __attribute__((__packed__)) MFT_RECORD_FLAGS;
-
-/*
- * mft references (aka file references or file record segment references) are
- * used whenever a structure needs to refer to a record in the mft.
- *
- * A reference consists of a 48-bit index into the mft and a 16-bit sequence
- * number used to detect stale references.
- *
- * For error reporting purposes we treat the 48-bit index as a signed quantity.
- *
- * The sequence number is a circular counter (skipping 0) describing how many
- * times the referenced mft record has been (re)used. This has to match the
- * sequence number of the mft record being referenced, otherwise the reference
- * is considered stale and removed (FIXME: only ntfsck or the driver itself?).
- *
- * If the sequence number is zero it is assumed that no sequence number
- * consistency checking should be performed.
- *
- * FIXME: Since inodes are 32-bit as of now, the driver needs to always check
- * for high_part being 0 and if not either BUG(), cause a panic() or handle
- * the situation in some other way. This shouldn't be a problem as a volume has
- * to become HUGE in order to need more than 32-bits worth of mft records.
- * Assuming the standard mft record size of 1kb only the records (never mind
- * the non-resident attributes, etc.) would require 4Tb of space on their own
- * for the first 32 bits worth of records. This is only if some strange person
- * doesn't decide to foul play and make the mft sparse which would be a really
- * horrible thing to do as it would trash our current driver implementation. )-:
- * Do I hear screams "we want 64-bit inodes!" ?!? (-;
- *
- * FIXME: The mft zone is defined as the first 12% of the volume. This space is
- * reserved so that the mft can grow contiguously and hence doesn't become
- * fragmented. Volume free space includes the empty part of the mft zone and
- * when the volume's free 88% are used up, the mft zone is shrunk by a factor
- * of 2, thus making more space available for more files/data. This process is
- * repeated every time there is no more free space except for the mft zone until
- * there really is no more free space.
- */
-
-/*
- * Typedef the MFT_REF as a 64-bit value for easier handling.
- * Also define two unpacking macros to get to the reference (MREF) and
- * sequence number (MSEQNO) respectively.
- * The _LE versions are to be applied on little endian MFT_REFs.
- * Note: The _LE versions will return a CPU endian formatted value!
- */
-#define MFT_REF_MASK_CPU 0x0000ffffffffffffULL
-#define MFT_REF_MASK_LE const_cpu_to_le64(MFT_REF_MASK_CPU)
-
-typedef u64 MFT_REF;
-typedef le64 leMFT_REF;
-
-#define MK_MREF(m, s)	((MFT_REF)(((MFT_REF)(s) << 48) |		\
-					((MFT_REF)(m) & MFT_REF_MASK_CPU)))
-#define MK_LE_MREF(m, s) const_cpu_to_le64(((MFT_REF)(((MFT_REF)(s) << 48) | \
-					((MFT_REF)(m) & MFT_REF_MASK_CPU))))
-
-#define MREF(x)		((u64)((x) & MFT_REF_MASK_CPU))
-#define MSEQNO(x)	((u16)(((x) >> 48) & 0xffff))
-#define MREF_LE(x)	((u64)(const_le64_to_cpu(x) & MFT_REF_MASK_CPU))
-#define MSEQNO_LE(x)	((u16)((const_le64_to_cpu(x) >> 48) & 0xffff))
-
-#define IS_ERR_MREF(x)	(((x) & 0x0000800000000000ULL) ? 1 : 0)
-#define ERR_MREF(x)	((u64)((s64)(x)))
-#define MREF_ERR(x)	((int)((s64)(x)))
-
-/**
- * struct MFT_RECORD - An MFT record layout (NTFS 3.1+)
- *
- * The mft record header present at the beginning of every record in the mft.
- * This is followed by a sequence of variable length attribute records which
- * is terminated by an attribute of type AT_END which is a truncated attribute
- * in that it only consists of the attribute type code AT_END and none of the
- * other members of the attribute structure are present.
- */
-typedef struct {
-/*Ofs*/
-/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
-	NTFS_RECORD_TYPES magic;/* Usually the magic is "FILE". */
-	le16 usa_ofs;		/* See NTFS_RECORD definition above. */
-	le16 usa_count;		/* See NTFS_RECORD definition above. */
-
-/*  8*/	leLSN lsn;		/* $LogFile sequence number for this record.
-				   Changed every time the record is modified. */
-/* 16*/	le16 sequence_number;	/* Number of times this mft record has been
-				   reused. (See description for MFT_REF
-				   above.) NOTE: The increment (skipping zero)
-				   is done when the file is deleted. NOTE: If
-				   this is zero it is left zero. */
-/* 18*/	le16 link_count;	/* Number of hard links, i.e. the number of
-				   directory entries referencing this record.
-				   NOTE: Only used in mft base records.
-				   NOTE: When deleting a directory entry we
-				   check the link_count and if it is 1 we
-				   delete the file. Otherwise we delete the
-				   FILE_NAME_ATTR being referenced by the
-				   directory entry from the mft record and
-				   decrement the link_count.
-				   FIXME: Careful with Win32 + DOS names! */
-/* 20*/	le16 attrs_offset;	/* Byte offset to the first attribute in this
-				   mft record from the start of the mft record.
-				   NOTE: Must be aligned to 8-byte boundary. */
-/* 22*/	MFT_RECORD_FLAGS flags;	/* Bit array of MFT_RECORD_FLAGS. When a file
-				   is deleted, the MFT_RECORD_IN_USE flag is
-				   set to zero. */
-/* 24*/	le32 bytes_in_use;	/* Number of bytes used in this mft record.
-				   NOTE: Must be aligned to 8-byte boundary. */
-/* 28*/	le32 bytes_allocated;	/* Number of bytes allocated for this mft
-				   record. This should be equal to the mft
-				   record size. */
-/* 32*/	leMFT_REF base_mft_record;/* This is zero for base mft records.
-				   When it is not zero it is a mft reference
-				   pointing to the base mft record to which
-				   this record belongs (this is then used to
-				   locate the attribute list attribute present
-				   in the base record which describes this
-				   extension record and hence might need
-				   modification when the extension record
-				   itself is modified, also locating the
-				   attribute list also means finding the other
-				   potential extents, belonging to the non-base
-				   mft record). */
-/* 40*/	le16 next_attr_instance; /* The instance number that will be
-				   assigned to the next attribute added to this
-				   mft record. NOTE: Incremented each time
-				   after it is used. NOTE: Every time the mft
-				   record is reused this number is set to zero.
-				   NOTE: The first instance number is always 0.
-				 */
-/* The below fields are specific to NTFS 3.1+ (Windows XP and above): */
-/* 42*/ le16 reserved;		/* Reserved/alignment. */
-/* 44*/ le32 mft_record_number;	/* Number of this mft record. */
-/* sizeof() = 48 bytes */
-/*
- * When (re)using the mft record, we place the update sequence array at this
- * offset, i.e. before we start with the attributes. This also makes sense,
- * otherwise we could run into problems with the update sequence array
- * containing in itself the last two bytes of a sector which would mean that
- * multi sector transfer protection wouldn't work. As you can't protect data
- * by overwriting it since you then can't get it back...
- * When reading we obviously use the data from the ntfs record header.
- */
-} __attribute__((__packed__)) MFT_RECORD;
-
-/**
- * struct MFT_RECORD_OLD - An MFT record layout (NTFS <=3.0)
- *
- * This is the version without the NTFS 3.1+ specific fields.
- */
-typedef struct {
-/*Ofs*/
-/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
-	NTFS_RECORD_TYPES magic;/* Usually the magic is "FILE". */
-	le16 usa_ofs;		/* See NTFS_RECORD definition above. */
-	le16 usa_count;		/* See NTFS_RECORD definition above. */
-
-/*  8*/	leLSN lsn;		/* $LogFile sequence number for this record.
-				   Changed every time the record is modified. */
-/* 16*/	le16 sequence_number;	/* Number of times this mft record has been
-				   reused. (See description for MFT_REF
-				   above.) NOTE: The increment (skipping zero)
-				   is done when the file is deleted. NOTE: If
-				   this is zero it is left zero. */
-/* 18*/	le16 link_count;	/* Number of hard links, i.e. the number of
-				   directory entries referencing this record.
-				   NOTE: Only used in mft base records.
-				   NOTE: When deleting a directory entry we
-				   check the link_count and if it is 1 we
-				   delete the file. Otherwise we delete the
-				   FILE_NAME_ATTR being referenced by the
-				   directory entry from the mft record and
-				   decrement the link_count.
-				   FIXME: Careful with Win32 + DOS names! */
-/* 20*/	le16 attrs_offset;	/* Byte offset to the first attribute in this
-				   mft record from the start of the mft record.
-				   NOTE: Must be aligned to 8-byte boundary. */
-/* 22*/	MFT_RECORD_FLAGS flags;	/* Bit array of MFT_RECORD_FLAGS. When a file
-				   is deleted, the MFT_RECORD_IN_USE flag is
-				   set to zero. */
-/* 24*/	le32 bytes_in_use;	/* Number of bytes used in this mft record.
-				   NOTE: Must be aligned to 8-byte boundary. */
-/* 28*/	le32 bytes_allocated;	/* Number of bytes allocated for this mft
-				   record. This should be equal to the mft
-				   record size. */
-/* 32*/	MFT_REF base_mft_record; /* This is zero for base mft records.
-				   When it is not zero it is a mft reference
-				   pointing to the base mft record to which
-				   this record belongs (this is then used to
-				   locate the attribute list attribute present
-				   in the base record which describes this
-				   extension record and hence might need
-				   modification when the extension record
-				   itself is modified, also locating the
-				   attribute list also means finding the other
-				   potential extents, belonging to the non-base
-				   mft record). */
-/* 40*/	le16 next_attr_instance; /* The instance number that will be
-				   assigned to the next attribute added to this
-				   mft record. NOTE: Incremented each time
-				   after it is used. NOTE: Every time the mft
-				   record is reused this number is set to zero.
-				   NOTE: The first instance number is always 0.
-				 */
-/* sizeof() = 42 bytes */
-/*
- * When (re)using the mft record, we place the update sequence array at this
- * offset, i.e. before we start with the attributes. This also makes sense,
- * otherwise we could run into problems with the update sequence array
- * containing in itself the last two bytes of a sector which would mean that
- * multi sector transfer protection wouldn't work. As you can't protect data
- * by overwriting it since you then can't get it back...
- * When reading we obviously use the data from the ntfs record header.
- */
-} __attribute__((__packed__)) MFT_RECORD_OLD;
-
-/**
- * enum ATTR_TYPES - System defined attributes (32-bit).
- *
- * Each attribute type has a corresponding attribute name (Unicode string of
- * maximum 64 character length) as described by the attribute definitions
- * present in the data attribute of the $AttrDef system file.
- *
- * On NTFS 3.0 volumes the names are just as the types are named in the below
- * enum exchanging AT_ for the dollar sign ($). If that isn't a revealing
- * choice of symbol... (-;
- */
-typedef enum {
-	AT_UNUSED			= const_cpu_to_le32(         0),
-	AT_STANDARD_INFORMATION		= const_cpu_to_le32(      0x10),
-	AT_ATTRIBUTE_LIST		= const_cpu_to_le32(      0x20),
-	AT_FILE_NAME			= const_cpu_to_le32(      0x30),
-	AT_OBJECT_ID			= const_cpu_to_le32(      0x40),
-	AT_SECURITY_DESCRIPTOR		= const_cpu_to_le32(      0x50),
-	AT_VOLUME_NAME			= const_cpu_to_le32(      0x60),
-	AT_VOLUME_INFORMATION		= const_cpu_to_le32(      0x70),
-	AT_DATA				= const_cpu_to_le32(      0x80),
-	AT_INDEX_ROOT			= const_cpu_to_le32(      0x90),
-	AT_INDEX_ALLOCATION		= const_cpu_to_le32(      0xa0),
-	AT_BITMAP			= const_cpu_to_le32(      0xb0),
-	AT_REPARSE_POINT		= const_cpu_to_le32(      0xc0),
-	AT_EA_INFORMATION		= const_cpu_to_le32(      0xd0),
-	AT_EA				= const_cpu_to_le32(      0xe0),
-	AT_PROPERTY_SET			= const_cpu_to_le32(      0xf0),
-	AT_LOGGED_UTILITY_STREAM	= const_cpu_to_le32(     0x100),
-	AT_FIRST_USER_DEFINED_ATTRIBUTE	= const_cpu_to_le32(    0x1000),
-	AT_END				= const_cpu_to_le32(0xffffffff),
-} ATTR_TYPES;
-
-/**
- * enum COLLATION_RULES - The collation rules for sorting views/indexes/etc
- * (32-bit).
- *
- * COLLATION_UNICODE_STRING - Collate Unicode strings by comparing their binary
- *	Unicode values, except that when a character can be uppercased, the
- *	upper case value collates before the lower case one.
- * COLLATION_FILE_NAME - Collate file names as Unicode strings. The collation
- *	is done very much like COLLATION_UNICODE_STRING. In fact I have no idea
- *	what the difference is. Perhaps the difference is that file names
- *	would treat some special characters in an odd way (see
- *	unistr.c::ntfs_collate_names() and unistr.c::legal_ansi_char_array[]
- *	for what I mean but COLLATION_UNICODE_STRING would not give any special
- *	treatment to any characters at all, but this is speculation.
- * COLLATION_NTOFS_ULONG - Sorting is done according to ascending le32 key
- *	values. E.g. used for $SII index in FILE_Secure, which sorts by
- *	security_id (le32).
- * COLLATION_NTOFS_SID - Sorting is done according to ascending SID values.
- *	E.g. used for $O index in FILE_Extend/$Quota.
- * COLLATION_NTOFS_SECURITY_HASH - Sorting is done first by ascending hash
- *	values and second by ascending security_id values. E.g. used for $SDH
- *	index in FILE_Secure.
- * COLLATION_NTOFS_ULONGS - Sorting is done according to a sequence of ascending
- *	le32 key values. E.g. used for $O index in FILE_Extend/$ObjId, which
- *	sorts by object_id (16-byte), by splitting up the object_id in four
- *	le32 values and using them as individual keys. E.g. take the following
- *	two security_ids, stored as follows on disk:
- *		1st: a1 61 65 b7 65 7b d4 11 9e 3d 00 e0 81 10 42 59
- *		2nd: 38 14 37 d2 d2 f3 d4 11 a5 21 c8 6b 79 b1 97 45
- *	To compare them, they are split into four le32 values each, like so:
- *		1st: 0xb76561a1 0x11d47b65 0xe0003d9e 0x59421081
- *		2nd: 0xd2371438 0x11d4f3d2 0x6bc821a5 0x4597b179
- *	Now, it is apparent why the 2nd object_id collates after the 1st: the
- *	first le32 value of the 1st object_id is less than the first le32 of
- *	the 2nd object_id. If the first le32 values of both object_ids were
- *	equal then the second le32 values would be compared, etc.
- */
-typedef enum {
-	COLLATION_BINARY	 = const_cpu_to_le32(0), /* Collate by binary
-					compare where the first byte is most
-					significant. */
-	COLLATION_FILE_NAME	 = const_cpu_to_le32(1), /* Collate file names
-					as Unicode strings. */
-	COLLATION_UNICODE_STRING = const_cpu_to_le32(2), /* Collate Unicode
-					strings by comparing their binary
-					Unicode values, except that when a
-					character can be uppercased, the upper
-					case value collates before the lower
-					case one. */
-	COLLATION_NTOFS_ULONG		= const_cpu_to_le32(16),
-	COLLATION_NTOFS_SID		= const_cpu_to_le32(17),
-	COLLATION_NTOFS_SECURITY_HASH	= const_cpu_to_le32(18),
-	COLLATION_NTOFS_ULONGS		= const_cpu_to_le32(19),
-} COLLATION_RULES;
-
-/**
- * enum ATTR_DEF_FLAGS -
- *
- * The flags (32-bit) describing attribute properties in the attribute
- * definition structure.  FIXME: This information is based on Regis's
- * information and, according to him, it is not certain and probably
- * incomplete.  The INDEXABLE flag is fairly certainly correct as only the file
- * name attribute has this flag set and this is the only attribute indexed in
- * NT4.
- */
-typedef enum {
-	ATTR_DEF_INDEXABLE	= const_cpu_to_le32(0x02), /* Attribute can be
-					indexed. */
-	ATTR_DEF_MULTIPLE	= const_cpu_to_le32(0x04), /* Attribute type
-					can be present multiple times in the
-					mft records of an inode. */
-	ATTR_DEF_NOT_ZERO	= const_cpu_to_le32(0x08), /* Attribute value
-					must contain at least one non-zero
-					byte. */
-	ATTR_DEF_INDEXED_UNIQUE	= const_cpu_to_le32(0x10), /* Attribute must be
-					indexed and the attribute value must be
-					unique for the attribute type in all of
-					the mft records of an inode. */
-	ATTR_DEF_NAMED_UNIQUE	= const_cpu_to_le32(0x20), /* Attribute must be
-					named and the name must be unique for
-					the attribute type in all of the mft
-					records of an inode. */
-	ATTR_DEF_RESIDENT	= const_cpu_to_le32(0x40), /* Attribute must be
-					resident. */
-	ATTR_DEF_ALWAYS_LOG	= const_cpu_to_le32(0x80), /* Always log
-					modifications to this attribute,
-					regardless of whether it is resident or
-					non-resident.  Without this, only log
-					modifications if the attribute is
-					resident. */
-} ATTR_DEF_FLAGS;
-
-/**
- * struct ATTR_DEF -
- *
- * The data attribute of FILE_AttrDef contains a sequence of attribute
- * definitions for the NTFS volume. With this, it is supposed to be safe for an
- * older NTFS driver to mount a volume containing a newer NTFS version without
- * damaging it (that's the theory. In practice it's: not damaging it too much).
- * Entries are sorted by attribute type. The flags describe whether the
- * attribute can be resident/non-resident and possibly other things, but the
- * actual bits are unknown.
- */
-typedef struct {
-/*hex ofs*/
-/*  0*/	ntfschar name[0x40];		/* Unicode name of the attribute. Zero
-					   terminated. */
-/* 80*/	ATTR_TYPES type;		/* Type of the attribute. */
-/* 84*/	le32 display_rule;		/* Default display rule.
-					   FIXME: What does it mean? (AIA) */
-/* 88*/ COLLATION_RULES collation_rule;	/* Default collation rule. */
-/* 8c*/	ATTR_DEF_FLAGS flags;		/* Flags describing the attribute. */
-/* 90*/	sle64 min_size;			/* Optional minimum attribute size. */
-/* 98*/	sle64 max_size;			/* Maximum size of attribute. */
-/* sizeof() = 0xa0 or 160 bytes */
-} __attribute__((__packed__)) ATTR_DEF;
-
-/**
- * enum ATTR_FLAGS - Attribute flags (16-bit).
- */
-typedef enum {
-	ATTR_IS_COMPRESSED	= const_cpu_to_le16(0x0001),
-	ATTR_COMPRESSION_MASK	= const_cpu_to_le16(0x00ff),  /* Compression
-						method mask. Also, first
-						illegal value. */
-	ATTR_IS_ENCRYPTED	= const_cpu_to_le16(0x4000),
-	ATTR_IS_SPARSE		= const_cpu_to_le16(0x8000),
-} __attribute__((__packed__)) ATTR_FLAGS;
-
-/*
- * Attribute compression.
- *
- * Only the data attribute is ever compressed in the current ntfs driver in
- * Windows. Further, compression is only applied when the data attribute is
- * non-resident. Finally, to use compression, the maximum allowed cluster size
- * on a volume is 4kib.
- *
- * The compression method is based on independently compressing blocks of X
- * clusters, where X is determined from the compression_unit value found in the
- * non-resident attribute record header (more precisely: X = 2^compression_unit
- * clusters). On Windows NT/2k, X always is 16 clusters (compression_unit = 4).
- *
- * There are three different cases of how a compression block of X clusters
- * can be stored:
- *
- *   1) The data in the block is all zero (a sparse block):
- *	  This is stored as a sparse block in the runlist, i.e. the runlist
- *	  entry has length = X and lcn = -1. The mapping pairs array actually
- *	  uses a delta_lcn value length of 0, i.e. delta_lcn is not present at
- *	  all, which is then interpreted by the driver as lcn = -1.
- *	  NOTE: Even uncompressed files can be sparse on NTFS 3.0 volumes, then
- *	  the same principles apply as above, except that the length is not
- *	  restricted to being any particular value.
- *
- *   2) The data in the block is not compressed:
- *	  This happens when compression doesn't reduce the size of the block
- *	  in clusters. I.e. if compression has a small effect so that the
- *	  compressed data still occupies X clusters, then the uncompressed data
- *	  is stored in the block.
- *	  This case is recognised by the fact that the runlist entry has
- *	  length = X and lcn >= 0. The mapping pairs array stores this as
- *	  normal with a run length of X and some specific delta_lcn, i.e.
- *	  delta_lcn has to be present.
- *
- *   3) The data in the block is compressed:
- *	  The common case. This case is recognised by the fact that the run
- *	  list entry has length L < X and lcn >= 0. The mapping pairs array
- *	  stores this as normal with a run length of X and some specific
- *	  delta_lcn, i.e. delta_lcn has to be present. This runlist entry is
- *	  immediately followed by a sparse entry with length = X - L and
- *	  lcn = -1. The latter entry is to make up the vcn counting to the
- *	  full compression block size X.
- *
- * In fact, life is more complicated because adjacent entries of the same type
- * can be coalesced. This means that one has to keep track of the number of
- * clusters handled and work on a basis of X clusters at a time being one
- * block. An example: if length L > X this means that this particular runlist
- * entry contains a block of length X and part of one or more blocks of length
- * L - X. Another example: if length L < X, this does not necessarily mean that
- * the block is compressed as it might be that the lcn changes inside the block
- * and hence the following runlist entry describes the continuation of the
- * potentially compressed block. The block would be compressed if the
- * following runlist entry describes at least X - L sparse clusters, thus
- * making up the compression block length as described in point 3 above. (Of
- * course, there can be several runlist entries with small lengths so that the
- * sparse entry does not follow the first data containing entry with
- * length < X.)
- *
- * NOTE: At the end of the compressed attribute value, there most likely is not
- * just the right amount of data to make up a compression block, thus this data
- * is not even attempted to be compressed. It is just stored as is, unless
- * the number of clusters it occupies is reduced when compressed in which case
- * it is stored as a compressed compression block, complete with sparse
- * clusters at the end.
- */
-
-/**
- * enum RESIDENT_ATTR_FLAGS - Flags of resident attributes (8-bit).
- */
-typedef enum {
-	RESIDENT_ATTR_IS_INDEXED = 0x01, /* Attribute is referenced in an index
-					    (has implications for deleting and
-					    modifying the attribute). */
-} __attribute__((__packed__)) RESIDENT_ATTR_FLAGS;
-
-/**
- * struct ATTR_RECORD - Attribute record header.
- *
- * Always aligned to 8-byte boundary.
- */
-typedef struct {
-/*Ofs*/
-/*  0*/	ATTR_TYPES type;	/* The (32-bit) type of the attribute. */
-/*  4*/	le32 length;		/* Byte size of the resident part of the
-				   attribute (aligned to 8-byte boundary).
-				   Used to get to the next attribute. */
-/*  8*/	u8 non_resident;	/* If 0, attribute is resident.
-				   If 1, attribute is non-resident. */
-/*  9*/	u8 name_length;		/* Unicode character size of name of attribute.
-				   0 if unnamed. */
-/* 10*/	le16 name_offset;	/* If name_length != 0, the byte offset to the
-				   beginning of the name from the attribute
-				   record. Note that the name is stored as a
-				   Unicode string. When creating, place offset
-				   just at the end of the record header. Then,
-				   follow with attribute value or mapping pairs
-				   array, resident and non-resident attributes
-				   respectively, aligning to an 8-byte
-				   boundary. */
-/* 12*/	ATTR_FLAGS flags;	/* Flags describing the attribute. */
-/* 14*/	le16 instance;		/* The instance of this attribute record. This
-				   number is unique within this mft record (see
-				   MFT_RECORD/next_attribute_instance notes
-				   above for more details). */
-/* 16*/	union {
-		/* Resident attributes. */
-		struct {
-/* 16 */		le32 value_length; /* Byte size of attribute value. */
-/* 20 */		le16 value_offset; /* Byte offset of the attribute
-					       value from the start of the
-					       attribute record. When creating,
-					       align to 8-byte boundary if we
-					       have a name present as this might
-					       not have a length of a multiple
-					       of 8-bytes. */
-/* 22 */		RESIDENT_ATTR_FLAGS resident_flags; /* See above. */
-/* 23 */		s8 reservedR;	    /* Reserved/alignment to 8-byte
-					       boundary. */
-/* 24 */		void *resident_end[0]; /* Use offsetof(ATTR_RECORD,
-						  resident_end) to get size of
-						  a resident attribute. */
-		} __attribute__((__packed__));
-		/* Non-resident attributes. */
-		struct {
-/* 16*/			leVCN lowest_vcn;/* Lowest valid virtual cluster number
-				for this portion of the attribute value or
-				0 if this is the only extent (usually the
-				case). - Only when an attribute list is used
-				does lowest_vcn != 0 ever occur. */
-/* 24*/			leVCN highest_vcn;/* Highest valid vcn of this extent of
-				the attribute value. - Usually there is only one
-				portion, so this usually equals the attribute
-				value size in clusters minus 1. Can be -1 for
-				zero length files. Can be 0 for "single extent"
-				attributes. */
-/* 32*/			le16 mapping_pairs_offset; /* Byte offset from the
-				beginning of the structure to the mapping pairs
-				array which contains the mappings between the
-				VCNs and the logical cluster numbers (LCNs).
-				When creating, place this at the end of this
-				record header aligned to 8-byte boundary. */
-/* 34*/			u8 compression_unit; /* The compression unit expressed
-				as the log to the base 2 of the number of
-				clusters in a compression unit. 0 means not
-				compressed. (This effectively limits the
-				compression unit size to be a power of two
-				clusters.) WinNT4 only uses a value of 4. */
-/* 35*/			u8 reserved1[5];	/* Align to 8-byte boundary. */
-/* The sizes below are only used when lowest_vcn is zero, as otherwise it would
-   be difficult to keep them up-to-date.*/
-/* 40*/			sle64 allocated_size;	/* Byte size of disk space
-				allocated to hold the attribute value. Always
-				is a multiple of the cluster size. When a file
-				is compressed, this field is a multiple of the
-				compression block size (2^compression_unit) and
-				it represents the logically allocated space
-				rather than the actual on disk usage. For this
-				use the compressed_size (see below). */
-/* 48*/			sle64 data_size;	/* Byte size of the attribute
-				value. Can be larger than allocated_size if
-				attribute value is compressed or sparse. */
-/* 56*/			sle64 initialized_size;	/* Byte size of initialized
-				portion of the attribute value. Usually equals
-				data_size. */
-/* 64 */		void *non_resident_end[0]; /* Use offsetof(ATTR_RECORD,
-						      non_resident_end) to get
-						      size of a non resident
-						      attribute. */
-/* sizeof(uncompressed attr) = 64*/
-/* 64*/			sle64 compressed_size;	/* Byte size of the attribute
-				value after compression. Only present when
-				compressed. Always is a multiple of the
-				cluster size. Represents the actual amount of
-				disk space being used on the disk. */
-/* 72 */		void *compressed_end[0];
-				/* Use offsetof(ATTR_RECORD, compressed_end) to
-				   get size of a compressed attribute. */
-/* sizeof(compressed attr) = 72*/
-		} __attribute__((__packed__));
-	} __attribute__((__packed__));
-} __attribute__((__packed__)) ATTR_RECORD;
-
-typedef ATTR_RECORD ATTR_REC;
-
-/**
- * enum FILE_ATTR_FLAGS - File attribute flags (32-bit).
- */
-typedef enum {
-	/*
-	 * These flags are only present in the STANDARD_INFORMATION attribute
-	 * (in the field file_attributes).
-	 */
-	FILE_ATTR_READONLY		= const_cpu_to_le32(0x00000001),
-	FILE_ATTR_HIDDEN		= const_cpu_to_le32(0x00000002),
-	FILE_ATTR_SYSTEM		= const_cpu_to_le32(0x00000004),
-	/* Old DOS valid. Unused in NT.	= cpu_to_le32(0x00000008), */
-
-	FILE_ATTR_DIRECTORY		= const_cpu_to_le32(0x00000010),
-	/* FILE_ATTR_DIRECTORY is not considered valid in NT. It is reserved
-	   for the DOS SUBDIRECTORY flag. */
-	FILE_ATTR_ARCHIVE		= const_cpu_to_le32(0x00000020),
-	FILE_ATTR_DEVICE		= const_cpu_to_le32(0x00000040),
-	FILE_ATTR_NORMAL		= const_cpu_to_le32(0x00000080),
-
-	FILE_ATTR_TEMPORARY		= const_cpu_to_le32(0x00000100),
-	FILE_ATTR_SPARSE_FILE		= const_cpu_to_le32(0x00000200),
-	FILE_ATTR_REPARSE_POINT		= const_cpu_to_le32(0x00000400),
-	FILE_ATTR_COMPRESSED		= const_cpu_to_le32(0x00000800),
-
-	FILE_ATTR_OFFLINE		= const_cpu_to_le32(0x00001000),
-	FILE_ATTR_NOT_CONTENT_INDEXED	= const_cpu_to_le32(0x00002000),
-	FILE_ATTR_ENCRYPTED		= const_cpu_to_le32(0x00004000),
-
-	FILE_ATTR_VALID_FLAGS		= const_cpu_to_le32(0x00007fb7),
-	/* FILE_ATTR_VALID_FLAGS masks out the old DOS VolId and the
-	   FILE_ATTR_DEVICE and preserves everything else. This mask
-	   is used to obtain all flags that are valid for reading. */
-	FILE_ATTR_VALID_SET_FLAGS	= const_cpu_to_le32(0x000031a7),
-	/* FILE_ATTR_VALID_SET_FLAGS masks out the old DOS VolId, the
-	   FILE_ATTR_DEVICE, FILE_ATTR_DIRECTORY, FILE_ATTR_SPARSE_FILE,
-	   FILE_ATTR_REPARSE_POINT, FILE_ATRE_COMPRESSED and FILE_ATTR_ENCRYPTED
-	   and preserves the rest. This mask is used to to obtain all flags that
-	   are valid for setting. */
-
-	/**
-	 * FILE_ATTR_I30_INDEX_PRESENT - Is it a directory?
-	 *
-	 * This is a copy of the MFT_RECORD_IS_DIRECTORY bit from the mft
-	 * record, telling us whether this is a directory or not, i.e. whether
-	 * it has an index root attribute named "$I30" or not.
-	 *
-	 * This flag is only present in the FILE_NAME attribute (in the
-	 * file_attributes field).
-	 */
-	FILE_ATTR_I30_INDEX_PRESENT	= const_cpu_to_le32(0x10000000),
-
-	/**
-	 * FILE_ATTR_VIEW_INDEX_PRESENT - Does have a non-directory index?
-	 *
-	 * This is a copy of the MFT_RECORD_IS_VIEW_INDEX bit from the mft
-	 * record, telling us whether this file has a view index present (eg.
-	 * object id index, quota index, one of the security indexes and the
-	 * reparse points index).
-	 *
-	 * This flag is only present in the $STANDARD_INFORMATION and
-	 * $FILE_NAME attributes.
-	 */
-	FILE_ATTR_VIEW_INDEX_PRESENT	= const_cpu_to_le32(0x20000000),
-} __attribute__((__packed__)) FILE_ATTR_FLAGS;
-
-/*
- * NOTE on times in NTFS: All times are in MS standard time format, i.e. they
- * are the number of 100-nanosecond intervals since 1st January 1601, 00:00:00
- * universal coordinated time (UTC). (In Linux time starts 1st January 1970,
- * 00:00:00 UTC and is stored as the number of 1-second intervals since then.)
- */
-
-/**
- * struct STANDARD_INFORMATION - Attribute: Standard information (0x10).
- *
- * NOTE: Always resident.
- * NOTE: Present in all base file records on a volume.
- * NOTE: There is conflicting information about the meaning of each of the time
- *	 fields but the meaning as defined below has been verified to be
- *	 correct by practical experimentation on Windows NT4 SP6a and is hence
- *	 assumed to be the one and only correct interpretation.
- */
-typedef struct {
-/*Ofs*/
-/*  0*/	sle64 creation_time;		/* Time file was created. Updated when
-					   a filename is changed(?). */
-/*  8*/	sle64 last_data_change_time;	/* Time the data attribute was last
-					   modified. */
-/* 16*/	sle64 last_mft_change_time;	/* Time this mft record was last
-					   modified. */
-/* 24*/	sle64 last_access_time;		/* Approximate time when the file was
-					   last accessed (obviously this is not
-					   updated on read-only volumes). In
-					   Windows this is only updated when
-					   accessed if some time delta has
-					   passed since the last update. Also,
-					   last access times updates can be
-					   disabled altogether for speed. */
-/* 32*/	FILE_ATTR_FLAGS file_attributes; /* Flags describing the file. */
-/* 36*/	union {
-		/* NTFS 1.2 (and previous, presumably) */
-		struct {
-		/* 36 */ u8 reserved12[12];	/* Reserved/alignment to 8-byte
-						   boundary. */
-		/* 48 */ void *v1_end[0];	/* Marker for offsetof(). */
-		} __attribute__((__packed__));
-/* sizeof() = 48 bytes */
-		/* NTFS 3.0 */
-		struct {
-/*
- * If a volume has been upgraded from a previous NTFS version, then these
- * fields are present only if the file has been accessed since the upgrade.
- * Recognize the difference by comparing the length of the resident attribute
- * value. If it is 48, then the following fields are missing. If it is 72 then
- * the fields are present. Maybe just check like this:
- *	if (resident.ValueLength < sizeof(STANDARD_INFORMATION)) {
- *		Assume NTFS 1.2- format.
- *		If (volume version is 3.0+)
- *			Upgrade attribute to NTFS 3.0 format.
- *		else
- *			Use NTFS 1.2- format for access.
- *	} else
- *		Use NTFS 3.0 format for access.
- * Only problem is that it might be legal to set the length of the value to
- * arbitrarily large values thus spoiling this check. - But chkdsk probably
- * views that as a corruption, assuming that it behaves like this for all
- * attributes.
- */
-		/* 36*/	le32 maximum_versions;	/* Maximum allowed versions for
-				file. Zero if version numbering is disabled. */
-		/* 40*/	le32 version_number;	/* This file's version (if any).
-				Set to zero if maximum_versions is zero. */
-		/* 44*/	le32 class_id;		/* Class id from bidirectional
-				class id index (?). */
-		/* 48*/	le32 owner_id;		/* Owner_id of the user owning
-				the file. Translate via $Q index in FILE_Extend
-				/$Quota to the quota control entry for the user
-				owning the file. Zero if quotas are disabled. */
-		/* 52*/	le32 security_id;	/* Security_id for the file.
-				Translate via $SII index and $SDS data stream
-				in FILE_Secure to the security descriptor. */
-		/* 56*/	le64 quota_charged;	/* Byte size of the charge to
-				the quota for all streams of the file. Note: Is
-				zero if quotas are disabled. */
-		/* 64*/	le64 usn;		/* Last update sequence number
-				of the file. This is a direct index into the
-				change (aka USN) journal file. It is zero if
-				the USN journal is disabled.
-				NOTE: To disable the journal need to delete
-				the journal file itself and to then walk the
-				whole mft and set all USN entries in all mft
-				records to zero! (This can take a while!)
-				The journal is FILE_Extend/$UsnJrnl. Win2k
-				will recreate the journal and initiate
-				logging if necessary when mounting the
-				partition. This, in contrast to disabling the
-				journal is a very fast process, so the user
-				won't even notice it. */
-		/* 72*/ void *v3_end[0]; /* Marker for offsetof(). */
-		} __attribute__((__packed__));
-	} __attribute__((__packed__));
-/* sizeof() = 72 bytes (NTFS 3.0) */
-} __attribute__((__packed__)) STANDARD_INFORMATION;
-
-/**
- * struct ATTR_LIST_ENTRY - Attribute: Attribute list (0x20).
- *
- * - Can be either resident or non-resident.
- * - Value consists of a sequence of variable length, 8-byte aligned,
- * ATTR_LIST_ENTRY records.
- * - The attribute list attribute contains one entry for each attribute of
- * the file in which the list is located, except for the list attribute
- * itself. The list is sorted: first by attribute type, second by attribute
- * name (if present), third by instance number. The extents of one
- * non-resident attribute (if present) immediately follow after the initial
- * extent. They are ordered by lowest_vcn and have their instance set to zero.
- * It is not allowed to have two attributes with all sorting keys equal.
- * - Further restrictions:
- *	- If not resident, the vcn to lcn mapping array has to fit inside the
- *	  base mft record.
- *	- The attribute list attribute value has a maximum size of 256kb. This
- *	  is imposed by the Windows cache manager.
- * - Attribute lists are only used when the attributes of mft record do not
- * fit inside the mft record despite all attributes (that can be made
- * non-resident) having been made non-resident. This can happen e.g. when:
- *	- File has a large number of hard links (lots of file name
- *	  attributes present).
- *	- The mapping pairs array of some non-resident attribute becomes so
- *	  large due to fragmentation that it overflows the mft record.
- *	- The security descriptor is very complex (not applicable to
- *	  NTFS 3.0 volumes).
- *	- There are many named streams.
- */
-typedef struct {
-/*Ofs*/
-/*  0*/	ATTR_TYPES type;	/* Type of referenced attribute. */
-/*  4*/	le16 length;		/* Byte size of this entry. */
-/*  6*/	u8 name_length;		/* Size in Unicode chars of the name of the
-				   attribute or 0 if unnamed. */
-/*  7*/	u8 name_offset;		/* Byte offset to beginning of attribute name
-				   (always set this to where the name would
-				   start even if unnamed). */
-/*  8*/	leVCN lowest_vcn;	/* Lowest virtual cluster number of this portion
-				   of the attribute value. This is usually 0. It
-				   is non-zero for the case where one attribute
-				   does not fit into one mft record and thus
-				   several mft records are allocated to hold
-				   this attribute. In the latter case, each mft
-				   record holds one extent of the attribute and
-				   there is one attribute list entry for each
-				   extent. NOTE: This is DEFINITELY a signed
-				   value! The windows driver uses cmp, followed
-				   by jg when comparing this, thus it treats it
-				   as signed. */
-/* 16*/	leMFT_REF mft_reference;/* The reference of the mft record holding
-				   the ATTR_RECORD for this portion of the
-				   attribute value. */
-/* 24*/	le16 instance;		/* If lowest_vcn = 0, the instance of the
-				   attribute being referenced; otherwise 0. */
-/* 26*/	ntfschar name[0];	/* Use when creating only. When reading use
-				   name_offset to determine the location of the
-				   name. */
-/* sizeof() = 26 + (attribute_name_length * 2) bytes */
-} __attribute__((__packed__)) ATTR_LIST_ENTRY;
-
-/*
- * The maximum allowed length for a file name.
- */
-#define NTFS_MAX_NAME_LEN	255
-
-/**
- * enum FILE_NAME_TYPE_FLAGS - Possible namespaces for filenames in ntfs.
- * (8-bit).
- */
-typedef enum {
-	FILE_NAME_POSIX			= 0x00,
-		/* This is the largest namespace. It is case sensitive and
-		   allows all Unicode characters except for: '\0' and '/'.
-		   Beware that in WinNT/2k files which eg have the same name
-		   except for their case will not be distinguished by the
-		   standard utilities and thus a "del filename" will delete
-		   both "filename" and "fileName" without warning. */
-	FILE_NAME_WIN32			= 0x01,
-		/* The standard WinNT/2k NTFS long filenames. Case insensitive.
-		   All Unicode chars except: '\0', '"', '*', '/', ':', '<',
-		   '>', '?', '\' and '|'. Further, names cannot end with a '.'
-		   or a space. */
-	FILE_NAME_DOS			= 0x02,
-		/* The standard DOS filenames (8.3 format). Uppercase only.
-		   All 8-bit characters greater space, except: '"', '*', '+',
-		   ',', '/', ':', ';', '<', '=', '>', '?' and '\'. */
-	FILE_NAME_WIN32_AND_DOS		= 0x03,
-		/* 3 means that both the Win32 and the DOS filenames are
-		   identical and hence have been saved in this single filename
-		   record. */
-} __attribute__((__packed__)) FILE_NAME_TYPE_FLAGS;
-
-/**
- * struct FILE_NAME_ATTR - Attribute: Filename (0x30).
- *
- * NOTE: Always resident.
- * NOTE: All fields, except the parent_directory, are only updated when the
- *	 filename is changed. Until then, they just become out of sync with
- *	 reality and the more up to date values are present in the standard
- *	 information attribute.
- * NOTE: There is conflicting information about the meaning of each of the time
- *	 fields but the meaning as defined below has been verified to be
- *	 correct by practical experimentation on Windows NT4 SP6a and is hence
- *	 assumed to be the one and only correct interpretation.
- */
-typedef struct {
-/*hex ofs*/
-/*  0*/	leMFT_REF parent_directory;	/* Directory this filename is
-					   referenced from. */
-/*  8*/	sle64 creation_time;		/* Time file was created. */
-/* 10*/	sle64 last_data_change_time;	/* Time the data attribute was last
-					   modified. */
-/* 18*/	sle64 last_mft_change_time;	/* Time this mft record was last
-					   modified. */
-/* 20*/	sle64 last_access_time;		/* Last time this mft record was
-					   accessed. */
-/* 28*/	sle64 allocated_size;		/* Byte size of on-disk allocated space
-					   for the data attribute.  So for
-					   normal $DATA, this is the
-					   allocated_size from the unnamed
-					   $DATA attribute and for compressed
-					   and/or sparse $DATA, this is the
-					   compressed_size from the unnamed
-					   $DATA attribute.  NOTE: This is a
-					   multiple of the cluster size. */
-/* 30*/	sle64 data_size;			/* Byte size of actual data in data
-					   attribute. */
-/* 38*/	FILE_ATTR_FLAGS file_attributes;	/* Flags describing the file. */
-/* 3c*/	union {
-	/* 3c*/	struct {
-		/* 3c*/	le16 packed_ea_size;	/* Size of the buffer needed to
-						   pack the extended attributes
-						   (EAs), if such are present.*/
-		/* 3e*/	le16 reserved;		/* Reserved for alignment. */
-		} __attribute__((__packed__));
-	/* 3c*/	le32 reparse_point_tag;		/* Type of reparse point,
-						   present only in reparse
-						   points and only if there are
-						   no EAs. */
-	} __attribute__((__packed__));
-/* 40*/	u8 file_name_length;			/* Length of file name in
-						   (Unicode) characters. */
-/* 41*/	FILE_NAME_TYPE_FLAGS file_name_type;	/* Namespace of the file name.*/
-/* 42*/	ntfschar file_name[0];			/* File name in Unicode. */
-} __attribute__((__packed__)) FILE_NAME_ATTR;
-
-/**
- * struct GUID - GUID structures store globally unique identifiers (GUID).
- *
- * A GUID is a 128-bit value consisting of one group of eight hexadecimal
- * digits, followed by three groups of four hexadecimal digits each, followed
- * by one group of twelve hexadecimal digits. GUIDs are Microsoft's
- * implementation of the distributed computing environment (DCE) universally
- * unique identifier (UUID).
- *
- * Example of a GUID in string format:
- *	1F010768-5A73-BC91-0010-A52216A7227B
- * And the same in binary:
- *	1F0107685A73BC910010A52216A7227B
- */
-typedef union {
-	struct {
-		le32 data1;	/* The first eight hexadecimal digits of the
-				   GUID. */
-		le16 data2;	/* The first group of four hexadecimal
-				   digits. */
-		le16 data3;	/* The second group of four hexadecimal
-				   digits. */
-		u8 data4[8];	/* The first two bytes are the third group of
-				   four hexadecimal digits.  The remaining six
-				   bytes are the final 12 hexadecimal digits. */
-	} __attribute__((__packed__));
-	u8 raw[16];		/* Raw binary for ease of access. */
-} __attribute__((__packed__)) GUID;
-
-/**
- * struct OBJ_ID_INDEX_DATA - FILE_Extend/$ObjId contains an index named $O.
- *
- * This index contains all object_ids present on the volume as the index keys
- * and the corresponding mft_record numbers as the index entry data parts.
- *
- * The data part (defined below) also contains three other object_ids:
- *	birth_volume_id - object_id of FILE_Volume on which the file was first
- *			  created. Optional (i.e. can be zero).
- *	birth_object_id - object_id of file when it was first created. Usually
- *			  equals the object_id. Optional (i.e. can be zero).
- *	domain_id	- Reserved (always zero).
- */
-typedef struct {
-	leMFT_REF mft_reference;/* Mft record containing the object_id in
-				   the index entry key. */
-	union {
-		struct {
-			GUID birth_volume_id;
-			GUID birth_object_id;
-			GUID domain_id;
-		} __attribute__((__packed__));
-		u8 extended_info[48];
-	} __attribute__((__packed__));
-} __attribute__((__packed__)) OBJ_ID_INDEX_DATA;
-
-/**
- * struct OBJECT_ID_ATTR - Attribute: Object id (NTFS 3.0+) (0x40).
- *
- * NOTE: Always resident.
- */
-typedef struct {
-	GUID object_id;				/* Unique id assigned to the
-						   file.*/
-	/* The following fields are optional. The attribute value size is 16
-	   bytes, i.e. sizeof(GUID), if these are not present at all. Note,
-	   the entries can be present but one or more (or all) can be zero
-	   meaning that that particular value(s) is(are) not defined. Note,
-	   when the fields are missing here, it is well possible that they are
-	   to be found within the $Extend/$ObjId system file indexed under the
-	   above object_id. */
-	union {
-		struct {
-			GUID birth_volume_id;	/* Unique id of volume on which
-						   the file was first created.*/
-			GUID birth_object_id;	/* Unique id of file when it was
-						   first created. */
-			GUID domain_id;		/* Reserved, zero. */
-		} __attribute__((__packed__));
-		u8 extended_info[48];
-	} __attribute__((__packed__));
-} __attribute__((__packed__)) OBJECT_ID_ATTR;
-
-#if 0
-/**
- * enum IDENTIFIER_AUTHORITIES -
- *
- * The pre-defined IDENTIFIER_AUTHORITIES used as SID_IDENTIFIER_AUTHORITY in
- * the SID structure (see below).
- */
-typedef enum {					/* SID string prefix. */
-	SECURITY_NULL_SID_AUTHORITY	= {0, 0, 0, 0, 0, 0},	/* S-1-0 */
-	SECURITY_WORLD_SID_AUTHORITY	= {0, 0, 0, 0, 0, 1},	/* S-1-1 */
-	SECURITY_LOCAL_SID_AUTHORITY	= {0, 0, 0, 0, 0, 2},	/* S-1-2 */
-	SECURITY_CREATOR_SID_AUTHORITY	= {0, 0, 0, 0, 0, 3},	/* S-1-3 */
-	SECURITY_NON_UNIQUE_AUTHORITY	= {0, 0, 0, 0, 0, 4},	/* S-1-4 */
-	SECURITY_NT_SID_AUTHORITY	= {0, 0, 0, 0, 0, 5},	/* S-1-5 */
-} IDENTIFIER_AUTHORITIES;
-#endif
-
-/**
- * enum RELATIVE_IDENTIFIERS -
- *
- * These relative identifiers (RIDs) are used with the above identifier
- * authorities to make up universal well-known SIDs.
- *
- * Note: The relative identifier (RID) refers to the portion of a SID, which
- * identifies a user or group in relation to the authority that issued the SID.
- * For example, the universal well-known SID Creator Owner ID (S-1-3-0) is
- * made up of the identifier authority SECURITY_CREATOR_SID_AUTHORITY (3) and
- * the relative identifier SECURITY_CREATOR_OWNER_RID (0).
- */
-typedef enum {					/* Identifier authority. */
-	SECURITY_NULL_RID		  = 0,	/* S-1-0 */
-	SECURITY_WORLD_RID		  = 0,	/* S-1-1 */
-	SECURITY_LOCAL_RID		  = 0,	/* S-1-2 */
-
-	SECURITY_CREATOR_OWNER_RID	  = 0,	/* S-1-3 */
-	SECURITY_CREATOR_GROUP_RID	  = 1,	/* S-1-3 */
-
-	SECURITY_CREATOR_OWNER_SERVER_RID = 2,	/* S-1-3 */
-	SECURITY_CREATOR_GROUP_SERVER_RID = 3,	/* S-1-3 */
-
-	SECURITY_DIALUP_RID		  = 1,
-	SECURITY_NETWORK_RID		  = 2,
-	SECURITY_BATCH_RID		  = 3,
-	SECURITY_INTERACTIVE_RID	  = 4,
-	SECURITY_SERVICE_RID		  = 6,
-	SECURITY_ANONYMOUS_LOGON_RID	  = 7,
-	SECURITY_PROXY_RID		  = 8,
-	SECURITY_ENTERPRISE_CONTROLLERS_RID=9,
-	SECURITY_SERVER_LOGON_RID	  = 9,
-	SECURITY_PRINCIPAL_SELF_RID	  = 0xa,
-	SECURITY_AUTHENTICATED_USER_RID	  = 0xb,
-	SECURITY_RESTRICTED_CODE_RID	  = 0xc,
-	SECURITY_TERMINAL_SERVER_RID	  = 0xd,
-
-	SECURITY_LOGON_IDS_RID		  = 5,
-	SECURITY_LOGON_IDS_RID_COUNT	  = 3,
-
-	SECURITY_LOCAL_SYSTEM_RID	  = 0x12,
-
-	SECURITY_NT_NON_UNIQUE		  = 0x15,
-
-	SECURITY_BUILTIN_DOMAIN_RID	  = 0x20,
-
-	/*
-	 * Well-known domain relative sub-authority values (RIDs).
-	 */
-
-	/* Users. */
-	DOMAIN_USER_RID_ADMIN		  = 0x1f4,
-	DOMAIN_USER_RID_GUEST		  = 0x1f5,
-	DOMAIN_USER_RID_KRBTGT		  = 0x1f6,
-
-	/* Groups. */
-	DOMAIN_GROUP_RID_ADMINS		  = 0x200,
-	DOMAIN_GROUP_RID_USERS		  = 0x201,
-	DOMAIN_GROUP_RID_GUESTS		  = 0x202,
-	DOMAIN_GROUP_RID_COMPUTERS	  = 0x203,
-	DOMAIN_GROUP_RID_CONTROLLERS	  = 0x204,
-	DOMAIN_GROUP_RID_CERT_ADMINS	  = 0x205,
-	DOMAIN_GROUP_RID_SCHEMA_ADMINS	  = 0x206,
-	DOMAIN_GROUP_RID_ENTERPRISE_ADMINS= 0x207,
-	DOMAIN_GROUP_RID_POLICY_ADMINS	  = 0x208,
-
-	/* Aliases. */
-	DOMAIN_ALIAS_RID_ADMINS		  = 0x220,
-	DOMAIN_ALIAS_RID_USERS		  = 0x221,
-	DOMAIN_ALIAS_RID_GUESTS		  = 0x222,
-	DOMAIN_ALIAS_RID_POWER_USERS	  = 0x223,
-
-	DOMAIN_ALIAS_RID_ACCOUNT_OPS	  = 0x224,
-	DOMAIN_ALIAS_RID_SYSTEM_OPS	  = 0x225,
-	DOMAIN_ALIAS_RID_PRINT_OPS	  = 0x226,
-	DOMAIN_ALIAS_RID_BACKUP_OPS	  = 0x227,
-
-	DOMAIN_ALIAS_RID_REPLICATOR	  = 0x228,
-	DOMAIN_ALIAS_RID_RAS_SERVERS	  = 0x229,
-	DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x22a,
-} RELATIVE_IDENTIFIERS;
-
-/*
- * The universal well-known SIDs:
- *
- *	NULL_SID			S-1-0-0
- *	WORLD_SID			S-1-1-0
- *	LOCAL_SID			S-1-2-0
- *	CREATOR_OWNER_SID		S-1-3-0
- *	CREATOR_GROUP_SID		S-1-3-1
- *	CREATOR_OWNER_SERVER_SID	S-1-3-2
- *	CREATOR_GROUP_SERVER_SID	S-1-3-3
- *
- *	(Non-unique IDs)		S-1-4
- *
- * NT well-known SIDs:
- *
- *	NT_AUTHORITY_SID	S-1-5
- *	DIALUP_SID		S-1-5-1
- *
- *	NETWORK_SID		S-1-5-2
- *	BATCH_SID		S-1-5-3
- *	INTERACTIVE_SID		S-1-5-4
- *	SERVICE_SID		S-1-5-6
- *	ANONYMOUS_LOGON_SID	S-1-5-7		(aka null logon session)
- *	PROXY_SID		S-1-5-8
- *	SERVER_LOGON_SID	S-1-5-9		(aka domain controller account)
- *	SELF_SID		S-1-5-10	(self RID)
- *	AUTHENTICATED_USER_SID	S-1-5-11
- *	RESTRICTED_CODE_SID	S-1-5-12	(running restricted code)
- *	TERMINAL_SERVER_SID	S-1-5-13	(running on terminal server)
- *
- *	(Logon IDs)		S-1-5-5-X-Y
- *
- *	(NT non-unique IDs)	S-1-5-0x15-...
- *
- *	(Built-in domain)	S-1-5-0x20
- */
-
-/**
- * union SID_IDENTIFIER_AUTHORITY - A 48-bit value used in the SID structure
- *
- * NOTE: This is stored as a big endian number.
- */
-typedef union {
-	struct {
-		be16 high_part;		/* High 16-bits. */
-		be32 low_part;		/* Low 32-bits. */
-	} __attribute__((__packed__));
-	u8 value[6];			/* Value as individual bytes. */
-} __attribute__((__packed__)) SID_IDENTIFIER_AUTHORITY;
-
-/**
- * struct SID -
- *
- * The SID structure is a variable-length structure used to uniquely identify
- * users or groups. SID stands for security identifier.
- *
- * The standard textual representation of the SID is of the form:
- *	S-R-I-S-S...
- * Where:
- *    - The first "S" is the literal character 'S' identifying the following
- *	digits as a SID.
- *    - R is the revision level of the SID expressed as a sequence of digits
- *	in decimal.
- *    - I is the 48-bit identifier_authority, expressed as digits in decimal,
- *	if I < 2^32, or hexadecimal prefixed by "0x", if I >= 2^32.
- *    - S... is one or more sub_authority values, expressed as digits in
- *	decimal.
- *
- * Example SID; the domain-relative SID of the local Administrators group on
- * Windows NT/2k:
- *	S-1-5-32-544
- * This translates to a SID with:
- *	revision = 1,
- *	sub_authority_count = 2,
- *	identifier_authority = {0,0,0,0,0,5},	// SECURITY_NT_AUTHORITY
- *	sub_authority[0] = 32,			// SECURITY_BUILTIN_DOMAIN_RID
- *	sub_authority[1] = 544			// DOMAIN_ALIAS_RID_ADMINS
- */
-typedef struct {
-	u8 revision;
-	u8 sub_authority_count;
-	SID_IDENTIFIER_AUTHORITY identifier_authority;
-	le32 sub_authority[1];		/* At least one sub_authority. */
-} __attribute__((__packed__)) SID;
-
-/**
- * enum SID_CONSTANTS - Current constants for SIDs.
- */
-typedef enum {
-	SID_REVISION			=  1,	/* Current revision level. */
-	SID_MAX_SUB_AUTHORITIES		= 15,	/* Maximum number of those. */
-	SID_RECOMMENDED_SUB_AUTHORITIES	=  1,	/* Will change to around 6 in
-						   a future revision. */
-} SID_CONSTANTS;
-
-/**
- * enum ACE_TYPES - The predefined ACE types (8-bit, see below).
- */
-typedef enum {
-	ACCESS_MIN_MS_ACE_TYPE		= 0,
-	ACCESS_ALLOWED_ACE_TYPE		= 0,
-	ACCESS_DENIED_ACE_TYPE		= 1,
-	SYSTEM_AUDIT_ACE_TYPE		= 2,
-	SYSTEM_ALARM_ACE_TYPE		= 3, /* Not implemented as of Win2k. */
-	ACCESS_MAX_MS_V2_ACE_TYPE	= 3,
-
-	ACCESS_ALLOWED_COMPOUND_ACE_TYPE= 4,
-	ACCESS_MAX_MS_V3_ACE_TYPE	= 4,
-
-	/* The following are Win2k only. */
-	ACCESS_MIN_MS_OBJECT_ACE_TYPE	= 5,
-	ACCESS_ALLOWED_OBJECT_ACE_TYPE	= 5,
-	ACCESS_DENIED_OBJECT_ACE_TYPE	= 6,
-	SYSTEM_AUDIT_OBJECT_ACE_TYPE	= 7,
-	SYSTEM_ALARM_OBJECT_ACE_TYPE	= 8,
-	ACCESS_MAX_MS_OBJECT_ACE_TYPE	= 8,
-
-	ACCESS_MAX_MS_V4_ACE_TYPE	= 8,
-
-	/* This one is for WinNT&2k. */
-	ACCESS_MAX_MS_ACE_TYPE		= 8,
-} __attribute__((__packed__)) ACE_TYPES;
-
-/**
- * enum ACE_FLAGS - The ACE flags (8-bit) for audit and inheritance.
- *
- * SUCCESSFUL_ACCESS_ACE_FLAG is only used with system audit and alarm ACE
- * types to indicate that a message is generated (in Windows!) for successful
- * accesses.
- *
- * FAILED_ACCESS_ACE_FLAG is only used with system audit and alarm ACE types
- * to indicate that a message is generated (in Windows!) for failed accesses.
- */
-typedef enum {
-	/* The inheritance flags. */
-	OBJECT_INHERIT_ACE		= 0x01,
-	CONTAINER_INHERIT_ACE		= 0x02,
-	NO_PROPAGATE_INHERIT_ACE	= 0x04,
-	INHERIT_ONLY_ACE		= 0x08,
-	INHERITED_ACE			= 0x10,	/* Win2k only. */
-	VALID_INHERIT_FLAGS		= 0x1f,
-
-	/* The audit flags. */
-	SUCCESSFUL_ACCESS_ACE_FLAG	= 0x40,
-	FAILED_ACCESS_ACE_FLAG		= 0x80,
-} __attribute__((__packed__)) ACE_FLAGS;
-
-/**
- * struct ACE_HEADER -
- *
- * An ACE is an access-control entry in an access-control list (ACL).
- * An ACE defines access to an object for a specific user or group or defines
- * the types of access that generate system-administration messages or alarms
- * for a specific user or group. The user or group is identified by a security
- * identifier (SID).
- *
- * Each ACE starts with an ACE_HEADER structure (aligned on 4-byte boundary),
- * which specifies the type and size of the ACE. The format of the subsequent
- * data depends on the ACE type.
- */
-typedef struct {
-	ACE_TYPES type;		/* Type of the ACE. */
-	ACE_FLAGS flags;	/* Flags describing the ACE. */
-	le16 size;		/* Size in bytes of the ACE. */
-} __attribute__((__packed__)) ACE_HEADER;
-
-/**
- * enum ACCESS_MASK - The access mask (32-bit).
- *
- * Defines the access rights.
- */
-typedef enum {
-	/*
-	 * The specific rights (bits 0 to 15). Depend on the type of the
-	 * object being secured by the ACE.
-	 */
-
-	/* Specific rights for files and directories are as follows: */
-
-	/* Right to read data from the file. (FILE) */
-	FILE_READ_DATA			= const_cpu_to_le32(0x00000001),
-	/* Right to list contents of a directory. (DIRECTORY) */
-	FILE_LIST_DIRECTORY		= const_cpu_to_le32(0x00000001),
-
-	/* Right to write data to the file. (FILE) */
-	FILE_WRITE_DATA			= const_cpu_to_le32(0x00000002),
-	/* Right to create a file in the directory. (DIRECTORY) */
-	FILE_ADD_FILE			= const_cpu_to_le32(0x00000002),
-
-	/* Right to append data to the file. (FILE) */
-	FILE_APPEND_DATA		= const_cpu_to_le32(0x00000004),
-	/* Right to create a subdirectory. (DIRECTORY) */
-	FILE_ADD_SUBDIRECTORY		= const_cpu_to_le32(0x00000004),
-
-	/* Right to read extended attributes. (FILE/DIRECTORY) */
-	FILE_READ_EA			= const_cpu_to_le32(0x00000008),
-
-	/* Right to write extended attributes. (FILE/DIRECTORY) */
-	FILE_WRITE_EA			= const_cpu_to_le32(0x00000010),
-
-	/* Right to execute a file. (FILE) */
-	FILE_EXECUTE			= const_cpu_to_le32(0x00000020),
-	/* Right to traverse the directory. (DIRECTORY) */
-	FILE_TRAVERSE			= const_cpu_to_le32(0x00000020),
-
-	/*
-	 * Right to delete a directory and all the files it contains (its
-	 * children), even if the files are read-only. (DIRECTORY)
-	 */
-	FILE_DELETE_CHILD		= const_cpu_to_le32(0x00000040),
-
-	/* Right to read file attributes. (FILE/DIRECTORY) */
-	FILE_READ_ATTRIBUTES		= const_cpu_to_le32(0x00000080),
-
-	/* Right to change file attributes. (FILE/DIRECTORY) */
-	FILE_WRITE_ATTRIBUTES		= const_cpu_to_le32(0x00000100),
-
-	/*
-	 * The standard rights (bits 16 to 23). Are independent of the type of
-	 * object being secured.
-	 */
-
-	/* Right to delete the object. */
-	DELETE				= const_cpu_to_le32(0x00010000),
-
-	/*
-	 * Right to read the information in the object's security descriptor,
-	 * not including the information in the SACL. I.e. right to read the
-	 * security descriptor and owner.
-	 */
-	READ_CONTROL			= const_cpu_to_le32(0x00020000),
-
-	/* Right to modify the DACL in the object's security descriptor. */
-	WRITE_DAC			= const_cpu_to_le32(0x00040000),
-
-	/* Right to change the owner in the object's security descriptor. */
-	WRITE_OWNER			= const_cpu_to_le32(0x00080000),
-
-	/*
-	 * Right to use the object for synchronization. Enables a process to
-	 * wait until the object is in the signalled state. Some object types
-	 * do not support this access right.
-	 */
-	SYNCHRONIZE			= const_cpu_to_le32(0x00100000),
-
-	/*
-	 * The following STANDARD_RIGHTS_* are combinations of the above for
-	 * convenience and are defined by the Win32 API.
-	 */
-
-	/* These are currently defined to READ_CONTROL. */
-	STANDARD_RIGHTS_READ		= const_cpu_to_le32(0x00020000),
-	STANDARD_RIGHTS_WRITE		= const_cpu_to_le32(0x00020000),
-	STANDARD_RIGHTS_EXECUTE		= const_cpu_to_le32(0x00020000),
-
-	/* Combines DELETE, READ_CONTROL, WRITE_DAC, and WRITE_OWNER access. */
-	STANDARD_RIGHTS_REQUIRED	= const_cpu_to_le32(0x000f0000),
-
-	/*
-	 * Combines DELETE, READ_CONTROL, WRITE_DAC, WRITE_OWNER, and
-	 * SYNCHRONIZE access.
-	 */
-	STANDARD_RIGHTS_ALL		= const_cpu_to_le32(0x001f0000),
-
-	/*
-	 * The access system ACL and maximum allowed access types (bits 24 to
-	 * 25, bits 26 to 27 are reserved).
-	 */
-	ACCESS_SYSTEM_SECURITY		= const_cpu_to_le32(0x01000000),
-	MAXIMUM_ALLOWED			= const_cpu_to_le32(0x02000000),
-
-	/*
-	 * The generic rights (bits 28 to 31). These map onto the standard and
-	 * specific rights.
-	 */
-
-	/* Read, write, and execute access. */
-	GENERIC_ALL			= const_cpu_to_le32(0x10000000),
-
-	/* Execute access. */
-	GENERIC_EXECUTE			= const_cpu_to_le32(0x20000000),
-
-	/*
-	 * Write access. For files, this maps onto:
-	 *	FILE_APPEND_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA |
-	 *	FILE_WRITE_EA | STANDARD_RIGHTS_WRITE | SYNCHRONIZE
-	 * For directories, the mapping has the same numerical value. See
-	 * above for the descriptions of the rights granted.
-	 */
-	GENERIC_WRITE			= const_cpu_to_le32(0x40000000),
-
-	/*
-	 * Read access. For files, this maps onto:
-	 *	FILE_READ_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA |
-	 *	STANDARD_RIGHTS_READ | SYNCHRONIZE
-	 * For directories, the mapping has the same numerical value. See
-	 * above for the descriptions of the rights granted.
-	 */
-	GENERIC_READ			= const_cpu_to_le32(0x80000000),
-} ACCESS_MASK;
-
-/**
- * struct GENERIC_MAPPING -
- *
- * The generic mapping array. Used to denote the mapping of each generic
- * access right to a specific access mask.
- *
- * FIXME: What exactly is this and what is it for? (AIA)
- */
-typedef struct {
-	ACCESS_MASK generic_read;
-	ACCESS_MASK generic_write;
-	ACCESS_MASK generic_execute;
-	ACCESS_MASK generic_all;
-} __attribute__((__packed__)) GENERIC_MAPPING;
-
-/*
- * The predefined ACE type structures are as defined below.
- */
-
-/**
- * struct ACCESS_DENIED_ACE -
- *
- * ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE, SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE
- */
-typedef struct {
-/*  0	ACE_HEADER; -- Unfolded here as gcc doesn't like unnamed structs. */
-	ACE_TYPES type;		/* Type of the ACE. */
-	ACE_FLAGS flags;	/* Flags describing the ACE. */
-	le16 size;		/* Size in bytes of the ACE. */
-
-/*  4*/	ACCESS_MASK mask;	/* Access mask associated with the ACE. */
-/*  8*/	SID sid;		/* The SID associated with the ACE. */
-} __attribute__((__packed__)) ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE,
-			       SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE;
-
-/**
- * enum OBJECT_ACE_FLAGS - The object ACE flags (32-bit).
- */
-typedef enum {
-	ACE_OBJECT_TYPE_PRESENT			= const_cpu_to_le32(1),
-	ACE_INHERITED_OBJECT_TYPE_PRESENT	= const_cpu_to_le32(2),
-} OBJECT_ACE_FLAGS;
-
-/**
- * struct ACCESS_ALLOWED_OBJECT_ACE -
- */
-typedef struct {
-/*  0	ACE_HEADER; -- Unfolded here as gcc doesn't like unnamed structs. */
-	ACE_TYPES type;		/* Type of the ACE. */
-	ACE_FLAGS flags;	/* Flags describing the ACE. */
-	le16 size;		/* Size in bytes of the ACE. */
-
-/*  4*/	ACCESS_MASK mask;	/* Access mask associated with the ACE. */
-/*  8*/	OBJECT_ACE_FLAGS object_flags;	/* Flags describing the object ACE. */
-/* 12*/	GUID object_type;
-/* 28*/	GUID inherited_object_type;
-/* 44*/	SID sid;		/* The SID associated with the ACE. */
-} __attribute__((__packed__)) ACCESS_ALLOWED_OBJECT_ACE,
-			       ACCESS_DENIED_OBJECT_ACE,
-			       SYSTEM_AUDIT_OBJECT_ACE,
-			       SYSTEM_ALARM_OBJECT_ACE;
-
-/**
- * struct ACL - An ACL is an access-control list (ACL).
- *
- * An ACL starts with an ACL header structure, which specifies the size of
- * the ACL and the number of ACEs it contains. The ACL header is followed by
- * zero or more access control entries (ACEs). The ACL as well as each ACE
- * are aligned on 4-byte boundaries.
- */
-typedef struct {
-	u8 revision;	/* Revision of this ACL. */
-	u8 alignment1;
-	le16 size;	/* Allocated space in bytes for ACL. Includes this
-			   header, the ACEs and the remaining free space. */
-	le16 ace_count;	/* Number of ACEs in the ACL. */
-	le16 alignment2;
-/* sizeof() = 8 bytes */
-} __attribute__((__packed__)) ACL;
-
-/**
- * enum ACL_CONSTANTS - Current constants for ACLs.
- */
-typedef enum {
-	/* Current revision. */
-	ACL_REVISION		= 2,
-	ACL_REVISION_DS		= 4,
-
-	/* History of revisions. */
-	ACL_REVISION1		= 1,
-	MIN_ACL_REVISION	= 2,
-	ACL_REVISION2		= 2,
-	ACL_REVISION3		= 3,
-	ACL_REVISION4		= 4,
-	MAX_ACL_REVISION	= 4,
-} ACL_CONSTANTS;
-
-/**
- * enum SECURITY_DESCRIPTOR_CONTROL -
- *
- * The security descriptor control flags (16-bit).
- *
- * SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
- *	SID pointed to by the Owner field was provided by a
- *	defaulting mechanism rather than explicitly provided by the
- *	original provider of the security descriptor.  This may
- *	affect the treatment of the SID with respect to inheritance
- *	of an owner.
- *
- * SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
- *	SID in the Group field was provided by a defaulting mechanism
- *	rather than explicitly provided by the original provider of
- *	the security descriptor.  This may affect the treatment of
- *	the SID with respect to inheritance of a primary group.
- *
- * SE_DACL_PRESENT - This boolean flag, when set, indicates that the
- *	security descriptor contains a discretionary ACL.  If this
- *	flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
- *	null, then a null ACL is explicitly being specified.
- *
- * SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
- *	ACL pointed to by the Dacl field was provided by a defaulting
- *	mechanism rather than explicitly provided by the original
- *	provider of the security descriptor.  This may affect the
- *	treatment of the ACL with respect to inheritance of an ACL.
- *	This flag is ignored if the DaclPresent flag is not set.
- *
- * SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
- *	security descriptor contains a system ACL pointed to by the
- *	Sacl field.  If this flag is set and the Sacl field of the
- *	SECURITY_DESCRIPTOR is null, then an empty (but present)
- *	ACL is being specified.
- *
- * SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
- *	ACL pointed to by the Sacl field was provided by a defaulting
- *	mechanism rather than explicitly provided by the original
- *	provider of the security descriptor.  This may affect the
- *	treatment of the ACL with respect to inheritance of an ACL.
- *	This flag is ignored if the SaclPresent flag is not set.
- *
- * SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
- *	security descriptor is in self-relative form.  In this form,
- *	all fields of the security descriptor are contiguous in memory
- *	and all pointer fields are expressed as offsets from the
- *	beginning of the security descriptor.
- */
-typedef enum {
-	SE_OWNER_DEFAULTED		= const_cpu_to_le16(0x0001),
-	SE_GROUP_DEFAULTED		= const_cpu_to_le16(0x0002),
-	SE_DACL_PRESENT			= const_cpu_to_le16(0x0004),
-	SE_DACL_DEFAULTED		= const_cpu_to_le16(0x0008),
-	SE_SACL_PRESENT			= const_cpu_to_le16(0x0010),
-	SE_SACL_DEFAULTED		= const_cpu_to_le16(0x0020),
-	SE_DACL_AUTO_INHERIT_REQ	= const_cpu_to_le16(0x0100),
-	SE_SACL_AUTO_INHERIT_REQ	= const_cpu_to_le16(0x0200),
-	SE_DACL_AUTO_INHERITED		= const_cpu_to_le16(0x0400),
-	SE_SACL_AUTO_INHERITED		= const_cpu_to_le16(0x0800),
-	SE_DACL_PROTECTED		= const_cpu_to_le16(0x1000),
-	SE_SACL_PROTECTED		= const_cpu_to_le16(0x2000),
-	SE_RM_CONTROL_VALID		= const_cpu_to_le16(0x4000),
-	SE_SELF_RELATIVE		= const_cpu_to_le16(0x8000),
-} __attribute__((__packed__)) SECURITY_DESCRIPTOR_CONTROL;
-
-/**
- * struct SECURITY_DESCRIPTOR_RELATIVE -
- *
- * Self-relative security descriptor. Contains the owner and group SIDs as well
- * as the sacl and dacl ACLs inside the security descriptor itself.
- */
-typedef struct {
-	u8 revision;	/* Revision level of the security descriptor. */
-	u8 alignment;
-	SECURITY_DESCRIPTOR_CONTROL control; /* Flags qualifying the type of
-			   the descriptor as well as the following fields. */
-	le32 owner;	/* Byte offset to a SID representing an object's
-			   owner. If this is NULL, no owner SID is present in
-			   the descriptor. */
-	le32 group;	/* Byte offset to a SID representing an object's
-			   primary group. If this is NULL, no primary group
-			   SID is present in the descriptor. */
-	le32 sacl;	/* Byte offset to a system ACL. Only valid, if
-			   SE_SACL_PRESENT is set in the control field. If
-			   SE_SACL_PRESENT is set but sacl is NULL, a NULL ACL
-			   is specified. */
-	le32 dacl;	/* Byte offset to a discretionary ACL. Only valid, if
-			   SE_DACL_PRESENT is set in the control field. If
-			   SE_DACL_PRESENT is set but dacl is NULL, a NULL ACL
-			   (unconditionally granting access) is specified. */
-/* sizeof() = 0x14 bytes */
-} __attribute__((__packed__)) SECURITY_DESCRIPTOR_RELATIVE;
-
-/**
- * struct SECURITY_DESCRIPTOR - Absolute security descriptor.
- *
- * Does not contain the owner and group SIDs, nor the sacl and dacl ACLs inside
- * the security descriptor. Instead, it contains pointers to these structures
- * in memory. Obviously, absolute security descriptors are only useful for in
- * memory representations of security descriptors.
- *
- * On disk, a self-relative security descriptor is used.
- */
-typedef struct {
-	u8 revision;	/* Revision level of the security descriptor. */
-	u8 alignment;
-	SECURITY_DESCRIPTOR_CONTROL control;	/* Flags qualifying the type of
-			   the descriptor as well as the following fields. */
-	SID *owner;	/* Points to a SID representing an object's owner. If
-			   this is NULL, no owner SID is present in the
-			   descriptor. */
-	SID *group;	/* Points to a SID representing an object's primary
-			   group. If this is NULL, no primary group SID is
-			   present in the descriptor. */
-	ACL *sacl;	/* Points to a system ACL. Only valid, if
-			   SE_SACL_PRESENT is set in the control field. If
-			   SE_SACL_PRESENT is set but sacl is NULL, a NULL ACL
-			   is specified. */
-	ACL *dacl;	/* Points to a discretionary ACL. Only valid, if
-			   SE_DACL_PRESENT is set in the control field. If
-			   SE_DACL_PRESENT is set but dacl is NULL, a NULL ACL
-			   (unconditionally granting access) is specified. */
-} __attribute__((__packed__)) SECURITY_DESCRIPTOR;
-
-/**
- * enum SECURITY_DESCRIPTOR_CONSTANTS -
- *
- * Current constants for security descriptors.
- */
-typedef enum {
-	/* Current revision. */
-	SECURITY_DESCRIPTOR_REVISION	= 1,
-	SECURITY_DESCRIPTOR_REVISION1	= 1,
-
-	/* The sizes of both the absolute and relative security descriptors is
-	   the same as pointers, at least on ia32 architecture are 32-bit. */
-	SECURITY_DESCRIPTOR_MIN_LENGTH	= sizeof(SECURITY_DESCRIPTOR),
-} SECURITY_DESCRIPTOR_CONSTANTS;
-
-/*
- * Attribute: Security descriptor (0x50).
- *
- * A standard self-relative security descriptor.
- *
- * NOTE: Can be resident or non-resident.
- * NOTE: Not used in NTFS 3.0+, as security descriptors are stored centrally
- * in FILE_Secure and the correct descriptor is found using the security_id
- * from the standard information attribute.
- */
-typedef SECURITY_DESCRIPTOR_RELATIVE SECURITY_DESCRIPTOR_ATTR;
-
-/*
- * On NTFS 3.0+, all security descriptors are stored in FILE_Secure. Only one
- * referenced instance of each unique security descriptor is stored.
- *
- * FILE_Secure contains no unnamed data attribute, i.e. it has zero length. It
- * does, however, contain two indexes ($SDH and $SII) as well as a named data
- * stream ($SDS).
- *
- * Every unique security descriptor is assigned a unique security identifier
- * (security_id, not to be confused with a SID). The security_id is unique for
- * the NTFS volume and is used as an index into the $SII index, which maps
- * security_ids to the security descriptor's storage location within the $SDS
- * data attribute. The $SII index is sorted by ascending security_id.
- *
- * A simple hash is computed from each security descriptor. This hash is used
- * as an index into the $SDH index, which maps security descriptor hashes to
- * the security descriptor's storage location within the $SDS data attribute.
- * The $SDH index is sorted by security descriptor hash and is stored in a B+
- * tree. When searching $SDH (with the intent of determining whether or not a
- * new security descriptor is already present in the $SDS data stream), if a
- * matching hash is found, but the security descriptors do not match, the
- * search in the $SDH index is continued, searching for a next matching hash.
- *
- * When a precise match is found, the security_id corresponding to the security
- * descriptor in the $SDS attribute is read from the found $SDH index entry and
- * is stored in the $STANDARD_INFORMATION attribute of the file/directory to
- * which the security descriptor is being applied. The $STANDARD_INFORMATION
- * attribute is present in all base mft records (i.e. in all files and
- * directories).
- *
- * If a match is not found, the security descriptor is assigned a new unique
- * security_id and is added to the $SDS data attribute. Then, entries
- * referencing the this security descriptor in the $SDS data attribute are
- * added to the $SDH and $SII indexes.
- *
- * Note: Entries are never deleted from FILE_Secure, even if nothing
- * references an entry any more.
- */
-
-/**
- * struct SECURITY_DESCRIPTOR_HEADER -
- *
- * This header precedes each security descriptor in the $SDS data stream.
- * This is also the index entry data part of both the $SII and $SDH indexes.
- */
-typedef struct {
-	le32 hash;	   /* Hash of the security descriptor. */
-	le32 security_id;   /* The security_id assigned to the descriptor. */
-	le64 offset;	   /* Byte offset of this entry in the $SDS stream. */
-	le32 length;	   /* Size in bytes of this entry in $SDS stream. */
-} __attribute__((__packed__)) SECURITY_DESCRIPTOR_HEADER;
-
-/**
- * struct SDH_INDEX_DATA -
- */
-typedef struct {
-	le32 hash;          /* Hash of the security descriptor. */
-	le32 security_id;   /* The security_id assigned to the descriptor. */
-	le64 offset;	   /* Byte offset of this entry in the $SDS stream. */
-	le32 length;	   /* Size in bytes of this entry in $SDS stream. */
-	le32 reserved_II;   /* Padding - always unicode "II" or zero. This field
-			      isn't counted in INDEX_ENTRY's data_length. */
-} __attribute__((__packed__)) SDH_INDEX_DATA;
-
-/**
- * struct SII_INDEX_DATA -
- */
-typedef SECURITY_DESCRIPTOR_HEADER SII_INDEX_DATA;
-
-/**
- * struct SDS_ENTRY -
- *
- * The $SDS data stream contains the security descriptors, aligned on 16-byte
- * boundaries, sorted by security_id in a B+ tree. Security descriptors cannot
- * cross 256kib boundaries (this restriction is imposed by the Windows cache
- * manager). Each security descriptor is contained in a SDS_ENTRY structure.
- * Also, each security descriptor is stored twice in the $SDS stream with a
- * fixed offset of 0x40000 bytes (256kib, the Windows cache manager's max size)
- * between them; i.e. if a SDS_ENTRY specifies an offset of 0x51d0, then the
- * the first copy of the security descriptor will be at offset 0x51d0 in the
- * $SDS data stream and the second copy will be at offset 0x451d0.
- */
-typedef struct {
-/*  0	SECURITY_DESCRIPTOR_HEADER; -- Unfolded here as gcc doesn't like
-				       unnamed structs. */
-	le32 hash;	  /* Hash of the security descriptor. */
-	le32 security_id; /* The security_id assigned to the descriptor. */
-	le64 offset;	  /* Byte offset of this entry in the $SDS stream. */
-	le32 length;	  /* Size in bytes of this entry in $SDS stream. */
-/* 20*/	SECURITY_DESCRIPTOR_RELATIVE sid; /* The self-relative security
-					     descriptor. */
-} __attribute__((__packed__)) SDS_ENTRY;
-
-/**
- * struct SII_INDEX_KEY - The index entry key used in the $SII index.
- *
- * The collation type is COLLATION_NTOFS_ULONG.
- */
-typedef struct {
-	le32 security_id;   /* The security_id assigned to the descriptor. */
-} __attribute__((__packed__)) SII_INDEX_KEY;
-
-/**
- * struct SDH_INDEX_KEY - The index entry key used in the $SDH index.
- *
- * The keys are sorted first by hash and then by security_id.
- * The collation rule is COLLATION_NTOFS_SECURITY_HASH.
- */
-typedef struct {
-	le32 hash;	   /* Hash of the security descriptor. */
-	le32 security_id;   /* The security_id assigned to the descriptor. */
-} __attribute__((__packed__)) SDH_INDEX_KEY;
-
-/**
- * struct VOLUME_NAME - Attribute: Volume name (0x60).
- *
- * NOTE: Always resident.
- * NOTE: Present only in FILE_Volume.
- */
-typedef struct {
-	ntfschar name[0];	/* The name of the volume in Unicode. */
-} __attribute__((__packed__)) VOLUME_NAME;
-
-/**
- * enum VOLUME_FLAGS - Possible flags for the volume (16-bit).
- *
- * WARNING: Setting VOLUME_MOUNTED_ON_NT4 on a Volume causes Windows Vista to
- * fail to boot (it hangs on a black screen).
- */
-typedef enum {
-	VOLUME_IS_DIRTY			= const_cpu_to_le16(0x0001),
-	VOLUME_RESIZE_LOG_FILE		= const_cpu_to_le16(0x0002),
-	VOLUME_UPGRADE_ON_MOUNT		= const_cpu_to_le16(0x0004),
-	VOLUME_MOUNTED_ON_NT4		= const_cpu_to_le16(0x0008),
-	VOLUME_DELETE_USN_UNDERWAY	= const_cpu_to_le16(0x0010),
-	VOLUME_REPAIR_OBJECT_ID		= const_cpu_to_le16(0x0020),
-	VOLUME_CHKDSK_UNDERWAY		= const_cpu_to_le16(0x4000),
-	VOLUME_MODIFIED_BY_CHKDSK	= const_cpu_to_le16(0x8000),
-	VOLUME_FLAGS_MASK		= const_cpu_to_le16(0xc03f),
-} __attribute__((__packed__)) VOLUME_FLAGS;
-
-/**
- * struct VOLUME_INFORMATION - Attribute: Volume information (0x70).
- *
- * NOTE: Always resident.
- * NOTE: Present only in FILE_Volume.
- * NOTE: Windows 2000 uses NTFS 3.0 while Windows NT4 service pack 6a uses
- *	 NTFS 1.2. I haven't personally seen other values yet.
- */
-typedef struct {
-	le64 reserved;		/* Not used (yet?). */
-	u8 major_ver;		/* Major version of the ntfs format. */
-	u8 minor_ver;		/* Minor version of the ntfs format. */
-	VOLUME_FLAGS flags;	/* Bit array of VOLUME_* flags. */
-} __attribute__((__packed__)) VOLUME_INFORMATION;
-
-/**
- * struct DATA_ATTR - Attribute: Data attribute (0x80).
- *
- * NOTE: Can be resident or non-resident.
- *
- * Data contents of a file (i.e. the unnamed stream) or of a named stream.
- */
-typedef struct {
-	u8 data[0];		/* The file's data contents. */
-} __attribute__((__packed__)) DATA_ATTR;
-
-/**
- * enum INDEX_HEADER_FLAGS - Index header flags (8-bit).
- */
-typedef enum {
-	/* When index header is in an index root attribute: */
-	SMALL_INDEX	= 0, /* The index is small enough to fit inside the
-				index root attribute and there is no index
-				allocation attribute present. */
-	LARGE_INDEX	= 1, /* The index is too large to fit in the index
-				root attribute and/or an index allocation
-				attribute is present. */
-	/*
-	 * When index header is in an index block, i.e. is part of index
-	 * allocation attribute:
-	 */
-	LEAF_NODE	= 0, /* This is a leaf node, i.e. there are no more
-				nodes branching off it. */
-	INDEX_NODE	= 1, /* This node indexes other nodes, i.e. is not a
-				leaf node. */
-	NODE_MASK	= 1, /* Mask for accessing the *_NODE bits. */
-} __attribute__((__packed__)) INDEX_HEADER_FLAGS;
-
-/**
- * struct INDEX_HEADER -
- *
- * This is the header for indexes, describing the INDEX_ENTRY records, which
- * follow the INDEX_HEADER. Together the index header and the index entries
- * make up a complete index.
- *
- * IMPORTANT NOTE: The offset, length and size structure members are counted
- * relative to the start of the index header structure and not relative to the
- * start of the index root or index allocation structures themselves.
- */
-typedef struct {
-	le32 entries_offset;		/* Byte offset to first INDEX_ENTRY
-					   aligned to 8-byte boundary. */
-	le32 index_length;		/* Data size of the index in bytes,
-					   i.e. bytes used from allocated
-					   size, aligned to 8-byte boundary. */
-	le32 allocated_size;		/* Byte size of this index (block),
-					   multiple of 8 bytes. */
-	/* NOTE: For the index root attribute, the above two numbers are always
-	   equal, as the attribute is resident and it is resized as needed. In
-	   the case of the index allocation attribute the attribute is not
-	   resident and hence the allocated_size is a fixed value and must
-	   equal the index_block_size specified by the INDEX_ROOT attribute
-	   corresponding to the INDEX_ALLOCATION attribute this INDEX_BLOCK
-	   belongs to. */
-	INDEX_HEADER_FLAGS flags;	/* Bit field of INDEX_HEADER_FLAGS. */
-	u8 reserved[3];			/* Reserved/align to 8-byte boundary. */
-} __attribute__((__packed__)) INDEX_HEADER;
-
-/**
- * struct INDEX_ROOT - Attribute: Index root (0x90).
- *
- * NOTE: Always resident.
- *
- * This is followed by a sequence of index entries (INDEX_ENTRY structures)
- * as described by the index header.
- *
- * When a directory is small enough to fit inside the index root then this
- * is the only attribute describing the directory. When the directory is too
- * large to fit in the index root, on the other hand, two additional attributes
- * are present: an index allocation attribute, containing sub-nodes of the B+
- * directory tree (see below), and a bitmap attribute, describing which virtual
- * cluster numbers (VCNs) in the index allocation attribute are in use by an
- * index block.
- *
- * NOTE: The root directory (FILE_root) contains an entry for itself. Other
- * directories do not contain entries for themselves, though.
- */
-typedef struct {
-	ATTR_TYPES type;		/* Type of the indexed attribute. Is
-					   $FILE_NAME for directories, zero
-					   for view indexes. No other values
-					   allowed. */
-	COLLATION_RULES collation_rule;	/* Collation rule used to sort the
-					   index entries. If type is $FILE_NAME,
-					   this must be COLLATION_FILE_NAME. */
-	le32 index_block_size;		/* Size of each index block in bytes (in
-					   the index allocation attribute). */
-	u8 clusters_per_index_block;	/* Cluster size of each index block (in
-					   the index allocation attribute), when
-					   an index block is >= than a cluster,
-					   otherwise sectors per index block. */
-	u8 reserved[3];			/* Reserved/align to 8-byte boundary. */
-	INDEX_HEADER index;		/* Index header describing the
-					   following index entries. */
-} __attribute__((__packed__)) INDEX_ROOT;
-
-/**
- * struct INDEX_BLOCK - Attribute: Index allocation (0xa0).
- *
- * NOTE: Always non-resident (doesn't make sense to be resident anyway!).
- *
- * This is an array of index blocks. Each index block starts with an
- * INDEX_BLOCK structure containing an index header, followed by a sequence of
- * index entries (INDEX_ENTRY structures), as described by the INDEX_HEADER.
- */
-typedef struct {
-/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
-	NTFS_RECORD_TYPES magic;/* Magic is "INDX". */
-	le16 usa_ofs;		/* See NTFS_RECORD definition. */
-	le16 usa_count;		/* See NTFS_RECORD definition. */
-
-/*  8*/	leLSN lsn;		/* $LogFile sequence number of the last
-				   modification of this index block. */
-/* 16*/	leVCN index_block_vcn;	/* Virtual cluster number of the index block. */
-/* 24*/	INDEX_HEADER index;	/* Describes the following index entries. */
-/* sizeof()= 40 (0x28) bytes */
-/*
- * When creating the index block, we place the update sequence array at this
- * offset, i.e. before we start with the index entries. This also makes sense,
- * otherwise we could run into problems with the update sequence array
- * containing in itself the last two bytes of a sector which would mean that
- * multi sector transfer protection wouldn't work. As you can't protect data
- * by overwriting it since you then can't get it back...
- * When reading use the data from the ntfs record header.
- */
-} __attribute__((__packed__)) INDEX_BLOCK;
-
-typedef INDEX_BLOCK INDEX_ALLOCATION;
-
-/**
- * struct REPARSE_INDEX_KEY -
- *
- * The system file FILE_Extend/$Reparse contains an index named $R listing
- * all reparse points on the volume. The index entry keys are as defined
- * below. Note, that there is no index data associated with the index entries.
- *
- * The index entries are sorted by the index key file_id. The collation rule is
- * COLLATION_NTOFS_ULONGS. FIXME: Verify whether the reparse_tag is not the
- * primary key / is not a key at all. (AIA)
- */
-typedef struct {
-	le32 reparse_tag;	/* Reparse point type (inc. flags). */
-	leMFT_REF file_id;	/* Mft record of the file containing the
-				   reparse point attribute. */
-} __attribute__((__packed__)) REPARSE_INDEX_KEY;
-
-/**
- * enum QUOTA_FLAGS - Quota flags (32-bit).
- */
-typedef enum {
-	/* The user quota flags. Names explain meaning. */
-	QUOTA_FLAG_DEFAULT_LIMITS	= const_cpu_to_le32(0x00000001),
-	QUOTA_FLAG_LIMIT_REACHED	= const_cpu_to_le32(0x00000002),
-	QUOTA_FLAG_ID_DELETED		= const_cpu_to_le32(0x00000004),
-
-	QUOTA_FLAG_USER_MASK		= const_cpu_to_le32(0x00000007),
-		/* Bit mask for user quota flags. */
-
-	/* These flags are only present in the quota defaults index entry,
-	   i.e. in the entry where owner_id = QUOTA_DEFAULTS_ID. */
-	QUOTA_FLAG_TRACKING_ENABLED	= const_cpu_to_le32(0x00000010),
-	QUOTA_FLAG_ENFORCEMENT_ENABLED	= const_cpu_to_le32(0x00000020),
-	QUOTA_FLAG_TRACKING_REQUESTED	= const_cpu_to_le32(0x00000040),
-	QUOTA_FLAG_LOG_THRESHOLD	= const_cpu_to_le32(0x00000080),
-	QUOTA_FLAG_LOG_LIMIT		= const_cpu_to_le32(0x00000100),
-	QUOTA_FLAG_OUT_OF_DATE		= const_cpu_to_le32(0x00000200),
-	QUOTA_FLAG_CORRUPT		= const_cpu_to_le32(0x00000400),
-	QUOTA_FLAG_PENDING_DELETES	= const_cpu_to_le32(0x00000800),
-} QUOTA_FLAGS;
-
-/**
- * struct QUOTA_CONTROL_ENTRY -
- *
- * The system file FILE_Extend/$Quota contains two indexes $O and $Q. Quotas
- * are on a per volume and per user basis.
- *
- * The $Q index contains one entry for each existing user_id on the volume. The
- * index key is the user_id of the user/group owning this quota control entry,
- * i.e. the key is the owner_id. The user_id of the owner of a file, i.e. the
- * owner_id, is found in the standard information attribute. The collation rule
- * for $Q is COLLATION_NTOFS_ULONG.
- *
- * The $O index contains one entry for each user/group who has been assigned
- * a quota on that volume. The index key holds the SID of the user_id the
- * entry belongs to, i.e. the owner_id. The collation rule for $O is
- * COLLATION_NTOFS_SID.
- *
- * The $O index entry data is the user_id of the user corresponding to the SID.
- * This user_id is used as an index into $Q to find the quota control entry
- * associated with the SID.
- *
- * The $Q index entry data is the quota control entry and is defined below.
- */
-typedef struct {
-	le32 version;		/* Currently equals 2. */
-	QUOTA_FLAGS flags;	/* Flags describing this quota entry. */
-	le64 bytes_used;	/* How many bytes of the quota are in use. */
-	sle64 change_time;	/* Last time this quota entry was changed. */
-	sle64 threshold;	/* Soft quota (-1 if not limited). */
-	sle64 limit;		/* Hard quota (-1 if not limited). */
-	sle64 exceeded_time;	/* How long the soft quota has been exceeded. */
-/* The below field is NOT present for the quota defaults entry. */
-	SID sid;		/* The SID of the user/object associated with
-				   this quota entry. If this field is missing
-				   then the INDEX_ENTRY is padded with zeros
-				   to multiply of 8 which are not counted in
-				   the data_length field. If the SID is present
-				   then this structure is padded with zeros to
-				   multiply of 8 and the padding is counted in
-				   the INDEX_ENTRY's data_length. */
-} __attribute__((__packed__)) QUOTA_CONTROL_ENTRY;
-
-/**
- * struct QUOTA_O_INDEX_DATA -
- */
-typedef struct {
-	le32 owner_id;
-	le32 unknown;		/* Always 32. Seems to be padding and it's not
-				   counted in the INDEX_ENTRY's data_length.
-				   This field shouldn't be really here. */
-} __attribute__((__packed__)) QUOTA_O_INDEX_DATA;
-
-/**
- * enum PREDEFINED_OWNER_IDS - Predefined owner_id values (32-bit).
- */
-typedef enum {
-	QUOTA_INVALID_ID	= const_cpu_to_le32(0x00000000),
-	QUOTA_DEFAULTS_ID	= const_cpu_to_le32(0x00000001),
-	QUOTA_FIRST_USER_ID	= const_cpu_to_le32(0x00000100),
-} PREDEFINED_OWNER_IDS;
-
-/**
- * enum INDEX_ENTRY_FLAGS - Index entry flags (16-bit).
- */
-typedef enum {
-	INDEX_ENTRY_NODE = const_cpu_to_le16(1), /* This entry contains a
-					sub-node, i.e. a reference to an index
-					block in form of a virtual cluster
-					number (see below). */
-	INDEX_ENTRY_END  = const_cpu_to_le16(2), /* This signifies the last
-					entry in an index block. The index
-					entry does not represent a file but it
-					can point to a sub-node. */
-	INDEX_ENTRY_SPACE_FILLER = const_cpu_to_le16(0xffff),
-					/* Just to force 16-bit width. */
-} __attribute__((__packed__)) INDEX_ENTRY_FLAGS;
-
-/**
- * struct INDEX_ENTRY_HEADER - This the index entry header (see below).
- */
-typedef struct {
-/*  0*/	union {		/* Only valid when INDEX_ENTRY_END is not set. */
-		leMFT_REF indexed_file;		/* The mft reference of the file
-						   described by this index
-						   entry. Used for directory
-						   indexes. */
-		struct { /* Used for views/indexes to find the entry's data. */
-			le16 data_offset;	/* Data byte offset from this
-						   INDEX_ENTRY. Follows the
-						   index key. */
-			le16 data_length;	/* Data length in bytes. */
-			le32 reservedV;	/* Reserved (zero). */
-		} __attribute__((__packed__));
-	} __attribute__((__packed__));
-/*  8*/	le16 length;		 /* Byte size of this index entry, multiple of
-				    8-bytes. */
-/* 10*/	le16 key_length;		 /* Byte size of the key value, which is in the
-				    index entry. It follows field reserved. Not
-				    multiple of 8-bytes. */
-/* 12*/	INDEX_ENTRY_FLAGS flags; /* Bit field of INDEX_ENTRY_* flags. */
-/* 14*/	le16 reserved;		 /* Reserved/align to 8-byte boundary. */
-/* sizeof() = 16 bytes */
-} __attribute__((__packed__)) INDEX_ENTRY_HEADER;
-
-/**
- * struct INDEX_ENTRY - This is an index entry.
- *
- * A sequence of such entries follows each INDEX_HEADER structure. Together
- * they make up a complete index. The index follows either an index root
- * attribute or an index allocation attribute.
- *
- * NOTE: Before NTFS 3.0 only filename attributes were indexed.
- */
-typedef struct {
-/*  0	INDEX_ENTRY_HEADER; -- Unfolded here as gcc dislikes unnamed structs. */
-	union {		/* Only valid when INDEX_ENTRY_END is not set. */
-		leMFT_REF indexed_file;		/* The mft reference of the file
-						   described by this index
-						   entry. Used for directory
-						   indexes. */
-		struct { /* Used for views/indexes to find the entry's data. */
-			le16 data_offset;	/* Data byte offset from this
-						   INDEX_ENTRY. Follows the
-						   index key. */
-			le16 data_length;	/* Data length in bytes. */
-			le32 reservedV;		/* Reserved (zero). */
-		} __attribute__((__packed__));
-	} __attribute__((__packed__));
-	le16 length;		 /* Byte size of this index entry, multiple of
-				    8-bytes. */
-	le16 key_length;	 /* Byte size of the key value, which is in the
-				    index entry. It follows field reserved. Not
-				    multiple of 8-bytes. */
-	INDEX_ENTRY_FLAGS flags; /* Bit field of INDEX_ENTRY_* flags. */
-	le16 reserved;		 /* Reserved/align to 8-byte boundary. */
-
-/* 16*/	union {		/* The key of the indexed attribute. NOTE: Only present
-			   if INDEX_ENTRY_END bit in flags is not set. NOTE: On
-			   NTFS versions before 3.0 the only valid key is the
-			   FILE_NAME_ATTR. On NTFS 3.0+ the following
-			   additional index keys are defined: */
-		FILE_NAME_ATTR file_name;/* $I30 index in directories. */
-		SII_INDEX_KEY sii;	/* $SII index in $Secure. */
-		SDH_INDEX_KEY sdh;	/* $SDH index in $Secure. */
-		GUID object_id;		/* $O index in FILE_Extend/$ObjId: The
-					   object_id of the mft record found in
-					   the data part of the index. */
-		REPARSE_INDEX_KEY reparse;	/* $R index in
-						   FILE_Extend/$Reparse. */
-		SID sid;		/* $O index in FILE_Extend/$Quota:
-					   SID of the owner of the user_id. */
-		le32 owner_id;		/* $Q index in FILE_Extend/$Quota:
-					   user_id of the owner of the quota
-					   control entry in the data part of
-					   the index. */
-	} __attribute__((__packed__)) key;
-	/* The (optional) index data is inserted here when creating. */
-	/* VCN vcn; */	/* If INDEX_ENTRY_NODE bit in flags is set, the last
-			   eight bytes of this index entry contain the virtual
-			   cluster number of the index block that holds the
-			   entries immediately preceding the current entry (the
-			   vcn references the corresponding cluster in the data
-			   of the non-resident index allocation attribute). If
-			   the key_length is zero, then the vcn immediately
-			   follows the INDEX_ENTRY_HEADER. Regardless of
-			   key_length, the address of the 8-byte boundary
-			   aligned vcn of INDEX_ENTRY{_HEADER} *ie is given by
-			   (char*)ie + le16_to_cpu(ie->length) - sizeof(VCN),
-			   where sizeof(VCN) can be hardcoded as 8 if wanted. */
-} __attribute__((__packed__)) INDEX_ENTRY;
-
-/**
- * struct BITMAP_ATTR - Attribute: Bitmap (0xb0).
- *
- * Contains an array of bits (aka a bitfield).
- *
- * When used in conjunction with the index allocation attribute, each bit
- * corresponds to one index block within the index allocation attribute. Thus
- * the number of bits in the bitmap * index block size / cluster size is the
- * number of clusters in the index allocation attribute.
- */
-typedef struct {
-	u8 bitmap[0];			/* Array of bits. */
-} __attribute__((__packed__)) BITMAP_ATTR;
-
-/**
- * enum PREDEFINED_REPARSE_TAGS -
- *
- * The reparse point tag defines the type of the reparse point. It also
- * includes several flags, which further describe the reparse point.
- *
- * The reparse point tag is an unsigned 32-bit value divided in three parts:
- *
- * 1. The least significant 16 bits (i.e. bits 0 to 15) specify the type of
- *    the reparse point.
- * 2. The 13 bits after this (i.e. bits 16 to 28) are reserved for future use.
- * 3. The most significant three bits are flags describing the reparse point.
- *    They are defined as follows:
- *	bit 29: Name surrogate bit. If set, the filename is an alias for
- *		another object in the system.
- *	bit 30: High-latency bit. If set, accessing the first byte of data will
- *		be slow. (E.g. the data is stored on a tape drive.)
- *	bit 31: Microsoft bit. If set, the tag is owned by Microsoft. User
- *		defined tags have to use zero here.
- */
-typedef enum {
-	IO_REPARSE_TAG_IS_ALIAS		= const_cpu_to_le32(0x20000000),
-	IO_REPARSE_TAG_IS_HIGH_LATENCY	= const_cpu_to_le32(0x40000000),
-	IO_REPARSE_TAG_IS_MICROSOFT	= const_cpu_to_le32(0x80000000),
-
-	IO_REPARSE_TAG_RESERVED_ZERO	= const_cpu_to_le32(0x00000000),
-	IO_REPARSE_TAG_RESERVED_ONE	= const_cpu_to_le32(0x00000001),
-	IO_REPARSE_TAG_RESERVED_RANGE	= const_cpu_to_le32(0x00000001),
-
-	IO_REPARSE_TAG_NSS		= const_cpu_to_le32(0x68000005),
-	IO_REPARSE_TAG_NSS_RECOVER	= const_cpu_to_le32(0x68000006),
-	IO_REPARSE_TAG_SIS		= const_cpu_to_le32(0x68000007),
-	IO_REPARSE_TAG_DFS		= const_cpu_to_le32(0x68000008),
-
-	IO_REPARSE_TAG_MOUNT_POINT	= const_cpu_to_le32(0x88000003),
-
-	IO_REPARSE_TAG_HSM		= const_cpu_to_le32(0xa8000004),
-
-	IO_REPARSE_TAG_SYMBOLIC_LINK	= const_cpu_to_le32(0xe8000000),
-
-	IO_REPARSE_TAG_VALID_VALUES	= const_cpu_to_le32(0xe000ffff),
-} PREDEFINED_REPARSE_TAGS;
-
-/**
- * struct REPARSE_POINT - Attribute: Reparse point (0xc0).
- *
- * NOTE: Can be resident or non-resident.
- */
-typedef struct {
-	le32 reparse_tag;		/* Reparse point type (inc. flags). */
-	le16 reparse_data_length;	/* Byte size of reparse data. */
-	le16 reserved;			/* Align to 8-byte boundary. */
-	u8 reparse_data[0];		/* Meaning depends on reparse_tag. */
-} __attribute__((__packed__)) REPARSE_POINT;
-
-/**
- * struct EA_INFORMATION - Attribute: Extended attribute information (0xd0).
- *
- * NOTE: Always resident.
- */
-typedef struct {
-	le16 ea_length;		/* Byte size of the packed extended
-				   attributes. */
-	le16 need_ea_count;	/* The number of extended attributes which have
-				   the NEED_EA bit set. */
-	le32 ea_query_length;	/* Byte size of the buffer required to query
-				   the extended attributes when calling
-				   ZwQueryEaFile() in Windows NT/2k. I.e. the
-				   byte size of the unpacked extended
-				   attributes. */
-} __attribute__((__packed__)) EA_INFORMATION;
-
-/**
- * enum EA_FLAGS - Extended attribute flags (8-bit).
- */
-typedef enum {
-	NEED_EA	= 0x80,		/* Indicate that the file to which the EA
-				   belongs cannot be interpreted without
-				   understanding the associated extended
-				   attributes. */
-} __attribute__((__packed__)) EA_FLAGS;
-
-/**
- * struct EA_ATTR - Attribute: Extended attribute (EA) (0xe0).
- *
- * Like the attribute list and the index buffer list, the EA attribute value is
- * a sequence of EA_ATTR variable length records.
- *
- * FIXME: It appears weird that the EA name is not Unicode. Is it true?
- * FIXME: It seems that name is always uppercased. Is it true?
- */
-typedef struct {
-	le32 next_entry_offset;	/* Offset to the next EA_ATTR. */
-	EA_FLAGS flags;		/* Flags describing the EA. */
-	u8 name_length;		/* Length of the name of the extended
-				   attribute in bytes. */
-	le16 value_length;	/* Byte size of the EA's value. */
-	u8 name[0];		/* Name of the EA. */
-	u8 value[0];		/* The value of the EA. Immediately
-				   follows the name. */
-} __attribute__((__packed__)) EA_ATTR;
-
-/**
- * struct PROPERTY_SET - Attribute: Property set (0xf0).
- *
- * Intended to support Native Structure Storage (NSS) - a feature removed from
- * NTFS 3.0 during beta testing.
- */
-typedef struct {
-	/* Irrelevant as feature unused. */
-} __attribute__((__packed__)) PROPERTY_SET;
-
-/**
- * struct LOGGED_UTILITY_STREAM - Attribute: Logged utility stream (0x100).
- *
- * NOTE: Can be resident or non-resident.
- *
- * Operations on this attribute are logged to the journal ($LogFile) like
- * normal metadata changes.
- *
- * Used by the Encrypting File System (EFS).  All encrypted files have this
- * attribute with the name $EFS.  See below for the relevant structures.
- */
-typedef struct {
-	/* Can be anything the creator chooses. */
-} __attribute__((__packed__)) LOGGED_UTILITY_STREAM;
-
-/*
- * $EFS Data Structure:
- *
- * The following information is about the data structures that are contained
- * inside a logged utility stream (0x100) with a name of "$EFS".
- *
- * The stream starts with an instance of EFS_ATTR_HEADER.
- *
- * Next, at offsets offset_to_ddf_array and offset_to_drf_array (unless any of
- * them is 0) there is a EFS_DF_ARRAY_HEADER immediately followed by a sequence
- * of multiple data decryption/recovery fields.
- *
- * Each data decryption/recovery field starts with a EFS_DF_HEADER and the next
- * one (if it exists) can be found by adding EFS_DF_HEADER->df_length bytes to
- * the offset of the beginning of the current EFS_DF_HEADER.
- *
- * The data decryption/recovery field contains an EFS_DF_CERTIFICATE_HEADER, a
- * SID, an optional GUID, an optional container name, a non-optional user name,
- * and the encrypted FEK.
- *
- * Note all the below are best guesses so may have mistakes/inaccuracies.
- * Corrections/clarifications/additions are always welcome!
- *
- * Ntfs.sys takes an EFS value length of <= 0x54 or > 0x40000 to BSOD, i.e. it
- * is invalid.
- */
-
-/**
- * struct EFS_ATTR_HEADER - "$EFS" header.
- *
- * The header of the Logged utility stream (0x100) attribute named "$EFS".
- */
-typedef struct {
-/*  0*/	le32 length;		/* Length of EFS attribute in bytes. */
-	le32 state;		/* Always 0? */
-	le32 version;		/* Efs version.  Always 2? */
-	le32 crypto_api_version;	/* Always 0? */
-/* 16*/	u8 unknown4[16];	/* MD5 hash of decrypted FEK?  This field is
-				   created with a call to UuidCreate() so is
-				   unlikely to be an MD5 hash and is more
-				   likely to be GUID of this encrytped file
-				   or something like that. */
-/* 32*/	u8 unknown5[16];	/* MD5 hash of DDFs? */
-/* 48*/	u8 unknown6[16];	/* MD5 hash of DRFs? */
-/* 64*/	le32 offset_to_ddf_array;/* Offset in bytes to the array of data
-				   decryption fields (DDF), see below.  Zero if
-				   no DDFs are present. */
-	le32 offset_to_drf_array;/* Offset in bytes to the array of data
-				   recovery fields (DRF), see below.  Zero if
-				   no DRFs are present. */
-	le32 reserved;		/* Reserved. */
-} __attribute__((__packed__)) EFS_ATTR_HEADER;
-
-/**
- * struct EFS_DF_ARRAY_HEADER -
- */
-typedef struct {
-	le32 df_count;		/* Number of data decryption/recovery fields in
-				   the array. */
-} __attribute__((__packed__)) EFS_DF_ARRAY_HEADER;
-
-/**
- * struct EFS_DF_HEADER -
- */
-typedef struct {
-/*  0*/	le32 df_length;		/* Length of this data decryption/recovery
-				   field in bytes. */
-	le32 cred_header_offset;/* Offset in bytes to the credential header. */
-	le32 fek_size;		/* Size in bytes of the encrypted file
-				   encryption key (FEK). */
-	le32 fek_offset;	/* Offset in bytes to the FEK from the start of
-				   the data decryption/recovery field. */
-/* 16*/	le32 unknown1;		/* always 0?  Might be just padding. */
-} __attribute__((__packed__)) EFS_DF_HEADER;
-
-/**
- * struct EFS_DF_CREDENTIAL_HEADER -
- */
-typedef struct {
-/*  0*/	le32 cred_length;	/* Length of this credential in bytes. */
-	le32 sid_offset;	/* Offset in bytes to the user's sid from start
-				   of this structure.  Zero if no sid is
-				   present. */
-/*  8*/	le32 type;		/* Type of this credential:
-					1 = CryptoAPI container.
-					2 = Unexpected type.
-					3 = Certificate thumbprint.
-					other = Unknown type. */
-	union {
-		/* CryptoAPI container. */
-		struct {
-/* 12*/			le32 container_name_offset;	/* Offset in bytes to
-				   the name of the container from start of this
-				   structure (may not be zero). */
-/* 16*/			le32 provider_name_offset;	/* Offset in bytes to
-				   the name of the provider from start of this
-				   structure (may not be zero). */
-			le32 public_key_blob_offset;	/* Offset in bytes to
-				   the public key blob from start of this
-				   structure. */
-/* 24*/			le32 public_key_blob_size;	/* Size in bytes of
-				   public key blob. */
-		} __attribute__((__packed__));
-		/* Certificate thumbprint. */
-		struct {
-/* 12*/			le32 cert_thumbprint_header_size;	/* Size in
-				   bytes of the header of the certificate
-				   thumbprint. */
-/* 16*/			le32 cert_thumbprint_header_offset;	/* Offset in
-				   bytes to the header of the certificate
-				   thumbprint from start of this structure. */
-			le32 unknown1;	/* Always 0?  Might be padding... */
-			le32 unknown2;	/* Always 0?  Might be padding... */
-		} __attribute__((__packed__));
-	} __attribute__((__packed__));
-} __attribute__((__packed__)) EFS_DF_CREDENTIAL_HEADER;
-
-typedef EFS_DF_CREDENTIAL_HEADER EFS_DF_CRED_HEADER;
-
-/**
- * struct EFS_DF_CERTIFICATE_THUMBPRINT_HEADER -
- */
-typedef struct {
-/*  0*/	le32 thumbprint_offset;		/* Offset in bytes to the thumbprint. */
-	le32 thumbprint_size;		/* Size of thumbprint in bytes. */
-/*  8*/	le32 container_name_offset;	/* Offset in bytes to the name of the
-					   container from start of this
-					   structure or 0 if no name present. */
-	le32 provider_name_offset;	/* Offset in bytes to the name of the
-					   cryptographic provider from start of
-					   this structure or 0 if no name
-					   present. */
-/* 16*/	le32 user_name_offset;		/* Offset in bytes to the user name
-					   from start of this structure or 0 if
-					   no user name present.  (This is also
-					   known as lpDisplayInformation.) */
-} __attribute__((__packed__)) EFS_DF_CERTIFICATE_THUMBPRINT_HEADER;
-
-typedef EFS_DF_CERTIFICATE_THUMBPRINT_HEADER EFS_DF_CERT_THUMBPRINT_HEADER;
-
-typedef enum {
-	INTX_SYMBOLIC_LINK =
-		const_cpu_to_le64(0x014B4E4C78746E49ULL), /* "IntxLNK\1" */
-	INTX_CHARACTER_DEVICE =
-		const_cpu_to_le64(0x0052484378746E49ULL), /* "IntxCHR\0" */
-	INTX_BLOCK_DEVICE =
-		const_cpu_to_le64(0x004B4C4278746E49ULL), /* "IntxBLK\0" */
-} INTX_FILE_TYPES;
-
-typedef struct {
-	INTX_FILE_TYPES magic;		/* Intx file magic. */
-	union {
-		/* For character and block devices. */
-		struct {
-			le64 major;		/* Major device number. */
-			le64 minor;		/* Minor device number. */
-			void *device_end[0];	/* Marker for offsetof(). */
-		} __attribute__((__packed__));
-		/* For symbolic links. */
-		ntfschar target[0];
-	} __attribute__((__packed__));
-} __attribute__((__packed__)) INTX_FILE;
-
-#endif /* defined _NTFS_LAYOUT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/lcnalloc.h ./include/ntfs/lcnalloc.h
--- ../ntfsprogs-2.0.0/include/ntfs/lcnalloc.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/lcnalloc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/*
- * lcnalloc.h - Exports for cluster (de)allocation. Part of the Linux-NTFS
- *		project.
- *
- * Copyright (c) 2002 Anton Altaparmakov
- * Copyright (c) 2004 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_LCNALLOC_H
-#define _NTFS_LCNALLOC_H
-
-#include "types.h"
-#include "runlist.h"
-#include "volume.h"
-
-/**
- * enum NTFS_CLUSTER_ALLOCATION_ZONES -
- */
-typedef enum {
-	FIRST_ZONE	= 0,	/* For sanity checking. */
-	MFT_ZONE	= 0,	/* Allocate from $MFT zone. */
-	DATA_ZONE	= 1,	/* Allocate from $DATA zone. */
-	LAST_ZONE	= 1,	/* For sanity checking. */
-} NTFS_CLUSTER_ALLOCATION_ZONES;
-
-extern runlist *ntfs_cluster_alloc(ntfs_volume *vol, VCN start_vcn, s64 count,
-		LCN start_lcn, const NTFS_CLUSTER_ALLOCATION_ZONES zone);
-
-extern int ntfs_cluster_free_from_rl(ntfs_volume *vol, runlist *rl);
-
-extern int ntfs_cluster_free(ntfs_volume *vol, ntfs_attr *na, VCN start_vcn,
-		s64 count);
-
-#endif /* defined _NTFS_LCNALLOC_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/list.h ./include/ntfs/list.h
--- ../ntfsprogs-2.0.0/include/ntfs/list.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/list.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,192 +0,0 @@
-/*
- * list.h - Linked list implementation. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2002 Anton Altaparmakov and others
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_LIST_H
-#define _NTFS_LIST_H
-
-/**
- * struct list_head - Simple doubly linked list implementation.
- *
- * Copied from Linux kernel 2.4.2-ac18 into Linux-NTFS (with minor
- * modifications). - AIA
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-struct list_head {
-	struct list_head *next, *prev;
-};
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define LIST_HEAD(name) \
-	struct list_head name = LIST_HEAD_INIT(name)
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
-} while (0)
-
-/**
- * __list_add - Insert a new entry between two known consecutive entries.
- * @new:
- * @prev:
- * @next:
- *
- * This is only for internal list manipulation where we know the prev/next
- * entries already!
- */
-static __inline__ void __list_add(struct list_head * new,
-		struct list_head * prev, struct list_head * next)
-{
-	next->prev = new;
-	new->next = next;
-	new->prev = prev;
-	prev->next = new;
-}
-
-/**
- * list_add - add a new entry
- * @new:	new entry to be added
- * @head:	list head to add it after
- *
- * Insert a new entry after the specified head.
- * This is good for implementing stacks.
- */
-static __inline__ void list_add(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head, head->next);
-}
-
-/**
- * list_add_tail - add a new entry
- * @new:	new entry to be added
- * @head:	list head to add it before
- *
- * Insert a new entry before the specified head.
- * This is useful for implementing queues.
- */
-static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head->prev, head);
-}
-
-/**
- * __list_del -
- * @prev:
- * @next:
- *
- * Delete a list entry by making the prev/next entries point to each other.
- *
- * This is only for internal list manipulation where we know the prev/next
- * entries already!
- */
-static __inline__ void __list_del(struct list_head * prev,
-		struct list_head * next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * list_del - deletes entry from list.
- * @entry:	the element to delete from the list.
- *
- * Note: list_empty on entry does not return true after this, the entry is in
- * an undefined state.
- */
-static __inline__ void list_del(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-}
-
-/**
- * list_del_init - deletes entry from list and reinitialize it.
- * @entry:	the element to delete from the list.
- */
-static __inline__ void list_del_init(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry);
-}
-
-/**
- * list_empty - tests whether a list is empty
- * @head:	the list to test.
- */
-static __inline__ int list_empty(struct list_head *head)
-{
-	return head->next == head;
-}
-
-/**
- * list_splice - join two lists
- * @list:	the new list to add.
- * @head:	the place to add it in the first list.
- */
-static __inline__ void list_splice(struct list_head *list,
-		struct list_head *head)
-{
-	struct list_head *first = list->next;
-
-	if (first != list) {
-		struct list_head *last = list->prev;
-		struct list_head *at = head->next;
-
-		first->prev = head;
-		head->next = first;
-
-		last->next = at;
-		at->prev = last;
-	}
-}
-
-/**
- * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
-
-/**
- * list_for_each - iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); pos = pos->next)
-
-/**
- * list_for_each_safe	-	iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
- * @head:	the head for your list.
- */
-#define list_for_each_safe(pos, n, head) \
-	for (pos = (head)->next, n = pos->next; pos != (head); \
-		pos = n, n = pos->next)
-
-#endif /* defined _NTFS_LIST_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/logfile.h ./include/ntfs/logfile.h
--- ../ntfsprogs-2.0.0/include/ntfs/logfile.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/logfile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,396 +0,0 @@
-/*
- * logfile.h - Exports for $LogFile handling.  Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2005 Anton Altaparmakov
- * Copyright (c) 2005-2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_LOGFILE_H
-#define _NTFS_LOGFILE_H
-
-#include "types.h"
-#include "endians.h"
-#include "layout.h"
-
-/*
- * Journal ($LogFile) organization:
- *
- * Two restart areas present in the first two pages (restart pages, one restart
- * area in each page).  When the volume is dismounted they should be identical,
- * except for the update sequence array which usually has a different update
- * sequence number.
- *
- * These are followed by log records organized in pages headed by a log record
- * header going up to log file size.  Not all pages contain log records when a
- * volume is first formatted, but as the volume ages, all records will be used.
- * When the log file fills up, the records at the beginning are purged (by
- * modifying the oldest_lsn to a higher value presumably) and writing begins
- * at the beginning of the file.  Effectively, the log file is viewed as a
- * circular entity.
- *
- * NOTE: Windows NT, 2000, and XP all use log file version 1.1 but they accept
- * versions <= 1.x, including 0.-1.  (Yes, that is a minus one in there!)  We
- * probably only want to support 1.1 as this seems to be the current version
- * and we don't know how that differs from the older versions.  The only
- * exception is if the journal is clean as marked by the two restart pages
- * then it doesn't matter whether we are on an earlier version.  We can just
- * reinitialize the logfile and start again with version 1.1.
- */
-
-/* Some $LogFile related constants. */
-#define MaxLogFileSize		0x100000000ULL
-#define DefaultLogPageSize	4096
-#define MinLogRecordPages	48
-
-/**
- * struct RESTART_PAGE_HEADER - Log file restart page header.
- *
- * Begins the restart area.
- */
-typedef struct {
-/*Ofs*/
-/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
-/*  0*/	NTFS_RECORD_TYPES magic;/* The magic is "RSTR". */
-/*  4*/	le16 usa_ofs;		/* See NTFS_RECORD definition in layout.h.
-				   When creating, set this to be immediately
-				   after this header structure (without any
-				   alignment). */
-/*  6*/	le16 usa_count;		/* See NTFS_RECORD definition in layout.h. */
-
-/*  8*/	leLSN chkdsk_lsn;	/* The last log file sequence number found by
-				   chkdsk.  Only used when the magic is changed
-				   to "CHKD".  Otherwise this is zero. */
-/* 16*/	le32 system_page_size;	/* Byte size of system pages when the log file
-				   was created, has to be >= 512 and a power of
-				   2.  Use this to calculate the required size
-				   of the usa (usa_count) and add it to usa_ofs.
-				   Then verify that the result is less than the
-				   value of the restart_area_offset. */
-/* 20*/	le32 log_page_size;	/* Byte size of log file pages, has to be >=
-				   512 and a power of 2.  The default is 4096
-				   and is used when the system page size is
-				   between 4096 and 8192.  Otherwise this is
-				   set to the system page size instead. */
-/* 24*/	le16 restart_area_offset;/* Byte offset from the start of this header to
-				   the RESTART_AREA.  Value has to be aligned
-				   to 8-byte boundary.  When creating, set this
-				   to be after the usa. */
-/* 26*/	sle16 minor_ver;	/* Log file minor version.  Only check if major
-				   version is 1. */
-/* 28*/	sle16 major_ver;	/* Log file major version.  We only support
-				   version 1.1. */
-/* sizeof() = 30 (0x1e) bytes */
-} __attribute__((__packed__)) RESTART_PAGE_HEADER;
-
-/*
- * Constant for the log client indices meaning that there are no client records
- * in this particular client array.  Also inside the client records themselves,
- * this means that there are no client records preceding or following this one.
- */
-#define LOGFILE_NO_CLIENT	const_cpu_to_le16(0xffff)
-#define LOGFILE_NO_CLIENT_CPU	0xffff
-
-/*
- * These are the so far known RESTART_AREA_* flags (16-bit) which contain
- * information about the log file in which they are present.
- */
-enum {
-	RESTART_VOLUME_IS_CLEAN	= const_cpu_to_le16(0x0002),
-	RESTART_SPACE_FILLER	= const_cpu_to_le16(0xffff),
-				/* gcc: Force enum bit width to 16. */
-} __attribute__((__packed__));
-
-typedef le16 RESTART_AREA_FLAGS;
-
-/**
- * struct RESTART_AREA - Log file restart area record.
- *
- * The offset of this record is found by adding the offset of the
- * RESTART_PAGE_HEADER to the restart_area_offset value found in it.
- * See notes at restart_area_offset above.
- */
-typedef struct {
-/*Ofs*/
-/*  0*/	leLSN current_lsn;	/* The current, i.e. last LSN inside the log
-				   when the restart area was last written.
-				   This happens often but what is the interval?
-				   Is it just fixed time or is it every time a
-				   check point is written or something else?
-				   On create set to 0. */
-/*  8*/	le16 log_clients;	/* Number of log client records in the array of
-				   log client records which follows this
-				   restart area.  Must be 1.  */
-/* 10*/	le16 client_free_list;	/* The index of the first free log client record
-				   in the array of log client records.
-				   LOGFILE_NO_CLIENT means that there are no
-				   free log client records in the array.
-				   If != LOGFILE_NO_CLIENT, check that
-				   log_clients > client_free_list.  On Win2k
-				   and presumably earlier, on a clean volume
-				   this is != LOGFILE_NO_CLIENT, and it should
-				   be 0, i.e. the first (and only) client
-				   record is free and thus the logfile is
-				   closed and hence clean.  A dirty volume
-				   would have left the logfile open and hence
-				   this would be LOGFILE_NO_CLIENT.  On WinXP
-				   and presumably later, the logfile is always
-				   open, even on clean shutdown so this should
-				   always be LOGFILE_NO_CLIENT. */
-/* 12*/	le16 client_in_use_list;/* The index of the first in-use log client
-				   record in the array of log client records.
-				   LOGFILE_NO_CLIENT means that there are no
-				   in-use log client records in the array.  If
-				   != LOGFILE_NO_CLIENT check that log_clients
-				   > client_in_use_list.  On Win2k and
-				   presumably earlier, on a clean volume this
-				   is LOGFILE_NO_CLIENT, i.e. there are no
-				   client records in use and thus the logfile
-				   is closed and hence clean.  A dirty volume
-				   would have left the logfile open and hence
-				   this would be != LOGFILE_NO_CLIENT, and it
-				   should be 0, i.e. the first (and only)
-				   client record is in use.  On WinXP and
-				   presumably later, the logfile is always
-				   open, even on clean shutdown so this should
-				   always be 0. */
-/* 14*/	RESTART_AREA_FLAGS flags;/* Flags modifying LFS behaviour.  On Win2k
-				   and presumably earlier this is always 0.  On
-				   WinXP and presumably later, if the logfile
-				   was shutdown cleanly, the second bit,
-				   RESTART_VOLUME_IS_CLEAN, is set.  This bit
-				   is cleared when the volume is mounted by
-				   WinXP and set when the volume is dismounted,
-				   thus if the logfile is dirty, this bit is
-				   clear.  Thus we don't need to check the
-				   Windows version to determine if the logfile
-				   is clean.  Instead if the logfile is closed,
-				   we know it must be clean.  If it is open and
-				   this bit is set, we also know it must be
-				   clean.  If on the other hand the logfile is
-				   open and this bit is clear, we can be almost
-				   certain that the logfile is dirty. */
-/* 16*/	le32 seq_number_bits;	/* How many bits to use for the sequence
-				   number.  This is calculated as 67 - the
-				   number of bits required to store the logfile
-				   size in bytes and this can be used in with
-				   the specified file_size as a consistency
-				   check. */
-/* 20*/	le16 restart_area_length;/* Length of the restart area including the
-				   client array.  Following checks required if
-				   version matches.  Otherwise, skip them.
-				   restart_area_offset + restart_area_length
-				   has to be <= system_page_size.  Also,
-				   restart_area_length has to be >=
-				   client_array_offset + (log_clients *
-				   sizeof(log client record)). */
-/* 22*/	le16 client_array_offset;/* Offset from the start of this record to
-				   the first log client record if versions are
-				   matched.  When creating, set this to be
-				   after this restart area structure, aligned
-				   to 8-bytes boundary.  If the versions do not
-				   match, this is ignored and the offset is
-				   assumed to be (sizeof(RESTART_AREA) + 7) &
-				   ~7, i.e. rounded up to first 8-byte
-				   boundary.  Either way, client_array_offset
-				   has to be aligned to an 8-byte boundary.
-				   Also, restart_area_offset +
-				   client_array_offset has to be <= 510.
-				   Finally, client_array_offset + (log_clients
-				   * sizeof(log client record)) has to be <=
-				   system_page_size.  On Win2k and presumably
-				   earlier, this is 0x30, i.e. immediately
-				   following this record.  On WinXP and
-				   presumably later, this is 0x40, i.e. there
-				   are 16 extra bytes between this record and
-				   the client array.  This probably means that
-				   the RESTART_AREA record is actually bigger
-				   in WinXP and later. */
-/* 24*/	sle64 file_size;	/* Usable byte size of the log file.  If the
-				   restart_area_offset + the offset of the
-				   file_size are > 510 then corruption has
-				   occurred.  This is the very first check when
-				   starting with the restart_area as if it
-				   fails it means that some of the above values
-				   will be corrupted by the multi sector
-				   transfer protection.  The file_size has to
-				   be rounded down to be a multiple of the
-				   log_page_size in the RESTART_PAGE_HEADER and
-				   then it has to be at least big enough to
-				   store the two restart pages and 48 (0x30)
-				   log record pages. */
-/* 32*/	le32 last_lsn_data_length;/* Length of data of last LSN, not including
-				   the log record header.  On create set to
-				   0. */
-/* 36*/	le16 log_record_header_length;/* Byte size of the log record header.
-				   If the version matches then check that the
-				   value of log_record_header_length is a
-				   multiple of 8, i.e.
-				   (log_record_header_length + 7) & ~7 ==
-				   log_record_header_length.  When creating set
-				   it to sizeof(LOG_RECORD_HEADER), aligned to
-				   8 bytes. */
-/* 38*/	le16 log_page_data_offset;/* Offset to the start of data in a log record
-				   page.  Must be a multiple of 8.  On create
-				   set it to immediately after the update
-				   sequence array of the log record page. */
-/* 40*/	le32 restart_log_open_count;/* A counter that gets incremented every
-				   time the logfile is restarted which happens
-				   at mount time when the logfile is opened.
-				   When creating set to a random value.  Win2k
-				   sets it to the low 32 bits of the current
-				   system time in NTFS format (see time.h). */
-/* 44*/	le32 reserved;		/* Reserved/alignment to 8-byte boundary. */
-/* sizeof() = 48 (0x30) bytes */
-} __attribute__((__packed__)) RESTART_AREA;
-
-/**
- * struct LOG_CLIENT_RECORD - Log client record.
- *
- * The offset of this record is found by adding the offset of the
- * RESTART_AREA to the client_array_offset value found in it.
- */
-typedef struct {
-/*Ofs*/
-/*  0*/	leLSN oldest_lsn;	/* Oldest LSN needed by this client.  On create
-				   set to 0. */
-/*  8*/	leLSN client_restart_lsn;/* LSN at which this client needs to restart
-				   the volume, i.e. the current position within
-				   the log file.  At present, if clean this
-				   should = current_lsn in restart area but it
-				   probably also = current_lsn when dirty most
-				   of the time.  At create set to 0. */
-/* 16*/	le16 prev_client;	/* The offset to the previous log client record
-				   in the array of log client records.
-				   LOGFILE_NO_CLIENT means there is no previous
-				   client record, i.e. this is the first one.
-				   This is always LOGFILE_NO_CLIENT. */
-/* 18*/	le16 next_client;	/* The offset to the next log client record in
-				   the array of log client records.
-				   LOGFILE_NO_CLIENT means there are no next
-				   client records, i.e. this is the last one.
-				   This is always LOGFILE_NO_CLIENT. */
-/* 20*/	le16 seq_number;	/* On Win2k and presumably earlier, this is set
-				   to zero every time the logfile is restarted
-				   and it is incremented when the logfile is
-				   closed at dismount time.  Thus it is 0 when
-				   dirty and 1 when clean.  On WinXP and
-				   presumably later, this is always 0. */
-/* 22*/	u8 reserved[6];		/* Reserved/alignment. */
-/* 28*/	le32 client_name_length;/* Length of client name in bytes.  Should
-				   always be 8. */
-/* 32*/	ntfschar client_name[64];/* Name of the client in Unicode.  Should
-				   always be "NTFS" with the remaining bytes
-				   set to 0. */
-/* sizeof() = 160 (0xa0) bytes */
-} __attribute__((__packed__)) LOG_CLIENT_RECORD;
-
-/**
- * struct RECORD_PAGE_HEADER - Log page record page header.
- *
- * Each log page begins with this header and is followed by several LOG_RECORD
- * structures, starting at offset 0x40 (the size of this structure and the
- * following update sequence array and then aligned to 8 byte boundary, but is
- * this specified anywhere?).
- */
-typedef struct {
-/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
-	NTFS_RECORD_TYPES magic;/* Usually the magic is "RCRD". */
-	u16 usa_ofs;		/* See NTFS_RECORD definition in layout.h.
-				   When creating, set this to be immediately
-				   after this header structure (without any
-				   alignment). */
-	u16 usa_count;		/* See NTFS_RECORD definition in layout.h. */
-
-	union {
-		LSN last_lsn;
-		s64 file_offset;
-	} __attribute__((__packed__)) copy;
-	u32 flags;
-	u16 page_count;
-	u16 page_position;
-	union {
-		struct {
-			u16 next_record_offset;
-			u8 reserved[6];
-			LSN last_end_lsn;
-		} __attribute__((__packed__)) packed;
-	} __attribute__((__packed__)) header;
-} __attribute__((__packed__)) RECORD_PAGE_HEADER;
-
-/**
- * enum LOG_RECORD_FLAGS - Possible 16-bit flags for log records.
- *
- * (Or is it log record pages?)
- */
-typedef enum {
-	LOG_RECORD_MULTI_PAGE = const_cpu_to_le16(0x0001),	/* ??? */
-	LOG_RECORD_SIZE_PLACE_HOLDER = 0xffff,
-		/* This has nothing to do with the log record. It is only so
-		   gcc knows to make the flags 16-bit. */
-} __attribute__((__packed__)) LOG_RECORD_FLAGS;
-
-/**
- * struct LOG_CLIENT_ID - The log client id structure identifying a log client.
- */
-typedef struct {
-	u16 seq_number;
-	u16 client_index;
-} __attribute__((__packed__)) LOG_CLIENT_ID;
-
-/**
- * struct LOG_RECORD - Log record header.
- *
- * Each log record seems to have a constant size of 0x70 bytes.
- */
-typedef struct {
-	LSN this_lsn;
-	LSN client_previous_lsn;
-	LSN client_undo_next_lsn;
-	u32 client_data_length;
-	LOG_CLIENT_ID client_id;
-	u32 record_type;
-	u32 transaction_id;
-	u16 flags;
-	u16 reserved_or_alignment[3];
-/* Now are at ofs 0x30 into struct. */
-	u16 redo_operation;
-	u16 undo_operation;
-	u16 redo_offset;
-	u16 redo_length;
-	u16 undo_offset;
-	u16 undo_length;
-	u16 target_attribute;
-	u16 lcns_to_follow;		   /* Number of lcn_list entries
-					      following this entry. */
-/* Now at ofs 0x40. */
-	u16 record_offset;
-	u16 attribute_offset;
-	u32 alignment_or_reserved;
-	VCN target_vcn;
-/* Now at ofs 0x50. */
-	struct {			   /* Only present if lcns_to_follow
-					      is not 0. */
-		LCN lcn;
-	} __attribute__((__packed__)) lcn_list[0];
-} __attribute__((__packed__)) LOG_RECORD;
-
-extern BOOL ntfs_check_logfile(ntfs_attr *log_na, RESTART_PAGE_HEADER **rp);
-extern BOOL ntfs_is_logfile_clean(ntfs_attr *log_na, RESTART_PAGE_HEADER *rp);
-extern int ntfs_empty_logfile(ntfs_attr *na);
-
-#endif /* defined _NTFS_LOGFILE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/logging.h ./include/ntfs/logging.h
--- ../ntfsprogs-2.0.0/include/ntfs/logging.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/logging.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/*
- * logging.h - Centralised logging. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _LOGGING_H_
-#define _LOGGING_H_
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef HAVE_STDARG_H
-#include <stdarg.h>
-#endif
-
-#include "types.h"
-
-/* Function prototype for the logging handlers */
-typedef int (ntfs_log_handler)(const char *function, const char *file, int line,
-	u32 level, void *data, const char *format, va_list args);
-
-/* Set the logging handler from one of the functions, below. */
-void ntfs_log_set_handler(ntfs_log_handler *handler);
-
-/* Logging handlers */
-ntfs_log_handler ntfs_log_handler_syslog  __attribute__((format(printf, 6, 0)));
-ntfs_log_handler ntfs_log_handler_fprintf __attribute__((format(printf, 6, 0)));
-ntfs_log_handler ntfs_log_handler_null    __attribute__((format(printf, 6, 0)));
-ntfs_log_handler ntfs_log_handler_stdout  __attribute__((format(printf, 6, 0)));
-ntfs_log_handler ntfs_log_handler_outerr  __attribute__((format(printf, 6, 0)));
-ntfs_log_handler ntfs_log_handler_stderr  __attribute__((format(printf, 6, 0)));
-
-/* Enable/disable certain log levels */
-u32 ntfs_log_set_levels(u32 levels);
-u32 ntfs_log_clear_levels(u32 levels);
-u32 ntfs_log_get_levels(void);
-
-/* Enable/disable certain log flags */
-u32 ntfs_log_set_flags(u32 flags);
-u32 ntfs_log_clear_flags(u32 flags);
-u32 ntfs_log_get_flags(void);
-
-/* Turn command-line options into logging flags */
-BOOL ntfs_log_parse_option(const char *option);
-
-int ntfs_log_redirect(const char *function, const char *file, int line,
-	u32 level, void *data, const char *format, ...)
-	__attribute__((format(printf, 6, 7)));
-
-/* Logging levels - Determine what gets logged */
-#define NTFS_LOG_LEVEL_DEBUG	((u32)1 <<  0) /* x = 42 */
-#define NTFS_LOG_LEVEL_TRACE	((u32)1 <<  1) /* Entering function x() */
-#define NTFS_LOG_LEVEL_QUIET	((u32)1 <<  2) /* Quietable output */
-#define NTFS_LOG_LEVEL_INFO	((u32)1 <<  3) /* Volume needs defragmenting */
-#define NTFS_LOG_LEVEL_VERBOSE	((u32)1 <<  4) /* Forced to continue */
-#define NTFS_LOG_LEVEL_PROGRESS	((u32)1 <<  5) /* 54% complete */
-#define NTFS_LOG_LEVEL_WARNING	((u32)1 <<  6) /* You should backup before starting */
-#define NTFS_LOG_LEVEL_ERROR	((u32)1 <<  7) /* Operation failed, no damage done */
-#define NTFS_LOG_LEVEL_PERROR	((u32)1 <<  8) /* Message : standard error description */
-#define NTFS_LOG_LEVEL_CRITICAL	((u32)1 <<  9) /* Operation failed,damage may have occurred */
-
-/* Logging style flags - Manage the style of the output */
-#define NTFS_LOG_FLAG_PREFIX	((u32)1 << 0) /* Prefix messages with "ERROR: ", etc */
-#define NTFS_LOG_FLAG_FILENAME	((u32)1 << 1) /* Show the file origin of the message */
-#define NTFS_LOG_FLAG_LINE	((u32)1 << 2) /* Show the line number of the message */
-#define NTFS_LOG_FLAG_FUNCTION	((u32)1 << 3) /* Show the function name containing the message */
-#define NTFS_LOG_FLAG_ONLYNAME	((u32)1 << 4) /* Only display the filename, not the pathname */
-#define NTFS_LOG_FLAG_COLOUR	((u32)1 << 5) /* Colour highlight some messages */
-
-/* Macros to simplify logging.  One for each level defined above.
- * Note, if DEBUG is not defined, then ntfs_log_debug/trace have no effect.
- */
-#define ntfs_log_critical(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_CRITICAL,NULL,FORMAT,##ARGS)
-#define ntfs_log_error(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_ERROR,NULL,FORMAT,##ARGS)
-#define ntfs_log_info(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_INFO,NULL,FORMAT,##ARGS)
-#define ntfs_log_perror(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_PERROR,NULL,FORMAT,##ARGS)
-#define ntfs_log_progress(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_PROGRESS,NULL,FORMAT,##ARGS)
-#define ntfs_log_quiet(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_QUIET,NULL,FORMAT,##ARGS)
-#define ntfs_log_verbose(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_VERBOSE,NULL,FORMAT,##ARGS)
-#define ntfs_log_warning(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_WARNING,NULL,FORMAT,##ARGS)
-
-/*
- * By default debug and trace messages are compiled into the program,
- * but not displayed.
- */
-#ifndef DEBUG
-#define ntfs_log_debug(FORMAT, ARGS...)do {} while (0)
-#define ntfs_log_trace(FORMAT, ARGS...)do {} while (0)
-#else /* !DEBUG */
-#define ntfs_log_debug(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_DEBUG,NULL,FORMAT,##ARGS)
-#define ntfs_log_trace(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_TRACE,NULL,FORMAT,##ARGS)
-#endif /* DEBUG */
-
-#endif /* _LOGGING_H_ */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/Makefile.am ./include/ntfs/Makefile.am
--- ../ntfsprogs-2.0.0/include/ntfs/Makefile.am	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/Makefile.am	2007-10-06 16:49:32.000000000 +0200
@@ -1,37 +1,37 @@

 linux_ntfsincludedir = $(includedir)/ntfs
 linux_ntfsinclude_HEADERS = \
-	attrib.h		\
-	attrlist.h		\
-	bitmap.h		\
-	bootsect.h		\
-	collate.h		\
-	compat.h		\
-	compress.h		\
-	crypto.h		\
-	debug.h			\
-	device.h		\
-	device_io.h		\
-	dir.h			\
-	endians.h		\
-	gnome-vfs-method.h	\
-	gnome-vfs-module.h	\
-	index.h			\
-	inode.h			\
-	layout.h		\
-	lcnalloc.h		\
-	list.h			\
-	logfile.h		\
-	logging.h		\
-	mft.h			\
-	mst.h			\
-	ntfstime.h		\
-	runlist.h		\
-	security.h		\
-	support.h		\
-	types.h			\
-	unistr.h		\
-	version.h		\
-	volume.h
+	ntfs_attrib.h		\
+	ntfs_attrlist.h		\
+	ntfs_bitmap.h		\
+	ntfs_bootsect.h		\
+	ntfs_collate.h		\
+	ntfs_compat.h		\
+	ntfs_compress.h		\
+	ntfs_crypto.h		\
+	ntfs_debug.h		\
+	ntfs_device.h		\
+	ntfs_device_io.h	\
+	ntfs_dir.h		\
+	ntfs_endians.h		\
+	ntfs_gnome-vfs-method.h	\
+	ntfs_gnome-vfs-module.h	\
+	ntfs_index.h		\
+	ntfs_inode.h		\
+	ntfs_layout.h		\
+	ntfs_lcnalloc.h		\
+	ntfs_list.h		\
+	ntfs_logfile.h		\
+	ntfs_logging.h		\
+	ntfs_mft.h		\
+	ntfs_mst.h		\
+	ntfs_time.h		\
+	ntfs_runlist.h		\
+	ntfs_security.h		\
+	ntfs_support.h		\
+	ntfs_types.h		\
+	ntfs_unistr.h		\
+	ntfs_version.h		\
+	ntfs_volume.h

 MAINTAINERCLEANFILES = Makefile.in
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/mft.h ./include/ntfs/mft.h
--- ../ntfsprogs-2.0.0/include/ntfs/mft.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/mft.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,116 +0,0 @@
-/*
- * mft.h - Exports for MFT record handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2002 Anton Altaparmakov
- * Copyright (c) 2004-2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_MFT_H
-#define _NTFS_MFT_H
-
-#include "volume.h"
-#include "inode.h"
-#include "layout.h"
-
-extern int ntfs_mft_records_read(const ntfs_volume *vol, const MFT_REF mref,
-		const s64 count, MFT_RECORD *b);
-
-/**
- * ntfs_mft_record_read - read a record from the mft
- * @vol:	volume to read from
- * @mref:	mft record number to read
- * @b:		output data buffer
- *
- * Read the mft record specified by @mref from volume @vol into buffer @b.
- * Return 0 on success or -1 on error, with errno set to the error code.
- *
- * The read mft record is mst deprotected and is hence ready to use. The caller
- * should check the record with is_baad_record() in case mst deprotection
- * failed.
- *
- * NOTE: @b has to be at least of size vol->mft_record_size.
- */
-static __inline__ int ntfs_mft_record_read(const ntfs_volume *vol,
-		const MFT_REF mref, MFT_RECORD *b)
-{
-	return ntfs_mft_records_read(vol, mref, 1, b);
-}
-
-extern int ntfs_file_record_read(const ntfs_volume *vol, const MFT_REF mref,
-		MFT_RECORD **mrec, ATTR_RECORD **attr);
-
-extern int ntfs_mft_records_write(const ntfs_volume *vol, const MFT_REF mref,
-		const s64 count, MFT_RECORD *b);
-
-/**
- * ntfs_mft_record_write - write an mft record to disk
- * @vol:	volume to write to
- * @mref:	mft record number to write
- * @b:		data buffer containing the mft record to write
- *
- * Write the mft record specified by @mref from buffer @b to volume @vol.
- * Return 0 on success or -1 on error, with errno set to the error code.
- *
- * Before the mft record is written, it is mst protected. After the write, it
- * is deprotected again, thus resulting in an increase in the update sequence
- * number inside the buffer @b.
- *
- * NOTE: @b has to be at least of size vol->mft_record_size.
- */
-static __inline__ int ntfs_mft_record_write(const ntfs_volume *vol,
-		const MFT_REF mref, MFT_RECORD *b)
-{
-	return ntfs_mft_records_write(vol, mref, 1, b);
-}
-
-/**
- * ntfs_mft_record_get_data_size - return number of bytes used in mft record @b
- * @m:		mft record to get the data size of
- *
- * Takes the mft record @m and returns the number of bytes used in the record
- * or 0 on error (i.e. @m is not a valid mft record).  Zero is not a valid size
- * for an mft record as it at least has to have the MFT_RECORD itself and a
- * zero length attribute of type AT_END, thus making the minimum size 56 bytes.
- *
- * Aside:  The size is independent of NTFS versions 1.x/3.x because the 8-byte
- * alignment of the first attribute mask the difference in MFT_RECORD size
- * between NTFS 1.x and 3.x.  Also, you would expect every mft record to
- * contain an update sequence array as well but that could in theory be
- * non-existent (don't know if Windows' NTFS driver/chkdsk wouldn't view this
- * as corruption in itself though).
- */
-static __inline__ u32 ntfs_mft_record_get_data_size(const MFT_RECORD *m)
-{
-	if (!m || !ntfs_is_mft_record(m->magic))
-		return 0;
-	/* Get the number of used bytes and return it. */
-	return le32_to_cpu(m->bytes_in_use);
-}
-
-extern int ntfs_mft_record_layout(const ntfs_volume *vol, const MFT_REF mref,
-		MFT_RECORD *mrec);
-
-extern int ntfs_mft_record_format(const ntfs_volume *vol, const MFT_REF mref);
-
-extern ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, ntfs_inode *base_ni);
-
-extern int ntfs_mft_record_free(ntfs_volume *vol, ntfs_inode *ni);
-
-extern int ntfs_mft_usn_dec(MFT_RECORD *mrec);
-
-#endif /* defined _NTFS_MFT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/mst.h ./include/ntfs/mst.h
--- ../ntfsprogs-2.0.0/include/ntfs/mst.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/mst.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-/*
- * mst.h - Exports for multi sector transfer fixup functions. Part of the
- *	   Linux-NTFS project.
- *
- * Copyright (c) 2000-2002 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_MST_H
-#define _NTFS_MST_H
-
-#include "types.h"
-#include "layout.h"
-
-extern int ntfs_mst_post_read_fixup(NTFS_RECORD *b, const u32 size);
-extern int ntfs_mst_pre_write_fixup(NTFS_RECORD *b, const u32 size);
-extern void ntfs_mst_post_write_fixup(NTFS_RECORD *b);
-
-#endif /* defined _NTFS_MST_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_attrib.h ./include/ntfs/ntfs_attrib.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_attrib.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_attrib.h	2007-10-06 16:51:08.000000000 +0200
@@ -0,0 +1,384 @@
+/*
+ * attrib.h - Exports for attribute handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c) 2004-2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_ATTRIB_H
+#define _NTFS_ATTRIB_H 1
+
+/* Forward declarations */
+typedef struct _ntfs_attr ntfs_attr;
+typedef struct _ntfs_attr_search_ctx ntfs_attr_search_ctx;
+
+#include "ntfs_list.h"
+#include "ntfs_types.h"
+#include "ntfs_inode.h"
+#include "ntfs_unistr.h"
+#include "ntfs_runlist.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_logging.h"
+#include "ntfs_crypto.h"
+
+__BEGIN_DECLS
+
+extern ntfschar NTFS_AT_UNNAMED[];
+
+/**
+ * enum ntfs_lcn_special_values - special return values for ntfs_*_vcn_to_lcn()
+ *
+ * Special return values for ntfs_rl_vcn_to_lcn() and ntfs_attr_vcn_to_lcn().
+ *
+ * TODO: Describe them.
+ */
+typedef enum {
+	NTFS_LCN_HOLE		= -1,	/* Keep this as highest value or die! */
+	NTFS_LCN_RL_NOT_MAPPED	= -2,
+	NTFS_LCN_ENOENT		= -3,
+	NTFS_LCN_EINVAL		= -4,
+	NTFS_LCN_EIO			= -5,
+} ntfs_lcn_special_values;
+
+/**
+ * struct ntfs_attr_search_ctx - search context used in attribute search functions
+ * @mrec:	buffer containing mft record to search
+ * @attr:	attribute record in @mrec where to begin/continue search
+ * @is_first:	if true lookup_attr() begins search with @attr, else after @attr
+ *
+ * Structure must be initialized to zero before the first call to one of the
+ * attribute search functions. Initialize @mrec to point to the mft record to
+ * search, and @attr to point to the first attribute within @mrec (not necessary
+ * if calling the _first() functions), and set @is_first to TRUE (not necessary
+ * if calling the _first() functions).
+ *
+ * If @is_first is TRUE, the search begins with @attr. If @is_first is FALSE,
+ * the search begins after @attr. This is so that, after the first call to one
+ * of the search attribute functions, we can call the function again, without
+ * any modification of the search context, to automagically get the next
+ * matching attribute.
+ */
+struct _ntfs_attr_search_ctx {
+	NTFS_MFT_RECORD *mrec;
+	NTFS_ATTR_RECORD *attr;
+	NTFS_BOOL is_first;
+	ntfs_inode *ntfs_ino;
+	NTFS_ATTR_LIST_ENTRY *al_entry;
+	ntfs_inode *base_ntfs_ino;
+	NTFS_MFT_RECORD *base_mrec;
+	NTFS_ATTR_RECORD *base_attr;
+};
+
+extern void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx);
+extern ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni,
+		NTFS_MFT_RECORD *mrec);
+extern void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx);
+
+extern int ntfs_attr_lookup(const NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_VCN lowest_vcn, const u8 *val, const u32 val_len,
+		ntfs_attr_search_ctx *ctx);
+
+extern NTFS_ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,
+		const NTFS_ATTR_TYPES type);
+
+/**
+ * ntfs_attrs_walk - syntactic sugar for walking all attributes in an inode
+ * @ctx:	initialised attribute search context
+ *
+ * Syntactic sugar for walking attributes in an inode.
+ *
+ * Return 0 on success and -1 on error with errno set to the error code from
+ * ntfs_attr_lookup().
+ *
+ * Example: When you want to enumerate all attributes in an open ntfs inode
+ *	    @ni, you can simply do:
+ *
+ *	int err;
+ *	ntfs_attr_search_ctx *ctx = ntfs_attr_get_search_ctx(ni, NULL);
+ *	if (!ctx)
+ *		// Error code is in errno. Handle this case.
+ *	while (!(err = ntfs_attrs_walk(ctx))) {
+ *		NTFS_ATTR_RECORD *attr = ctx->attr;
+ *		// attr now contains the next attribute. Do whatever you want
+ *		// with it and then just continue with the while loop.
+ *	}
+ *	if (err && errno != ENOENT)
+ *		// Ooops. An error occurred! You should handle this case.
+ *	// Now finished with all attributes in the inode.
+ */
+static __inline__ int ntfs_attrs_walk(ntfs_attr_search_ctx *ctx)
+{
+	return ntfs_attr_lookup(NTFS_AT_UNUSED, NULL, 0, NTFS_CASE_SENSITIVE, 0,
+			NULL, 0, ctx);
+}
+
+/**
+ * struct ntfs_attr - ntfs in memory non-resident attribute structure
+ * @rl:			if not NULL, the decompressed ntfs_runlist
+ * @ni:			base ntfs inode to which this attribute belongs
+ * @type:		attribute type
+ * @name:		Unicode name of the attribute
+ * @name_len:		length of @name in Unicode characters
+ * @state:		NTFS attribute specific flags describing this attribute
+ * @allocated_size:	copy from the attribute record
+ * @data_size:		copy from the attribute record
+ * @initialized_size:	copy from the attribute record
+ * @compressed_size:	copy from the attribute record
+ * @compression_block_size:		size of a compression block (cb)
+ * @compression_block_size_bits:	log2 of the size of a cb
+ * @compression_block_clusters:		number of clusters per cb
+ * @crypto:		(valid only for encrypted) see description below
+ *
+ * This structure exists purely to provide a mechanism of caching the ntfs_runlist
+ * of an attribute. If you want to operate on a particular attribute extent,
+ * you should not be using this structure at all. If you want to work with a
+ * resident attribute, you should not be using this structure at all. As a
+ * fail-safe check make sure to test NAttrNonResident() and if it is false, you
+ * know you shouldn't be using this structure.
+ *
+ * If you want to work on a resident attribute or on a specific attribute
+ * extent, you should use ntfs_lookup_attr() to retrieve the attribute (extent)
+ * record, edit that, and then write back the mft record (or set the
+ * corresponding ntfs inode dirty for delayed write back).
+ *
+ * @rl is the decompressed ntfs_runlist of the attribute described by this
+ * structure. Obviously this only makes sense if the attribute is not resident,
+ * i.e. NAttrNonResident() is true. If the ntfs_runlist hasn't been decompressed yet
+ * @rl is NULL, so be prepared to cope with @rl == NULL.
+ *
+ * @ni is the base ntfs inode of the attribute described by this structure.
+ *
+ * @type is the attribute type (see layout.h for the definition of NTFS_ATTR_TYPES),
+ * @name and @name_len are the little endian Unicode name and the name length
+ * in Unicode characters of the attribute, respectively.
+ *
+ * @state contains NTFS attribute specific flags describing this attribute
+ * structure. See ntfs_attr_state_bits above.
+ *
+ * @crypto points to private structure of crypto code. You should not access
+ * fields of this structure, but you can check whether it is NULL or not. If it
+ * is not NULL, then we successfully obtained FEK (File Encryption Key) and
+ * ntfs_attr_p{read,write} calls probably would succeed. If it is NULL, then we
+ * failed to obtain FEK (do not have corresponding PFX file, wrong password,
+ * etc..) or library was compiled without crypto support. Attribute size can be
+ * changed without knowledge of FEK, so you can use ntfs_attr_truncate in any
+ * case.
+ * NOTE: This field valid only if attribute encrypted (eg., NAttrEncrypted
+ * returns non-zero).
+ */
+struct _ntfs_attr {
+	ntfs_runlist_element *rl;
+	ntfs_inode *ni;
+	NTFS_ATTR_TYPES type;
+	ntfschar *name;
+	u32 name_len;
+	unsigned long state;
+	s64 allocated_size;
+	s64 data_size;
+	s64 initialized_size;
+	s64 compressed_size;
+	u32 compression_block_size;
+	u8 compression_block_size_bits;
+	u8 compression_block_clusters;
+	ntfs_crypto_attr *crypto;
+	struct ntfs_list_head ntfs_list_entry;
+	int nr_references;
+};
+
+/**
+ * enum ntfs_attr_state_bits - bits for the state field in the ntfs_attr
+ * structure
+ */
+typedef enum {
+	NA_Initialized,		/* 1: structure is initialized. */
+	NA_NonResident,		/* 1: Attribute is not resident. */
+} ntfs_attr_state_bits;
+
+#define  test_nattr_flag(na, flag)	 test_bit(NA_##flag, (na)->state)
+#define   set_nattr_flag(na, flag)	  set_bit(NA_##flag, (na)->state)
+#define clear_nattr_flag(na, flag)	clear_bit(NA_##flag, (na)->state)
+
+#define NAttrInitialized(na)		 test_nattr_flag(na, Initialized)
+#define NAttrSetInitialized(na)		  set_nattr_flag(na, Initialized)
+#define NAttrClearInitialized(na)	clear_nattr_flag(na, Initialized)
+
+#define NAttrNonResident(na)		 test_nattr_flag(na, NonResident)
+#define NAttrSetNonResident(na)		  set_nattr_flag(na, NonResident)
+#define NAttrClearNonResident(na)	clear_nattr_flag(na, NonResident)
+
+#define GenNAttrIno(func_name,flag)					\
+static inline int NAttr##func_name(ntfs_attr *na)			\
+{									\
+	if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED)	\
+		return (na->ni->flags & NTFS_FILE_ATTR_##flag) ? 1 : 0;	\
+	return 0;							\
+}									\
+static inline void NAttrSet##func_name(ntfs_attr *na)			\
+{									\
+	if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED)	\
+		na->ni->flags |= NTFS_FILE_ATTR_##flag;			\
+	else								\
+		ntfs_log_trace("BUG! Should be called only for "	\
+				"unnamed data attribute.\n");		\
+}									\
+static inline void NAttrClear##func_name(ntfs_attr *na)			\
+{									\
+	if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED)	\
+		na->ni->flags &= ~NTFS_FILE_ATTR_##flag;		\
+}
+
+GenNAttrIno(Compressed, COMPRESSED)
+GenNAttrIno(Encrypted, ENCRYPTED)
+GenNAttrIno(Sparse, SPARSE_FILE)
+
+/**
+ * union attr_val - Union of all known attribute values
+ *
+ * For convenience. Used in the attr structure.
+ */
+typedef union {
+	u8 _default;	/* Unnamed u8 to serve as default when just using
+			   a_val without specifying any of the below. */
+	NTFS_STANDARD_INFORMATION std_inf;
+	NTFS_ATTR_LIST_ENTRY al_entry;
+	NTFS_FILE_NAME_ATTR filename;
+	NTFS_OBJECT_ID_ATTR obj_id;
+	NTFS_SECURITY_DESCRIPTOR_ATTR sec_desc;
+	NTFS_VOLUME_NAME vol_name;
+	NTFS_VOLUME_INFORMATION vol_inf;
+	NTFS_DATA_ATTR data;
+	NTFS_INDEX_ROOT index_root;
+	NTFS_INDEX_BLOCK index_blk;
+	NTFS_BITMAP_ATTR bmp;
+	NTFS_REPARSE_POINT reparse;
+	NTFS_EA_INFORMATION ea_inf;
+	NTFS_EA_ATTR ea;
+	NTFS_PROPERTY_SET property_set;
+	NTFS_LOGGED_UTILITY_STREAM logged_util_stream;
+	NTFS_EFS_ATTR_HEADER efs;
+} attr_val;
+
+extern void ntfs_attr_init(ntfs_attr *na, const NTFS_BOOL non_resident,
+		const NTFS_BOOL compressed, const NTFS_BOOL encrypted, const NTFS_BOOL sparse,
+		const s64 allocated_size, const s64 data_size,
+		const s64 initialized_size, const s64 compressed_size,
+		const u8 compression_unit);
+
+extern ntfs_attr *ntfs_attr_open(ntfs_inode *ni, const NTFS_ATTR_TYPES type,
+		ntfschar *name, u32 name_len);
+extern void ntfs_attr_close(ntfs_attr *na);
+
+extern s64 ntfs_attr_pread(ntfs_attr *na, const s64 pos, s64 count,
+		void *b);
+extern s64 ntfs_attr_pwrite(ntfs_attr *na, const s64 pos, s64 count,
+		const void *b);
+
+extern void *ntfs_attr_readall(ntfs_inode *ni, const NTFS_ATTR_TYPES type,
+			       ntfschar *name, u32 name_len, s64 *data_size);
+
+extern s64 ntfs_attr_mst_pread(ntfs_attr *na, const s64 pos,
+		const s64 bk_cnt, const u32 bk_size, void *dst);
+extern s64 ntfs_attr_mst_pwrite(ntfs_attr *na, const s64 pos,
+		s64 bk_cnt, const u32 bk_size, void *src);
+
+extern int ntfs_attr_map_runlist(ntfs_attr *na, NTFS_VCN vcn);
+extern int ntfs_attr_map_runlist_range(ntfs_attr *na, NTFS_VCN from_vcn, NTFS_VCN to_vcn);
+extern int ntfs_attr_map_whole_runlist(ntfs_attr *na);
+
+extern NTFS_LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const NTFS_VCN vcn);
+extern ntfs_runlist_element *ntfs_attr_find_vcn(ntfs_attr *na, const NTFS_VCN vcn);
+
+extern int ntfs_attr_size_bounds_check(const ntfs_volume *vol,
+		const NTFS_ATTR_TYPES type, const s64 size);
+extern int ntfs_attr_can_be_non_resident(const ntfs_volume *vol,
+		const NTFS_ATTR_TYPES type);
+extern int ntfs_attr_can_be_resident(const ntfs_volume *vol,
+		const NTFS_ATTR_TYPES type);
+
+extern int ntfs_make_room_for_attr(NTFS_MFT_RECORD *m, u8 *pos, u32 size);
+
+extern int ntfs_resident_attr_record_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
+		ntfschar *name, u8 name_len, u8 *val, u32 size,
+		NTFS_ATTR_FLAGS flags);
+extern int ntfs_non_resident_attr_record_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
+		ntfschar *name, u8 name_len, NTFS_VCN lowest_vcn, int dataruns_size,
+		NTFS_ATTR_FLAGS flags);
+extern int ntfs_attr_record_rm(ntfs_attr_search_ctx *ctx);
+
+extern int ntfs_attr_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
+		ntfschar *name, u8 name_len, u8 *val, s64 size);
+extern int ntfs_attr_rm(ntfs_attr *na);
+
+extern int ntfs_attr_record_resize(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a, u32 new_size);
+
+extern int ntfs_resident_attr_value_resize(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a,
+		const u32 new_size);
+
+extern int ntfs_attr_record_move_to(ntfs_attr_search_ctx *ctx, ntfs_inode *ni);
+extern int ntfs_attr_record_move_away(ntfs_attr_search_ctx *ctx, int extra);
+
+extern int ntfs_attr_update_mapping_pairs(ntfs_attr *na, NTFS_VCN from_vcn);
+
+extern int __ntfs_attr_truncate(ntfs_attr *na, const s64 newsize, NTFS_BOOL sparse);
+extern int ntfs_attr_truncate(ntfs_attr *na, const s64 newsize);
+
+extern int ntfs_attr_exist(ntfs_inode *ni, const NTFS_ATTR_TYPES type,
+		ntfschar *name, u32 name_len);
+
+static __inline__ ntfschar *ntfs_attr_get_name(NTFS_ATTR_RECORD *attr)
+{
+	return (ntfschar*)((u8*)attr + le16_to_cpu(attr->name_offset));
+}
+
+// FIXME / TODO: Above here the file is cleaned up. (AIA)
+/**
+ * get_attribute_value_length - return the length of the value of an attribute
+ * @a:	pointer to a buffer containing the attribute record
+ *
+ * Return the byte size of the attribute value of the attribute @a (as it
+ * would be after eventual decompression and filling in of holes if sparse).
+ * If we return 0, check errno. If errno is 0 the actual length was 0,
+ * otherwise errno describes the error.
+ *
+ * FIXME: Describe possible errnos.
+ */
+s64 ntfs_get_attribute_value_length(const NTFS_ATTR_RECORD *a);
+
+/**
+ * get_attribute_value - return the attribute value of an attribute
+ * @vol:	volume on which the attribute is present
+ * @a:		attribute to get the value of
+ * @b:		destination buffer for the attribute value
+ *
+ * Make a copy of the attribute value of the attribute @a into the destination
+ * buffer @b. Note, that the size of @b has to be at least equal to the value
+ * returned by get_attribute_value_length(@a).
+ *
+ * Return number of bytes copied. If this is zero check errno. If errno is 0
+ * then nothing was read due to a zero-length attribute value, otherwise
+ * errno describes the error.
+ */
+s64 ntfs_get_attribute_value(const ntfs_volume *vol, const NTFS_ATTR_RECORD *a,
+		u8 *b);
+
+__END_DECLS
+
+#endif /* defined _NTFS_ATTRIB_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_attrlist.h ./include/ntfs/ntfs_attrlist.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_attrlist.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_attrlist.h	2007-10-06 16:50:34.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * attrlist.h - Exports for attribute list attribute handling.  Part of the
+ *		Linux-NTFS project.
+ *
+ * Copyright (c) 2004 Anton Altaparmakov
+ * Copyright (c) 2004 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_ATTRLIST_H
+#define _NTFS_ATTRLIST_H 1
+
+#include "ntfs_attrib.h"
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+extern int ntfs_attrlist_need(ntfs_inode *ni);
+
+extern int ntfs_attrlist_entry_add(ntfs_inode *ni, NTFS_ATTR_RECORD *attr);
+extern int ntfs_attrlist_entry_rm(ntfs_attr_search_ctx *ctx);
+
+/**
+ * ntfs_attrlist_mark_dirty - set the attribute list dirty
+ * @ni:		ntfs inode which base inode contain dirty attribute list
+ *
+ * Set the attribute list dirty so it is written out later (at the latest at
+ * ntfs_inode_close() time).
+ *
+ * This function cannot fail.
+ */
+static __inline__ void ntfs_attrlist_mark_dirty(ntfs_inode *ni)
+{
+	if (ni->nr_extents == -1)
+		NInoAttrListSetDirty(ni->base_ni);
+	else
+		NInoAttrListSetDirty(ni);
+}
+
+__END_DECLS
+
+#endif /* defined _NTFS_ATTRLIST_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_bitmap.h ./include/ntfs/ntfs_bitmap.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_bitmap.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_bitmap.h	2007-10-06 16:51:24.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+ * bitmap.h - Exports for bitmap handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c) 2004-2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_BITMAP_H
+#define _NTFS_BITMAP_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+
+__BEGIN_DECLS
+
+/*
+ * NOTES:
+ *
+ * - Operations are 8-bit only to ensure the functions work both on little
+ *   and big endian machines! So don't make them 32-bit ops!
+ * - bitmap starts at bit = 0 and ends at bit = bitmap size - 1.
+ * - _Caller_ has to make sure that the bit to operate on is less than the
+ *   size of the bitmap.
+ */
+
+/**
+ * ntfs_bit_set - set a bit in a field of bits
+ * @bitmap:	field of bits
+ * @bit:	bit to set
+ * @new_value:	value to set bit to (0 or 1)
+ *
+ * Set the bit @bit in the @bitmap to @new_value. Ignore all errors.
+ */
+static __inline__ void ntfs_bit_set(u8 *bitmap, const u64 bit,
+		const u8 new_value)
+{
+	if (!bitmap || new_value > 1)
+		return;
+	if (!new_value)
+		bitmap[bit >> 3] &= ~(1 << (bit & 7));
+	else
+		bitmap[bit >> 3] |= (1 << (bit & 7));
+}
+
+/**
+ * ntfs_bit_get - get value of a bit in a field of bits
+ * @bitmap:	field of bits
+ * @bit:	bit to get
+ *
+ * Get and return the value of the bit @bit in @bitmap (0 or 1).
+ * Return -1 on error.
+ */
+static __inline__ char ntfs_bit_get(const u8 *bitmap, const u64 bit)
+{
+	if (!bitmap)
+		return -1;
+	return (bitmap[bit >> 3] >> (bit & 7)) & 1;
+}
+
+static __inline__ void ntfs_bit_change(u8 *bitmap, const u64 bit)
+{
+	if (!bitmap)
+		return;
+	bitmap[bit >> 3] ^= 1 << (bit & 7);
+}
+
+/**
+ * ntfs_bit_get_and_set - get value of a bit in a field of bits and set it
+ * @bitmap:	field of bits
+ * @bit:	bit to get/set
+ * @new_value:	value to set bit to (0 or 1)
+ *
+ * Return the value of the bit @bit and set it to @new_value (0 or 1).
+ * Return -1 on error.
+ */
+static __inline__ char ntfs_bit_get_and_set(u8 *bitmap, const u64 bit,
+		const u8 new_value)
+{
+	register u8 old_bit, shift;
+
+	if (!bitmap || new_value > 1)
+		return -1;
+	shift = bit & 7;
+	old_bit = (bitmap[bit >> 3] >> shift) & 1;
+	if (new_value != old_bit)
+		bitmap[bit >> 3] ^= 1 << shift;
+	return old_bit;
+}
+
+extern int ntfs_bitmap_set_run(ntfs_attr *na, s64 start_bit, s64 count);
+extern int ntfs_bitmap_clear_run(ntfs_attr *na, s64 start_bit, s64 count);
+
+/**
+ * ntfs_bitmap_set_bit - set a bit in a bitmap
+ * @na:		attribute containing the bitmap
+ * @bit:	bit to set
+ *
+ * Set the @bit in the bitmap described by the attribute @na.
+ *
+ * On success return 0 and on error return -1 with errno set to the error code.
+ */
+static __inline__ int ntfs_bitmap_set_bit(ntfs_attr *na, s64 bit)
+{
+	return ntfs_bitmap_set_run(na, bit, 1);
+}
+
+/**
+ * ntfs_bitmap_clear_bit - clear a bit in a bitmap
+ * @na:		attribute containing the bitmap
+ * @bit:	bit to clear
+ *
+ * Clear @bit in the bitmap described by the attribute @na.
+ *
+ * On success return 0 and on error return -1 with errno set to the error code.
+ */
+static __inline__ int ntfs_bitmap_clear_bit(ntfs_attr *na, s64 bit)
+{
+	return ntfs_bitmap_clear_run(na, bit, 1);
+}
+
+__END_DECLS
+
+#endif /* defined _NTFS_BITMAP_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_bootsect.h ./include/ntfs/ntfs_bootsect.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_bootsect.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_bootsect.h	2007-10-06 16:51:37.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * bootsect.h - Exports for bootsector record handling. Part of the Linux-NTFS
+ *		project.
+ *
+ * Copyright (c) 2000-2002 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_BOOTSECT_H
+#define _NTFS_BOOTSECT_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
+#include "ntfs_layout.h"
+
+__BEGIN_DECLS
+
+/**
+ * is_boot_sector_ntfs - check a boot sector for describing an ntfs volume
+ * @b:		buffer containing the boot sector
+ * @silent:	if 1 don't display progress information
+ *
+ * This function checks the boot sector in @b for describing a valid ntfs
+ * volume. Return TRUE if @b is a valid NTFS boot sector or FALSE otherwise.
+ * If silent is FALSE, progress output will be output to stdout. If silent is
+ * TRUE no output to stdout will occur. Errors/warnings to stderr will occur
+ * disregarding the value of silent (but only if configure was run with
+ * --enable-debug).
+ */
+extern NTFS_BOOL ntfs_boot_sector_is_ntfs(NTFS_BOOT_SECTOR *b, NTFS_BOOL silent);
+extern int ntfs_boot_sector_parse(ntfs_volume *vol,
+		const NTFS_BOOT_SECTOR *bs);
+
+__END_DECLS
+
+#endif /* defined _NTFS_BOOTSECT_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_collate.h ./include/ntfs/ntfs_collate.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_collate.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_collate.h	2007-10-06 16:51:55.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * collate.h - Defines for NTFS collation handling.  Part of the Linux-NTFS
+ *             project.
+ *
+ * Copyright (c) 2004 Anton Altaparmakov
+ * Copyright (c) 2005 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_COLLATE_H
+#define _NTFS_COLLATE_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
+
+__BEGIN_DECLS
+
+#define NTFS_COLLATION_ERROR (-2)
+
+extern NTFS_BOOL ntfs_is_collation_rule_supported(NTFS_COLLATION_RULES cr);
+
+extern int ntfs_collate(ntfs_volume *vol, NTFS_COLLATION_RULES cr,
+		const void *data1, size_t data1_len,
+		const void *data2, size_t data2_len);
+
+__END_DECLS
+
+#endif /* _NTFS_COLLATE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_compat.h ./include/ntfs/ntfs_compat.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_compat.h	2007-10-06 16:59:47.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ * compat.h - Tweaks for Windows compatibility.
+ *
+ * Copyright (c) 2002 Richard Russon
+ * Copyright (c) 2002-2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_COMPAT_H
+#define _NTFS_COMPAT_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_STDIO_H 1
+#define HAVE_STDARG_H 1
+#endif
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+#ifdef WINDOWS
+
+#ifndef HAVE_FFS
+#define HAVE_FFS 1
+extern int ffs(int i);
+#endif /* HAVE_FFS */
+
+#define HAVE_STDIO_H 1		/* mimic config.h */
+#define HAVE_STDARG_H 1
+
+#define atoll			_atoi64
+#define fdatasync		commit
+
+#ifndef __inline__
+#define __inline__		inline
+#endif
+
+#ifndef __attribute__
+#define __attribute__(X)	/*nothing*/
+#endif
+
+#else /* !defined WINDOWS */
+
+#ifndef O_BINARY
+#define O_BINARY		0		/* unix is binary by default */
+#endif
+
+#endif /* defined WINDOWS */
+
+__END_DECLS
+
+#endif /* defined _NTFS_COMPAT_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_compress.h ./include/ntfs/ntfs_compress.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_compress.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_compress.h	2007-10-06 16:52:56.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ * compress.h - Exports for compressed attribute handling. Part of the
+ *		Linux-NTFS project.
+ *
+ * Copyright (c) 2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_COMPRESS_H
+#define _NTFS_COMPRESS_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+
+__BEGIN_DECLS
+
+extern s64 ntfs_compressed_attr_pread(ntfs_attr *na, s64 pos, s64 count,
+		void *b);
+
+__END_DECLS
+
+#endif /* defined _NTFS_COMPRESS_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_crypto.h ./include/ntfs/ntfs_crypto.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_crypto.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_crypto.h	2007-10-06 16:53:12.000000000 +0200
@@ -0,0 +1,52 @@
+/**
+ * crypto.h - Exports for dealing with encrypted files.  Part of the
+ *            Linux-NTFS project.
+ *
+ * Copyright (c) 2007 Yura Pakhuchiy
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_CRYPTO_H
+#define _NTFS_CRYPTO_H 1
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+extern ntfschar NTFS_EFS[5];
+
+/*
+ * This is our Big Secret (TM) structure, so do not allow anyone even read it
+ * values. ;-) In fact, it is private because exist only in libntfs version
+ * compiled with cryptography support, so users can not depend on it.
+ */
+typedef struct _ntfs_crypto_attr ntfs_crypto_attr;
+
+/*
+ * These functions should not be used directly. They are called for encrypted
+ * attributes from corresponding functions without _crypto_ part.
+ */
+
+extern int ntfs_crypto_attr_open(ntfs_attr *na);
+extern void ntfs_crypto_attr_close(ntfs_attr *na);
+
+extern s64 ntfs_crypto_attr_pread(ntfs_attr *na, const s64 pos, s64 count,
+		void *b);
+
+__END_DECLS
+
+#endif /* _NTFS_CRYPTO_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_debug.h ./include/ntfs/ntfs_debug.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_debug.h	2007-10-06 16:53:39.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * debug.h - Debugging output functions. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2002-2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_DEBUG_H
+#define _NTFS_DEBUG_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "ntfs_logging.h"
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+struct _ntfs_runlist_element;
+
+#ifndef DEBUG
+static __inline__ void ntfs_debug_runlist_dump(const struct _ntfs_runlist_element *rl __attribute__((unused))) {}
+#define NTFS_ON_DEBUG(x)
+#else
+extern void ntfs_debug_runlist_dump(const struct _ntfs_runlist_element *rl);
+#define NTFS_ON_DEBUG(x) (x)
+#endif
+
+#define NTFS_BUG(msg)							\
+{									\
+	int ___i;							\
+	ntfs_log_critical("Bug in %s(): %s\n", __FUNCTION__, msg);	\
+	ntfs_log_debug("Forcing segmentation fault!");			\
+	___i = ((int*)NULL)[1];						\
+}
+
+__END_DECLS
+
+#endif /* defined _NTFS_DEBUG_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_device.h ./include/ntfs/ntfs_device.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_device.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_device.h	2007-10-06 16:53:59.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * device.h - Exports for low level device io. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2006 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_DEVICE_H
+#define _NTFS_DEVICE_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "ntfs_device_io.h"
+#include "ntfs_types.h"
+#include "ntfs_support.h"
+#include "ntfs_volume.h"
+
+__BEGIN_DECLS
+
+/**
+ * enum ntfs_device_state_bits -
+ *
+ * Defined bits for the state field in the ntfs_device structure.
+ */
+typedef enum {
+	ND_Open,	/* 1: Device is open. */
+	ND_ReadOnly,	/* 1: Device is read-only. */
+	ND_Dirty,	/* 1: Device is dirty, needs sync. */
+	ND_Block,	/* 1: Device is a block device. */
+} ntfs_device_state_bits;
+
+#define  test_ndev_flag(nd, flag)	   test_bit(ND_##flag, (nd)->d_state)
+#define   set_ndev_flag(nd, flag)	    set_bit(ND_##flag, (nd)->d_state)
+#define clear_ndev_flag(nd, flag)	  clear_bit(ND_##flag, (nd)->d_state)
+
+#define NDevOpen(nd)		 test_ndev_flag(nd, Open)
+#define NDevSetOpen(nd)		  set_ndev_flag(nd, Open)
+#define NDevClearOpen(nd)	clear_ndev_flag(nd, Open)
+
+#define NDevReadOnly(nd)	 test_ndev_flag(nd, ReadOnly)
+#define NDevSetReadOnly(nd)	  set_ndev_flag(nd, ReadOnly)
+#define NDevClearReadOnly(nd)	clear_ndev_flag(nd, ReadOnly)
+
+#define NDevDirty(nd)		 test_ndev_flag(nd, Dirty)
+#define NDevSetDirty(nd)	  set_ndev_flag(nd, Dirty)
+#define NDevClearDirty(nd)	clear_ndev_flag(nd, Dirty)
+
+#define NDevBlock(nd)		 test_ndev_flag(nd, Block)
+#define NDevSetBlock(nd)	  set_ndev_flag(nd, Block)
+#define NDevClearBlock(nd)	clear_ndev_flag(nd, Block)
+
+/**
+ * struct ntfs_device -
+ *
+ * The ntfs device structure defining all operations needed to access the low
+ * level device underlying the ntfs volume.
+ */
+struct ntfs_device {
+	struct ntfs_device_operations *d_ops;	/* Device operations. */
+	unsigned long d_state;			/* State of the device. */
+	char *d_name;				/* Name of device. */
+	void *d_private;			/* Private data used by the
+						   device operations. */
+};
+
+struct stat;
+
+/**
+ * struct ntfs_device_operations -
+ *
+ * The ntfs device operations defining all operations that can be performed on
+ * the low level device described by an ntfs device structure.
+ */
+struct ntfs_device_operations {
+	int (*open)(struct ntfs_device *dev, int flags);
+	int (*close)(struct ntfs_device *dev);
+	s64 (*seek)(struct ntfs_device *dev, s64 offset, int whence);
+	s64 (*read)(struct ntfs_device *dev, void *buf, s64 count);
+	s64 (*write)(struct ntfs_device *dev, const void *buf, s64 count);
+	s64 (*pread)(struct ntfs_device *dev, void *buf, s64 count, s64 offset);
+	s64 (*pwrite)(struct ntfs_device *dev, const void *buf, s64 count,
+			s64 offset);
+	int (*sync)(struct ntfs_device *dev);
+	int (*stat)(struct ntfs_device *dev, struct stat *buf);
+	int (*ioctl)(struct ntfs_device *dev, int request, void *argp);
+};
+
+extern struct ntfs_device *ntfs_device_alloc(const char *name, const long state,
+		struct ntfs_device_operations *dops, void *priv_data);
+extern int ntfs_device_free(struct ntfs_device *dev);
+
+extern s64 ntfs_pread(struct ntfs_device *dev, const s64 pos, s64 count,
+		void *b);
+extern s64 ntfs_pwrite(struct ntfs_device *dev, const s64 pos, s64 count,
+		const void *b);
+
+extern s64 ntfs_mst_pread(struct ntfs_device *dev, const s64 pos, s64 count,
+		const u32 bksize, void *b);
+extern s64 ntfs_mst_pwrite(struct ntfs_device *dev, const s64 pos, s64 count,
+		const u32 bksize, void *b);
+
+extern s64 ntfs_cluster_read(const ntfs_volume *vol, const s64 lcn,
+		const s64 count, void *b);
+extern s64 ntfs_cluster_write(const ntfs_volume *vol, const s64 lcn,
+		const s64 count, const void *b);
+
+extern s64 ntfs_device_size_get(struct ntfs_device *dev, int block_size);
+extern s64 ntfs_device_partition_start_sector_get(struct ntfs_device *dev);
+extern int ntfs_device_heads_get(struct ntfs_device *dev);
+extern int ntfs_device_sectors_per_track_get(struct ntfs_device *dev);
+extern int ntfs_device_sector_size_get(struct ntfs_device *dev);
+extern int ntfs_device_block_size_set(struct ntfs_device *dev, int block_size);
+
+__END_DECLS
+
+#endif /* defined _NTFS_DEVICE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_device_io.h ./include/ntfs/ntfs_device_io.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_device_io.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_device_io.h	2007-10-06 16:54:26.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+ * device_io.h - Exports for default device io. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2006 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_DEVICE_IO_H
+#define _NTFS_DEVICE_IO_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+#ifndef NO_NTFS_DEVICE_DEFAULT_IO_OPS
+
+#ifndef __CYGWIN32__
+
+/* Not on Cygwin; use standard Unix style low level device operations. */
+#define ntfs_device_default_io_ops ntfs_device_unix_io_ops
+
+#else /* __CYGWIN32__ */
+
+#ifndef HDIO_GETGEO
+#	define HDIO_GETGEO	0x301
+/**
+ * struct hd_geometry -
+ */
+struct hd_geometry {
+	unsigned char heads;
+	unsigned char sectors;
+	unsigned short cylinders;
+	unsigned long start;
+};
+#endif
+#ifndef BLKGETSIZE
+#	define BLKGETSIZE	0x1260
+#endif
+#ifndef BLKSSZGET
+#	define BLKSSZGET	0x1268
+#endif
+#ifndef BLKGETSIZE64
+#	define BLKGETSIZE64	0x80041272
+#endif
+#ifndef BLKBSZSET
+#	define BLKBSZSET	0x40041271
+#endif
+
+/* On Cygwin; use Win32 low level device operations. */
+#define ntfs_device_default_io_ops ntfs_device_win32_io_ops
+
+#endif /* __CYGWIN32__ */
+
+
+/* Forward declaration. */
+struct ntfs_device_operations;
+
+extern struct ntfs_device_operations ntfs_device_default_io_ops;
+
+#endif /* NO_NTFS_DEVICE_DEFAULT_IO_OPS */
+
+__END_DECLS
+
+#endif /* defined _NTFS_DEVICE_IO_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_dir.h ./include/ntfs/ntfs_dir.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_dir.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_dir.h	2007-10-06 16:54:48.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+ * dir.h - Exports for directory handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2002 Anton Altaparmakov
+ * Copyright (c) 2005-2006 Yura Pakhuchiy
+ * Copyright (c) 2004-2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_DIR_H
+#define _NTFS_DIR_H 1
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+#define PATH_SEP '/'
+
+#ifndef MAX_PATH
+#define MAX_PATH 1024
+#endif
+
+/*
+ * We do not have these under DJGPP, so define our version that do not conflict
+ * with other S_IFs defined under DJGPP.
+ */
+#ifdef DJGPP
+#ifndef S_IFLNK
+#define S_IFLNK  0120000
+#endif
+#ifndef S_ISLNK
+#define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)
+#endif
+#ifndef S_IFSOCK
+#define S_IFSOCK 0140000
+#endif
+#ifndef S_ISSOCK
+#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#endif
+#endif
+
+/*
+ * The little endian Unicode strings $I30, $SII, $SDH, $O, $Q, $R
+ * as a global constant.
+ */
+extern ntfschar NTFS_INDEX_I30[5];
+extern ntfschar NTFS_INDEX_SII[5];
+extern ntfschar NTFS_INDEX_SDH[5];
+extern ntfschar NTFS_INDEX_O[3];
+extern ntfschar NTFS_INDEX_Q[3];
+extern ntfschar NTFS_INDEX_R[3];
+
+extern u64 ntfs_inode_lookup_by_name(ntfs_inode *dir_ni,
+		const ntfschar *uname, const int uname_len);
+
+extern u64 ntfs_pathname_to_inode_num(ntfs_volume *vol, ntfs_inode *parent,
+		const char *pathname);
+extern ntfs_inode *ntfs_pathname_to_inode(ntfs_volume *vol, ntfs_inode *parent,
+		const char *pathname);
+
+extern ntfs_inode *ntfs_create(ntfs_inode *dir_ni, ntfschar *name, u8 name_len,
+		dev_t type);
+extern ntfs_inode *ntfs_create_device(ntfs_inode *dir_ni,
+		ntfschar *name, u8 name_len, dev_t type, dev_t dev);
+extern ntfs_inode *ntfs_create_symlink(ntfs_inode *dir_ni,
+		ntfschar *name, u8 name_len, ntfschar *target, u8 target_len);
+
+extern int ntfs_delete(ntfs_inode **pni, ntfs_inode *dir_ni, ntfschar *name,
+		u8 name_len);
+
+extern int ntfs_link(ntfs_inode *ni, ntfs_inode *dir_ni, ntfschar *name,
+		u8 name_len);
+
+/*
+ * File types (adapted from include <linux/fs.h>)
+ */
+#define NTFS_DT_UNKNOWN		0
+#define NTFS_DT_FIFO		1
+#define NTFS_DT_CHR		2
+#define NTFS_DT_DIR		4
+#define NTFS_DT_BLK		6
+#define NTFS_DT_REG		8
+#define NTFS_DT_LNK		10
+#define NTFS_DT_SOCK		12
+#define NTFS_DT_WHT		14
+
+/*
+ * This is the "ntfs_filldir" function type, used by ntfs_readdir() to let
+ * the caller specify what kind of dirent layout it wants to have.
+ * This allows the caller to read directories into their application or
+ * to have different dirent layouts depending on the binary type.
+ */
+typedef int (*ntfs_filldir_t)(void *dirent, const ntfschar *name,
+		const int name_len, const int name_type, const s64 pos,
+		const NTFS_MFT_REF mref, const unsigned dt_type);
+
+extern int ntfs_readdir(ntfs_inode *dir_ni, s64 *pos,
+		void *dirent, ntfs_filldir_t filldir);
+
+__END_DECLS
+
+#endif /* defined _NTFS_DIR_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_endians.h ./include/ntfs/ntfs_endians.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_endians.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_endians.h	2007-10-06 16:56:04.000000000 +0200
@@ -0,0 +1,258 @@
+/*
+ * endians.h - Definitions related to handling of byte ordering. Part of the
+ *	       Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2005 Anton Altaparmakov
+ * Copyright (c)      2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_ENDIANS_H
+#define _NTFS_ENDIANS_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_ENDIAN_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_BYTESWAP_H 1
+#endif
+
+/*
+ * Notes:
+ *	We define the conversion functions including typecasts since the
+ * defaults don't necessarily perform appropriate typecasts.
+ *	Also, using our own functions means that we can change them if it
+ * turns out that we do need to use the unaligned access macros on
+ * architectures requiring aligned memory accesses...
+ */
+
+#ifdef HAVE_ENDIAN_H
+#include <endian.h>
+#endif
+#ifdef HAVE_SYS_ENDIAN_H
+#include <sys/endian.h>
+#endif
+#ifdef HAVE_MACHINE_ENDIAN_H
+#include <machine/endian.h>
+#endif
+#ifdef HAVE_SYS_BYTEORDER_H
+#include <sys/byteorder.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+
+#ifndef __BYTE_ORDER
+#	if defined(_BYTE_ORDER)
+#		define __BYTE_ORDER _BYTE_ORDER
+#		define __LITTLE_ENDIAN _LITTLE_ENDIAN
+#		define __BIG_ENDIAN _BIG_ENDIAN
+#	elif defined(BYTE_ORDER)
+#		define __BYTE_ORDER BYTE_ORDER
+#		define __LITTLE_ENDIAN LITTLE_ENDIAN
+#		define __BIG_ENDIAN BIG_ENDIAN
+#	elif defined(__BYTE_ORDER__)
+#		define __BYTE_ORDER __BYTE_ORDER__
+#		define __LITTLE_ENDIAN __LITTLE_ENDIAN__
+#		define __BIG_ENDIAN __BIG_ENDIAN__
+#	elif (defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)) || \
+			defined(WORDS_LITTLEENDIAN)
+#		define __BYTE_ORDER 1
+#		define __LITTLE_ENDIAN 1
+#		define __BIG_ENDIAN 0
+#	elif (!defined(_LITTLE_ENDIAN) && defined(_BIG_ENDIAN)) || \
+			defined(WORDS_BIGENDIAN)
+#		define __BYTE_ORDER 0
+#		define __LITTLE_ENDIAN 1
+#		define __BIG_ENDIAN 0
+#	else
+#		error "__BYTE_ORDER is not defined."
+#	endif
+#endif
+
+#define __ntfs_bswap_constant_16(x)		\
+	  (u16)((((u16)(x) & 0xff00) >> 8) |	\
+		(((u16)(x) & 0x00ff) << 8))
+
+#define __ntfs_bswap_constant_32(x)			\
+	  (u32)((((u32)(x) & 0xff000000u) >> 24) |	\
+		(((u32)(x) & 0x00ff0000u) >>  8) |	\
+		(((u32)(x) & 0x0000ff00u) <<  8) |	\
+		(((u32)(x) & 0x000000ffu) << 24))
+
+#define __ntfs_bswap_constant_64(x)				\
+	  (u64)((((u64)(x) & 0xff00000000000000ull) >> 56) |	\
+		(((u64)(x) & 0x00ff000000000000ull) >> 40) |	\
+		(((u64)(x) & 0x0000ff0000000000ull) >> 24) |	\
+		(((u64)(x) & 0x000000ff00000000ull) >>  8) |	\
+		(((u64)(x) & 0x00000000ff000000ull) <<  8) |	\
+		(((u64)(x) & 0x0000000000ff0000ull) << 24) |	\
+		(((u64)(x) & 0x000000000000ff00ull) << 40) |	\
+		(((u64)(x) & 0x00000000000000ffull) << 56))
+
+#ifdef HAVE_BYTESWAP_H
+#	include <byteswap.h>
+#else
+#	define bswap_16(x) __ntfs_bswap_constant_16(x)
+#	define bswap_32(x) __ntfs_bswap_constant_32(x)
+#	define bswap_64(x) __ntfs_bswap_constant_64(x)
+#endif
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+#if defined(__LITTLE_ENDIAN) && (__BYTE_ORDER == __LITTLE_ENDIAN)
+
+#define __le16_to_cpu(x) ((__force u16)(x))
+#define __le32_to_cpu(x) ((__force u32)(x))
+#define __le64_to_cpu(x) ((__force u64)(x))
+
+#define __cpu_to_le16(x) ((__force le16)(x))
+#define __cpu_to_le32(x) ((__force le32)(x))
+#define __cpu_to_le64(x) ((__force le64)(x))
+
+#define __constant_le16_to_cpu(x) ((__force u16)(x))
+#define __constant_le32_to_cpu(x) ((__force u32)(x))
+#define __constant_le64_to_cpu(x) ((__force u64)(x))
+
+#define __constant_cpu_to_le16(x) ((__force le16)(x))
+#define __constant_cpu_to_le32(x) ((__force le32)(x))
+#define __constant_cpu_to_le64(x) ((__force le64)(x))
+
+#elif defined(__BIG_ENDIAN) && (__BYTE_ORDER == __BIG_ENDIAN)
+
+#define __le16_to_cpu(x) bswap_16((__force u16)(x))
+#define __le32_to_cpu(x) bswap_32((__force u16)(x))
+#define __le64_to_cpu(x) bswap_64((__force u16)(x))
+
+#define __cpu_to_le16(x) (__force le16)bswap_16((__force u16)(x))
+#define __cpu_to_le32(x) (__force le32)bswap_32((__force u32)(x))
+#define __cpu_to_le64(x) (__force le64)bswap_64((__force u64)(x))
+
+#define __constant_le16_to_cpu(x) __ntfs_bswap_constant_16((__force u16)(x))
+#define __constant_le32_to_cpu(x) __ntfs_bswap_constant_32((__force u32)(x))
+#define __constant_le64_to_cpu(x) __ntfs_bswap_constant_64((__force u64)(x))
+
+#define __constant_cpu_to_le16(x) \
+	(__force le16)__ntfs_bswap_constant_16((__force u16)(x))
+#define __constant_cpu_to_le32(x) \
+	(__force le32)__ntfs_bswap_constant_32((__force u32)(x))
+#define __constant_cpu_to_le64(x) \
+	(__force le64)__ntfs_bswap_constant_64((__force u64)(x))
+
+#else
+
+#error "You must define __BYTE_ORDER to be __LITTLE_ENDIAN or __BIG_ENDIAN."
+
+#endif
+
+/* Unsigned from LE to CPU conversion. */
+
+#define le16_to_cpu(x)		(u16)__le16_to_cpu((le16)(x))
+#define le32_to_cpu(x)		(u32)__le32_to_cpu((le32)(x))
+#define le64_to_cpu(x)		(u64)__le64_to_cpu((le64)(x))
+
+#define le16_to_cpup(x)		(u16)__le16_to_cpu(*(const le16*)(x))
+#define le32_to_cpup(x)		(u32)__le32_to_cpu(*(const le32*)(x))
+#define le64_to_cpup(x)		(u64)__le64_to_cpu(*(const le64*)(x))
+
+/* Signed from LE to CPU conversion. */
+
+#define sle16_to_cpu(x)		(s16)__le16_to_cpu((sle16)(x))
+#define sle32_to_cpu(x)		(s32)__le32_to_cpu((sle32)(x))
+#define sle64_to_cpu(x)		(s64)__le64_to_cpu((sle64)(x))
+
+#define sle16_to_cpup(x)	(s16)__le16_to_cpu(*(const sle16*)(x))
+#define sle32_to_cpup(x)	(s32)__le32_to_cpu(*(const sle32*)(x))
+#define sle64_to_cpup(x)	(s64)__le64_to_cpu(*(const sle64*)(x))
+
+/* Unsigned from CPU to LE conversion. */
+
+#define cpu_to_le16(x)		(le16)__cpu_to_le16((u16)(x))
+#define cpu_to_le32(x)		(le32)__cpu_to_le32((u32)(x))
+#define cpu_to_le64(x)		(le64)__cpu_to_le64((u64)(x))
+
+#define cpu_to_le16p(x)		(le16)__cpu_to_le16(*(const u16*)(x))
+#define cpu_to_le32p(x)		(le32)__cpu_to_le32(*(const u32*)(x))
+#define cpu_to_le64p(x)		(le64)__cpu_to_le64(*(const u64*)(x))
+
+/* Signed from CPU to LE conversion. */
+
+#define cpu_to_sle16(x)		(__force sle16)__cpu_to_le16((s16)(x))
+#define cpu_to_sle32(x)		(__force sle32)__cpu_to_le32((s32)(x))
+#define cpu_to_sle64(x)		(__force sle64)__cpu_to_le64((s64)(x))
+
+#define cpu_to_sle16p(x)	(__force sle16)__cpu_to_le16(*(const s16*)(x))
+#define cpu_to_sle32p(x)	(__force sle32)__cpu_to_le32(*(const s32*)(x))
+#define cpu_to_sle64p(x)	(__force sle64)__cpu_to_le64(*(const s64*)(x))
+
+/* Constant endianness conversion defines. */
+
+#define const_le16_to_cpu(x)	(u16)__constant_le16_to_cpu((le16)(x))
+#define const_le32_to_cpu(x)	(u32)__constant_le32_to_cpu((le32)(x))
+#define const_le64_to_cpu(x)	(u64)__constant_le64_to_cpu((le64)(x))
+
+#define const_cpu_to_le16(x)	(le16)__constant_cpu_to_le16((u16)(x))
+#define const_cpu_to_le32(x)	(le32)__constant_cpu_to_le32((u32)(x))
+#define const_cpu_to_le64(x)	(le64)__constant_cpu_to_le64((u64)(x))
+
+#ifdef __CHECKER__
+static void ntfs_endian_self_test(void)
+{
+	/* Should not generate warnings. */
+	(le16)cpu_to_le16((u16)1);
+	(le32)cpu_to_le32((u32)1);
+	(le64)cpu_to_le64((u64)1);
+	(sle16)cpu_to_sle16((s16)1);
+	(sle32)cpu_to_sle32((s32)1);
+	(sle64)cpu_to_sle64((s64)1);
+	(u16)le16_to_cpu((__force le16)1);
+	(u32)le32_to_cpu((__force le32)1);
+	(u64)le64_to_cpu((__force le64)1);
+	(s16)sle16_to_cpu((__force sle16)1);
+	(s32)sle32_to_cpu((__force sle32)1);
+	(s64)sle64_to_cpu((__force sle64)1);
+	(le16)const_cpu_to_le16((u16)1);
+	(le32)const_cpu_to_le32((u32)1);
+	(le64)const_cpu_to_le64((u64)1);
+	(u16)const_le16_to_cpu((__force le16)1);
+	(u32)const_le32_to_cpu((__force le32)1);
+	(u64)const_le64_to_cpu((__force le64)1);
+
+	/*
+	 * TODO: Need some how to test that warnings are actually generated,
+	 * but without flooding output with them and vice-versa print warning
+	 * in case if some one warning is not triggered, but should.  (Yura)
+	 *
+	 * I think it can only be done in  a ./configure like script / shell
+	 * script that will compile known good  and known bad code and pipe the
+	 * output from sparse to a file, then  grep the file for the wanted
+	 * warnings/lack thereof and then it would  say "Tests: PASS " or
+	 * "Tests: FAILED" or whatever.  And you can then  hook that into a
+	 * "make test" make target or similar so it is only  done when one
+	 * wants to do it...  (Anton)
+	 *
+	 * Also we can look on sparse self test script.  (Yura)
+	 */
+}
+#endif
+
+__END_DECLS
+
+#endif /* defined _NTFS_ENDIANS_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_gnome-vfs-method.h ./include/ntfs/ntfs_gnome-vfs-method.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_gnome-vfs-method.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_gnome-vfs-method.h	2007-10-06 16:56:53.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * gnome-vfs-method.h - Export for Gnome-VFS init/shutdown implementation of
+ *			interface to libntfs. Par of the Linux-NTFS project.
+ *
+ * Copyright (c) 2002-2003 Jan Kratochvil <project-captive@jankratochvil.net>
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_GNOME_VFS_METHOD_H
+#define _NTFS_GNOME_VFS_METHOD_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <libgnomevfs/gnome-vfs-method.h>
+#include "ntfs_types.h"
+
+#ifndef G_BEGIN_DECLS
+#define G_BEGIN_DECLS __BEGIN_DECLS
+#endif
+
+#ifndef G_END_DECLS
+#define G_END_DECLS __END_DECLS
+#endif
+
+G_BEGIN_DECLS
+
+GnomeVFSMethod *libntfs_gnomevfs_method_init(const gchar *method_name,
+		const gchar *args);
+
+void libntfs_gnomevfs_method_shutdown(void);
+
+G_END_DECLS
+
+#endif /* _NTFS_GNOME_VFS_METHOD_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_gnome-vfs-module.h ./include/ntfs/ntfs_gnome-vfs-module.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_gnome-vfs-module.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_gnome-vfs-module.h	2007-10-06 16:57:08.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * gnome-vfs-module.h - Exports for Gnome-VFS init/shutdown implementation of
+ *			interface to libntfs. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2003 Jan Kratochvil <project-captive@jankratochvil.net>
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_GNOME_VFS_MODULE_H
+#define _NTFS_GNOME_VFS_MODULE_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "ntfs_types.h"
+
+#ifndef G_BEGIN_DECLS
+#define G_BEGIN_DECLS __BEGIN_DECLS
+#endif
+
+#ifndef G_END_DECLS
+#define G_END_DECLS __END_DECLS
+#endif
+
+G_BEGIN_DECLS
+
+G_LOCK_EXTERN(libntfs);
+
+#define libntfs_newn(objp, n)	((objp) = (typeof(objp))g_new(typeof(*(objp)), (n)))
+#define libntfs_new(objp)	(libntfs_newn((objp), 1))
+#define LIBNTFS_MEMZERO(objp)	(memset((objp), 0, sizeof(*(objp))))
+
+G_END_DECLS
+
+#endif /* _NTFS_GNOME_VFS_MODULE_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_index.h ./include/ntfs/ntfs_index.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_index.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_index.h	2007-10-06 16:57:22.000000000 +0200
@@ -0,0 +1,135 @@
+/*
+ * index.h - Defines for NTFS index handling.  Part of the Linux-NTFS project.
+ *
+ * Copyright (c)      2004 Anton Altaparmakov
+ * Copyright (c) 2004-2005 Richard Russon
+ * Copyright (c) 2005-2006 Yura Pakhuchiy
+ * Copyright (c)      2006 Szabolcs Szakacsits
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_INDEX_H
+#define _NTFS_INDEX_H 1
+
+#include "ntfs_attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_inode.h"
+#include "ntfs_mft.h"
+
+#define  NTFS_VCN_INDEX_ROOT_PARENT  ((NTFS_VCN)-2)
+
+#define  NTFS_MAX_PARENT_VCN		32
+
+__BEGIN_DECLS
+
+/**
+ * struct ntfs_index_context -
+ * @ni:			inode containing the @entry described by this context
+ * @name:		name of the index described by this context
+ * @name_len:		length of the index name
+ * @entry:		index entry (points into @ir or @ib)
+ * @data:		index entry data (points into @entry)
+ * @data_len:		length in bytes of @data
+ * @cr:
+ * @is_in_root:		TRUE if @entry is in @ir or FALSE if it is in @ib
+ * @ir:			index root if @is_in_root or NULL otherwise
+ * @actx:		attribute search context if in root or NULL otherwise
+ * @ia_na:		opened NTFS_INDEX_ALLOCATION attribute
+ * @ib:			index block if @is_in_root is FALSE or NULL otherwise
+ * @ib_vcn:		NTFS_VCN from which @ib where read from
+ * @ib_dirty:		TRUE if index block was changed
+ * @parent_pos:		parent entries' positions in the index block
+ * @parent_vcn:		entry's parent nodes or NTFS_VCN_INDEX_ROOT_PARENT for root
+ * @max_depth:		number of the parent nodes
+ * @pindex:		maximum it's the number of the parent nodes
+ * @block_size:		index block size
+ * @vcn_size_bits:	NTFS_VCN size bits for this index block
+ *
+ * @ni is the inode this context belongs to.
+ *
+ * @entry is the index entry described by this context.  @data and @data_len
+ * are the index entry data and its length in bytes, respectively.  @data
+ * simply points into @entry.  This is probably what the user is interested in.
+ *
+ * If @is_in_root is TRUE, @entry is in the index root attribute @ir described
+ * by the attribute search context @actx and inode @ni.  @ib, @ib_vcn and
+ * @ib_dirty are undefined in this case.
+ *
+ * If @is_in_root is FALSE, @entry is in the index allocation attribute and @ib
+ * and @ib_vcn point to the index allocation block and NTFS_VCN where it's placed,
+ * respectively. @ir and @actx are NULL in this case. @ia_na is opened
+ * NTFS_INDEX_ALLOCATION attribute. @ib_dirty is TRUE if index block was changed and
+ * FALSE otherwise.
+ *
+ * To obtain a context call ntfs_index_ctx_get().
+ *
+ * When finished with the @entry and its @data, call ntfs_index_ctx_put() to
+ * free the context and other associated resources.
+ *
+ * If the index entry was modified, call ntfs_index_entry_mark_dirty() before
+ * the call to ntfs_index_ctx_put() to ensure that the changes are written
+ * to disk.
+ */
+typedef struct {
+	ntfs_inode *ni;
+	ntfschar *name;
+	u32 name_len;
+	NTFS_INDEX_ENTRY *entry;
+	void *data;
+	u16 data_len;
+	NTFS_COLLATION_RULES cr;
+	NTFS_BOOL is_in_root;
+	NTFS_INDEX_ROOT *ir;
+	ntfs_attr_search_ctx *actx;
+	ntfs_attr *ia_na;
+	NTFS_INDEX_BLOCK *ib;
+	NTFS_VCN ib_vcn;
+	NTFS_BOOL ib_dirty;
+	int parent_pos[NTFS_MAX_PARENT_VCN];
+	NTFS_VCN parent_vcn[NTFS_MAX_PARENT_VCN];
+	int max_depth;
+	int pindex;
+	u32 block_size;
+	u8 vcn_size_bits;
+} ntfs_index_context;
+
+extern ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *ni,
+						ntfschar *name, u32 name_len);
+extern void ntfs_index_ctx_put(ntfs_index_context *ictx);
+extern void ntfs_index_ctx_reinit(ntfs_index_context *ictx);
+
+extern int ntfs_index_lookup(const void *key, const int key_len,
+		ntfs_index_context *ictx);
+
+extern int ntfs_index_add_filename(ntfs_inode *ni, NTFS_FILE_NAME_ATTR *fn,
+		NTFS_MFT_REF mref);
+extern int ntfs_index_rm(ntfs_index_context *ictx);
+
+extern NTFS_INDEX_ROOT *ntfs_index_root_get(ntfs_inode *ni, NTFS_ATTR_RECORD *attr);
+
+extern NTFS_VCN ntfs_ie_get_vcn(NTFS_INDEX_ENTRY *ie);
+
+extern char *ntfs_ie_filename_get(NTFS_INDEX_ENTRY *ie);
+extern void ntfs_ie_filename_dump(NTFS_INDEX_ENTRY *ie);
+extern void ntfs_ih_filename_dump(NTFS_INDEX_HEADER *ih);
+
+extern void ntfs_index_entry_mark_dirty(ntfs_index_context *ictx);
+
+__END_DECLS
+
+#endif /* _NTFS_INDEX_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_inode.h ./include/ntfs/ntfs_inode.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_inode.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_inode.h	2007-10-06 16:57:36.000000000 +0200
@@ -0,0 +1,219 @@
+/*
+ * inode.h - Defines for NTFS inode handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2001,2002 Anton Altaparmakov
+ * Copyright (c) 2004-2007 Yura Pakhuchiy
+ * Copyright (c) 2004-2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_INODE_H
+#define _NTFS_INODE_H 1
+
+/* Forward declaration */
+typedef struct _ntfs_inode ntfs_inode;
+
+#include "ntfs_list.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_support.h"
+#include "ntfs_volume.h"
+
+__BEGIN_DECLS
+
+/**
+ * enum ntfs_inode_state_bits -
+ *
+ * Defined bits for the state field in the ntfs_inode structure.
+ * (f) = files only, (d) = directories only
+ */
+typedef enum {
+	NI_Dirty,		/* 1: Mft record needs to be written to disk. */
+
+	/* Below fields only make sense for base inodes. */
+	NI_AttrList,		/* 1: Mft record contains an attribute list. */
+	NI_AttrListDirty,	/* 1: Attribute list needs to be written to the
+				      mft record and then to disk. */
+	NI_FileNameDirty,	/* 1: FILE_NAME attributes need to be updated
+				      in the index. */
+} ntfs_inode_state_bits;
+
+#define  test_nino_flag(ni, flag)	   test_bit(NI_##flag, (ni)->state)
+#define   set_nino_flag(ni, flag)	    set_bit(NI_##flag, (ni)->state)
+#define clear_nino_flag(ni, flag)	  clear_bit(NI_##flag, (ni)->state)
+
+#define test_and_set_nino_flag(ni, flag)	\
+				   test_and_set_bit(NI_##flag, (ni)->state)
+#define test_and_clear_nino_flag(ni, flag)	\
+				 test_and_clear_bit(NI_##flag, (ni)->state)
+
+#define NInoDirty(ni)				  test_nino_flag(ni, Dirty)
+#define NInoSetDirty(ni)			   set_nino_flag(ni, Dirty)
+#define NInoClearDirty(ni)			 clear_nino_flag(ni, Dirty)
+#define NInoTestAndSetDirty(ni)		  test_and_set_nino_flag(ni, Dirty)
+#define NInoTestAndClearDirty(ni)	test_and_clear_nino_flag(ni, Dirty)
+
+#define NInoAttrList(ni)			  test_nino_flag(ni, AttrList)
+#define NInoSetAttrList(ni)			   set_nino_flag(ni, AttrList)
+#define NInoClearAttrList(ni)			 clear_nino_flag(ni, AttrList)
+
+
+#define  test_nino_al_flag(ni, flag)	 test_nino_flag(ni, AttrList##flag)
+#define   set_nino_al_flag(ni, flag)	  set_nino_flag(ni, AttrList##flag)
+#define clear_nino_al_flag(ni, flag)	clear_nino_flag(ni, AttrList##flag)
+
+#define test_and_set_nino_al_flag(ni, flag)	\
+				 test_and_set_nino_flag(ni, AttrList##flag)
+#define test_and_clear_nino_al_flag(ni, flag)	\
+			       test_and_clear_nino_flag(ni, AttrList##flag)
+
+#define NInoAttrListDirty(ni)			    test_nino_al_flag(ni, Dirty)
+#define NInoAttrListSetDirty(ni)		     set_nino_al_flag(ni, Dirty)
+#define NInoAttrListClearDirty(ni)		   clear_nino_al_flag(ni, Dirty)
+#define NInoAttrListTestAndSetDirty(ni)	    test_and_set_nino_al_flag(ni, Dirty)
+#define NInoAttrListTestAndClearDirty(ni) test_and_clear_nino_al_flag(ni, Dirty)
+
+#define NInoFileNameDirty(ni)			\
+					  test_nino_flag(ni, FileNameDirty)
+#define NInoFileNameSetDirty(ni)		\
+					   set_nino_flag(ni, FileNameDirty)
+#define NInoFileNameClearDirty(ni)		\
+					 clear_nino_flag(ni, FileNameDirty)
+#define NInoFileNameTestAndSetDirty(ni)		\
+				  test_and_set_nino_flag(ni, FileNameDirty)
+#define NInoFileNameTestAndClearDirty(ni)	\
+				test_and_clear_nino_flag(ni, FileNameDirty)
+
+/**
+ * struct _ntfs_inode - The NTFS in-memory inode structure.
+ *
+ * It is just used as an extension to the fields already provided in the VFS
+ * inode.
+ */
+struct _ntfs_inode {
+	u64 mft_no;		/* Inode / mft record number. */
+	NTFS_MFT_RECORD *mrec;	/* The actual mft record of the inode. */
+	ntfs_volume *vol;	/* Pointer to the ntfs volume of this inode. */
+	unsigned long state;	/* NTFS specific flags describing this inode.
+				   See ntfs_inode_state_bits above. */
+	NTFS_FILE_ATTR_FLAGS flags;	/* Flags describing the file.
+				   (Copy from NTFS_STANDARD_INFORMATION) */
+	/*
+	 * Attribute list support (for use by the attribute lookup functions).
+	 * Setup during ntfs_open_inode() for all inodes with attribute lists.
+	 * Only valid if NI_AttrList is set in state.
+	 */
+	u32 attr_list_size;	/* Length of attribute list value in bytes. */
+	u8 *attr_list;		/* Attribute list value itself. */
+	/* Below fields are always valid. */
+	s32 nr_extents;		/* For a base mft record, the number of
+				   attached extent inodes (0 if none), for
+				   extent records this is -1. */
+	union {		/* This union is only used if nr_extents != 0. */
+		ntfs_inode **extent_nis;/* For nr_extents > 0, array of the
+					   ntfs inodes of the extent mft
+					   records belonging to this base
+					   inode which have been loaded. */
+		ntfs_inode *base_ni;	/* For nr_extents == -1, the ntfs
+					   inode of the base mft record. */
+	};
+
+	/* Below fields are valid only for base inode. */
+
+	/*
+	 * These two fields are used to sync filename index and guaranteed to be
+	 * correct, however value in index itself maybe wrong (windows itself
+	 * do not update them properly).
+	 */
+	s64 data_size;		/* Data size of unnamed DATA attribute. */
+	s64 allocated_size;	/* Allocated size stored in the filename
+				   index. (NOTE: Equal to allocated size of
+				   the unnamed data attribute for normal or
+				   encrypted files and to compressed size
+				   of the unnamed data attribute for sparse or
+				   compressed files.) */
+
+	/*
+	 * These four fields are copy of relevant fields from
+	 * NTFS_STANDARD_INFORMATION attribute and used to sync it and FILE_NAME
+	 * attribute in the index.
+	 */
+	time_t creation_time;
+	time_t last_data_change_time;
+	time_t last_mft_change_time;
+	time_t last_access_time;
+
+	/* These 2 fields are used to keep track of opened inodes. */
+	struct ntfs_list_head ntfs_list_entry;	/* Keep pointers to the next/prev list
+					   entry. */
+	int nr_references;		/* How many times this inode was
+					   opened.  We really close inode only
+					   when this reaches zero. */
+
+	struct ntfs_list_head attr_cache;	/* List of opened attributes. */
+};
+
+extern void __ntfs_inode_add_to_cache(ntfs_inode *ni);
+
+extern ntfs_inode *ntfs_inode_allocate(ntfs_volume *vol);
+
+extern ntfs_inode *ntfs_inode_open(ntfs_volume *vol, const NTFS_MFT_REF mref);
+
+extern int ntfs_inode_close(ntfs_inode *ni);
+
+extern ntfs_inode *ntfs_extent_inode_open(ntfs_inode *base_ni,
+		const NTFS_leMFT_REF mref);
+
+extern int ntfs_inode_attach_all_extents(ntfs_inode *ni);
+
+/**
+ * ntfs_inode_mark_dirty - set the inode (and its base inode if it exists) dirty
+ * @ni:		ntfs inode to set dirty
+ *
+ * Set the inode @ni dirty so it is written out later (at the latest at
+ * ntfs_inode_close() time). If @ni is an extent inode, set the base inode
+ * dirty, too.
+ *
+ * This function cannot fail.
+ */
+static __inline__ void ntfs_inode_mark_dirty(ntfs_inode *ni)
+{
+	NInoSetDirty(ni);
+	if (ni->nr_extents == -1)
+		NInoSetDirty(ni->base_ni);
+}
+
+typedef enum {
+	NTFS_UPDATE_ATIME = 1 << 0,
+	NTFS_UPDATE_MTIME = 1 << 1,
+	NTFS_UPDATE_CTIME = 1 << 2,
+} ntfs_time_update_flags;
+
+extern void ntfs_inode_update_times(ntfs_inode *ni,
+		ntfs_time_update_flags mask);
+
+extern int ntfs_inode_sync(ntfs_inode *ni);
+
+extern int ntfs_inode_add_attrlist(ntfs_inode *ni);
+
+extern int ntfs_inode_free_space(ntfs_inode *ni, int size);
+
+extern int ntfs_inode_badclus_bad(u64 mft_no, NTFS_ATTR_RECORD *a);
+
+__END_DECLS
+
+#endif /* defined _NTFS_INODE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_layout.h ./include/ntfs/ntfs_layout.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_layout.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_layout.h	2007-10-06 16:57:49.000000000 +0200
@@ -0,0 +1,2687 @@
+/*
+ * layout.h - Ntfs on-disk layout structures.  Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2005 Anton Altaparmakov
+ * Copyright (c) 2005-2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_LAYOUT_H
+#define _NTFS_LAYOUT_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_endians.h"
+#include "ntfs_support.h"
+
+__BEGIN_DECLS
+
+/* The NTFS oem_id "NTFS    " */
+#define NTFS_SB_MAGIC	const_cpu_to_le64(0x202020205346544eULL)
+
+/*
+ * Location of boot sector on partition:
+ *	The standard NTFS_BOOT_SECTOR is on sector 0 of the partition.
+ *	On NT4 and above there is one backup copy of the boot sector to
+ *	be found on the last sector of the partition (not normally accessible
+ *	from within Windows as the boot sector contained number of sectors
+ *	value is one less than the actual value!).
+ *	On versions of NT 3.51 and earlier, the backup copy was located at
+ *	number of sectors/2 (integer divide), i.e. in the middle of the volume.
+ */
+
+/**
+ * struct NTFS_BIOS_PARAMETER_BLOCK - BIOS parameter block (BPB) structure.
+ */
+typedef struct {
+	le16 bytes_per_sector;		/* Size of a sector in bytes. */
+	u8  sectors_per_cluster;	/* Size of a cluster in sectors. */
+	le16 reserved_sectors;		/* zero */
+	u8  fats;			/* zero */
+	le16 root_entries;		/* zero */
+	le16 sectors;			/* zero */
+	u8  media_type;			/* 0xf8 = hard disk */
+	le16 sectors_per_fat;		/* zero */
+/*0x0d*/le16 sectors_per_track;		/* Required to boot Windows. */
+/*0x0f*/le16 heads;			/* Required to boot Windows. */
+/*0x11*/le32 hidden_sectors;		/* Offset to the start of the partition
+					   relative to the disk in sectors.
+					   Required to boot Windows. */
+/*0x15*/le32 large_sectors;		/* zero */
+/* sizeof() = 25 (0x19) bytes */
+} __attribute__((__packed__)) NTFS_BIOS_PARAMETER_BLOCK;
+
+/**
+ * struct NTFS_BOOT_SECTOR - NTFS boot sector structure.
+ */
+typedef struct {
+	u8  jump[3];			/* Irrelevant (jump to boot up code).*/
+	le64 oem_id;			/* Magic "NTFS    ". */
+/*0x0b*/NTFS_BIOS_PARAMETER_BLOCK bpb;	/* See NTFS_BIOS_PARAMETER_BLOCK. */
+	u8 physical_drive;		/* 0x00 floppy, 0x80 hard disk */
+	u8 current_head;		/* zero */
+	u8 extended_boot_signature; 	/* 0x80 */
+	u8 reserved2;			/* zero */
+/*0x28*/sle64 number_of_sectors;	/* Number of sectors in volume. Gives
+					   maximum volume size of 2^63 sectors.
+					   Assuming standard sector size of 512
+					   bytes, the maximum byte size is
+					   approx. 4.7x10^21 bytes. (-; */
+	sle64 mft_lcn;			/* Cluster location of mft data. */
+	sle64 mftmirr_lcn;		/* Cluster location of copy of mft. */
+	s8  clusters_per_mft_record;	/* Mft record size in clusters. */
+	u8  reserved0[3];		/* zero */
+	s8  clusters_per_index_record;	/* Index block size in clusters. */
+	u8  reserved1[3];		/* zero */
+	le64 volume_serial_number;	/* Irrelevant (serial number). */
+	le32 checksum;			/* Boot sector checksum. */
+/*0x54*/u8  bootstrap[426];		/* Irrelevant (boot up code). */
+	le16 end_of_sector_marker;	/* End of boot sector magic. Always is
+					   0xaa55 in little endian. */
+/* sizeof() = 512 (0x200) bytes */
+} __attribute__((__packed__)) NTFS_BOOT_SECTOR;
+
+/**
+ * enum NTFS_RECORD_TYPES -
+ *
+ * Magic identifiers present at the beginning of all ntfs record containing
+ * records (like mft records for example).
+ */
+typedef enum {
+	/* Found in $MFT/$DATA. */
+	magic_FILE = const_cpu_to_le32(0x454c4946), /* Mft entry. */
+	magic_INDX = const_cpu_to_le32(0x58444e49), /* Index buffer. */
+	magic_HOLE = const_cpu_to_le32(0x454c4f48), /* ? (NTFS 3.0+?) */
+
+	/* Found in $LogFile/$DATA. */
+	magic_RSTR = const_cpu_to_le32(0x52545352), /* Restart page. */
+	magic_RCRD = const_cpu_to_le32(0x44524352), /* Log record page. */
+
+	/* Found in $LogFile/$DATA.  (May be found in $MFT/$DATA, also?) */
+	magic_CHKD = const_cpu_to_le32(0x444b4843), /* Modified by chkdsk. */
+
+	/* Found in all ntfs record containing records. */
+	magic_BAAD = const_cpu_to_le32(0x44414142), /* Failed multi sector
+						       transfer was detected. */
+
+	/*
+	 * Found in $LogFile/$DATA when a page is full or 0xff bytes and is
+	 * thus not initialized.  User has to initialize the page before using
+	 * it.
+	 */
+	magic_empty = const_cpu_to_le32(0xffffffff),/* Record is empty and has
+						       to be initialized before
+						       it can be used. */
+} NTFS_RECORD_TYPES;
+
+/*
+ * Generic magic comparison macros. Finally found a use for the ## preprocessor
+ * operator! (-8
+ */
+
+static inline NTFS_BOOL __ntfs_is_magic(le32 x, NTFS_RECORD_TYPES r)
+{
+	return (x == (__force le32)r);
+}
+#define ntfs_is_magic(x, m)   __ntfs_is_magic(x, magic_##m)
+
+static inline NTFS_BOOL __ntfs_is_magicp(le32 *p, NTFS_RECORD_TYPES r)
+{
+	return (*p == (__force le32)r);
+}
+#define ntfs_is_magicp(p, m)  __ntfs_is_magicp(p, magic_##m)
+
+/*
+ * Specialised magic comparison macros for the NTFS_RECORD_TYPES defined above.
+ */
+#define ntfs_is_file_record(x)	( ntfs_is_magic (x, FILE) )
+#define ntfs_is_file_recordp(p)	( ntfs_is_magicp(p, FILE) )
+#define ntfs_is_mft_record(x)	( ntfs_is_file_record(x) )
+#define ntfs_is_mft_recordp(p)	( ntfs_is_file_recordp(p) )
+#define ntfs_is_indx_record(x)	( ntfs_is_magic (x, INDX) )
+#define ntfs_is_indx_recordp(p)	( ntfs_is_magicp(p, INDX) )
+#define ntfs_is_hole_record(x)	( ntfs_is_magic (x, HOLE) )
+#define ntfs_is_hole_recordp(p)	( ntfs_is_magicp(p, HOLE) )
+
+#define ntfs_is_rstr_record(x)	( ntfs_is_magic (x, RSTR) )
+#define ntfs_is_rstr_recordp(p)	( ntfs_is_magicp(p, RSTR) )
+#define ntfs_is_rcrd_record(x)	( ntfs_is_magic (x, RCRD) )
+#define ntfs_is_rcrd_recordp(p)	( ntfs_is_magicp(p, RCRD) )
+
+#define ntfs_is_chkd_record(x)	( ntfs_is_magic (x, CHKD) )
+#define ntfs_is_chkd_recordp(p)	( ntfs_is_magicp(p, CHKD) )
+
+#define ntfs_is_baad_record(x)	( ntfs_is_magic (x, BAAD) )
+#define ntfs_is_baad_recordp(p)	( ntfs_is_magicp(p, BAAD) )
+
+#define ntfs_is_empty_record(x)		( ntfs_is_magic (x, empty) )
+#define ntfs_is_empty_recordp(p)	( ntfs_is_magicp(p, empty) )
+
+
+#define NTFS_BLOCK_SIZE		512
+#define NTFS_BLOCK_SIZE_BITS	9
+
+/**
+ * struct NTFS_RECORD -
+ *
+ * The Update Sequence Array (USA) is an array of the le16 values which belong
+ * to the end of each sector protected by the update sequence record in which
+ * this array is contained. Note that the first entry is the Update Sequence
+ * Number (USN), a cyclic counter of how many times the protected record has
+ * been written to disk. The values 0 and -1 (ie. 0xffff) are not used. All
+ * last le16's of each sector have to be equal to the USN (during reading) or
+ * are set to it (during writing). If they are not, an incomplete multi sector
+ * transfer has occurred when the data was written.
+ * The maximum size for the update sequence array is fixed to:
+ *	maximum size = usa_ofs + (usa_count * 2) = 510 bytes
+ * The 510 bytes comes from the fact that the last le16 in the array has to
+ * (obviously) finish before the last le16 of the first 512-byte sector.
+ * This formula can be used as a consistency check in that usa_ofs +
+ * (usa_count * 2) has to be less than or equal to 510.
+ */
+typedef struct {
+	NTFS_RECORD_TYPES magic;/* A four-byte magic identifying the
+				   record type and/or status. */
+	le16 usa_ofs;		/* Offset to the Update Sequence Array (USA)
+				   from the start of the ntfs record. */
+	le16 usa_count;		/* Number of u16 sized entries in the USA
+				   including the Update Sequence Number (USN),
+				   thus the number of fixups is the usa_count
+				   minus 1. */
+} __attribute__((__packed__)) NTFS_RECORD;
+
+/**
+ * enum NTFS_SYSTEM_FILES - System files mft record numbers.
+ *
+ * All these files are always marked as used in the bitmap attribute of the
+ * mft; presumably in order to avoid accidental allocation for random other
+ * mft records. Also, the sequence number for each of the system files is
+ * always equal to their mft record number and it is never modified.
+ */
+typedef enum {
+	NTFS_FILE_MFT	= 0,	/* Master file table (mft). Data attribute
+				   contains the entries and bitmap attribute
+				   records which ones are in use (bit==1). */
+	NTFS_FILE_MFTMirr	= 1,	/* Mft mirror: copy of first four mft records
+				   in data attribute. If cluster size > 4kiB,
+				   copy of first N mft records, with
+					N = cluster_size / mft_record_size. */
+	NTFS_FILE_LogFile	= 2,	/* Journalling log in data attribute. */
+	NTFS_FILE_Volume	= 3,	/* Volume name attribute and volume information
+				   attribute (flags and ntfs version). Windows
+				   refers to this file as volume DASD (Direct
+				   Access Storage Device). */
+	NTFS_FILE_AttrDef	= 4,	/* Array of attribute definitions in data
+				   attribute. */
+	NTFS_FILE_root	= 5,	/* Root directory. */
+	NTFS_FILE_Bitmap	= 6,	/* Allocation bitmap of all clusters (LCNs) in
+				   data attribute. */
+	NTFS_FILE_Boot	= 7,	/* Boot sector (always at cluster 0) in data
+				   attribute. */
+	NTFS_FILE_BadClus	= 8,	/* Contains all bad clusters in the non-resident
+				   data attribute. */
+	NTFS_FILE_Secure	= 9,	/* Shared security descriptors in data attribute
+				   and two indexes into the descriptors.
+				   Appeared in Windows 2000. Before that, this
+				   file was named $Quota but was unused. */
+	NTFS_FILE_UpCase	= 10,	/* Uppercase equivalents of all 65536 Unicode
+				   characters in data attribute. */
+	NTFS_FILE_Extend	= 11,	/* Directory containing other system files (eg.
+				   $ObjId, $Quota, $Reparse and $UsnJrnl). This
+				   is new to NTFS 3.0. */
+	FILE_reserved12	= 12,	/* Reserved for future use (records 12-15). */
+	FILE_reserved13	= 13,
+	FILE_reserved14	= 14,
+	FILE_reserved15	= 15,
+	NTFS_FILE_first_user	= 16,	/* First user file, used as test limit for
+				   whether to allow opening a file or not. */
+} NTFS_SYSTEM_FILES;
+
+/**
+ * enum NTFS_MFT_RECORD_FLAGS -
+ *
+ * These are the so far known MFT_RECORD_* flags (16-bit) which contain
+ * information about the mft record in which they are present.
+ *
+ * NTFS_MFT_RECORD_IS_4 exists on all $Extend sub-files.
+ * It seems that it marks it is a metadata file with MFT record >24, however,
+ * it is unknown if it is limited to metadata files only.
+ *
+ * NTFS_MFT_RECORD_IS_VIEW_INDEX exists on every metafile with a non directory
+ * index, that means an NTFS_INDEX_ROOT and an NTFS_INDEX_ALLOCATION with a name other
+ * than "$I30". It is unknown if it is limited to metadata files only.
+ */
+typedef enum {
+	NTFS_MFT_RECORD_IN_USE		= const_cpu_to_le16(0x0001),
+	NTFS_MFT_RECORD_IS_DIRECTORY		= const_cpu_to_le16(0x0002),
+	NTFS_MFT_RECORD_IS_4			= const_cpu_to_le16(0x0004),
+	NTFS_MFT_RECORD_IS_VIEW_INDEX	= const_cpu_to_le16(0x0008),
+	NTFS_MFT_REC_SPACE_FILLER		= const_cpu_to_le16(0xffff),
+					/* Just to make flags 16-bit. */
+} __attribute__((__packed__)) NTFS_MFT_RECORD_FLAGS;
+
+/*
+ * mft references (aka file references or file record segment references) are
+ * used whenever a structure needs to refer to a record in the mft.
+ *
+ * A reference consists of a 48-bit index into the mft and a 16-bit sequence
+ * number used to detect stale references.
+ *
+ * For error reporting purposes we treat the 48-bit index as a signed quantity.
+ *
+ * The sequence number is a circular counter (skipping 0) describing how many
+ * times the referenced mft record has been (re)used. This has to match the
+ * sequence number of the mft record being referenced, otherwise the reference
+ * is considered stale and removed (FIXME: only ntfsck or the driver itself?).
+ *
+ * If the sequence number is zero it is assumed that no sequence number
+ * consistency checking should be performed.
+ *
+ * FIXME: Since inodes are 32-bit as of now, the driver needs to always check
+ * for high_part being 0 and if not either BUG(), cause a panic() or handle
+ * the situation in some other way. This shouldn't be a problem as a volume has
+ * to become HUGE in order to need more than 32-bits worth of mft records.
+ * Assuming the standard mft record size of 1kb only the records (never mind
+ * the non-resident attributes, etc.) would require 4Tb of space on their own
+ * for the first 32 bits worth of records. This is only if some strange person
+ * doesn't decide to foul play and make the mft sparse which would be a really
+ * horrible thing to do as it would trash our current driver implementation. )-:
+ * Do I hear screams "we want 64-bit inodes!" ?!? (-;
+ *
+ * FIXME: The mft zone is defined as the first 12% of the volume. This space is
+ * reserved so that the mft can grow contiguously and hence doesn't become
+ * fragmented. Volume free space includes the empty part of the mft zone and
+ * when the volume's free 88% are used up, the mft zone is shrunk by a factor
+ * of 2, thus making more space available for more files/data. This process is
+ * repeated every time there is no more free space except for the mft zone until
+ * there really is no more free space.
+ */
+
+/*
+ * Typedef the NTFS_MFT_REF as a 64-bit value for easier handling.
+ * Also define two unpacking macros to get to the reference (NTFS_MREF) and
+ * sequence number (NTFS_MSEQNO) respectively.
+ * The _LE versions are to be applied on little endian MFT_REFs.
+ * Note: The _LE versions will return a CPU endian formatted value!
+ */
+#define NTFS_MFT_REF_MASK_CPU 0x0000ffffffffffffULL
+#define NTFS_MFT_REF_MASK_LE const_cpu_to_le64(NTFS_MFT_REF_MASK_CPU)
+
+typedef u64 NTFS_MFT_REF;
+typedef le64 NTFS_leMFT_REF;
+
+#define NTFS_MK_MREF(m, s)	((NTFS_MFT_REF)(((NTFS_MFT_REF)(s) << 48) |		\
+					((NTFS_MFT_REF)(m) & NTFS_MFT_REF_MASK_CPU)))
+#define NTFS_MK_LE_MREF(m, s) const_cpu_to_le64(((NTFS_MFT_REF)(((NTFS_MFT_REF)(s) << 48) | \
+					((NTFS_MFT_REF)(m) & NTFS_MFT_REF_MASK_CPU))))
+
+#define NTFS_MREF(x)		((u64)((x) & NTFS_MFT_REF_MASK_CPU))
+#define NTFS_MSEQNO(x)	((u16)(((x) >> 48) & 0xffff))
+#define NTFS_MREF_LE(x)	((u64)(const_le64_to_cpu(x) & NTFS_MFT_REF_MASK_CPU))
+#define NTFS_MSEQNO_LE(x)	((u16)((const_le64_to_cpu(x) >> 48) & 0xffff))
+
+#define NTFS_IS_ERR_MREF(x)	(((x) & 0x0000800000000000ULL) ? 1 : 0)
+#define NTFS_ERR_MREF(x)	((u64)((s64)(x)))
+#define NTFS_MREF_ERR(x)	((int)((s64)(x)))
+
+/**
+ * struct NTFS_MFT_RECORD - An MFT record layout (NTFS 3.1+)
+ *
+ * The mft record header present at the beginning of every record in the mft.
+ * This is followed by a sequence of variable length attribute records which
+ * is terminated by an attribute of type NTFS_AT_END which is a truncated attribute
+ * in that it only consists of the attribute type code NTFS_AT_END and none of the
+ * other members of the attribute structure are present.
+ */
+typedef struct {
+/*Ofs*/
+/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_RECORD_TYPES magic;/* Usually the magic is "FILE". */
+	le16 usa_ofs;		/* See NTFS_RECORD definition above. */
+	le16 usa_count;		/* See NTFS_RECORD definition above. */
+
+/*  8*/	NTFS_leLSN lsn;		/* $LogFile sequence number for this record.
+				   Changed every time the record is modified. */
+/* 16*/	le16 sequence_number;	/* Number of times this mft record has been
+				   reused. (See description for NTFS_MFT_REF
+				   above.) NOTE: The increment (skipping zero)
+				   is done when the file is deleted. NOTE: If
+				   this is zero it is left zero. */
+/* 18*/	le16 link_count;	/* Number of hard links, i.e. the number of
+				   directory entries referencing this record.
+				   NOTE: Only used in mft base records.
+				   NOTE: When deleting a directory entry we
+				   check the link_count and if it is 1 we
+				   delete the file. Otherwise we delete the
+				   NTFS_FILE_NAME_ATTR being referenced by the
+				   directory entry from the mft record and
+				   decrement the link_count.
+				   FIXME: Careful with Win32 + DOS names! */
+/* 20*/	le16 attrs_offset;	/* Byte offset to the first attribute in this
+				   mft record from the start of the mft record.
+				   NOTE: Must be aligned to 8-byte boundary. */
+/* 22*/	NTFS_MFT_RECORD_FLAGS flags;	/* Bit array of NTFS_MFT_RECORD_FLAGS. When a file
+				   is deleted, the NTFS_MFT_RECORD_IN_USE flag is
+				   set to zero. */
+/* 24*/	le32 bytes_in_use;	/* Number of bytes used in this mft record.
+				   NOTE: Must be aligned to 8-byte boundary. */
+/* 28*/	le32 bytes_allocated;	/* Number of bytes allocated for this mft
+				   record. This should be equal to the mft
+				   record size. */
+/* 32*/	NTFS_leMFT_REF base_mft_record;/* This is zero for base mft records.
+				   When it is not zero it is a mft reference
+				   pointing to the base mft record to which
+				   this record belongs (this is then used to
+				   locate the attribute list attribute present
+				   in the base record which describes this
+				   extension record and hence might need
+				   modification when the extension record
+				   itself is modified, also locating the
+				   attribute list also means finding the other
+				   potential extents, belonging to the non-base
+				   mft record). */
+/* 40*/	le16 next_attr_instance; /* The instance number that will be
+				   assigned to the next attribute added to this
+				   mft record. NOTE: Incremented each time
+				   after it is used. NOTE: Every time the mft
+				   record is reused this number is set to zero.
+				   NOTE: The first instance number is always 0.
+				 */
+/* The below fields are specific to NTFS 3.1+ (Windows XP and above): */
+/* 42*/ le16 reserved;		/* Reserved/alignment. */
+/* 44*/ le32 mft_record_number;	/* Number of this mft record. */
+/* sizeof() = 48 bytes */
+/*
+ * When (re)using the mft record, we place the update sequence array at this
+ * offset, i.e. before we start with the attributes. This also makes sense,
+ * otherwise we could run into problems with the update sequence array
+ * containing in itself the last two bytes of a sector which would mean that
+ * multi sector transfer protection wouldn't work. As you can't protect data
+ * by overwriting it since you then can't get it back...
+ * When reading we obviously use the data from the ntfs record header.
+ */
+} __attribute__((__packed__)) NTFS_MFT_RECORD;
+
+/**
+ * struct NTFS_MFT_RECORD_OLD - An MFT record layout (NTFS <=3.0)
+ *
+ * This is the version without the NTFS 3.1+ specific fields.
+ */
+typedef struct {
+/*Ofs*/
+/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_RECORD_TYPES magic;/* Usually the magic is "FILE". */
+	le16 usa_ofs;		/* See NTFS_RECORD definition above. */
+	le16 usa_count;		/* See NTFS_RECORD definition above. */
+
+/*  8*/	NTFS_leLSN lsn;		/* $LogFile sequence number for this record.
+				   Changed every time the record is modified. */
+/* 16*/	le16 sequence_number;	/* Number of times this mft record has been
+				   reused. (See description for NTFS_MFT_REF
+				   above.) NOTE: The increment (skipping zero)
+				   is done when the file is deleted. NOTE: If
+				   this is zero it is left zero. */
+/* 18*/	le16 link_count;	/* Number of hard links, i.e. the number of
+				   directory entries referencing this record.
+				   NOTE: Only used in mft base records.
+				   NOTE: When deleting a directory entry we
+				   check the link_count and if it is 1 we
+				   delete the file. Otherwise we delete the
+				   NTFS_FILE_NAME_ATTR being referenced by the
+				   directory entry from the mft record and
+				   decrement the link_count.
+				   FIXME: Careful with Win32 + DOS names! */
+/* 20*/	le16 attrs_offset;	/* Byte offset to the first attribute in this
+				   mft record from the start of the mft record.
+				   NOTE: Must be aligned to 8-byte boundary. */
+/* 22*/	NTFS_MFT_RECORD_FLAGS flags;	/* Bit array of NTFS_MFT_RECORD_FLAGS. When a file
+				   is deleted, the NTFS_MFT_RECORD_IN_USE flag is
+				   set to zero. */
+/* 24*/	le32 bytes_in_use;	/* Number of bytes used in this mft record.
+				   NOTE: Must be aligned to 8-byte boundary. */
+/* 28*/	le32 bytes_allocated;	/* Number of bytes allocated for this mft
+				   record. This should be equal to the mft
+				   record size. */
+/* 32*/	NTFS_MFT_REF base_mft_record; /* This is zero for base mft records.
+				   When it is not zero it is a mft reference
+				   pointing to the base mft record to which
+				   this record belongs (this is then used to
+				   locate the attribute list attribute present
+				   in the base record which describes this
+				   extension record and hence might need
+				   modification when the extension record
+				   itself is modified, also locating the
+				   attribute list also means finding the other
+				   potential extents, belonging to the non-base
+				   mft record). */
+/* 40*/	le16 next_attr_instance; /* The instance number that will be
+				   assigned to the next attribute added to this
+				   mft record. NOTE: Incremented each time
+				   after it is used. NOTE: Every time the mft
+				   record is reused this number is set to zero.
+				   NOTE: The first instance number is always 0.
+				 */
+/* sizeof() = 42 bytes */
+/*
+ * When (re)using the mft record, we place the update sequence array at this
+ * offset, i.e. before we start with the attributes. This also makes sense,
+ * otherwise we could run into problems with the update sequence array
+ * containing in itself the last two bytes of a sector which would mean that
+ * multi sector transfer protection wouldn't work. As you can't protect data
+ * by overwriting it since you then can't get it back...
+ * When reading we obviously use the data from the ntfs record header.
+ */
+} __attribute__((__packed__)) NTFS_MFT_RECORD_OLD;
+
+/**
+ * enum NTFS_ATTR_TYPES - System defined attributes (32-bit).
+ *
+ * Each attribute type has a corresponding attribute name (Unicode string of
+ * maximum 64 character length) as described by the attribute definitions
+ * present in the data attribute of the $AttrDef system file.
+ *
+ * On NTFS 3.0 volumes the names are just as the types are named in the below
+ * enum exchanging AT_ for the dollar sign ($). If that isn't a revealing
+ * choice of symbol... (-;
+ */
+typedef enum {
+	NTFS_AT_UNUSED			= const_cpu_to_le32(         0),
+	NTFS_AT_STANDARD_INFORMATION		= const_cpu_to_le32(      0x10),
+	NTFS_AT_ATTRIBUTE_LIST		= const_cpu_to_le32(      0x20),
+	NTFS_AT_FILE_NAME			= const_cpu_to_le32(      0x30),
+	NTFS_AT_OBJECT_ID			= const_cpu_to_le32(      0x40),
+	NTFS_AT_SECURITY_DESCRIPTOR		= const_cpu_to_le32(      0x50),
+	NTFS_AT_VOLUME_NAME			= const_cpu_to_le32(      0x60),
+	NTFS_AT_VOLUME_INFORMATION		= const_cpu_to_le32(      0x70),
+	NTFS_AT_DATA				= const_cpu_to_le32(      0x80),
+	NTFS_AT_INDEX_ROOT			= const_cpu_to_le32(      0x90),
+	NTFS_AT_INDEX_ALLOCATION		= const_cpu_to_le32(      0xa0),
+	NTFS_AT_BITMAP			= const_cpu_to_le32(      0xb0),
+	NTFS_AT_REPARSE_POINT		= const_cpu_to_le32(      0xc0),
+	NTFS_AT_EA_INFORMATION		= const_cpu_to_le32(      0xd0),
+	NTFS_AT_EA				= const_cpu_to_le32(      0xe0),
+	NTFS_AT_PROPERTY_SET			= const_cpu_to_le32(      0xf0),
+	NTFS_AT_LOGGED_UTILITY_STREAM	= const_cpu_to_le32(     0x100),
+	NTFS_AT_FIRST_USER_DEFINED_ATTRIBUTE	= const_cpu_to_le32(    0x1000),
+	NTFS_AT_END				= const_cpu_to_le32(0xffffffff),
+} NTFS_ATTR_TYPES;
+
+/**
+ * enum NTFS_COLLATION_RULES - The collation rules for sorting views/indexes/etc
+ * (32-bit).
+ *
+ * NTFS_COLLATION_UNICODE_STRING - Collate Unicode strings by comparing their binary
+ *	Unicode values, except that when a character can be uppercased, the
+ *	upper case value collates before the lower case one.
+ * NTFS_COLLATION_FILE_NAME - Collate file names as Unicode strings. The collation
+ *	is done very much like NTFS_COLLATION_UNICODE_STRING. In fact I have no idea
+ *	what the difference is. Perhaps the difference is that file names
+ *	would treat some special characters in an odd way (see
+ *	unistr.c::ntfs_collate_names() and unistr.c::legal_ansi_char_array[]
+ *	for what I mean but NTFS_COLLATION_UNICODE_STRING would not give any special
+ *	treatment to any characters at all, but this is speculation.
+ * NTFS_COLLATION_NTOFS_ULONG - Sorting is done according to ascending le32 key
+ *	values. E.g. used for $SII index in NTFS_FILE_Secure, which sorts by
+ *	security_id (le32).
+ * NTFS_COLLATION_NTOFS_SID - Sorting is done according to ascending NTFS_SID values.
+ *	E.g. used for $O index in NTFS_FILE_Extend/$Quota.
+ * NTFS_COLLATION_NTOFS_SECURITY_HASH - Sorting is done first by ascending hash
+ *	values and second by ascending security_id values. E.g. used for $SDH
+ *	index in NTFS_FILE_Secure.
+ * NTFS_COLLATION_NTOFS_ULONGS - Sorting is done according to a sequence of ascending
+ *	le32 key values. E.g. used for $O index in NTFS_FILE_Extend/$ObjId, which
+ *	sorts by object_id (16-byte), by splitting up the object_id in four
+ *	le32 values and using them as individual keys. E.g. take the following
+ *	two security_ids, stored as follows on disk:
+ *		1st: a1 61 65 b7 65 7b d4 11 9e 3d 00 e0 81 10 42 59
+ *		2nd: 38 14 37 d2 d2 f3 d4 11 a5 21 c8 6b 79 b1 97 45
+ *	To compare them, they are split into four le32 values each, like so:
+ *		1st: 0xb76561a1 0x11d47b65 0xe0003d9e 0x59421081
+ *		2nd: 0xd2371438 0x11d4f3d2 0x6bc821a5 0x4597b179
+ *	Now, it is apparent why the 2nd object_id collates after the 1st: the
+ *	first le32 value of the 1st object_id is less than the first le32 of
+ *	the 2nd object_id. If the first le32 values of both object_ids were
+ *	equal then the second le32 values would be compared, etc.
+ */
+typedef enum {
+	NTFS_COLLATION_BINARY	 = const_cpu_to_le32(0), /* Collate by binary
+					compare where the first byte is most
+					significant. */
+	NTFS_COLLATION_FILE_NAME	 = const_cpu_to_le32(1), /* Collate file names
+					as Unicode strings. */
+	NTFS_COLLATION_UNICODE_STRING = const_cpu_to_le32(2), /* Collate Unicode
+					strings by comparing their binary
+					Unicode values, except that when a
+					character can be uppercased, the upper
+					case value collates before the lower
+					case one. */
+	NTFS_COLLATION_NTOFS_ULONG		= const_cpu_to_le32(16),
+	NTFS_COLLATION_NTOFS_SID		= const_cpu_to_le32(17),
+	NTFS_COLLATION_NTOFS_SECURITY_HASH	= const_cpu_to_le32(18),
+	NTFS_COLLATION_NTOFS_ULONGS		= const_cpu_to_le32(19),
+} NTFS_COLLATION_RULES;
+
+/**
+ * enum NTFS_ATTR_DEF_FLAGS -
+ *
+ * The flags (32-bit) describing attribute properties in the attribute
+ * definition structure.  FIXME: This information is based on Regis's
+ * information and, according to him, it is not certain and probably
+ * incomplete.  The INDEXABLE flag is fairly certainly correct as only the file
+ * name attribute has this flag set and this is the only attribute indexed in
+ * NT4.
+ */
+typedef enum {
+	NTFS_ATTR_DEF_INDEXABLE	= const_cpu_to_le32(0x02), /* Attribute can be
+					indexed. */
+	NTFS_ATTR_DEF_MULTIPLE	= const_cpu_to_le32(0x04), /* Attribute type
+					can be present multiple times in the
+					mft records of an inode. */
+	NTFS_ATTR_DEF_NOT_ZERO	= const_cpu_to_le32(0x08), /* Attribute value
+					must contain at least one non-zero
+					byte. */
+	NTFS_ATTR_DEF_INDEXED_UNIQUE	= const_cpu_to_le32(0x10), /* Attribute must be
+					indexed and the attribute value must be
+					unique for the attribute type in all of
+					the mft records of an inode. */
+	NTFS_ATTR_DEF_NAMED_UNIQUE	= const_cpu_to_le32(0x20), /* Attribute must be
+					named and the name must be unique for
+					the attribute type in all of the mft
+					records of an inode. */
+	NTFS_ATTR_DEF_RESIDENT	= const_cpu_to_le32(0x40), /* Attribute must be
+					resident. */
+	NTFS_ATTR_DEF_ALWAYS_LOG	= const_cpu_to_le32(0x80), /* Always log
+					modifications to this attribute,
+					regardless of whether it is resident or
+					non-resident.  Without this, only log
+					modifications if the attribute is
+					resident. */
+} NTFS_ATTR_DEF_FLAGS;
+
+/**
+ * struct NTFS_ATTR_DEF -
+ *
+ * The data attribute of NTFS_FILE_AttrDef contains a sequence of attribute
+ * definitions for the NTFS volume. With this, it is supposed to be safe for an
+ * older NTFS driver to mount a volume containing a newer NTFS version without
+ * damaging it (that's the theory. In practice it's: not damaging it too much).
+ * Entries are sorted by attribute type. The flags describe whether the
+ * attribute can be resident/non-resident and possibly other things, but the
+ * actual bits are unknown.
+ */
+typedef struct {
+/*hex ofs*/
+/*  0*/	ntfschar name[0x40];		/* Unicode name of the attribute. Zero
+					   terminated. */
+/* 80*/	NTFS_ATTR_TYPES type;		/* Type of the attribute. */
+/* 84*/	le32 display_rule;		/* Default display rule.
+					   FIXME: What does it mean? (AIA) */
+/* 88*/ NTFS_COLLATION_RULES collation_rule;	/* Default collation rule. */
+/* 8c*/	NTFS_ATTR_DEF_FLAGS flags;		/* Flags describing the attribute. */
+/* 90*/	sle64 min_size;			/* Optional minimum attribute size. */
+/* 98*/	sle64 max_size;			/* Maximum size of attribute. */
+/* sizeof() = 0xa0 or 160 bytes */
+} __attribute__((__packed__)) NTFS_ATTR_DEF;
+
+/**
+ * enum NTFS_ATTR_FLAGS - Attribute flags (16-bit).
+ */
+typedef enum {
+	NTFS_ATTR_IS_COMPRESSED	= const_cpu_to_le16(0x0001),
+	NTFS_ATTR_COMPRESSION_MASK	= const_cpu_to_le16(0x00ff),  /* Compression
+						method mask. Also, first
+						illegal value. */
+	NTFS_ATTR_IS_ENCRYPTED	= const_cpu_to_le16(0x4000),
+	NTFS_ATTR_IS_SPARSE		= const_cpu_to_le16(0x8000),
+} __attribute__((__packed__)) NTFS_ATTR_FLAGS;
+
+/*
+ * Attribute compression.
+ *
+ * Only the data attribute is ever compressed in the current ntfs driver in
+ * Windows. Further, compression is only applied when the data attribute is
+ * non-resident. Finally, to use compression, the maximum allowed cluster size
+ * on a volume is 4kib.
+ *
+ * The compression method is based on independently compressing blocks of X
+ * clusters, where X is determined from the compression_unit value found in the
+ * non-resident attribute record header (more precisely: X = 2^compression_unit
+ * clusters). On Windows NT/2k, X always is 16 clusters (compression_unit = 4).
+ *
+ * There are three different cases of how a compression block of X clusters
+ * can be stored:
+ *
+ *   1) The data in the block is all zero (a sparse block):
+ *	  This is stored as a sparse block in the ntfs_runlist, i.e. the ntfs_runlist
+ *	  entry has length = X and lcn = -1. The mapping pairs array actually
+ *	  uses a delta_lcn value length of 0, i.e. delta_lcn is not present at
+ *	  all, which is then interpreted by the driver as lcn = -1.
+ *	  NOTE: Even uncompressed files can be sparse on NTFS 3.0 volumes, then
+ *	  the same principles apply as above, except that the length is not
+ *	  restricted to being any particular value.
+ *
+ *   2) The data in the block is not compressed:
+ *	  This happens when compression doesn't reduce the size of the block
+ *	  in clusters. I.e. if compression has a small effect so that the
+ *	  compressed data still occupies X clusters, then the uncompressed data
+ *	  is stored in the block.
+ *	  This case is recognised by the fact that the ntfs_runlist entry has
+ *	  length = X and lcn >= 0. The mapping pairs array stores this as
+ *	  normal with a run length of X and some specific delta_lcn, i.e.
+ *	  delta_lcn has to be present.
+ *
+ *   3) The data in the block is compressed:
+ *	  The common case. This case is recognised by the fact that the run
+ *	  list entry has length L < X and lcn >= 0. The mapping pairs array
+ *	  stores this as normal with a run length of X and some specific
+ *	  delta_lcn, i.e. delta_lcn has to be present. This ntfs_runlist entry is
+ *	  immediately followed by a sparse entry with length = X - L and
+ *	  lcn = -1. The latter entry is to make up the vcn counting to the
+ *	  full compression block size X.
+ *
+ * In fact, life is more complicated because adjacent entries of the same type
+ * can be coalesced. This means that one has to keep track of the number of
+ * clusters handled and work on a basis of X clusters at a time being one
+ * block. An example: if length L > X this means that this particular ntfs_runlist
+ * entry contains a block of length X and part of one or more blocks of length
+ * L - X. Another example: if length L < X, this does not necessarily mean that
+ * the block is compressed as it might be that the lcn changes inside the block
+ * and hence the following ntfs_runlist entry describes the continuation of the
+ * potentially compressed block. The block would be compressed if the
+ * following ntfs_runlist entry describes at least X - L sparse clusters, thus
+ * making up the compression block length as described in point 3 above. (Of
+ * course, there can be several ntfs_runlist entries with small lengths so that the
+ * sparse entry does not follow the first data containing entry with
+ * length < X.)
+ *
+ * NOTE: At the end of the compressed attribute value, there most likely is not
+ * just the right amount of data to make up a compression block, thus this data
+ * is not even attempted to be compressed. It is just stored as is, unless
+ * the number of clusters it occupies is reduced when compressed in which case
+ * it is stored as a compressed compression block, complete with sparse
+ * clusters at the end.
+ */
+
+/**
+ * enum NTFS_RESIDENT_ATTR_FLAGS - Flags of resident attributes (8-bit).
+ */
+typedef enum {
+	NTFS_RESIDENT_ATTR_IS_INDEXED = 0x01, /* Attribute is referenced in an index
+					    (has implications for deleting and
+					    modifying the attribute). */
+} __attribute__((__packed__)) NTFS_RESIDENT_ATTR_FLAGS;
+
+/**
+ * struct NTFS_ATTR_RECORD - Attribute record header.
+ *
+ * Always aligned to 8-byte boundary.
+ */
+typedef struct {
+/*Ofs*/
+/*  0*/	NTFS_ATTR_TYPES type;	/* The (32-bit) type of the attribute. */
+/*  4*/	le32 length;		/* Byte size of the resident part of the
+				   attribute (aligned to 8-byte boundary).
+				   Used to get to the next attribute. */
+/*  8*/	u8 non_resident;	/* If 0, attribute is resident.
+				   If 1, attribute is non-resident. */
+/*  9*/	u8 name_length;		/* Unicode character size of name of attribute.
+				   0 if unnamed. */
+/* 10*/	le16 name_offset;	/* If name_length != 0, the byte offset to the
+				   beginning of the name from the attribute
+				   record. Note that the name is stored as a
+				   Unicode string. When creating, place offset
+				   just at the end of the record header. Then,
+				   follow with attribute value or mapping pairs
+				   array, resident and non-resident attributes
+				   respectively, aligning to an 8-byte
+				   boundary. */
+/* 12*/	NTFS_ATTR_FLAGS flags;	/* Flags describing the attribute. */
+/* 14*/	le16 instance;		/* The instance of this attribute record. This
+				   number is unique within this mft record (see
+				   NTFS_MFT_RECORD/next_attribute_instance notes
+				   above for more details). */
+/* 16*/	union {
+		/* Resident attributes. */
+		struct {
+/* 16 */		le32 value_length; /* Byte size of attribute value. */
+/* 20 */		le16 value_offset; /* Byte offset of the attribute
+					       value from the start of the
+					       attribute record. When creating,
+					       align to 8-byte boundary if we
+					       have a name present as this might
+					       not have a length of a multiple
+					       of 8-bytes. */
+/* 22 */		NTFS_RESIDENT_ATTR_FLAGS resident_flags; /* See above. */
+/* 23 */		s8 reservedR;	    /* Reserved/alignment to 8-byte
+					       boundary. */
+/* 24 */		void *resident_end[0]; /* Use offsetof(NTFS_ATTR_RECORD,
+						  resident_end) to get size of
+						  a resident attribute. */
+		} __attribute__((__packed__));
+		/* Non-resident attributes. */
+		struct {
+/* 16*/			NTFS_leVCN lowest_vcn;/* Lowest valid virtual cluster number
+				for this portion of the attribute value or
+				0 if this is the only extent (usually the
+				case). - Only when an attribute list is used
+				does lowest_vcn != 0 ever occur. */
+/* 24*/			NTFS_leVCN highest_vcn;/* Highest valid vcn of this extent of
+				the attribute value. - Usually there is only one
+				portion, so this usually equals the attribute
+				value size in clusters minus 1. Can be -1 for
+				zero length files. Can be 0 for "single extent"
+				attributes. */
+/* 32*/			le16 mapping_pairs_offset; /* Byte offset from the
+				beginning of the structure to the mapping pairs
+				array which contains the mappings between the
+				VCNs and the logical cluster numbers (LCNs).
+				When creating, place this at the end of this
+				record header aligned to 8-byte boundary. */
+/* 34*/			u8 compression_unit; /* The compression unit expressed
+				as the log to the base 2 of the number of
+				clusters in a compression unit. 0 means not
+				compressed. (This effectively limits the
+				compression unit size to be a power of two
+				clusters.) WinNT4 only uses a value of 4. */
+/* 35*/			u8 reserved1[5];	/* Align to 8-byte boundary. */
+/* The sizes below are only used when lowest_vcn is zero, as otherwise it would
+   be difficult to keep them up-to-date.*/
+/* 40*/			sle64 allocated_size;	/* Byte size of disk space
+				allocated to hold the attribute value. Always
+				is a multiple of the cluster size. When a file
+				is compressed, this field is a multiple of the
+				compression block size (2^compression_unit) and
+				it represents the logically allocated space
+				rather than the actual on disk usage. For this
+				use the compressed_size (see below). */
+/* 48*/			sle64 data_size;	/* Byte size of the attribute
+				value. Can be larger than allocated_size if
+				attribute value is compressed or sparse. */
+/* 56*/			sle64 initialized_size;	/* Byte size of initialized
+				portion of the attribute value. Usually equals
+				data_size. */
+/* 64 */		void *non_resident_end[0]; /* Use offsetof(NTFS_ATTR_RECORD,
+						      non_resident_end) to get
+						      size of a non resident
+						      attribute. */
+/* sizeof(uncompressed attr) = 64*/
+/* 64*/			sle64 compressed_size;	/* Byte size of the attribute
+				value after compression. Only present when
+				compressed. Always is a multiple of the
+				cluster size. Represents the actual amount of
+				disk space being used on the disk. */
+/* 72 */		void *compressed_end[0];
+				/* Use offsetof(NTFS_ATTR_RECORD, compressed_end) to
+				   get size of a compressed attribute. */
+/* sizeof(compressed attr) = 72*/
+		} __attribute__((__packed__));
+	} __attribute__((__packed__));
+} __attribute__((__packed__)) NTFS_ATTR_RECORD;
+
+typedef NTFS_ATTR_RECORD NTFS_ATTR_REC;
+
+/**
+ * enum NTFS_FILE_ATTR_FLAGS - File attribute flags (32-bit).
+ */
+typedef enum {
+	/*
+	 * These flags are only present in the NTFS_STANDARD_INFORMATION attribute
+	 * (in the field file_attributes).
+	 */
+	NTFS_FILE_ATTR_READONLY		= const_cpu_to_le32(0x00000001),
+	NTFS_FILE_ATTR_HIDDEN		= const_cpu_to_le32(0x00000002),
+	NTFS_FILE_ATTR_SYSTEM		= const_cpu_to_le32(0x00000004),
+	/* Old DOS valid. Unused in NT.	= cpu_to_le32(0x00000008), */
+
+	NTFS_FILE_ATTR_DIRECTORY		= const_cpu_to_le32(0x00000010),
+	/* NTFS_FILE_ATTR_DIRECTORY is not considered valid in NT. It is reserved
+	   for the DOS SUBDIRECTORY flag. */
+	NTFS_FILE_ATTR_ARCHIVE		= const_cpu_to_le32(0x00000020),
+	NTFS_FILE_ATTR_DEVICE		= const_cpu_to_le32(0x00000040),
+	NTFS_FILE_ATTR_NORMAL		= const_cpu_to_le32(0x00000080),
+
+	NTFS_FILE_ATTR_TEMPORARY		= const_cpu_to_le32(0x00000100),
+	NTFS_FILE_ATTR_SPARSE_FILE		= const_cpu_to_le32(0x00000200),
+	NTFS_FILE_ATTR_REPARSE_POINT		= const_cpu_to_le32(0x00000400),
+	NTFS_FILE_ATTR_COMPRESSED		= const_cpu_to_le32(0x00000800),
+
+	NTFS_FILE_ATTR_OFFLINE		= const_cpu_to_le32(0x00001000),
+	NTFS_FILE_ATTR_NOT_CONTENT_INDEXED	= const_cpu_to_le32(0x00002000),
+	NTFS_FILE_ATTR_ENCRYPTED		= const_cpu_to_le32(0x00004000),
+
+	NTFS_FILE_ATTR_VALID_FLAGS		= const_cpu_to_le32(0x00007fb7),
+	/* NTFS_FILE_ATTR_VALID_FLAGS masks out the old DOS VolId and the
+	   NTFS_FILE_ATTR_DEVICE and preserves everything else. This mask
+	   is used to obtain all flags that are valid for reading. */
+	NTFS_FILE_ATTR_VALID_SET_FLAGS	= const_cpu_to_le32(0x000031a7),
+	/* NTFS_FILE_ATTR_VALID_SET_FLAGS masks out the old DOS VolId, the
+	   NTFS_FILE_ATTR_DEVICE, NTFS_FILE_ATTR_DIRECTORY, NTFS_FILE_ATTR_SPARSE_FILE,
+	   NTFS_FILE_ATTR_REPARSE_POINT, FILE_ATRE_COMPRESSED and NTFS_FILE_ATTR_ENCRYPTED
+	   and preserves the rest. This mask is used to to obtain all flags that
+	   are valid for setting. */
+
+	/**
+	 * NTFS_FILE_ATTR_I30_INDEX_PRESENT - Is it a directory?
+	 *
+	 * This is a copy of the NTFS_MFT_RECORD_IS_DIRECTORY bit from the mft
+	 * record, telling us whether this is a directory or not, i.e. whether
+	 * it has an index root attribute named "$I30" or not.
+	 *
+	 * This flag is only present in the FILE_NAME attribute (in the
+	 * file_attributes field).
+	 */
+	NTFS_FILE_ATTR_I30_INDEX_PRESENT	= const_cpu_to_le32(0x10000000),
+
+	/**
+	 * NTFS_FILE_ATTR_VIEW_INDEX_PRESENT - Does have a non-directory index?
+	 *
+	 * This is a copy of the NTFS_MFT_RECORD_IS_VIEW_INDEX bit from the mft
+	 * record, telling us whether this file has a view index present (eg.
+	 * object id index, quota index, one of the security indexes and the
+	 * reparse points index).
+	 *
+	 * This flag is only present in the $NTFS_STANDARD_INFORMATION and
+	 * $FILE_NAME attributes.
+	 */
+	NTFS_FILE_ATTR_VIEW_INDEX_PRESENT	= const_cpu_to_le32(0x20000000),
+} __attribute__((__packed__)) NTFS_FILE_ATTR_FLAGS;
+
+/*
+ * NOTE on times in NTFS: All times are in MS standard time format, i.e. they
+ * are the number of 100-nanosecond intervals since 1st January 1601, 00:00:00
+ * universal coordinated time (UTC). (In Linux time starts 1st January 1970,
+ * 00:00:00 UTC and is stored as the number of 1-second intervals since then.)
+ */
+
+/**
+ * struct NTFS_STANDARD_INFORMATION - Attribute: Standard information (0x10).
+ *
+ * NOTE: Always resident.
+ * NOTE: Present in all base file records on a volume.
+ * NOTE: There is conflicting information about the meaning of each of the time
+ *	 fields but the meaning as defined below has been verified to be
+ *	 correct by practical experimentation on Windows NT4 SP6a and is hence
+ *	 assumed to be the one and only correct interpretation.
+ */
+typedef struct {
+/*Ofs*/
+/*  0*/	sle64 creation_time;		/* Time file was created. Updated when
+					   a filename is changed(?). */
+/*  8*/	sle64 last_data_change_time;	/* Time the data attribute was last
+					   modified. */
+/* 16*/	sle64 last_mft_change_time;	/* Time this mft record was last
+					   modified. */
+/* 24*/	sle64 last_access_time;		/* Approximate time when the file was
+					   last accessed (obviously this is not
+					   updated on read-only volumes). In
+					   Windows this is only updated when
+					   accessed if some time delta has
+					   passed since the last update. Also,
+					   last access times updates can be
+					   disabled altogether for speed. */
+/* 32*/	NTFS_FILE_ATTR_FLAGS file_attributes; /* Flags describing the file. */
+/* 36*/	union {
+		/* NTFS 1.2 (and previous, presumably) */
+		struct {
+		/* 36 */ u8 reserved12[12];	/* Reserved/alignment to 8-byte
+						   boundary. */
+		/* 48 */ void *v1_end[0];	/* Marker for offsetof(). */
+		} __attribute__((__packed__));
+/* sizeof() = 48 bytes */
+		/* NTFS 3.0 */
+		struct {
+/*
+ * If a volume has been upgraded from a previous NTFS version, then these
+ * fields are present only if the file has been accessed since the upgrade.
+ * Recognize the difference by comparing the length of the resident attribute
+ * value. If it is 48, then the following fields are missing. If it is 72 then
+ * the fields are present. Maybe just check like this:
+ *	if (resident.ValueLength < sizeof(NTFS_STANDARD_INFORMATION)) {
+ *		Assume NTFS 1.2- format.
+ *		If (volume version is 3.0+)
+ *			Upgrade attribute to NTFS 3.0 format.
+ *		else
+ *			Use NTFS 1.2- format for access.
+ *	} else
+ *		Use NTFS 3.0 format for access.
+ * Only problem is that it might be legal to set the length of the value to
+ * arbitrarily large values thus spoiling this check. - But chkdsk probably
+ * views that as a corruption, assuming that it behaves like this for all
+ * attributes.
+ */
+		/* 36*/	le32 maximum_versions;	/* Maximum allowed versions for
+				file. Zero if version numbering is disabled. */
+		/* 40*/	le32 version_number;	/* This file's version (if any).
+				Set to zero if maximum_versions is zero. */
+		/* 44*/	le32 class_id;		/* Class id from bidirectional
+				class id index (?). */
+		/* 48*/	le32 owner_id;		/* Owner_id of the user owning
+				the file. Translate via $Q index in NTFS_FILE_Extend
+				/$Quota to the quota control entry for the user
+				owning the file. Zero if quotas are disabled. */
+		/* 52*/	le32 security_id;	/* Security_id for the file.
+				Translate via $SII index and $SDS data stream
+				in NTFS_FILE_Secure to the security descriptor. */
+		/* 56*/	le64 quota_charged;	/* Byte size of the charge to
+				the quota for all streams of the file. Note: Is
+				zero if quotas are disabled. */
+		/* 64*/	le64 usn;		/* Last update sequence number
+				of the file. This is a direct index into the
+				change (aka USN) journal file. It is zero if
+				the USN journal is disabled.
+				NOTE: To disable the journal need to delete
+				the journal file itself and to then walk the
+				whole mft and set all USN entries in all mft
+				records to zero! (This can take a while!)
+				The journal is NTFS_FILE_Extend/$UsnJrnl. Win2k
+				will recreate the journal and initiate
+				logging if necessary when mounting the
+				partition. This, in contrast to disabling the
+				journal is a very fast process, so the user
+				won't even notice it. */
+		/* 72*/ void *v3_end[0]; /* Marker for offsetof(). */
+		} __attribute__((__packed__));
+	} __attribute__((__packed__));
+/* sizeof() = 72 bytes (NTFS 3.0) */
+} __attribute__((__packed__)) NTFS_STANDARD_INFORMATION;
+
+/**
+ * struct NTFS_ATTR_LIST_ENTRY - Attribute: Attribute list (0x20).
+ *
+ * - Can be either resident or non-resident.
+ * - Value consists of a sequence of variable length, 8-byte aligned,
+ * NTFS_ATTR_LIST_ENTRY records.
+ * - The attribute list attribute contains one entry for each attribute of
+ * the file in which the list is located, except for the list attribute
+ * itself. The list is sorted: first by attribute type, second by attribute
+ * name (if present), third by instance number. The extents of one
+ * non-resident attribute (if present) immediately follow after the initial
+ * extent. They are ordered by lowest_vcn and have their instance set to zero.
+ * It is not allowed to have two attributes with all sorting keys equal.
+ * - Further restrictions:
+ *	- If not resident, the vcn to lcn mapping array has to fit inside the
+ *	  base mft record.
+ *	- The attribute list attribute value has a maximum size of 256kb. This
+ *	  is imposed by the Windows cache manager.
+ * - Attribute lists are only used when the attributes of mft record do not
+ * fit inside the mft record despite all attributes (that can be made
+ * non-resident) having been made non-resident. This can happen e.g. when:
+ *	- File has a large number of hard links (lots of file name
+ *	  attributes present).
+ *	- The mapping pairs array of some non-resident attribute becomes so
+ *	  large due to fragmentation that it overflows the mft record.
+ *	- The security descriptor is very complex (not applicable to
+ *	  NTFS 3.0 volumes).
+ *	- There are many named streams.
+ */
+typedef struct {
+/*Ofs*/
+/*  0*/	NTFS_ATTR_TYPES type;	/* Type of referenced attribute. */
+/*  4*/	le16 length;		/* Byte size of this entry. */
+/*  6*/	u8 name_length;		/* Size in Unicode chars of the name of the
+				   attribute or 0 if unnamed. */
+/*  7*/	u8 name_offset;		/* Byte offset to beginning of attribute name
+				   (always set this to where the name would
+				   start even if unnamed). */
+/*  8*/	NTFS_leVCN lowest_vcn;	/* Lowest virtual cluster number of this portion
+				   of the attribute value. This is usually 0. It
+				   is non-zero for the case where one attribute
+				   does not fit into one mft record and thus
+				   several mft records are allocated to hold
+				   this attribute. In the latter case, each mft
+				   record holds one extent of the attribute and
+				   there is one attribute list entry for each
+				   extent. NOTE: This is DEFINITELY a signed
+				   value! The windows driver uses cmp, followed
+				   by jg when comparing this, thus it treats it
+				   as signed. */
+/* 16*/	NTFS_leMFT_REF mft_reference;/* The reference of the mft record holding
+				   the NTFS_ATTR_RECORD for this portion of the
+				   attribute value. */
+/* 24*/	le16 instance;		/* If lowest_vcn = 0, the instance of the
+				   attribute being referenced; otherwise 0. */
+/* 26*/	ntfschar name[0];	/* Use when creating only. When reading use
+				   name_offset to determine the location of the
+				   name. */
+/* sizeof() = 26 + (attribute_name_length * 2) bytes */
+} __attribute__((__packed__)) NTFS_ATTR_LIST_ENTRY;
+
+/*
+ * The maximum allowed length for a file name.
+ */
+#define NTFS_MAX_NAME_LEN	255
+
+/**
+ * enum NTFS_FILE_NAME_TYPE_FLAGS - Possible namespaces for filenames in ntfs.
+ * (8-bit).
+ */
+typedef enum {
+	NTFS_FILE_NAME_POSIX			= 0x00,
+		/* This is the largest namespace. It is case sensitive and
+		   allows all Unicode characters except for: '\0' and '/'.
+		   Beware that in WinNT/2k files which eg have the same name
+		   except for their case will not be distinguished by the
+		   standard utilities and thus a "del filename" will delete
+		   both "filename" and "fileName" without warning. */
+	NTFS_FILE_NAME_WIN32			= 0x01,
+		/* The standard WinNT/2k NTFS long filenames. Case insensitive.
+		   All Unicode chars except: '\0', '"', '*', '/', ':', '<',
+		   '>', '?', '\' and '|'. Further, names cannot end with a '.'
+		   or a space. */
+	NTFS_FILE_NAME_DOS			= 0x02,
+		/* The standard DOS filenames (8.3 format). Uppercase only.
+		   All 8-bit characters greater space, except: '"', '*', '+',
+		   ',', '/', ':', ';', '<', '=', '>', '?' and '\'. */
+	NTFS_FILE_NAME_WIN32_AND_DOS		= 0x03,
+		/* 3 means that both the Win32 and the DOS filenames are
+		   identical and hence have been saved in this single filename
+		   record. */
+} __attribute__((__packed__)) NTFS_FILE_NAME_TYPE_FLAGS;
+
+/**
+ * struct NTFS_FILE_NAME_ATTR - Attribute: Filename (0x30).
+ *
+ * NOTE: Always resident.
+ * NOTE: All fields, except the parent_directory, are only updated when the
+ *	 filename is changed. Until then, they just become out of sync with
+ *	 reality and the more up to date values are present in the standard
+ *	 information attribute.
+ * NOTE: There is conflicting information about the meaning of each of the time
+ *	 fields but the meaning as defined below has been verified to be
+ *	 correct by practical experimentation on Windows NT4 SP6a and is hence
+ *	 assumed to be the one and only correct interpretation.
+ */
+typedef struct {
+/*hex ofs*/
+/*  0*/	NTFS_leMFT_REF parent_directory;	/* Directory this filename is
+					   referenced from. */
+/*  8*/	sle64 creation_time;		/* Time file was created. */
+/* 10*/	sle64 last_data_change_time;	/* Time the data attribute was last
+					   modified. */
+/* 18*/	sle64 last_mft_change_time;	/* Time this mft record was last
+					   modified. */
+/* 20*/	sle64 last_access_time;		/* Last time this mft record was
+					   accessed. */
+/* 28*/	sle64 allocated_size;		/* Byte size of on-disk allocated space
+					   for the data attribute.  So for
+					   normal $DATA, this is the
+					   allocated_size from the unnamed
+					   $DATA attribute and for compressed
+					   and/or sparse $DATA, this is the
+					   compressed_size from the unnamed
+					   $DATA attribute.  NOTE: This is a
+					   multiple of the cluster size. */
+/* 30*/	sle64 data_size;			/* Byte size of actual data in data
+					   attribute. */
+/* 38*/	NTFS_FILE_ATTR_FLAGS file_attributes;	/* Flags describing the file. */
+/* 3c*/	union {
+	/* 3c*/	struct {
+		/* 3c*/	le16 packed_ea_size;	/* Size of the buffer needed to
+						   pack the extended attributes
+						   (EAs), if such are present.*/
+		/* 3e*/	le16 reserved;		/* Reserved for alignment. */
+		} __attribute__((__packed__));
+	/* 3c*/	le32 reparse_point_tag;		/* Type of reparse point,
+						   present only in reparse
+						   points and only if there are
+						   no EAs. */
+	} __attribute__((__packed__));
+/* 40*/	u8 file_name_length;			/* Length of file name in
+						   (Unicode) characters. */
+/* 41*/	NTFS_FILE_NAME_TYPE_FLAGS file_name_type;	/* Namespace of the file name.*/
+/* 42*/	ntfschar file_name[0];			/* File name in Unicode. */
+} __attribute__((__packed__)) NTFS_FILE_NAME_ATTR;
+
+/**
+ * struct NTFS_GUID - NTFS_GUID structures store globally unique identifiers (NTFS_GUID).
+ *
+ * A NTFS_GUID is a 128-bit value consisting of one group of eight hexadecimal
+ * digits, followed by three groups of four hexadecimal digits each, followed
+ * by one group of twelve hexadecimal digits. GUIDs are Microsoft's
+ * implementation of the distributed computing environment (DCE) universally
+ * unique identifier (UUID).
+ *
+ * Example of a NTFS_GUID in string format:
+ *	1F010768-5A73-BC91-0010-A52216A7227B
+ * And the same in binary:
+ *	1F0107685A73BC910010A52216A7227B
+ */
+typedef union {
+	struct {
+		le32 data1;	/* The first eight hexadecimal digits of the
+				   NTFS_GUID. */
+		le16 data2;	/* The first group of four hexadecimal
+				   digits. */
+		le16 data3;	/* The second group of four hexadecimal
+				   digits. */
+		u8 data4[8];	/* The first two bytes are the third group of
+				   four hexadecimal digits.  The remaining six
+				   bytes are the final 12 hexadecimal digits. */
+	} __attribute__((__packed__));
+	u8 raw[16];		/* Raw binary for ease of access. */
+} __attribute__((__packed__)) NTFS_GUID;
+
+/**
+ * struct NTFS_OBJ_ID_INDEX_DATA - NTFS_FILE_Extend/$ObjId contains an index named $O.
+ *
+ * This index contains all object_ids present on the volume as the index keys
+ * and the corresponding mft_record numbers as the index entry data parts.
+ *
+ * The data part (defined below) also contains three other object_ids:
+ *	birth_volume_id - object_id of NTFS_FILE_Volume on which the file was first
+ *			  created. Optional (i.e. can be zero).
+ *	birth_object_id - object_id of file when it was first created. Usually
+ *			  equals the object_id. Optional (i.e. can be zero).
+ *	domain_id	- Reserved (always zero).
+ */
+typedef struct {
+	NTFS_leMFT_REF mft_reference;/* Mft record containing the object_id in
+				   the index entry key. */
+	union {
+		struct {
+			NTFS_GUID birth_volume_id;
+			NTFS_GUID birth_object_id;
+			NTFS_GUID domain_id;
+		} __attribute__((__packed__));
+		u8 extended_info[48];
+	} __attribute__((__packed__));
+} __attribute__((__packed__)) NTFS_OBJ_ID_INDEX_DATA;
+
+/**
+ * struct NTFS_OBJECT_ID_ATTR - Attribute: Object id (NTFS 3.0+) (0x40).
+ *
+ * NOTE: Always resident.
+ */
+typedef struct {
+	NTFS_GUID object_id;				/* Unique id assigned to the
+						   file.*/
+	/* The following fields are optional. The attribute value size is 16
+	   bytes, i.e. sizeof(NTFS_GUID), if these are not present at all. Note,
+	   the entries can be present but one or more (or all) can be zero
+	   meaning that that particular value(s) is(are) not defined. Note,
+	   when the fields are missing here, it is well possible that they are
+	   to be found within the $Extend/$ObjId system file indexed under the
+	   above object_id. */
+	union {
+		struct {
+			NTFS_GUID birth_volume_id;	/* Unique id of volume on which
+						   the file was first created.*/
+			NTFS_GUID birth_object_id;	/* Unique id of file when it was
+						   first created. */
+			NTFS_GUID domain_id;		/* Reserved, zero. */
+		} __attribute__((__packed__));
+		u8 extended_info[48];
+	} __attribute__((__packed__));
+} __attribute__((__packed__)) NTFS_OBJECT_ID_ATTR;
+
+#if 0
+/**
+ * enum NTFS_IDENTIFIER_AUTHORITIES -
+ *
+ * The pre-defined NTFS_IDENTIFIER_AUTHORITIES used as NTFS_SID_IDENTIFIER_AUTHORITY in
+ * the NTFS_SID structure (see below).
+ */
+typedef enum {					/* NTFS_SID string prefix. */
+	NTFS_SECURITY_NULL_SID_AUTHORITY	= {0, 0, 0, 0, 0, 0},	/* S-1-0 */
+	NTFS_SECURITY_WORLD_SID_AUTHORITY	= {0, 0, 0, 0, 0, 1},	/* S-1-1 */
+	NTFS_SECURITY_LOCAL_SID_AUTHORITY	= {0, 0, 0, 0, 0, 2},	/* S-1-2 */
+	NTFS_SECURITY_CREATOR_SID_AUTHORITY	= {0, 0, 0, 0, 0, 3},	/* S-1-3 */
+	NTFS_SECURITY_NON_UNIQUE_AUTHORITY	= {0, 0, 0, 0, 0, 4},	/* S-1-4 */
+	NTFS_SECURITY_NT_SID_AUTHORITY	= {0, 0, 0, 0, 0, 5},	/* S-1-5 */
+} NTFS_IDENTIFIER_AUTHORITIES;
+#endif
+
+/**
+ * enum NTFS_RELATIVE_IDENTIFIERS -
+ *
+ * These relative identifiers (RIDs) are used with the above identifier
+ * authorities to make up universal well-known SIDs.
+ *
+ * Note: The relative identifier (RID) refers to the portion of a NTFS_SID, which
+ * identifies a user or group in relation to the authority that issued the NTFS_SID.
+ * For example, the universal well-known NTFS_SID Creator Owner ID (S-1-3-0) is
+ * made up of the identifier authority NTFS_SECURITY_CREATOR_SID_AUTHORITY (3) and
+ * the relative identifier NTFS_SECURITY_CREATOR_OWNER_RID (0).
+ */
+typedef enum {					/* Identifier authority. */
+	NTFS_SECURITY_NULL_RID		  = 0,	/* S-1-0 */
+	NTFS_SECURITY_WORLD_RID		  = 0,	/* S-1-1 */
+	NTFS_SECURITY_LOCAL_RID		  = 0,	/* S-1-2 */
+
+	NTFS_SECURITY_CREATOR_OWNER_RID	  = 0,	/* S-1-3 */
+	NTFS_SECURITY_CREATOR_GROUP_RID	  = 1,	/* S-1-3 */
+
+	NTFS_SECURITY_CREATOR_OWNER_SERVER_RID = 2,	/* S-1-3 */
+	NTFS_SECURITY_CREATOR_GROUP_SERVER_RID = 3,	/* S-1-3 */
+
+	NTFS_SECURITY_DIALUP_RID		  = 1,
+	NTFS_SECURITY_NETWORK_RID		  = 2,
+	NTFS_SECURITY_BATCH_RID		  = 3,
+	NTFS_SECURITY_INTERACTIVE_RID	  = 4,
+	NTFS_SECURITY_SERVICE_RID		  = 6,
+	NTFS_SECURITY_ANONYMOUS_LOGON_RID	  = 7,
+	NTFS_SECURITY_PROXY_RID		  = 8,
+	NTFS_SECURITY_ENTERPRISE_CONTROLLERS_RID=9,
+	NTFS_SECURITY_SERVER_LOGON_RID	  = 9,
+	NTFS_SECURITY_PRINCIPAL_SELF_RID	  = 0xa,
+	NTFS_SECURITY_AUTHENTICATED_USER_RID	  = 0xb,
+	NTFS_SECURITY_RESTRICTED_CODE_RID	  = 0xc,
+	NTFS_SECURITY_TERMINAL_SERVER_RID	  = 0xd,
+
+	NTFS_SECURITY_LOGON_IDS_RID		  = 5,
+	NTFS_SECURITY_LOGON_IDS_RID_COUNT	  = 3,
+
+	NTFS_SECURITY_LOCAL_SYSTEM_RID	  = 0x12,
+
+	NTFS_SECURITY_NT_NON_UNIQUE		  = 0x15,
+
+	NTFS_SECURITY_BUILTIN_DOMAIN_RID	  = 0x20,
+
+	/*
+	 * Well-known domain relative sub-authority values (RIDs).
+	 */
+
+	/* Users. */
+	NTFS_DOMAIN_USER_RID_ADMIN		  = 0x1f4,
+	NTFS_DOMAIN_USER_RID_GUEST		  = 0x1f5,
+	NTFS_DOMAIN_USER_RID_KRBTGT		  = 0x1f6,
+
+	/* Groups. */
+	NTFS_DOMAIN_GROUP_RID_ADMINS		  = 0x200,
+	NTFS_DOMAIN_GROUP_RID_USERS		  = 0x201,
+	NTFS_DOMAIN_GROUP_RID_GUESTS		  = 0x202,
+	NTFS_DOMAIN_GROUP_RID_COMPUTERS	  = 0x203,
+	NTFS_DOMAIN_GROUP_RID_CONTROLLERS	  = 0x204,
+	NTFS_DOMAIN_GROUP_RID_CERT_ADMINS	  = 0x205,
+	NTFS_DOMAIN_GROUP_RID_SCHEMA_ADMINS	  = 0x206,
+	NTFS_DOMAIN_GROUP_RID_ENTERPRISE_ADMINS= 0x207,
+	NTFS_DOMAIN_GROUP_RID_POLICY_ADMINS	  = 0x208,
+
+	/* Aliases. */
+	NTFS_DOMAIN_ALIAS_RID_ADMINS		  = 0x220,
+	NTFS_DOMAIN_ALIAS_RID_USERS		  = 0x221,
+	NTFS_DOMAIN_ALIAS_RID_GUESTS		  = 0x222,
+	NTFS_DOMAIN_ALIAS_RID_POWER_USERS	  = 0x223,
+
+	NTFS_DOMAIN_ALIAS_RID_ACCOUNT_OPS	  = 0x224,
+	NTFS_DOMAIN_ALIAS_RID_SYSTEM_OPS	  = 0x225,
+	NTFS_DOMAIN_ALIAS_RID_PRINT_OPS	  = 0x226,
+	NTFS_DOMAIN_ALIAS_RID_BACKUP_OPS	  = 0x227,
+
+	NTFS_DOMAIN_ALIAS_RID_REPLICATOR	  = 0x228,
+	NTFS_DOMAIN_ALIAS_RID_RAS_SERVERS	  = 0x229,
+	NTFS_DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x22a,
+} NTFS_RELATIVE_IDENTIFIERS;
+
+/*
+ * The universal well-known SIDs:
+ *
+ *	NULL_SID			S-1-0-0
+ *	WORLD_SID			S-1-1-0
+ *	LOCAL_SID			S-1-2-0
+ *	CREATOR_OWNER_SID		S-1-3-0
+ *	CREATOR_GROUP_SID		S-1-3-1
+ *	CREATOR_OWNER_SERVER_SID	S-1-3-2
+ *	CREATOR_GROUP_SERVER_SID	S-1-3-3
+ *
+ *	(Non-unique IDs)		S-1-4
+ *
+ * NT well-known SIDs:
+ *
+ *	NT_AUTHORITY_SID	S-1-5
+ *	DIALUP_SID		S-1-5-1
+ *
+ *	NETWORK_SID		S-1-5-2
+ *	BATCH_SID		S-1-5-3
+ *	INTERACTIVE_SID		S-1-5-4
+ *	SERVICE_SID		S-1-5-6
+ *	ANONYMOUS_LOGON_SID	S-1-5-7		(aka null logon session)
+ *	PROXY_SID		S-1-5-8
+ *	SERVER_LOGON_SID	S-1-5-9		(aka domain controller account)
+ *	SELF_SID		S-1-5-10	(self RID)
+ *	AUTHENTICATED_USER_SID	S-1-5-11
+ *	RESTRICTED_CODE_SID	S-1-5-12	(running restricted code)
+ *	TERMINAL_SERVER_SID	S-1-5-13	(running on terminal server)
+ *
+ *	(Logon IDs)		S-1-5-5-X-Y
+ *
+ *	(NT non-unique IDs)	S-1-5-0x15-...
+ *
+ *	(Built-in domain)	S-1-5-0x20
+ */
+
+/**
+ * union NTFS_SID_IDENTIFIER_AUTHORITY - A 48-bit value used in the NTFS_SID structure
+ *
+ * NOTE: This is stored as a big endian number.
+ */
+typedef union {
+	struct {
+		be16 high_part;		/* High 16-bits. */
+		be32 low_part;		/* Low 32-bits. */
+	} __attribute__((__packed__));
+	u8 value[6];			/* Value as individual bytes. */
+} __attribute__((__packed__)) NTFS_SID_IDENTIFIER_AUTHORITY;
+
+/**
+ * struct NTFS_SID -
+ *
+ * The NTFS_SID structure is a variable-length structure used to uniquely identify
+ * users or groups. NTFS_SID stands for security identifier.
+ *
+ * The standard textual representation of the NTFS_SID is of the form:
+ *	S-R-I-S-S...
+ * Where:
+ *    - The first "S" is the literal character 'S' identifying the following
+ *	digits as a NTFS_SID.
+ *    - R is the revision level of the NTFS_SID expressed as a sequence of digits
+ *	in decimal.
+ *    - I is the 48-bit identifier_authority, expressed as digits in decimal,
+ *	if I < 2^32, or hexadecimal prefixed by "0x", if I >= 2^32.
+ *    - S... is one or more sub_authority values, expressed as digits in
+ *	decimal.
+ *
+ * Example NTFS_SID; the domain-relative NTFS_SID of the local Administrators group on
+ * Windows NT/2k:
+ *	S-1-5-32-544
+ * This translates to a NTFS_SID with:
+ *	revision = 1,
+ *	sub_authority_count = 2,
+ *	identifier_authority = {0,0,0,0,0,5},	// SECURITY_NT_AUTHORITY
+ *	sub_authority[0] = 32,			// NTFS_SECURITY_BUILTIN_DOMAIN_RID
+ *	sub_authority[1] = 544			// NTFS_DOMAIN_ALIAS_RID_ADMINS
+ */
+typedef struct {
+	u8 revision;
+	u8 sub_authority_count;
+	NTFS_SID_IDENTIFIER_AUTHORITY identifier_authority;
+	le32 sub_authority[1];		/* At least one sub_authority. */
+} __attribute__((__packed__)) NTFS_SID;
+
+/**
+ * enum NTFS_SID_CONSTANTS - Current constants for SIDs.
+ */
+typedef enum {
+	NTFS_SID_REVISION			=  1,	/* Current revision level. */
+	NTFS_SID_MAX_SUB_AUTHORITIES		= 15,	/* Maximum number of those. */
+	NTFS_SID_RECOMMENDED_SUB_AUTHORITIES	=  1,	/* Will change to around 6 in
+						   a future revision. */
+} NTFS_SID_CONSTANTS;
+
+/**
+ * enum NTFS_ACE_TYPES - The predefined ACE types (8-bit, see below).
+ */
+typedef enum {
+	NTFS_ACCESS_MIN_MS_ACE_TYPE		= 0,
+	NTFS_ACCESS_ALLOWED_ACE_TYPE		= 0,
+	NTFS_ACCESS_DENIED_ACE_TYPE		= 1,
+	NTFS_SYSTEM_AUDIT_ACE_TYPE		= 2,
+	NTFS_SYSTEM_ALARM_ACE_TYPE		= 3, /* Not implemented as of Win2k. */
+	NTFS_ACCESS_MAX_MS_V2_ACE_TYPE	= 3,
+
+	NTFS_ACCESS_ALLOWED_COMPOUND_ACE_TYPE= 4,
+	NTFS_ACCESS_MAX_MS_V3_ACE_TYPE	= 4,
+
+	/* The following are Win2k only. */
+	NTFS_ACCESS_MIN_MS_OBJECT_ACE_TYPE	= 5,
+	NTFS_ACCESS_ALLOWED_OBJECT_ACE_TYPE	= 5,
+	NTFS_ACCESS_DENIED_OBJECT_ACE_TYPE	= 6,
+	NTFS_SYSTEM_AUDIT_OBJECT_ACE_TYPE	= 7,
+	NTFS_SYSTEM_ALARM_OBJECT_ACE_TYPE	= 8,
+	NTFS_ACCESS_MAX_MS_OBJECT_ACE_TYPE	= 8,
+
+	NTFS_ACCESS_MAX_MS_V4_ACE_TYPE	= 8,
+
+	/* This one is for WinNT&2k. */
+	NTFS_ACCESS_MAX_MS_ACE_TYPE		= 8,
+} __attribute__((__packed__)) NTFS_ACE_TYPES;
+
+/**
+ * enum NTFS_ACE_FLAGS - The ACE flags (8-bit) for audit and inheritance.
+ *
+ * NTFS_SUCCESSFUL_ACCESS_ACE_FLAG is only used with system audit and alarm ACE
+ * types to indicate that a message is generated (in Windows!) for successful
+ * accesses.
+ *
+ * NTFS_FAILED_ACCESS_ACE_FLAG is only used with system audit and alarm ACE types
+ * to indicate that a message is generated (in Windows!) for failed accesses.
+ */
+typedef enum {
+	/* The inheritance flags. */
+	NTFS_OBJECT_INHERIT_ACE		= 0x01,
+	NTFS_CONTAINER_INHERIT_ACE		= 0x02,
+	NTFS_NO_PROPAGATE_INHERIT_ACE	= 0x04,
+	NTFS_INHERIT_ONLY_ACE		= 0x08,
+	NTFS_INHERITED_ACE			= 0x10,	/* Win2k only. */
+	NTFS_VALID_INHERIT_FLAGS		= 0x1f,
+
+	/* The audit flags. */
+	NTFS_SUCCESSFUL_ACCESS_ACE_FLAG	= 0x40,
+	NTFS_FAILED_ACCESS_ACE_FLAG		= 0x80,
+} __attribute__((__packed__)) NTFS_ACE_FLAGS;
+
+/**
+ * struct NTFS_ACE_HEADER -
+ *
+ * An ACE is an access-control entry in an access-control list (NTFS_ACL).
+ * An ACE defines access to an object for a specific user or group or defines
+ * the types of access that generate system-administration messages or alarms
+ * for a specific user or group. The user or group is identified by a security
+ * identifier (NTFS_SID).
+ *
+ * Each ACE starts with an NTFS_ACE_HEADER structure (aligned on 4-byte boundary),
+ * which specifies the type and size of the ACE. The format of the subsequent
+ * data depends on the ACE type.
+ */
+typedef struct {
+	NTFS_ACE_TYPES type;		/* Type of the ACE. */
+	NTFS_ACE_FLAGS flags;	/* Flags describing the ACE. */
+	le16 size;		/* Size in bytes of the ACE. */
+} __attribute__((__packed__)) NTFS_ACE_HEADER;
+
+/**
+ * enum NTFS_ACCESS_MASK - The access mask (32-bit).
+ *
+ * Defines the access rights.
+ */
+typedef enum {
+	/*
+	 * The specific rights (bits 0 to 15). Depend on the type of the
+	 * object being secured by the ACE.
+	 */
+
+	/* Specific rights for files and directories are as follows: */
+
+	/* Right to read data from the file. (FILE) */
+	NTFS_FILE_READ_DATA			= const_cpu_to_le32(0x00000001),
+	/* Right to list contents of a directory. (DIRECTORY) */
+	NTFS_FILE_LIST_DIRECTORY		= const_cpu_to_le32(0x00000001),
+
+	/* Right to write data to the file. (FILE) */
+	NTFS_FILE_WRITE_DATA			= const_cpu_to_le32(0x00000002),
+	/* Right to create a file in the directory. (DIRECTORY) */
+	NTFS_FILE_ADD_FILE			= const_cpu_to_le32(0x00000002),
+
+	/* Right to append data to the file. (FILE) */
+	NTFS_FILE_APPEND_DATA		= const_cpu_to_le32(0x00000004),
+	/* Right to create a subdirectory. (DIRECTORY) */
+	NTFS_FILE_ADD_SUBDIRECTORY		= const_cpu_to_le32(0x00000004),
+
+	/* Right to read extended attributes. (FILE/DIRECTORY) */
+	NTFS_FILE_READ_EA			= const_cpu_to_le32(0x00000008),
+
+	/* Right to write extended attributes. (FILE/DIRECTORY) */
+	NTFS_FILE_WRITE_EA			= const_cpu_to_le32(0x00000010),
+
+	/* Right to execute a file. (FILE) */
+	NTFS_FILE_EXECUTE			= const_cpu_to_le32(0x00000020),
+	/* Right to traverse the directory. (DIRECTORY) */
+	NTFS_FILE_TRAVERSE			= const_cpu_to_le32(0x00000020),
+
+	/*
+	 * Right to delete a directory and all the files it contains (its
+	 * children), even if the files are read-only. (DIRECTORY)
+	 */
+	NTFS_FILE_DELETE_CHILD		= const_cpu_to_le32(0x00000040),
+
+	/* Right to read file attributes. (FILE/DIRECTORY) */
+	NTFS_FILE_READ_ATTRIBUTES		= const_cpu_to_le32(0x00000080),
+
+	/* Right to change file attributes. (FILE/DIRECTORY) */
+	NTFS_FILE_WRITE_ATTRIBUTES		= const_cpu_to_le32(0x00000100),
+
+	/*
+	 * The standard rights (bits 16 to 23). Are independent of the type of
+	 * object being secured.
+	 */
+
+	/* Right to delete the object. */
+	NTFS_DELETE				= const_cpu_to_le32(0x00010000),
+
+	/*
+	 * Right to read the information in the object's security descriptor,
+	 * not including the information in the SACL. I.e. right to read the
+	 * security descriptor and owner.
+	 */
+	NTFS_READ_CONTROL			= const_cpu_to_le32(0x00020000),
+
+	/* Right to modify the DACL in the object's security descriptor. */
+	NTFS_WRITE_DAC			= const_cpu_to_le32(0x00040000),
+
+	/* Right to change the owner in the object's security descriptor. */
+	NTFS_WRITE_OWNER			= const_cpu_to_le32(0x00080000),
+
+	/*
+	 * Right to use the object for synchronization. Enables a process to
+	 * wait until the object is in the signalled state. Some object types
+	 * do not support this access right.
+	 */
+	NTFS_SYNCHRONIZE			= const_cpu_to_le32(0x00100000),
+
+	/*
+	 * The following STANDARD_RIGHTS_* are combinations of the above for
+	 * convenience and are defined by the Win32 API.
+	 */
+
+	/* These are currently defined to NTFS_READ_CONTROL. */
+	NTFS_STANDARD_RIGHTS_READ		= const_cpu_to_le32(0x00020000),
+	NTFS_STANDARD_RIGHTS_WRITE		= const_cpu_to_le32(0x00020000),
+	NTFS_STANDARD_RIGHTS_EXECUTE		= const_cpu_to_le32(0x00020000),
+
+	/* Combines NTFS_DELETE, NTFS_READ_CONTROL, NTFS_WRITE_DAC, and NTFS_WRITE_OWNER access. */
+	NTFS_STANDARD_RIGHTS_REQUIRED	= const_cpu_to_le32(0x000f0000),
+
+	/*
+	 * Combines NTFS_DELETE, NTFS_READ_CONTROL, NTFS_WRITE_DAC, NTFS_WRITE_OWNER, and
+	 * NTFS_SYNCHRONIZE access.
+	 */
+	NTFS_STANDARD_RIGHTS_ALL		= const_cpu_to_le32(0x001f0000),
+
+	/*
+	 * The access system NTFS_ACL and maximum allowed access types (bits 24 to
+	 * 25, bits 26 to 27 are reserved).
+	 */
+	NTFS_ACCESS_SYSTEM_SECURITY		= const_cpu_to_le32(0x01000000),
+	NTFS_MAXIMUM_ALLOWED			= const_cpu_to_le32(0x02000000),
+
+	/*
+	 * The generic rights (bits 28 to 31). These map onto the standard and
+	 * specific rights.
+	 */
+
+	/* Read, write, and execute access. */
+	NTFS_GENERIC_ALL			= const_cpu_to_le32(0x10000000),
+
+	/* Execute access. */
+	NTFS_GENERIC_EXECUTE			= const_cpu_to_le32(0x20000000),
+
+	/*
+	 * Write access. For files, this maps onto:
+	 *	NTFS_FILE_APPEND_DATA | NTFS_FILE_WRITE_ATTRIBUTES | NTFS_FILE_WRITE_DATA |
+	 *	NTFS_FILE_WRITE_EA | NTFS_STANDARD_RIGHTS_WRITE | NTFS_SYNCHRONIZE
+	 * For directories, the mapping has the same numerical value. See
+	 * above for the descriptions of the rights granted.
+	 */
+	NTFS_GENERIC_WRITE			= const_cpu_to_le32(0x40000000),
+
+	/*
+	 * Read access. For files, this maps onto:
+	 *	NTFS_FILE_READ_ATTRIBUTES | NTFS_FILE_READ_DATA | NTFS_FILE_READ_EA |
+	 *	NTFS_STANDARD_RIGHTS_READ | NTFS_SYNCHRONIZE
+	 * For directories, the mapping has the same numerical value. See
+	 * above for the descriptions of the rights granted.
+	 */
+	NTFS_GENERIC_READ			= const_cpu_to_le32(0x80000000),
+} NTFS_ACCESS_MASK;
+
+/**
+ * struct NTFS_GENERIC_MAPPING -
+ *
+ * The generic mapping array. Used to denote the mapping of each generic
+ * access right to a specific access mask.
+ *
+ * FIXME: What exactly is this and what is it for? (AIA)
+ */
+typedef struct {
+	NTFS_ACCESS_MASK generic_read;
+	NTFS_ACCESS_MASK generic_write;
+	NTFS_ACCESS_MASK generic_execute;
+	NTFS_ACCESS_MASK generic_all;
+} __attribute__((__packed__)) NTFS_GENERIC_MAPPING;
+
+/*
+ * The predefined ACE type structures are as defined below.
+ */
+
+/**
+ * struct NTFS_ACCESS_DENIED_ACE -
+ *
+ * NTFS_ACCESS_ALLOWED_ACE, NTFS_ACCESS_DENIED_ACE, NTFS_SYSTEM_AUDIT_ACE, NTFS_SYSTEM_ALARM_ACE
+ */
+typedef struct {
+/*  0	NTFS_ACE_HEADER; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_ACE_TYPES type;		/* Type of the ACE. */
+	NTFS_ACE_FLAGS flags;	/* Flags describing the ACE. */
+	le16 size;		/* Size in bytes of the ACE. */
+
+/*  4*/	NTFS_ACCESS_MASK mask;	/* Access mask associated with the ACE. */
+/*  8*/	NTFS_SID sid;		/* The NTFS_SID associated with the ACE. */
+} __attribute__((__packed__)) NTFS_ACCESS_ALLOWED_ACE, NTFS_ACCESS_DENIED_ACE,
+			       NTFS_SYSTEM_AUDIT_ACE, NTFS_SYSTEM_ALARM_ACE;
+
+/**
+ * enum NTFS_OBJECT_ACE_FLAGS - The object ACE flags (32-bit).
+ */
+typedef enum {
+	NTFS_ACE_OBJECT_TYPE_PRESENT			= const_cpu_to_le32(1),
+	NTFS_ACE_INHERITED_OBJECT_TYPE_PRESENT	= const_cpu_to_le32(2),
+} NTFS_OBJECT_ACE_FLAGS;
+
+/**
+ * struct NTFS_ACCESS_ALLOWED_OBJECT_ACE -
+ */
+typedef struct {
+/*  0	NTFS_ACE_HEADER; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_ACE_TYPES type;		/* Type of the ACE. */
+	NTFS_ACE_FLAGS flags;	/* Flags describing the ACE. */
+	le16 size;		/* Size in bytes of the ACE. */
+
+/*  4*/	NTFS_ACCESS_MASK mask;	/* Access mask associated with the ACE. */
+/*  8*/	NTFS_OBJECT_ACE_FLAGS object_flags;	/* Flags describing the object ACE. */
+/* 12*/	NTFS_GUID object_type;
+/* 28*/	NTFS_GUID inherited_object_type;
+/* 44*/	NTFS_SID sid;		/* The NTFS_SID associated with the ACE. */
+} __attribute__((__packed__)) NTFS_ACCESS_ALLOWED_OBJECT_ACE,
+			       NTFS_ACCESS_DENIED_OBJECT_ACE,
+			       NTFS_SYSTEM_AUDIT_OBJECT_ACE,
+			       NTFS_SYSTEM_ALARM_OBJECT_ACE;
+
+/**
+ * struct NTFS_ACL - An NTFS_ACL is an access-control list (NTFS_ACL).
+ *
+ * An NTFS_ACL starts with an NTFS_ACL header structure, which specifies the size of
+ * the NTFS_ACL and the number of ACEs it contains. The NTFS_ACL header is followed by
+ * zero or more access control entries (ACEs). The NTFS_ACL as well as each ACE
+ * are aligned on 4-byte boundaries.
+ */
+typedef struct {
+	u8 revision;	/* Revision of this NTFS_ACL. */
+	u8 alignment1;
+	le16 size;	/* Allocated space in bytes for NTFS_ACL. Includes this
+			   header, the ACEs and the remaining free space. */
+	le16 ace_count;	/* Number of ACEs in the NTFS_ACL. */
+	le16 alignment2;
+/* sizeof() = 8 bytes */
+} __attribute__((__packed__)) NTFS_ACL;
+
+/**
+ * enum NTFS_ACL_CONSTANTS - Current constants for ACLs.
+ */
+typedef enum {
+	/* Current revision. */
+	NTFS_ACL_REVISION		= 2,
+	NTFS_ACL_REVISION_DS		= 4,
+
+	/* History of revisions. */
+	NTFS_ACL_REVISION1		= 1,
+	NTFS_MIN_ACL_REVISION	= 2,
+	NTFS_ACL_REVISION2		= 2,
+	NTFS_ACL_REVISION3		= 3,
+	NTFS_ACL_REVISION4		= 4,
+	NTFS_MAX_ACL_REVISION	= 4,
+} NTFS_ACL_CONSTANTS;
+
+/**
+ * enum NTFS_SECURITY_DESCRIPTOR_CONTROL -
+ *
+ * The security descriptor control flags (16-bit).
+ *
+ * NTFS_SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
+ *	NTFS_SID pointed to by the Owner field was provided by a
+ *	defaulting mechanism rather than explicitly provided by the
+ *	original provider of the security descriptor.  This may
+ *	affect the treatment of the NTFS_SID with respect to inheritance
+ *	of an owner.
+ *
+ * NTFS_SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
+ *	NTFS_SID in the Group field was provided by a defaulting mechanism
+ *	rather than explicitly provided by the original provider of
+ *	the security descriptor.  This may affect the treatment of
+ *	the NTFS_SID with respect to inheritance of a primary group.
+ *
+ * NTFS_SE_DACL_PRESENT - This boolean flag, when set, indicates that the
+ *	security descriptor contains a discretionary NTFS_ACL.  If this
+ *	flag is set and the Dacl field of the NTFS_SECURITY_DESCRIPTOR is
+ *	null, then a null NTFS_ACL is explicitly being specified.
+ *
+ * NTFS_SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
+ *	NTFS_ACL pointed to by the Dacl field was provided by a defaulting
+ *	mechanism rather than explicitly provided by the original
+ *	provider of the security descriptor.  This may affect the
+ *	treatment of the NTFS_ACL with respect to inheritance of an NTFS_ACL.
+ *	This flag is ignored if the DaclPresent flag is not set.
+ *
+ * NTFS_SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
+ *	security descriptor contains a system NTFS_ACL pointed to by the
+ *	Sacl field.  If this flag is set and the Sacl field of the
+ *	NTFS_SECURITY_DESCRIPTOR is null, then an empty (but present)
+ *	NTFS_ACL is being specified.
+ *
+ * NTFS_SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
+ *	NTFS_ACL pointed to by the Sacl field was provided by a defaulting
+ *	mechanism rather than explicitly provided by the original
+ *	provider of the security descriptor.  This may affect the
+ *	treatment of the NTFS_ACL with respect to inheritance of an NTFS_ACL.
+ *	This flag is ignored if the SaclPresent flag is not set.
+ *
+ * NTFS_SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
+ *	security descriptor is in self-relative form.  In this form,
+ *	all fields of the security descriptor are contiguous in memory
+ *	and all pointer fields are expressed as offsets from the
+ *	beginning of the security descriptor.
+ */
+typedef enum {
+	NTFS_SE_OWNER_DEFAULTED		= const_cpu_to_le16(0x0001),
+	NTFS_SE_GROUP_DEFAULTED		= const_cpu_to_le16(0x0002),
+	NTFS_SE_DACL_PRESENT			= const_cpu_to_le16(0x0004),
+	NTFS_SE_DACL_DEFAULTED		= const_cpu_to_le16(0x0008),
+	NTFS_SE_SACL_PRESENT			= const_cpu_to_le16(0x0010),
+	NTFS_SE_SACL_DEFAULTED		= const_cpu_to_le16(0x0020),
+	NTFS_SE_DACL_AUTO_INHERIT_REQ	= const_cpu_to_le16(0x0100),
+	NTFS_SE_SACL_AUTO_INHERIT_REQ	= const_cpu_to_le16(0x0200),
+	NTFS_SE_DACL_AUTO_INHERITED		= const_cpu_to_le16(0x0400),
+	NTFS_SE_SACL_AUTO_INHERITED		= const_cpu_to_le16(0x0800),
+	NTFS_SE_DACL_PROTECTED		= const_cpu_to_le16(0x1000),
+	NTFS_SE_SACL_PROTECTED		= const_cpu_to_le16(0x2000),
+	NTFS_SE_RM_CONTROL_VALID		= const_cpu_to_le16(0x4000),
+	NTFS_SE_SELF_RELATIVE		= const_cpu_to_le16(0x8000),
+} __attribute__((__packed__)) NTFS_SECURITY_DESCRIPTOR_CONTROL;
+
+/**
+ * struct NTFS_SECURITY_DESCRIPTOR_RELATIVE -
+ *
+ * Self-relative security descriptor. Contains the owner and group SIDs as well
+ * as the sacl and dacl ACLs inside the security descriptor itself.
+ */
+typedef struct {
+	u8 revision;	/* Revision level of the security descriptor. */
+	u8 alignment;
+	NTFS_SECURITY_DESCRIPTOR_CONTROL control; /* Flags qualifying the type of
+			   the descriptor as well as the following fields. */
+	le32 owner;	/* Byte offset to a NTFS_SID representing an object's
+			   owner. If this is NULL, no owner NTFS_SID is present in
+			   the descriptor. */
+	le32 group;	/* Byte offset to a NTFS_SID representing an object's
+			   primary group. If this is NULL, no primary group
+			   NTFS_SID is present in the descriptor. */
+	le32 sacl;	/* Byte offset to a system NTFS_ACL. Only valid, if
+			   NTFS_SE_SACL_PRESENT is set in the control field. If
+			   NTFS_SE_SACL_PRESENT is set but sacl is NULL, a NULL NTFS_ACL
+			   is specified. */
+	le32 dacl;	/* Byte offset to a discretionary NTFS_ACL. Only valid, if
+			   NTFS_SE_DACL_PRESENT is set in the control field. If
+			   NTFS_SE_DACL_PRESENT is set but dacl is NULL, a NULL NTFS_ACL
+			   (unconditionally granting access) is specified. */
+/* sizeof() = 0x14 bytes */
+} __attribute__((__packed__)) NTFS_SECURITY_DESCRIPTOR_RELATIVE;
+
+/**
+ * struct NTFS_SECURITY_DESCRIPTOR - Absolute security descriptor.
+ *
+ * Does not contain the owner and group SIDs, nor the sacl and dacl ACLs inside
+ * the security descriptor. Instead, it contains pointers to these structures
+ * in memory. Obviously, absolute security descriptors are only useful for in
+ * memory representations of security descriptors.
+ *
+ * On disk, a self-relative security descriptor is used.
+ */
+typedef struct {
+	u8 revision;	/* Revision level of the security descriptor. */
+	u8 alignment;
+	NTFS_SECURITY_DESCRIPTOR_CONTROL control;	/* Flags qualifying the type of
+			   the descriptor as well as the following fields. */
+	NTFS_SID *owner;	/* Points to a NTFS_SID representing an object's owner. If
+			   this is NULL, no owner NTFS_SID is present in the
+			   descriptor. */
+	NTFS_SID *group;	/* Points to a NTFS_SID representing an object's primary
+			   group. If this is NULL, no primary group NTFS_SID is
+			   present in the descriptor. */
+	NTFS_ACL *sacl;	/* Points to a system NTFS_ACL. Only valid, if
+			   NTFS_SE_SACL_PRESENT is set in the control field. If
+			   NTFS_SE_SACL_PRESENT is set but sacl is NULL, a NULL NTFS_ACL
+			   is specified. */
+	NTFS_ACL *dacl;	/* Points to a discretionary NTFS_ACL. Only valid, if
+			   NTFS_SE_DACL_PRESENT is set in the control field. If
+			   NTFS_SE_DACL_PRESENT is set but dacl is NULL, a NULL NTFS_ACL
+			   (unconditionally granting access) is specified. */
+} __attribute__((__packed__)) NTFS_SECURITY_DESCRIPTOR;
+
+/**
+ * enum NTFS_SECURITY_DESCRIPTOR_CONSTANTS -
+ *
+ * Current constants for security descriptors.
+ */
+typedef enum {
+	/* Current revision. */
+	NTFS_SECURITY_DESCRIPTOR_REVISION	= 1,
+	NTFS_SECURITY_DESCRIPTOR_REVISION1	= 1,
+
+	/* The sizes of both the absolute and relative security descriptors is
+	   the same as pointers, at least on ia32 architecture are 32-bit. */
+	NTFS_SECURITY_DESCRIPTOR_MIN_LENGTH	= sizeof(NTFS_SECURITY_DESCRIPTOR),
+} NTFS_SECURITY_DESCRIPTOR_CONSTANTS;
+
+/*
+ * Attribute: Security descriptor (0x50).
+ *
+ * A standard self-relative security descriptor.
+ *
+ * NOTE: Can be resident or non-resident.
+ * NOTE: Not used in NTFS 3.0+, as security descriptors are stored centrally
+ * in NTFS_FILE_Secure and the correct descriptor is found using the security_id
+ * from the standard information attribute.
+ */
+typedef NTFS_SECURITY_DESCRIPTOR_RELATIVE NTFS_SECURITY_DESCRIPTOR_ATTR;
+
+/*
+ * On NTFS 3.0+, all security descriptors are stored in NTFS_FILE_Secure. Only one
+ * referenced instance of each unique security descriptor is stored.
+ *
+ * NTFS_FILE_Secure contains no unnamed data attribute, i.e. it has zero length. It
+ * does, however, contain two indexes ($SDH and $SII) as well as a named data
+ * stream ($SDS).
+ *
+ * Every unique security descriptor is assigned a unique security identifier
+ * (security_id, not to be confused with a NTFS_SID). The security_id is unique for
+ * the NTFS volume and is used as an index into the $SII index, which maps
+ * security_ids to the security descriptor's storage location within the $SDS
+ * data attribute. The $SII index is sorted by ascending security_id.
+ *
+ * A simple hash is computed from each security descriptor. This hash is used
+ * as an index into the $SDH index, which maps security descriptor hashes to
+ * the security descriptor's storage location within the $SDS data attribute.
+ * The $SDH index is sorted by security descriptor hash and is stored in a B+
+ * tree. When searching $SDH (with the intent of determining whether or not a
+ * new security descriptor is already present in the $SDS data stream), if a
+ * matching hash is found, but the security descriptors do not match, the
+ * search in the $SDH index is continued, searching for a next matching hash.
+ *
+ * When a precise match is found, the security_id corresponding to the security
+ * descriptor in the $SDS attribute is read from the found $SDH index entry and
+ * is stored in the $NTFS_STANDARD_INFORMATION attribute of the file/directory to
+ * which the security descriptor is being applied. The $NTFS_STANDARD_INFORMATION
+ * attribute is present in all base mft records (i.e. in all files and
+ * directories).
+ *
+ * If a match is not found, the security descriptor is assigned a new unique
+ * security_id and is added to the $SDS data attribute. Then, entries
+ * referencing the this security descriptor in the $SDS data attribute are
+ * added to the $SDH and $SII indexes.
+ *
+ * Note: Entries are never deleted from NTFS_FILE_Secure, even if nothing
+ * references an entry any more.
+ */
+
+/**
+ * struct NTFS_SECURITY_DESCRIPTOR_HEADER -
+ *
+ * This header precedes each security descriptor in the $SDS data stream.
+ * This is also the index entry data part of both the $SII and $SDH indexes.
+ */
+typedef struct {
+	le32 hash;	   /* Hash of the security descriptor. */
+	le32 security_id;   /* The security_id assigned to the descriptor. */
+	le64 offset;	   /* Byte offset of this entry in the $SDS stream. */
+	le32 length;	   /* Size in bytes of this entry in $SDS stream. */
+} __attribute__((__packed__)) NTFS_SECURITY_DESCRIPTOR_HEADER;
+
+/**
+ * struct NTFS_SDH_INDEX_DATA -
+ */
+typedef struct {
+	le32 hash;          /* Hash of the security descriptor. */
+	le32 security_id;   /* The security_id assigned to the descriptor. */
+	le64 offset;	   /* Byte offset of this entry in the $SDS stream. */
+	le32 length;	   /* Size in bytes of this entry in $SDS stream. */
+	le32 reserved_II;   /* Padding - always unicode "II" or zero. This field
+			      isn't counted in NTFS_INDEX_ENTRY's data_length. */
+} __attribute__((__packed__)) NTFS_SDH_INDEX_DATA;
+
+/**
+ * struct NTFS_SII_INDEX_DATA -
+ */
+typedef NTFS_SECURITY_DESCRIPTOR_HEADER NTFS_SII_INDEX_DATA;
+
+/**
+ * struct NTFS_SDS_ENTRY -
+ *
+ * The $SDS data stream contains the security descriptors, aligned on 16-byte
+ * boundaries, sorted by security_id in a B+ tree. Security descriptors cannot
+ * cross 256kib boundaries (this restriction is imposed by the Windows cache
+ * manager). Each security descriptor is contained in a NTFS_SDS_ENTRY structure.
+ * Also, each security descriptor is stored twice in the $SDS stream with a
+ * fixed offset of 0x40000 bytes (256kib, the Windows cache manager's max size)
+ * between them; i.e. if a NTFS_SDS_ENTRY specifies an offset of 0x51d0, then the
+ * the first copy of the security descriptor will be at offset 0x51d0 in the
+ * $SDS data stream and the second copy will be at offset 0x451d0.
+ */
+typedef struct {
+/*  0	NTFS_SECURITY_DESCRIPTOR_HEADER; -- Unfolded here as gcc doesn't like
+				       unnamed structs. */
+	le32 hash;	  /* Hash of the security descriptor. */
+	le32 security_id; /* The security_id assigned to the descriptor. */
+	le64 offset;	  /* Byte offset of this entry in the $SDS stream. */
+	le32 length;	  /* Size in bytes of this entry in $SDS stream. */
+/* 20*/	NTFS_SECURITY_DESCRIPTOR_RELATIVE sid; /* The self-relative security
+					     descriptor. */
+} __attribute__((__packed__)) NTFS_SDS_ENTRY;
+
+/**
+ * struct NTFS_SII_INDEX_KEY - The index entry key used in the $SII index.
+ *
+ * The collation type is NTFS_COLLATION_NTOFS_ULONG.
+ */
+typedef struct {
+	le32 security_id;   /* The security_id assigned to the descriptor. */
+} __attribute__((__packed__)) NTFS_SII_INDEX_KEY;
+
+/**
+ * struct NTFS_SDH_INDEX_KEY - The index entry key used in the $SDH index.
+ *
+ * The keys are sorted first by hash and then by security_id.
+ * The collation rule is NTFS_COLLATION_NTOFS_SECURITY_HASH.
+ */
+typedef struct {
+	le32 hash;	   /* Hash of the security descriptor. */
+	le32 security_id;   /* The security_id assigned to the descriptor. */
+} __attribute__((__packed__)) NTFS_SDH_INDEX_KEY;
+
+/**
+ * struct NTFS_VOLUME_NAME - Attribute: Volume name (0x60).
+ *
+ * NOTE: Always resident.
+ * NOTE: Present only in NTFS_FILE_Volume.
+ */
+typedef struct {
+	ntfschar name[0];	/* The name of the volume in Unicode. */
+} __attribute__((__packed__)) NTFS_VOLUME_NAME;
+
+/**
+ * enum NTFS_VOLUME_FLAGS - Possible flags for the volume (16-bit).
+ *
+ * WARNING: Setting NTFS_VOLUME_MOUNTED_ON_NT4 on a Volume causes Windows Vista to
+ * fail to boot (it hangs on a black screen).
+ */
+typedef enum {
+	NTFS_VOLUME_IS_DIRTY			= const_cpu_to_le16(0x0001),
+	NTFS_VOLUME_RESIZE_LOG_FILE		= const_cpu_to_le16(0x0002),
+	NTFS_VOLUME_UPGRADE_ON_MOUNT		= const_cpu_to_le16(0x0004),
+	NTFS_VOLUME_MOUNTED_ON_NT4		= const_cpu_to_le16(0x0008),
+	NTFS_VOLUME_DELETE_USN_UNDERWAY	= const_cpu_to_le16(0x0010),
+	NTFS_VOLUME_REPAIR_OBJECT_ID		= const_cpu_to_le16(0x0020),
+	NTFS_VOLUME_CHKDSK_UNDERWAY		= const_cpu_to_le16(0x4000),
+	NTFS_VOLUME_MODIFIED_BY_CHKDSK	= const_cpu_to_le16(0x8000),
+	NTFS_VOLUME_FLAGS_MASK		= const_cpu_to_le16(0xc03f),
+} __attribute__((__packed__)) NTFS_VOLUME_FLAGS;
+
+/**
+ * struct NTFS_VOLUME_INFORMATION - Attribute: Volume information (0x70).
+ *
+ * NOTE: Always resident.
+ * NOTE: Present only in NTFS_FILE_Volume.
+ * NOTE: Windows 2000 uses NTFS 3.0 while Windows NT4 service pack 6a uses
+ *	 NTFS 1.2. I haven't personally seen other values yet.
+ */
+typedef struct {
+	le64 reserved;		/* Not used (yet?). */
+	u8 major_ver;		/* Major version of the ntfs format. */
+	u8 minor_ver;		/* Minor version of the ntfs format. */
+	NTFS_VOLUME_FLAGS flags;	/* Bit array of VOLUME_* flags. */
+} __attribute__((__packed__)) NTFS_VOLUME_INFORMATION;
+
+/**
+ * struct NTFS_DATA_ATTR - Attribute: Data attribute (0x80).
+ *
+ * NOTE: Can be resident or non-resident.
+ *
+ * Data contents of a file (i.e. the unnamed stream) or of a named stream.
+ */
+typedef struct {
+	u8 data[0];		/* The file's data contents. */
+} __attribute__((__packed__)) NTFS_DATA_ATTR;
+
+/**
+ * enum NTFS_INDEX_HEADER_FLAGS - Index header flags (8-bit).
+ */
+typedef enum {
+	/* When index header is in an index root attribute: */
+	NTFS_SMALL_INDEX	= 0, /* The index is small enough to fit inside the
+				index root attribute and there is no index
+				allocation attribute present. */
+	NTFS_LARGE_INDEX	= 1, /* The index is too large to fit in the index
+				root attribute and/or an index allocation
+				attribute is present. */
+	/*
+	 * When index header is in an index block, i.e. is part of index
+	 * allocation attribute:
+	 */
+	NTFS_LEAF_NODE	= 0, /* This is a leaf node, i.e. there are no more
+				nodes branching off it. */
+	NTFS_INDEX_NODE	= 1, /* This node indexes other nodes, i.e. is not a
+				leaf node. */
+	NTFS_NODE_MASK	= 1, /* Mask for accessing the *_NODE bits. */
+} __attribute__((__packed__)) NTFS_INDEX_HEADER_FLAGS;
+
+/**
+ * struct NTFS_INDEX_HEADER -
+ *
+ * This is the header for indexes, describing the NTFS_INDEX_ENTRY records, which
+ * follow the NTFS_INDEX_HEADER. Together the index header and the index entries
+ * make up a complete index.
+ *
+ * IMPORTANT NOTE: The offset, length and size structure members are counted
+ * relative to the start of the index header structure and not relative to the
+ * start of the index root or index allocation structures themselves.
+ */
+typedef struct {
+	le32 entries_offset;		/* Byte offset to first NTFS_INDEX_ENTRY
+					   aligned to 8-byte boundary. */
+	le32 index_length;		/* Data size of the index in bytes,
+					   i.e. bytes used from allocated
+					   size, aligned to 8-byte boundary. */
+	le32 allocated_size;		/* Byte size of this index (block),
+					   multiple of 8 bytes. */
+	/* NOTE: For the index root attribute, the above two numbers are always
+	   equal, as the attribute is resident and it is resized as needed. In
+	   the case of the index allocation attribute the attribute is not
+	   resident and hence the allocated_size is a fixed value and must
+	   equal the index_block_size specified by the NTFS_INDEX_ROOT attribute
+	   corresponding to the NTFS_INDEX_ALLOCATION attribute this NTFS_INDEX_BLOCK
+	   belongs to. */
+	NTFS_INDEX_HEADER_FLAGS flags;	/* Bit field of NTFS_INDEX_HEADER_FLAGS. */
+	u8 reserved[3];			/* Reserved/align to 8-byte boundary. */
+} __attribute__((__packed__)) NTFS_INDEX_HEADER;
+
+/**
+ * struct NTFS_INDEX_ROOT - Attribute: Index root (0x90).
+ *
+ * NOTE: Always resident.
+ *
+ * This is followed by a sequence of index entries (NTFS_INDEX_ENTRY structures)
+ * as described by the index header.
+ *
+ * When a directory is small enough to fit inside the index root then this
+ * is the only attribute describing the directory. When the directory is too
+ * large to fit in the index root, on the other hand, two additional attributes
+ * are present: an index allocation attribute, containing sub-nodes of the B+
+ * directory tree (see below), and a bitmap attribute, describing which virtual
+ * cluster numbers (VCNs) in the index allocation attribute are in use by an
+ * index block.
+ *
+ * NOTE: The root directory (NTFS_FILE_root) contains an entry for itself. Other
+ * directories do not contain entries for themselves, though.
+ */
+typedef struct {
+	NTFS_ATTR_TYPES type;		/* Type of the indexed attribute. Is
+					   $FILE_NAME for directories, zero
+					   for view indexes. No other values
+					   allowed. */
+	NTFS_COLLATION_RULES collation_rule;	/* Collation rule used to sort the
+					   index entries. If type is $FILE_NAME,
+					   this must be NTFS_COLLATION_FILE_NAME. */
+	le32 index_block_size;		/* Size of each index block in bytes (in
+					   the index allocation attribute). */
+	u8 clusters_per_index_block;	/* Cluster size of each index block (in
+					   the index allocation attribute), when
+					   an index block is >= than a cluster,
+					   otherwise sectors per index block. */
+	u8 reserved[3];			/* Reserved/align to 8-byte boundary. */
+	NTFS_INDEX_HEADER index;		/* Index header describing the
+					   following index entries. */
+} __attribute__((__packed__)) NTFS_INDEX_ROOT;
+
+/**
+ * struct NTFS_INDEX_BLOCK - Attribute: Index allocation (0xa0).
+ *
+ * NOTE: Always non-resident (doesn't make sense to be resident anyway!).
+ *
+ * This is an array of index blocks. Each index block starts with an
+ * NTFS_INDEX_BLOCK structure containing an index header, followed by a sequence of
+ * index entries (NTFS_INDEX_ENTRY structures), as described by the NTFS_INDEX_HEADER.
+ */
+typedef struct {
+/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_RECORD_TYPES magic;/* Magic is "INDX". */
+	le16 usa_ofs;		/* See NTFS_RECORD definition. */
+	le16 usa_count;		/* See NTFS_RECORD definition. */
+
+/*  8*/	NTFS_leLSN lsn;		/* $LogFile sequence number of the last
+				   modification of this index block. */
+/* 16*/	NTFS_leVCN index_block_vcn;	/* Virtual cluster number of the index block. */
+/* 24*/	NTFS_INDEX_HEADER index;	/* Describes the following index entries. */
+/* sizeof()= 40 (0x28) bytes */
+/*
+ * When creating the index block, we place the update sequence array at this
+ * offset, i.e. before we start with the index entries. This also makes sense,
+ * otherwise we could run into problems with the update sequence array
+ * containing in itself the last two bytes of a sector which would mean that
+ * multi sector transfer protection wouldn't work. As you can't protect data
+ * by overwriting it since you then can't get it back...
+ * When reading use the data from the ntfs record header.
+ */
+} __attribute__((__packed__)) NTFS_INDEX_BLOCK;
+
+typedef NTFS_INDEX_BLOCK NTFS_INDEX_ALLOCATION;
+
+/**
+ * struct NTFS_REPARSE_INDEX_KEY -
+ *
+ * The system file NTFS_FILE_Extend/$Reparse contains an index named $R listing
+ * all reparse points on the volume. The index entry keys are as defined
+ * below. Note, that there is no index data associated with the index entries.
+ *
+ * The index entries are sorted by the index key file_id. The collation rule is
+ * NTFS_COLLATION_NTOFS_ULONGS. FIXME: Verify whether the reparse_tag is not the
+ * primary key / is not a key at all. (AIA)
+ */
+typedef struct {
+	le32 reparse_tag;	/* Reparse point type (inc. flags). */
+	NTFS_leMFT_REF file_id;	/* Mft record of the file containing the
+				   reparse point attribute. */
+} __attribute__((__packed__)) NTFS_REPARSE_INDEX_KEY;
+
+/**
+ * enum NTFS_QUOTA_FLAGS - Quota flags (32-bit).
+ */
+typedef enum {
+	/* The user quota flags. Names explain meaning. */
+	NTFS_QUOTA_FLAG_DEFAULT_LIMITS	= const_cpu_to_le32(0x00000001),
+	NTFS_QUOTA_FLAG_LIMIT_REACHED	= const_cpu_to_le32(0x00000002),
+	NTFS_QUOTA_FLAG_ID_DELETED		= const_cpu_to_le32(0x00000004),
+
+	NTFS_QUOTA_FLAG_USER_MASK		= const_cpu_to_le32(0x00000007),
+		/* Bit mask for user quota flags. */
+
+	/* These flags are only present in the quota defaults index entry,
+	   i.e. in the entry where owner_id = NTFS_QUOTA_DEFAULTS_ID. */
+	NTFS_QUOTA_FLAG_TRACKING_ENABLED	= const_cpu_to_le32(0x00000010),
+	NTFS_QUOTA_FLAG_ENFORCEMENT_ENABLED	= const_cpu_to_le32(0x00000020),
+	NTFS_QUOTA_FLAG_TRACKING_REQUESTED	= const_cpu_to_le32(0x00000040),
+	NTFS_QUOTA_FLAG_LOG_THRESHOLD	= const_cpu_to_le32(0x00000080),
+	NTFS_QUOTA_FLAG_LOG_LIMIT		= const_cpu_to_le32(0x00000100),
+	NTFS_QUOTA_FLAG_OUT_OF_DATE		= const_cpu_to_le32(0x00000200),
+	NTFS_QUOTA_FLAG_CORRUPT		= const_cpu_to_le32(0x00000400),
+	NTFS_QUOTA_FLAG_PENDING_DELETES	= const_cpu_to_le32(0x00000800),
+} NTFS_QUOTA_FLAGS;
+
+/**
+ * struct NTFS_QUOTA_CONTROL_ENTRY -
+ *
+ * The system file NTFS_FILE_Extend/$Quota contains two indexes $O and $Q. Quotas
+ * are on a per volume and per user basis.
+ *
+ * The $Q index contains one entry for each existing user_id on the volume. The
+ * index key is the user_id of the user/group owning this quota control entry,
+ * i.e. the key is the owner_id. The user_id of the owner of a file, i.e. the
+ * owner_id, is found in the standard information attribute. The collation rule
+ * for $Q is NTFS_COLLATION_NTOFS_ULONG.
+ *
+ * The $O index contains one entry for each user/group who has been assigned
+ * a quota on that volume. The index key holds the NTFS_SID of the user_id the
+ * entry belongs to, i.e. the owner_id. The collation rule for $O is
+ * NTFS_COLLATION_NTOFS_SID.
+ *
+ * The $O index entry data is the user_id of the user corresponding to the NTFS_SID.
+ * This user_id is used as an index into $Q to find the quota control entry
+ * associated with the NTFS_SID.
+ *
+ * The $Q index entry data is the quota control entry and is defined below.
+ */
+typedef struct {
+	le32 version;		/* Currently equals 2. */
+	NTFS_QUOTA_FLAGS flags;	/* Flags describing this quota entry. */
+	le64 bytes_used;	/* How many bytes of the quota are in use. */
+	sle64 change_time;	/* Last time this quota entry was changed. */
+	sle64 threshold;	/* Soft quota (-1 if not limited). */
+	sle64 limit;		/* Hard quota (-1 if not limited). */
+	sle64 exceeded_time;	/* How long the soft quota has been exceeded. */
+/* The below field is NOT present for the quota defaults entry. */
+	NTFS_SID sid;		/* The NTFS_SID of the user/object associated with
+				   this quota entry. If this field is missing
+				   then the NTFS_INDEX_ENTRY is padded with zeros
+				   to multiply of 8 which are not counted in
+				   the data_length field. If the NTFS_SID is present
+				   then this structure is padded with zeros to
+				   multiply of 8 and the padding is counted in
+				   the NTFS_INDEX_ENTRY's data_length. */
+} __attribute__((__packed__)) NTFS_QUOTA_CONTROL_ENTRY;
+
+/**
+ * struct NTFS_QUOTA_O_INDEX_DATA -
+ */
+typedef struct {
+	le32 owner_id;
+	le32 unknown;		/* Always 32. Seems to be padding and it's not
+				   counted in the NTFS_INDEX_ENTRY's data_length.
+				   This field shouldn't be really here. */
+} __attribute__((__packed__)) NTFS_QUOTA_O_INDEX_DATA;
+
+/**
+ * enum NTFS_PREDEFINED_OWNER_IDS - Predefined owner_id values (32-bit).
+ */
+typedef enum {
+	NTFS_QUOTA_INVALID_ID	= const_cpu_to_le32(0x00000000),
+	NTFS_QUOTA_DEFAULTS_ID	= const_cpu_to_le32(0x00000001),
+	NTFS_QUOTA_FIRST_USER_ID	= const_cpu_to_le32(0x00000100),
+} NTFS_PREDEFINED_OWNER_IDS;
+
+/**
+ * enum NTFS_INDEX_ENTRY_FLAGS - Index entry flags (16-bit).
+ */
+typedef enum {
+	NTFS_INDEX_ENTRY_NODE = const_cpu_to_le16(1), /* This entry contains a
+					sub-node, i.e. a reference to an index
+					block in form of a virtual cluster
+					number (see below). */
+	NTFS_INDEX_ENTRY_END  = const_cpu_to_le16(2), /* This signifies the last
+					entry in an index block. The index
+					entry does not represent a file but it
+					can point to a sub-node. */
+	NTFS_INDEX_ENTRY_SPACE_FILLER = const_cpu_to_le16(0xffff),
+					/* Just to force 16-bit width. */
+} __attribute__((__packed__)) NTFS_INDEX_ENTRY_FLAGS;
+
+/**
+ * struct NTFS_INDEX_ENTRY_HEADER - This the index entry header (see below).
+ */
+typedef struct {
+/*  0*/	union {		/* Only valid when NTFS_INDEX_ENTRY_END is not set. */
+		NTFS_leMFT_REF indexed_file;		/* The mft reference of the file
+						   described by this index
+						   entry. Used for directory
+						   indexes. */
+		struct { /* Used for views/indexes to find the entry's data. */
+			le16 data_offset;	/* Data byte offset from this
+						   NTFS_INDEX_ENTRY. Follows the
+						   index key. */
+			le16 data_length;	/* Data length in bytes. */
+			le32 reservedV;	/* Reserved (zero). */
+		} __attribute__((__packed__));
+	} __attribute__((__packed__));
+/*  8*/	le16 length;		 /* Byte size of this index entry, multiple of
+				    8-bytes. */
+/* 10*/	le16 key_length;		 /* Byte size of the key value, which is in the
+				    index entry. It follows field reserved. Not
+				    multiple of 8-bytes. */
+/* 12*/	NTFS_INDEX_ENTRY_FLAGS flags; /* Bit field of INDEX_ENTRY_* flags. */
+/* 14*/	le16 reserved;		 /* Reserved/align to 8-byte boundary. */
+/* sizeof() = 16 bytes */
+} __attribute__((__packed__)) NTFS_INDEX_ENTRY_HEADER;
+
+/**
+ * struct NTFS_INDEX_ENTRY - This is an index entry.
+ *
+ * A sequence of such entries follows each NTFS_INDEX_HEADER structure. Together
+ * they make up a complete index. The index follows either an index root
+ * attribute or an index allocation attribute.
+ *
+ * NOTE: Before NTFS 3.0 only filename attributes were indexed.
+ */
+typedef struct {
+/*  0	NTFS_INDEX_ENTRY_HEADER; -- Unfolded here as gcc dislikes unnamed structs. */
+	union {		/* Only valid when NTFS_INDEX_ENTRY_END is not set. */
+		NTFS_leMFT_REF indexed_file;		/* The mft reference of the file
+						   described by this index
+						   entry. Used for directory
+						   indexes. */
+		struct { /* Used for views/indexes to find the entry's data. */
+			le16 data_offset;	/* Data byte offset from this
+						   NTFS_INDEX_ENTRY. Follows the
+						   index key. */
+			le16 data_length;	/* Data length in bytes. */
+			le32 reservedV;		/* Reserved (zero). */
+		} __attribute__((__packed__));
+	} __attribute__((__packed__));
+	le16 length;		 /* Byte size of this index entry, multiple of
+				    8-bytes. */
+	le16 key_length;	 /* Byte size of the key value, which is in the
+				    index entry. It follows field reserved. Not
+				    multiple of 8-bytes. */
+	NTFS_INDEX_ENTRY_FLAGS flags; /* Bit field of INDEX_ENTRY_* flags. */
+	le16 reserved;		 /* Reserved/align to 8-byte boundary. */
+
+/* 16*/	union {		/* The key of the indexed attribute. NOTE: Only present
+			   if NTFS_INDEX_ENTRY_END bit in flags is not set. NOTE: On
+			   NTFS versions before 3.0 the only valid key is the
+			   NTFS_FILE_NAME_ATTR. On NTFS 3.0+ the following
+			   additional index keys are defined: */
+		NTFS_FILE_NAME_ATTR file_name;/* $I30 index in directories. */
+		NTFS_SII_INDEX_KEY sii;	/* $SII index in $Secure. */
+		NTFS_SDH_INDEX_KEY sdh;	/* $SDH index in $Secure. */
+		NTFS_GUID object_id;		/* $O index in NTFS_FILE_Extend/$ObjId: The
+					   object_id of the mft record found in
+					   the data part of the index. */
+		NTFS_REPARSE_INDEX_KEY reparse;	/* $R index in
+						   NTFS_FILE_Extend/$Reparse. */
+		NTFS_SID sid;		/* $O index in NTFS_FILE_Extend/$Quota:
+					   NTFS_SID of the owner of the user_id. */
+		le32 owner_id;		/* $Q index in NTFS_FILE_Extend/$Quota:
+					   user_id of the owner of the quota
+					   control entry in the data part of
+					   the index. */
+	} __attribute__((__packed__)) key;
+	/* The (optional) index data is inserted here when creating. */
+	/* NTFS_VCN vcn; */	/* If NTFS_INDEX_ENTRY_NODE bit in flags is set, the last
+			   eight bytes of this index entry contain the virtual
+			   cluster number of the index block that holds the
+			   entries immediately preceding the current entry (the
+			   vcn references the corresponding cluster in the data
+			   of the non-resident index allocation attribute). If
+			   the key_length is zero, then the vcn immediately
+			   follows the NTFS_INDEX_ENTRY_HEADER. Regardless of
+			   key_length, the address of the 8-byte boundary
+			   aligned vcn of NTFS_INDEX_ENTRY{_HEADER} *ie is given by
+			   (char*)ie + le16_to_cpu(ie->length) - sizeof(NTFS_VCN),
+			   where sizeof(NTFS_VCN) can be hardcoded as 8 if wanted. */
+} __attribute__((__packed__)) NTFS_INDEX_ENTRY;
+
+/**
+ * struct NTFS_BITMAP_ATTR - Attribute: Bitmap (0xb0).
+ *
+ * Contains an array of bits (aka a bitfield).
+ *
+ * When used in conjunction with the index allocation attribute, each bit
+ * corresponds to one index block within the index allocation attribute. Thus
+ * the number of bits in the bitmap * index block size / cluster size is the
+ * number of clusters in the index allocation attribute.
+ */
+typedef struct {
+	u8 bitmap[0];			/* Array of bits. */
+} __attribute__((__packed__)) NTFS_BITMAP_ATTR;
+
+/**
+ * enum NTFS_PREDEFINED_REPARSE_TAGS -
+ *
+ * The reparse point tag defines the type of the reparse point. It also
+ * includes several flags, which further describe the reparse point.
+ *
+ * The reparse point tag is an unsigned 32-bit value divided in three parts:
+ *
+ * 1. The least significant 16 bits (i.e. bits 0 to 15) specify the type of
+ *    the reparse point.
+ * 2. The 13 bits after this (i.e. bits 16 to 28) are reserved for future use.
+ * 3. The most significant three bits are flags describing the reparse point.
+ *    They are defined as follows:
+ *	bit 29: Name surrogate bit. If set, the filename is an alias for
+ *		another object in the system.
+ *	bit 30: High-latency bit. If set, accessing the first byte of data will
+ *		be slow. (E.g. the data is stored on a tape drive.)
+ *	bit 31: Microsoft bit. If set, the tag is owned by Microsoft. User
+ *		defined tags have to use zero here.
+ */
+typedef enum {
+	NTFS_IO_REPARSE_TAG_IS_ALIAS		= const_cpu_to_le32(0x20000000),
+	NTFS_IO_REPARSE_TAG_IS_HIGH_LATENCY	= const_cpu_to_le32(0x40000000),
+	NTFS_IO_REPARSE_TAG_IS_MICROSOFT	= const_cpu_to_le32(0x80000000),
+
+	NTFS_IO_REPARSE_TAG_RESERVED_ZERO	= const_cpu_to_le32(0x00000000),
+	NTFS_IO_REPARSE_TAG_RESERVED_ONE	= const_cpu_to_le32(0x00000001),
+	NTFS_IO_REPARSE_TAG_RESERVED_RANGE	= const_cpu_to_le32(0x00000001),
+
+	NTFS_IO_REPARSE_TAG_NSS		= const_cpu_to_le32(0x68000005),
+	NTFS_IO_REPARSE_TAG_NSS_RECOVER	= const_cpu_to_le32(0x68000006),
+	NTFS_IO_REPARSE_TAG_SIS		= const_cpu_to_le32(0x68000007),
+	NTFS_IO_REPARSE_TAG_DFS		= const_cpu_to_le32(0x68000008),
+
+	NTFS_IO_REPARSE_TAG_MOUNT_POINT	= const_cpu_to_le32(0x88000003),
+
+	NTFS_IO_REPARSE_TAG_HSM		= const_cpu_to_le32(0xa8000004),
+
+	NTFS_IO_REPARSE_TAG_SYMBOLIC_LINK	= const_cpu_to_le32(0xe8000000),
+
+	NTFS_IO_REPARSE_TAG_VALID_VALUES	= const_cpu_to_le32(0xe000ffff),
+} NTFS_PREDEFINED_REPARSE_TAGS;
+
+/**
+ * struct NTFS_REPARSE_POINT - Attribute: Reparse point (0xc0).
+ *
+ * NOTE: Can be resident or non-resident.
+ */
+typedef struct {
+	le32 reparse_tag;		/* Reparse point type (inc. flags). */
+	le16 reparse_data_length;	/* Byte size of reparse data. */
+	le16 reserved;			/* Align to 8-byte boundary. */
+	u8 reparse_data[0];		/* Meaning depends on reparse_tag. */
+} __attribute__((__packed__)) NTFS_REPARSE_POINT;
+
+/**
+ * struct NTFS_EA_INFORMATION - Attribute: Extended attribute information (0xd0).
+ *
+ * NOTE: Always resident.
+ */
+typedef struct {
+	le16 ea_length;		/* Byte size of the packed extended
+				   attributes. */
+	le16 need_ea_count;	/* The number of extended attributes which have
+				   the NTFS_NEED_EA bit set. */
+	le32 ea_query_length;	/* Byte size of the buffer required to query
+				   the extended attributes when calling
+				   ZwQueryEaFile() in Windows NT/2k. I.e. the
+				   byte size of the unpacked extended
+				   attributes. */
+} __attribute__((__packed__)) NTFS_EA_INFORMATION;
+
+/**
+ * enum NTFS_EA_FLAGS - Extended attribute flags (8-bit).
+ */
+typedef enum {
+	NTFS_NEED_EA	= 0x80,		/* Indicate that the file to which the EA
+				   belongs cannot be interpreted without
+				   understanding the associated extended
+				   attributes. */
+} __attribute__((__packed__)) NTFS_EA_FLAGS;
+
+/**
+ * struct NTFS_EA_ATTR - Attribute: Extended attribute (EA) (0xe0).
+ *
+ * Like the attribute list and the index buffer list, the EA attribute value is
+ * a sequence of NTFS_EA_ATTR variable length records.
+ *
+ * FIXME: It appears weird that the EA name is not Unicode. Is it true?
+ * FIXME: It seems that name is always uppercased. Is it true?
+ */
+typedef struct {
+	le32 next_entry_offset;	/* Offset to the next NTFS_EA_ATTR. */
+	NTFS_EA_FLAGS flags;		/* Flags describing the EA. */
+	u8 name_length;		/* Length of the name of the extended
+				   attribute in bytes. */
+	le16 value_length;	/* Byte size of the EA's value. */
+	u8 name[0];		/* Name of the EA. */
+	u8 value[0];		/* The value of the EA. Immediately
+				   follows the name. */
+} __attribute__((__packed__)) NTFS_EA_ATTR;
+
+/**
+ * struct NTFS_PROPERTY_SET - Attribute: Property set (0xf0).
+ *
+ * Intended to support Native Structure Storage (NSS) - a feature removed from
+ * NTFS 3.0 during beta testing.
+ */
+typedef struct {
+	/* Irrelevant as feature unused. */
+} __attribute__((__packed__)) NTFS_PROPERTY_SET;
+
+/**
+ * struct NTFS_LOGGED_UTILITY_STREAM - Attribute: Logged utility stream (0x100).
+ *
+ * NOTE: Can be resident or non-resident.
+ *
+ * Operations on this attribute are logged to the journal ($LogFile) like
+ * normal metadata changes.
+ *
+ * Used by the Encrypting File System (EFS).  All encrypted files have this
+ * attribute with the name $EFS.  See below for the relevant structures.
+ */
+typedef struct {
+	/* Can be anything the creator chooses. */
+} __attribute__((__packed__)) NTFS_LOGGED_UTILITY_STREAM;
+
+/*
+ * $EFS Data Structure:
+ *
+ * The following information is about the data structures that are contained
+ * inside a logged utility stream (0x100) with a name of "$EFS".
+ *
+ * The stream starts with an instance of NTFS_EFS_ATTR_HEADER.
+ *
+ * Next, at offsets offset_to_ddf_array and offset_to_drf_array (unless any of
+ * them is 0) there is a NTFS_EFS_DF_ARRAY_HEADER immediately followed by a sequence
+ * of multiple data decryption/recovery fields.
+ *
+ * Each data decryption/recovery field starts with a NTFS_EFS_DF_HEADER and the next
+ * one (if it exists) can be found by adding NTFS_EFS_DF_HEADER->df_length bytes to
+ * the offset of the beginning of the current NTFS_EFS_DF_HEADER.
+ *
+ * The data decryption/recovery field contains an EFS_DF_CERTIFICATE_HEADER, a
+ * NTFS_SID, an optional NTFS_GUID, an optional container name, a non-optional user name,
+ * and the encrypted FEK.
+ *
+ * Note all the below are best guesses so may have mistakes/inaccuracies.
+ * Corrections/clarifications/additions are always welcome!
+ *
+ * Ntfs.sys takes an EFS value length of <= 0x54 or > 0x40000 to BSOD, i.e. it
+ * is invalid.
+ */
+
+/**
+ * struct NTFS_EFS_ATTR_HEADER - "$EFS" header.
+ *
+ * The header of the Logged utility stream (0x100) attribute named "$EFS".
+ */
+typedef struct {
+/*  0*/	le32 length;		/* Length of EFS attribute in bytes. */
+	le32 state;		/* Always 0? */
+	le32 version;		/* Efs version.  Always 2? */
+	le32 crypto_api_version;	/* Always 0? */
+/* 16*/	u8 unknown4[16];	/* MD5 hash of decrypted FEK?  This field is
+				   created with a call to UuidCreate() so is
+				   unlikely to be an MD5 hash and is more
+				   likely to be NTFS_GUID of this encrytped file
+				   or something like that. */
+/* 32*/	u8 unknown5[16];	/* MD5 hash of DDFs? */
+/* 48*/	u8 unknown6[16];	/* MD5 hash of DRFs? */
+/* 64*/	le32 offset_to_ddf_array;/* Offset in bytes to the array of data
+				   decryption fields (DDF), see below.  Zero if
+				   no DDFs are present. */
+	le32 offset_to_drf_array;/* Offset in bytes to the array of data
+				   recovery fields (DRF), see below.  Zero if
+				   no DRFs are present. */
+	le32 reserved;		/* Reserved. */
+} __attribute__((__packed__)) NTFS_EFS_ATTR_HEADER;
+
+/**
+ * struct NTFS_EFS_DF_ARRAY_HEADER -
+ */
+typedef struct {
+	le32 df_count;		/* Number of data decryption/recovery fields in
+				   the array. */
+} __attribute__((__packed__)) NTFS_EFS_DF_ARRAY_HEADER;
+
+/**
+ * struct NTFS_EFS_DF_HEADER -
+ */
+typedef struct {
+/*  0*/	le32 df_length;		/* Length of this data decryption/recovery
+				   field in bytes. */
+	le32 cred_header_offset;/* Offset in bytes to the credential header. */
+	le32 fek_size;		/* Size in bytes of the encrypted file
+				   encryption key (FEK). */
+	le32 fek_offset;	/* Offset in bytes to the FEK from the start of
+				   the data decryption/recovery field. */
+/* 16*/	le32 unknown1;		/* always 0?  Might be just padding. */
+} __attribute__((__packed__)) NTFS_EFS_DF_HEADER;
+
+/**
+ * struct NTFS_EFS_DF_CREDENTIAL_HEADER -
+ */
+typedef struct {
+/*  0*/	le32 cred_length;	/* Length of this credential in bytes. */
+	le32 sid_offset;	/* Offset in bytes to the user's sid from start
+				   of this structure.  Zero if no sid is
+				   present. */
+/*  8*/	le32 type;		/* Type of this credential:
+					1 = CryptoAPI container.
+					2 = Unexpected type.
+					3 = Certificate thumbprint.
+					other = Unknown type. */
+	union {
+		/* CryptoAPI container. */
+		struct {
+/* 12*/			le32 container_name_offset;	/* Offset in bytes to
+				   the name of the container from start of this
+				   structure (may not be zero). */
+/* 16*/			le32 provider_name_offset;	/* Offset in bytes to
+				   the name of the provider from start of this
+				   structure (may not be zero). */
+			le32 public_key_blob_offset;	/* Offset in bytes to
+				   the public key blob from start of this
+				   structure. */
+/* 24*/			le32 public_key_blob_size;	/* Size in bytes of
+				   public key blob. */
+		} __attribute__((__packed__));
+		/* Certificate thumbprint. */
+		struct {
+/* 12*/			le32 cert_thumbprint_header_size;	/* Size in
+				   bytes of the header of the certificate
+				   thumbprint. */
+/* 16*/			le32 cert_thumbprint_header_offset;	/* Offset in
+				   bytes to the header of the certificate
+				   thumbprint from start of this structure. */
+			le32 unknown1;	/* Always 0?  Might be padding... */
+			le32 unknown2;	/* Always 0?  Might be padding... */
+		} __attribute__((__packed__));
+	} __attribute__((__packed__));
+} __attribute__((__packed__)) NTFS_EFS_DF_CREDENTIAL_HEADER;
+
+typedef NTFS_EFS_DF_CREDENTIAL_HEADER NTFS_EFS_DF_CRED_HEADER;
+
+/**
+ * struct NTFS_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER -
+ */
+typedef struct {
+/*  0*/	le32 thumbprint_offset;		/* Offset in bytes to the thumbprint. */
+	le32 thumbprint_size;		/* Size of thumbprint in bytes. */
+/*  8*/	le32 container_name_offset;	/* Offset in bytes to the name of the
+					   container from start of this
+					   structure or 0 if no name present. */
+	le32 provider_name_offset;	/* Offset in bytes to the name of the
+					   cryptographic provider from start of
+					   this structure or 0 if no name
+					   present. */
+/* 16*/	le32 user_name_offset;		/* Offset in bytes to the user name
+					   from start of this structure or 0 if
+					   no user name present.  (This is also
+					   known as lpDisplayInformation.) */
+} __attribute__((__packed__)) NTFS_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER;
+
+typedef NTFS_EFS_DF_CERTIFICATE_THUMBPRINT_HEADER NTFS_EFS_DF_CERT_THUMBPRINT_HEADER;
+
+typedef enum {
+	NTFS_INTX_SYMBOLIC_LINK =
+		const_cpu_to_le64(0x014B4E4C78746E49ULL), /* "IntxLNK\1" */
+	NTFS_INTX_CHARACTER_DEVICE =
+		const_cpu_to_le64(0x0052484378746E49ULL), /* "IntxCHR\0" */
+	NTFS_INTX_BLOCK_DEVICE =
+		const_cpu_to_le64(0x004B4C4278746E49ULL), /* "IntxBLK\0" */
+} NTFS_INTX_FILE_TYPES;
+
+typedef struct {
+	NTFS_INTX_FILE_TYPES magic;		/* Intx file magic. */
+	union {
+		/* For character and block devices. */
+		struct {
+			le64 major;		/* Major device number. */
+			le64 minor;		/* Minor device number. */
+			void *device_end[0];	/* Marker for offsetof(). */
+		} __attribute__((__packed__));
+		/* For symbolic links. */
+		ntfschar target[0];
+	} __attribute__((__packed__));
+} __attribute__((__packed__)) NTFS_INTX_FILE;
+
+__END_DECLS
+
+#endif /* defined _NTFS_LAYOUT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_lcnalloc.h ./include/ntfs/ntfs_lcnalloc.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_lcnalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_lcnalloc.h	2007-10-06 16:58:22.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * lcnalloc.h - Exports for cluster (de)allocation. Part of the Linux-NTFS
+ *		project.
+ *
+ * Copyright (c) 2002 Anton Altaparmakov
+ * Copyright (c) 2004 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_LCNALLOC_H
+#define _NTFS_LCNALLOC_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_runlist.h"
+#include "ntfs_volume.h"
+
+__BEGIN_DECLS
+
+/**
+ * enum NTFS_CLUSTER_ALLOCATION_ZONES -
+ */
+typedef enum {
+	NTFS_FIRST_ZONE	= 0,	/* For sanity checking. */
+	NTFS_MFT_ZONE	= 0,	/* Allocate from $MFT zone. */
+	NTFS_DATA_ZONE	= 1,	/* Allocate from $DATA zone. */
+	NTFS_LAST_ZONE	= 1,	/* For sanity checking. */
+} NTFS_CLUSTER_ALLOCATION_ZONES;
+
+extern ntfs_runlist *ntfs_cluster_alloc(ntfs_volume *vol, NTFS_VCN start_vcn, s64 count,
+		NTFS_LCN start_lcn, const NTFS_CLUSTER_ALLOCATION_ZONES zone);
+
+extern int ntfs_cluster_free_from_rl(ntfs_volume *vol, ntfs_runlist *rl);
+
+extern int ntfs_cluster_free(ntfs_volume *vol, ntfs_attr *na, NTFS_VCN start_vcn,
+		s64 count);
+
+__END_DECLS
+
+#endif /* defined _NTFS_LCNALLOC_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_list.h ./include/ntfs/ntfs_list.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_list.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_list.h	2007-10-06 16:58:49.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ * list.h - Linked list implementation. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2002 Anton Altaparmakov and others
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_LIST_H
+#define _NTFS_LIST_H 1
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+/**
+ * struct ntfs_list_head - Simple doubly linked list implementation.
+ *
+ * Copied from Linux kernel 2.4.2-ac18 into Linux-NTFS (with minor
+ * modifications). - AIA
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+struct ntfs_list_head {
+	struct ntfs_list_head *next, *prev;
+};
+
+#define NTFS_LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define NTFS_LIST_HEAD(name) \
+	struct ntfs_list_head name = NTFS_LIST_HEAD_INIT(name)
+
+#define NTFS_INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/**
+ * __ntfs_list_add - Insert a new entry between two known consecutive entries.
+ * @new:
+ * @prev:
+ * @next:
+ *
+ * This is only for internal list manipulation where we know the prev/next
+ * entries already!
+ */
+static __inline__ void __ntfs_list_add(struct ntfs_list_head * new,
+		struct ntfs_list_head * prev, struct ntfs_list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * ntfs_list_add - add a new entry
+ * @new:	new entry to be added
+ * @head:	list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void ntfs_list_add(struct ntfs_list_head *new, struct ntfs_list_head *head)
+{
+	__ntfs_list_add(new, head, head->next);
+}
+
+/**
+ * ntfs_list_add_tail - add a new entry
+ * @new:	new entry to be added
+ * @head:	list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void ntfs_list_add_tail(struct ntfs_list_head *new, struct ntfs_list_head *head)
+{
+	__ntfs_list_add(new, head->prev, head);
+}
+
+/**
+ * __ntfs_list_del -
+ * @prev:
+ * @next:
+ *
+ * Delete a list entry by making the prev/next entries point to each other.
+ *
+ * This is only for internal list manipulation where we know the prev/next
+ * entries already!
+ */
+static __inline__ void __ntfs_list_del(struct ntfs_list_head * prev,
+		struct ntfs_list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * ntfs_list_del - deletes entry from list.
+ * @entry:	the element to delete from the list.
+ *
+ * Note: ntfs_list_empty on entry does not return true after this, the entry is in
+ * an undefined state.
+ */
+static __inline__ void ntfs_list_del(struct ntfs_list_head *entry)
+{
+	__ntfs_list_del(entry->prev, entry->next);
+}
+
+/**
+ * ntfs_list_del_init - deletes entry from list and reinitialize it.
+ * @entry:	the element to delete from the list.
+ */
+static __inline__ void ntfs_list_del_init(struct ntfs_list_head *entry)
+{
+	__ntfs_list_del(entry->prev, entry->next);
+	NTFS_INIT_LIST_HEAD(entry);
+}
+
+/**
+ * ntfs_list_empty - tests whether a list is empty
+ * @head:	the list to test.
+ */
+static __inline__ int ntfs_list_empty(struct ntfs_list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * ntfs_list_splice - join two lists
+ * @list:	the new list to add.
+ * @head:	the place to add it in the first list.
+ */
+static __inline__ void ntfs_list_splice(struct ntfs_list_head *list,
+		struct ntfs_list_head *head)
+{
+	struct ntfs_list_head *first = list->next;
+
+	if (first != list) {
+		struct ntfs_list_head *last = list->prev;
+		struct ntfs_list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * ntfs_list_entry - get the struct for this entry
+ * @ptr:	the &struct ntfs_list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define ntfs_list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * ntfs_list_for_each - iterate over a list
+ * @pos:	the &struct ntfs_list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define ntfs_list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * ntfs_list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct ntfs_list_head to use as a loop counter.
+ * @n:		another &struct ntfs_list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define ntfs_list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+__END_DECLS
+
+#endif /* defined _NTFS_LIST_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_logfile.h ./include/ntfs/ntfs_logfile.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_logfile.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_logfile.h	2007-10-06 17:01:45.000000000 +0200
@@ -0,0 +1,400 @@
+/*
+ * logfile.h - Exports for $LogFile handling.  Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2005 Anton Altaparmakov
+ * Copyright (c) 2005-2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_LOGFILE_H
+#define _NTFS_LOGFILE_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_endians.h"
+#include "ntfs_layout.h"
+
+__BEGIN_DECLS
+
+/*
+ * Journal ($LogFile) organization:
+ *
+ * Two restart areas present in the first two pages (restart pages, one restart
+ * area in each page).  When the volume is dismounted they should be identical,
+ * except for the update sequence array which usually has a different update
+ * sequence number.
+ *
+ * These are followed by log records organized in pages headed by a log record
+ * header going up to log file size.  Not all pages contain log records when a
+ * volume is first formatted, but as the volume ages, all records will be used.
+ * When the log file fills up, the records at the beginning are purged (by
+ * modifying the oldest_lsn to a higher value presumably) and writing begins
+ * at the beginning of the file.  Effectively, the log file is viewed as a
+ * circular entity.
+ *
+ * NOTE: Windows NT, 2000, and XP all use log file version 1.1 but they accept
+ * versions <= 1.x, including 0.-1.  (Yes, that is a minus one in there!)  We
+ * probably only want to support 1.1 as this seems to be the current version
+ * and we don't know how that differs from the older versions.  The only
+ * exception is if the journal is clean as marked by the two restart pages
+ * then it doesn't matter whether we are on an earlier version.  We can just
+ * reinitialize the logfile and start again with version 1.1.
+ */
+
+/* Some $LogFile related constants. */
+#define NTFS_MaxLogFileSize		0x100000000ULL
+#define NTFS_DefaultLogPageSize	4096
+#define NTFS_MinLogRecordPages	48
+
+/**
+ * struct NTFS_RESTART_PAGE_HEADER - Log file restart page header.
+ *
+ * Begins the restart area.
+ */
+typedef struct {
+/*Ofs*/
+/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
+/*  0*/	NTFS_RECORD_TYPES magic;/* The magic is "RSTR". */
+/*  4*/	le16 usa_ofs;		/* See NTFS_RECORD definition in layout.h.
+				   When creating, set this to be immediately
+				   after this header structure (without any
+				   alignment). */
+/*  6*/	le16 usa_count;		/* See NTFS_RECORD definition in layout.h. */
+
+/*  8*/	NTFS_leLSN chkdsk_lsn;	/* The last log file sequence number found by
+				   chkdsk.  Only used when the magic is changed
+				   to "CHKD".  Otherwise this is zero. */
+/* 16*/	le32 system_page_size;	/* Byte size of system pages when the log file
+				   was created, has to be >= 512 and a power of
+				   2.  Use this to calculate the required size
+				   of the usa (usa_count) and add it to usa_ofs.
+				   Then verify that the result is less than the
+				   value of the restart_area_offset. */
+/* 20*/	le32 log_page_size;	/* Byte size of log file pages, has to be >=
+				   512 and a power of 2.  The default is 4096
+				   and is used when the system page size is
+				   between 4096 and 8192.  Otherwise this is
+				   set to the system page size instead. */
+/* 24*/	le16 restart_area_offset;/* Byte offset from the start of this header to
+				   the NTFS_RESTART_AREA.  Value has to be aligned
+				   to 8-byte boundary.  When creating, set this
+				   to be after the usa. */
+/* 26*/	sle16 minor_ver;	/* Log file minor version.  Only check if major
+				   version is 1. */
+/* 28*/	sle16 major_ver;	/* Log file major version.  We only support
+				   version 1.1. */
+/* sizeof() = 30 (0x1e) bytes */
+} __attribute__((__packed__)) NTFS_RESTART_PAGE_HEADER;
+
+/*
+ * Constant for the log client indices meaning that there are no client records
+ * in this particular client array.  Also inside the client records themselves,
+ * this means that there are no client records preceding or following this one.
+ */
+#define NTFS_LOGFILE_NO_CLIENT	const_cpu_to_le16(0xffff)
+#define NTFS_LOGFILE_NO_CLIENT_CPU	0xffff
+
+/*
+ * These are the so far known RESTART_AREA_* flags (16-bit) which contain
+ * information about the log file in which they are present.
+ */
+enum {
+	NTFS_RESTART_VOLUME_IS_CLEAN	= const_cpu_to_le16(0x0002),
+	NTFS_RESTART_SPACE_FILLER	= const_cpu_to_le16(0xffff),
+				/* gcc: Force enum bit width to 16. */
+} __attribute__((__packed__));
+
+typedef le16 NTFS_RESTART_AREA_FLAGS;
+
+/**
+ * struct NTFS_RESTART_AREA - Log file restart area record.
+ *
+ * The offset of this record is found by adding the offset of the
+ * NTFS_RESTART_PAGE_HEADER to the restart_area_offset value found in it.
+ * See notes at restart_area_offset above.
+ */
+typedef struct {
+/*Ofs*/
+/*  0*/	NTFS_leLSN current_lsn;	/* The current, i.e. last NTFS_LSN inside the log
+				   when the restart area was last written.
+				   This happens often but what is the interval?
+				   Is it just fixed time or is it every time a
+				   check point is written or something else?
+				   On create set to 0. */
+/*  8*/	le16 log_clients;	/* Number of log client records in the array of
+				   log client records which follows this
+				   restart area.  Must be 1.  */
+/* 10*/	le16 client_free_list;	/* The index of the first free log client record
+				   in the array of log client records.
+				   NTFS_LOGFILE_NO_CLIENT means that there are no
+				   free log client records in the array.
+				   If != NTFS_LOGFILE_NO_CLIENT, check that
+				   log_clients > client_free_list.  On Win2k
+				   and presumably earlier, on a clean volume
+				   this is != NTFS_LOGFILE_NO_CLIENT, and it should
+				   be 0, i.e. the first (and only) client
+				   record is free and thus the logfile is
+				   closed and hence clean.  A dirty volume
+				   would have left the logfile open and hence
+				   this would be NTFS_LOGFILE_NO_CLIENT.  On WinXP
+				   and presumably later, the logfile is always
+				   open, even on clean shutdown so this should
+				   always be NTFS_LOGFILE_NO_CLIENT. */
+/* 12*/	le16 client_in_use_list;/* The index of the first in-use log client
+				   record in the array of log client records.
+				   NTFS_LOGFILE_NO_CLIENT means that there are no
+				   in-use log client records in the array.  If
+				   != NTFS_LOGFILE_NO_CLIENT check that log_clients
+				   > client_in_use_list.  On Win2k and
+				   presumably earlier, on a clean volume this
+				   is NTFS_LOGFILE_NO_CLIENT, i.e. there are no
+				   client records in use and thus the logfile
+				   is closed and hence clean.  A dirty volume
+				   would have left the logfile open and hence
+				   this would be != NTFS_LOGFILE_NO_CLIENT, and it
+				   should be 0, i.e. the first (and only)
+				   client record is in use.  On WinXP and
+				   presumably later, the logfile is always
+				   open, even on clean shutdown so this should
+				   always be 0. */
+/* 14*/	NTFS_RESTART_AREA_FLAGS flags;/* Flags modifying LFS behaviour.  On Win2k
+				   and presumably earlier this is always 0.  On
+				   WinXP and presumably later, if the logfile
+				   was shutdown cleanly, the second bit,
+				   NTFS_RESTART_VOLUME_IS_CLEAN, is set.  This bit
+				   is cleared when the volume is mounted by
+				   WinXP and set when the volume is dismounted,
+				   thus if the logfile is dirty, this bit is
+				   clear.  Thus we don't need to check the
+				   Windows version to determine if the logfile
+				   is clean.  Instead if the logfile is closed,
+				   we know it must be clean.  If it is open and
+				   this bit is set, we also know it must be
+				   clean.  If on the other hand the logfile is
+				   open and this bit is clear, we can be almost
+				   certain that the logfile is dirty. */
+/* 16*/	le32 seq_number_bits;	/* How many bits to use for the sequence
+				   number.  This is calculated as 67 - the
+				   number of bits required to store the logfile
+				   size in bytes and this can be used in with
+				   the specified file_size as a consistency
+				   check. */
+/* 20*/	le16 restart_area_length;/* Length of the restart area including the
+				   client array.  Following checks required if
+				   version matches.  Otherwise, skip them.
+				   restart_area_offset + restart_area_length
+				   has to be <= system_page_size.  Also,
+				   restart_area_length has to be >=
+				   client_array_offset + (log_clients *
+				   sizeof(log client record)). */
+/* 22*/	le16 client_array_offset;/* Offset from the start of this record to
+				   the first log client record if versions are
+				   matched.  When creating, set this to be
+				   after this restart area structure, aligned
+				   to 8-bytes boundary.  If the versions do not
+				   match, this is ignored and the offset is
+				   assumed to be (sizeof(NTFS_RESTART_AREA) + 7) &
+				   ~7, i.e. rounded up to first 8-byte
+				   boundary.  Either way, client_array_offset
+				   has to be aligned to an 8-byte boundary.
+				   Also, restart_area_offset +
+				   client_array_offset has to be <= 510.
+				   Finally, client_array_offset + (log_clients
+				   * sizeof(log client record)) has to be <=
+				   system_page_size.  On Win2k and presumably
+				   earlier, this is 0x30, i.e. immediately
+				   following this record.  On WinXP and
+				   presumably later, this is 0x40, i.e. there
+				   are 16 extra bytes between this record and
+				   the client array.  This probably means that
+				   the NTFS_RESTART_AREA record is actually bigger
+				   in WinXP and later. */
+/* 24*/	sle64 file_size;	/* Usable byte size of the log file.  If the
+				   restart_area_offset + the offset of the
+				   file_size are > 510 then corruption has
+				   occurred.  This is the very first check when
+				   starting with the restart_area as if it
+				   fails it means that some of the above values
+				   will be corrupted by the multi sector
+				   transfer protection.  The file_size has to
+				   be rounded down to be a multiple of the
+				   log_page_size in the NTFS_RESTART_PAGE_HEADER and
+				   then it has to be at least big enough to
+				   store the two restart pages and 48 (0x30)
+				   log record pages. */
+/* 32*/	le32 last_lsn_data_length;/* Length of data of last NTFS_LSN, not including
+				   the log record header.  On create set to
+				   0. */
+/* 36*/	le16 log_record_header_length;/* Byte size of the log record header.
+				   If the version matches then check that the
+				   value of log_record_header_length is a
+				   multiple of 8, i.e.
+				   (log_record_header_length + 7) & ~7 ==
+				   log_record_header_length.  When creating set
+				   it to sizeof(LOG_RECORD_HEADER), aligned to
+				   8 bytes. */
+/* 38*/	le16 log_page_data_offset;/* Offset to the start of data in a log record
+				   page.  Must be a multiple of 8.  On create
+				   set it to immediately after the update
+				   sequence array of the log record page. */
+/* 40*/	le32 restart_log_open_count;/* A counter that gets incremented every
+				   time the logfile is restarted which happens
+				   at mount time when the logfile is opened.
+				   When creating set to a random value.  Win2k
+				   sets it to the low 32 bits of the current
+				   system time in NTFS format (see time.h). */
+/* 44*/	le32 reserved;		/* Reserved/alignment to 8-byte boundary. */
+/* sizeof() = 48 (0x30) bytes */
+} __attribute__((__packed__)) NTFS_RESTART_AREA;
+
+/**
+ * struct NTFS_LOG_CLIENT_RECORD - Log client record.
+ *
+ * The offset of this record is found by adding the offset of the
+ * NTFS_RESTART_AREA to the client_array_offset value found in it.
+ */
+typedef struct {
+/*Ofs*/
+/*  0*/	NTFS_leLSN oldest_lsn;	/* Oldest NTFS_LSN needed by this client.  On create
+				   set to 0. */
+/*  8*/	NTFS_leLSN client_restart_lsn;/* NTFS_LSN at which this client needs to restart
+				   the volume, i.e. the current position within
+				   the log file.  At present, if clean this
+				   should = current_lsn in restart area but it
+				   probably also = current_lsn when dirty most
+				   of the time.  At create set to 0. */
+/* 16*/	le16 prev_client;	/* The offset to the previous log client record
+				   in the array of log client records.
+				   NTFS_LOGFILE_NO_CLIENT means there is no previous
+				   client record, i.e. this is the first one.
+				   This is always NTFS_LOGFILE_NO_CLIENT. */
+/* 18*/	le16 next_client;	/* The offset to the next log client record in
+				   the array of log client records.
+				   NTFS_LOGFILE_NO_CLIENT means there are no next
+				   client records, i.e. this is the last one.
+				   This is always NTFS_LOGFILE_NO_CLIENT. */
+/* 20*/	le16 seq_number;	/* On Win2k and presumably earlier, this is set
+				   to zero every time the logfile is restarted
+				   and it is incremented when the logfile is
+				   closed at dismount time.  Thus it is 0 when
+				   dirty and 1 when clean.  On WinXP and
+				   presumably later, this is always 0. */
+/* 22*/	u8 reserved[6];		/* Reserved/alignment. */
+/* 28*/	le32 client_name_length;/* Length of client name in bytes.  Should
+				   always be 8. */
+/* 32*/	ntfschar client_name[64];/* Name of the client in Unicode.  Should
+				   always be "NTFS" with the remaining bytes
+				   set to 0. */
+/* sizeof() = 160 (0xa0) bytes */
+} __attribute__((__packed__)) NTFS_LOG_CLIENT_RECORD;
+
+/**
+ * struct NTFS_RECORD_PAGE_HEADER - Log page record page header.
+ *
+ * Each log page begins with this header and is followed by several NTFS_LOG_RECORD
+ * structures, starting at offset 0x40 (the size of this structure and the
+ * following update sequence array and then aligned to 8 byte boundary, but is
+ * this specified anywhere?).
+ */
+typedef struct {
+/*  0	NTFS_RECORD; -- Unfolded here as gcc doesn't like unnamed structs. */
+	NTFS_RECORD_TYPES magic;/* Usually the magic is "RCRD". */
+	u16 usa_ofs;		/* See NTFS_RECORD definition in layout.h.
+				   When creating, set this to be immediately
+				   after this header structure (without any
+				   alignment). */
+	u16 usa_count;		/* See NTFS_RECORD definition in layout.h. */
+
+	union {
+		NTFS_LSN last_lsn;
+		s64 file_offset;
+	} __attribute__((__packed__)) copy;
+	u32 flags;
+	u16 page_count;
+	u16 page_position;
+	union {
+		struct {
+			u16 next_record_offset;
+			u8 reserved[6];
+			NTFS_LSN last_end_lsn;
+		} __attribute__((__packed__)) packed;
+	} __attribute__((__packed__)) header;
+} __attribute__((__packed__)) NTFS_RECORD_PAGE_HEADER;
+
+/**
+ * enum NTFS_LOG_RECORD_FLAGS - Possible 16-bit flags for log records.
+ *
+ * (Or is it log record pages?)
+ */
+typedef enum {
+	NTFS_LOG_RECORD_MULTI_PAGE = const_cpu_to_le16(0x0001),	/* ??? */
+	NTFS_LOG_RECORD_SIZE_PLACE_HOLDER = 0xffff,
+		/* This has nothing to do with the log record. It is only so
+		   gcc knows to make the flags 16-bit. */
+} __attribute__((__packed__)) NTFS_LOG_RECORD_FLAGS;
+
+/**
+ * struct NTFS_LOG_CLIENT_ID - The log client id structure identifying a log client.
+ */
+typedef struct {
+	u16 seq_number;
+	u16 client_index;
+} __attribute__((__packed__)) NTFS_LOG_CLIENT_ID;
+
+/**
+ * struct NTFS_LOG_RECORD - Log record header.
+ *
+ * Each log record seems to have a constant size of 0x70 bytes.
+ */
+typedef struct {
+	NTFS_LSN this_lsn;
+	NTFS_LSN client_previous_lsn;
+	NTFS_LSN client_undo_next_lsn;
+	u32 client_data_length;
+	NTFS_LOG_CLIENT_ID client_id;
+	u32 record_type;
+	u32 transaction_id;
+	u16 flags;
+	u16 reserved_or_alignment[3];
+/* Now are at ofs 0x30 into struct. */
+	u16 redo_operation;
+	u16 undo_operation;
+	u16 redo_offset;
+	u16 redo_length;
+	u16 undo_offset;
+	u16 undo_length;
+	u16 target_attribute;
+	u16 lcns_to_follow;		   /* Number of lcn_list entries
+					      following this entry. */
+/* Now at ofs 0x40. */
+	u16 record_offset;
+	u16 attribute_offset;
+	u32 alignment_or_reserved;
+	NTFS_VCN target_vcn;
+/* Now at ofs 0x50. */
+	struct {			   /* Only present if lcns_to_follow
+					      is not 0. */
+		NTFS_LCN lcn;
+	} __attribute__((__packed__)) lcn_list[0];
+} __attribute__((__packed__)) NTFS_LOG_RECORD;
+
+extern NTFS_BOOL ntfs_check_logfile(ntfs_attr *log_na, NTFS_RESTART_PAGE_HEADER **rp);
+extern NTFS_BOOL ntfs_is_logfile_clean(ntfs_attr *log_na, NTFS_RESTART_PAGE_HEADER *rp);
+extern int ntfs_empty_logfile(ntfs_attr *na);
+
+__END_DECLS
+
+#endif /* defined _NTFS_LOGFILE_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_logging.h ./include/ntfs/ntfs_logging.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_logging.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_logging.h	2007-10-06 17:02:14.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ * logging.h - Centralised logging. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LOGGING_H_
+#define _LOGGING_H_ 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_STDARG_H 1
+#endif
+
+#ifdef HAVE_STDARG_H
+#include <stdarg.h>
+#endif
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+/* Function prototype for the logging handlers */
+typedef int (ntfs_log_handler)(const char *function, const char *file, int line,
+	u32 level, void *data, const char *format, va_list args);
+
+/* Set the logging handler from one of the functions, below. */
+void ntfs_log_set_handler(ntfs_log_handler *handler);
+
+/* Logging handlers */
+ntfs_log_handler ntfs_log_handler_syslog  __attribute__((format(printf, 6, 0)));
+ntfs_log_handler ntfs_log_handler_fprintf __attribute__((format(printf, 6, 0)));
+ntfs_log_handler ntfs_log_handler_null    __attribute__((format(printf, 6, 0)));
+ntfs_log_handler ntfs_log_handler_stdout  __attribute__((format(printf, 6, 0)));
+ntfs_log_handler ntfs_log_handler_outerr  __attribute__((format(printf, 6, 0)));
+ntfs_log_handler ntfs_log_handler_stderr  __attribute__((format(printf, 6, 0)));
+
+/* Enable/disable certain log levels */
+u32 ntfs_log_set_levels(u32 levels);
+u32 ntfs_log_clear_levels(u32 levels);
+u32 ntfs_log_get_levels(void);
+
+/* Enable/disable certain log flags */
+u32 ntfs_log_set_flags(u32 flags);
+u32 ntfs_log_clear_flags(u32 flags);
+u32 ntfs_log_get_flags(void);
+
+/* Turn command-line options into logging flags */
+NTFS_BOOL ntfs_log_parse_option(const char *option);
+
+int ntfs_log_redirect(const char *function, const char *file, int line,
+	u32 level, void *data, const char *format, ...)
+	__attribute__((format(printf, 6, 7)));
+
+/* Logging levels - Determine what gets logged */
+#define NTFS_LOG_LEVEL_DEBUG	((u32)1 <<  0) /* x = 42 */
+#define NTFS_LOG_LEVEL_TRACE	((u32)1 <<  1) /* Entering function x() */
+#define NTFS_LOG_LEVEL_QUIET	((u32)1 <<  2) /* Quietable output */
+#define NTFS_LOG_LEVEL_INFO	((u32)1 <<  3) /* Volume needs defragmenting */
+#define NTFS_LOG_LEVEL_VERBOSE	((u32)1 <<  4) /* Forced to continue */
+#define NTFS_LOG_LEVEL_PROGRESS	((u32)1 <<  5) /* 54% complete */
+#define NTFS_LOG_LEVEL_WARNING	((u32)1 <<  6) /* You should backup before starting */
+#define NTFS_LOG_LEVEL_ERROR	((u32)1 <<  7) /* Operation failed, no damage done */
+#define NTFS_LOG_LEVEL_PERROR	((u32)1 <<  8) /* Message : standard error description */
+#define NTFS_LOG_LEVEL_CRITICAL	((u32)1 <<  9) /* Operation failed,damage may have occurred */
+
+/* Logging style flags - Manage the style of the output */
+#define NTFS_LOG_FLAG_PREFIX	((u32)1 << 0) /* Prefix messages with "ERROR: ", etc */
+#define NTFS_LOG_FLAG_FILENAME	((u32)1 << 1) /* Show the file origin of the message */
+#define NTFS_LOG_FLAG_LINE	((u32)1 << 2) /* Show the line number of the message */
+#define NTFS_LOG_FLAG_FUNCTION	((u32)1 << 3) /* Show the function name containing the message */
+#define NTFS_LOG_FLAG_ONLYNAME	((u32)1 << 4) /* Only display the filename, not the pathname */
+#define NTFS_LOG_FLAG_COLOUR	((u32)1 << 5) /* Colour highlight some messages */
+
+/* Macros to simplify logging.  One for each level defined above.
+ * Note, if DEBUG is not defined, then ntfs_log_debug/trace have no effect.
+ */
+#define ntfs_log_critical(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_CRITICAL,NULL,FORMAT,##ARGS)
+#define ntfs_log_error(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_ERROR,NULL,FORMAT,##ARGS)
+#define ntfs_log_info(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_INFO,NULL,FORMAT,##ARGS)
+#define ntfs_log_perror(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_PERROR,NULL,FORMAT,##ARGS)
+#define ntfs_log_progress(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_PROGRESS,NULL,FORMAT,##ARGS)
+#define ntfs_log_quiet(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_QUIET,NULL,FORMAT,##ARGS)
+#define ntfs_log_verbose(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_VERBOSE,NULL,FORMAT,##ARGS)
+#define ntfs_log_warning(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_WARNING,NULL,FORMAT,##ARGS)
+
+/*
+ * By default debug and trace messages are compiled into the program,
+ * but not displayed.
+ */
+#ifndef DEBUG
+#define ntfs_log_debug(FORMAT, ARGS...)do {} while (0)
+#define ntfs_log_trace(FORMAT, ARGS...)do {} while (0)
+#else /* !DEBUG */
+#define ntfs_log_debug(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_DEBUG,NULL,FORMAT,##ARGS)
+#define ntfs_log_trace(FORMAT, ARGS...) ntfs_log_redirect(__FUNCTION__,__FILE__,__LINE__,NTFS_LOG_LEVEL_TRACE,NULL,FORMAT,##ARGS)
+#endif /* DEBUG */
+
+__END_DECLS
+
+#endif /* _LOGGING_H_ */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_mft.h ./include/ntfs/ntfs_mft.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_mft.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_mft.h	2007-10-06 17:02:35.000000000 +0200
@@ -0,0 +1,121 @@
+/*
+ * mft.h - Exports for MFT record handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2002 Anton Altaparmakov
+ * Copyright (c) 2004-2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_MFT_H
+#define _NTFS_MFT_H 1
+
+#include "ntfs_volume.h"
+#include "ntfs_inode.h"
+#include "ntfs_layout.h"
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+extern int ntfs_mft_records_read(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		const s64 count, NTFS_MFT_RECORD *b);
+
+/**
+ * ntfs_mft_record_read - read a record from the mft
+ * @vol:	volume to read from
+ * @mref:	mft record number to read
+ * @b:		output data buffer
+ *
+ * Read the mft record specified by @mref from volume @vol into buffer @b.
+ * Return 0 on success or -1 on error, with errno set to the error code.
+ *
+ * The read mft record is mst deprotected and is hence ready to use. The caller
+ * should check the record with is_baad_record() in case mst deprotection
+ * failed.
+ *
+ * NOTE: @b has to be at least of size vol->mft_record_size.
+ */
+static __inline__ int ntfs_mft_record_read(const ntfs_volume *vol,
+		const NTFS_MFT_REF mref, NTFS_MFT_RECORD *b)
+{
+	return ntfs_mft_records_read(vol, mref, 1, b);
+}
+
+extern int ntfs_file_record_read(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		NTFS_MFT_RECORD **mrec, NTFS_ATTR_RECORD **attr);
+
+extern int ntfs_mft_records_write(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		const s64 count, NTFS_MFT_RECORD *b);
+
+/**
+ * ntfs_mft_record_write - write an mft record to disk
+ * @vol:	volume to write to
+ * @mref:	mft record number to write
+ * @b:		data buffer containing the mft record to write
+ *
+ * Write the mft record specified by @mref from buffer @b to volume @vol.
+ * Return 0 on success or -1 on error, with errno set to the error code.
+ *
+ * Before the mft record is written, it is mst protected. After the write, it
+ * is deprotected again, thus resulting in an increase in the update sequence
+ * number inside the buffer @b.
+ *
+ * NOTE: @b has to be at least of size vol->mft_record_size.
+ */
+static __inline__ int ntfs_mft_record_write(const ntfs_volume *vol,
+		const NTFS_MFT_REF mref, NTFS_MFT_RECORD *b)
+{
+	return ntfs_mft_records_write(vol, mref, 1, b);
+}
+
+/**
+ * ntfs_mft_record_get_data_size - return number of bytes used in mft record @b
+ * @m:		mft record to get the data size of
+ *
+ * Takes the mft record @m and returns the number of bytes used in the record
+ * or 0 on error (i.e. @m is not a valid mft record).  Zero is not a valid size
+ * for an mft record as it at least has to have the NTFS_MFT_RECORD itself and a
+ * zero length attribute of type NTFS_AT_END, thus making the minimum size 56 bytes.
+ *
+ * Aside:  The size is independent of NTFS versions 1.x/3.x because the 8-byte
+ * alignment of the first attribute mask the difference in NTFS_MFT_RECORD size
+ * between NTFS 1.x and 3.x.  Also, you would expect every mft record to
+ * contain an update sequence array as well but that could in theory be
+ * non-existent (don't know if Windows' NTFS driver/chkdsk wouldn't view this
+ * as corruption in itself though).
+ */
+static __inline__ u32 ntfs_mft_record_get_data_size(const NTFS_MFT_RECORD *m)
+{
+	if (!m || !ntfs_is_mft_record(m->magic))
+		return 0;
+	/* Get the number of used bytes and return it. */
+	return le32_to_cpu(m->bytes_in_use);
+}
+
+extern int ntfs_mft_record_layout(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		NTFS_MFT_RECORD *mrec);
+
+extern int ntfs_mft_record_format(const ntfs_volume *vol, const NTFS_MFT_REF mref);
+
+extern ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, ntfs_inode *base_ni);
+
+extern int ntfs_mft_record_free(ntfs_volume *vol, ntfs_inode *ni);
+
+extern int ntfs_mft_usn_dec(NTFS_MFT_RECORD *mrec);
+
+__END_DECLS
+
+#endif /* defined _NTFS_MFT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_mst.h ./include/ntfs/ntfs_mst.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_mst.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_mst.h	2007-10-06 17:02:50.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ * mst.h - Exports for multi sector transfer fixup functions. Part of the
+ *	   Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2002 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_MST_H
+#define _NTFS_MST_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+
+__BEGIN_DECLS
+
+extern int ntfs_mst_post_read_fixup(NTFS_RECORD *b, const u32 size);
+extern int ntfs_mst_pre_write_fixup(NTFS_RECORD *b, const u32 size);
+extern void ntfs_mst_post_write_fixup(NTFS_RECORD *b);
+
+__END_DECLS
+
+#endif /* defined _NTFS_MST_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_runlist.h ./include/ntfs/ntfs_runlist.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_runlist.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_runlist.h	2007-10-06 17:03:03.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * ntfs_runlist.h - Exports for ntfs_runlist handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2002 Anton Altaparmakov
+ * Copyright (c) 2002 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_RUNLIST_H
+#define _NTFS_RUNLIST_H 1
+
+#include "ntfs_types.h"
+
+/* Forward declarations */
+typedef struct _ntfs_runlist_element ntfs_runlist_element;
+typedef ntfs_runlist_element ntfs_runlist;
+
+#include "ntfs_attrib.h"
+#include "ntfs_volume.h"
+
+__BEGIN_DECLS
+
+/**
+ * struct _ntfs_runlist_element - in memory vcn to lcn mapping array element.
+ * @vcn:	starting vcn of the current array element
+ * @lcn:	starting lcn of the current array element
+ * @length:	length in clusters of the current array element
+ *
+ * The last vcn (in fact the last vcn + 1) is reached when length == 0.
+ *
+ * When lcn == -1 this means that the count vcns starting at vcn are not
+ * physically allocated (i.e. this is a hole / data is sparse).
+ */
+struct _ntfs_runlist_element {/* In memory vcn to lcn mapping structure element. */
+	NTFS_VCN vcn;	/* vcn = Starting virtual cluster number. */
+	NTFS_LCN lcn;	/* lcn = Starting logical cluster number. */
+	s64 length;	/* Run length in clusters. */
+};
+
+extern NTFS_LCN ntfs_rl_vcn_to_lcn(const ntfs_runlist_element *rl, const NTFS_VCN vcn);
+
+extern s64 ntfs_rl_pread(const ntfs_volume *vol, const ntfs_runlist_element *rl,
+		const s64 pos, s64 count, void *b);
+extern s64 ntfs_rl_pwrite(const ntfs_volume *vol, const ntfs_runlist_element *rl,
+		const s64 pos, s64 count, void *b);
+
+extern int ntfs_rl_fill_zero(const ntfs_volume *vol, const ntfs_runlist *rl,
+		s64 pos, const s64 count);
+
+extern ntfs_runlist_element *ntfs_runlists_merge(ntfs_runlist_element *drl,
+		ntfs_runlist_element *srl);
+
+extern ntfs_runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,
+		const NTFS_ATTR_RECORD *attr, ntfs_runlist_element *old_rl);
+
+extern int ntfs_get_nr_significant_bytes(const s64 n);
+
+extern int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,
+		const ntfs_runlist_element *rl, const NTFS_VCN start_vcn);
+
+extern int ntfs_write_significant_bytes(u8 *dst, const u8 *dst_max,
+		const s64 n);
+
+extern int ntfs_mapping_pairs_build(const ntfs_volume *vol, u8 *dst,
+		const int dst_len, const ntfs_runlist_element *rl,
+		const NTFS_VCN start_vcn, NTFS_VCN *const stop_vcn);
+
+extern int ntfs_rl_truncate(ntfs_runlist **arl, const NTFS_VCN start_vcn);
+
+extern int ntfs_rl_sparse(ntfs_runlist *rl);
+extern s64 ntfs_rl_get_compressed_size(ntfs_volume *vol, ntfs_runlist *rl);
+
+#ifdef NTFS_TEST
+int test_rl_main(int argc, char *argv[]);
+#endif
+
+__END_DECLS
+
+#endif /* defined _NTFS_RUNLIST_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_security.h ./include/ntfs/ntfs_security.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_security.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_security.h	2007-10-06 17:03:16.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * security.h - Exports for handling security/ACLs in NTFS.  Part of the
+ *		Linux-NTFS project.
+ *
+ * Copyright (c) 2004 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_SECURITY_H
+#define _NTFS_SECURITY_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+
+__BEGIN_DECLS
+
+extern const NTFS_GUID *const zero_guid;
+
+extern NTFS_BOOL ntfs_guid_is_zero(const NTFS_GUID *guid);
+extern char *ntfs_guid_to_mbs(const NTFS_GUID *guid, char *guid_str);
+
+/**
+ * ntfs_sid_is_valid - determine if a NTFS_SID is valid
+ * @sid:	NTFS_SID for which to determine if it is valid
+ *
+ * Determine if the NTFS_SID pointed to by @sid is valid.
+ *
+ * Return TRUE if it is valid and FALSE otherwise.
+ */
+static __inline__ NTFS_BOOL ntfs_sid_is_valid(const NTFS_SID *sid)
+{
+	if (!sid || sid->revision != NTFS_SID_REVISION ||
+			sid->sub_authority_count > NTFS_SID_MAX_SUB_AUTHORITIES)
+		return FALSE;
+	return TRUE;
+}
+
+extern int ntfs_sid_to_mbs_size(const NTFS_SID *sid);
+extern char *ntfs_sid_to_mbs(const NTFS_SID *sid, char *sid_str,
+		size_t sid_str_size);
+extern void ntfs_generate_guid(NTFS_GUID *guid);
+
+__END_DECLS
+
+#endif /* defined _NTFS_SECURITY_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_support.h ./include/ntfs/ntfs_support.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_support.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_support.h	2007-10-06 17:03:53.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ * support.h - Various useful things. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c)      2006 Szabolcs Szakacsits
+ * Copyright (c)      2006 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_SUPPORT_H
+#define _NTFS_SUPPORT_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_STDDEF_H 1
+#define HAVE_STDLIB_H 1
+#endif
+
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ntfs_logging.h"
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+/*
+ * Our mailing list. Use this define to prevent typos in email address.
+ */
+#define NTFS_DEV_LIST	"linux-ntfs-dev@lists.sf.net"
+
+/*
+ * Generic macro to convert pointers to values for comparison purposes.
+ */
+#ifndef p2n
+#define p2n(p)		((ptrdiff_t)((ptrdiff_t*)(p)))
+#endif
+
+/*
+ * The classic min and max macros.
+ */
+#ifndef min
+#define min(a,b)	((a) <= (b) ? (a) : (b))
+#endif
+
+#ifndef max
+#define max(a,b)	((a) >= (b) ? (a) : (b))
+#endif
+
+/*
+ * Useful macro for determining the offset of a struct member.
+ */
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+/*
+ * Round up and down @num to 2 in power of @order.
+ */
+#define ROUND_UP(num,order)	(((num) + ((1 << (order)) - 1)) & \
+				~((1 << (order)) - 1))
+#define ROUND_DOWN(num,order)	((num) & ~((1 << (order)) - 1))
+
+/*
+ * Simple bit operation macros. NOTE: These are NOT atomic.
+ */
+#define test_bit(bit, var)	      ((var) & (1 << (bit)))
+#define set_bit(bit, var)	      (var) |= 1 << (bit)
+#define clear_bit(bit, var)	      (var) &= ~(1 << (bit))
+
+#define test_and_set_bit(bit, var)			\
+({							\
+	const NTFS_BOOL old_state = test_bit(bit, var);	\
+	set_bit(bit, var);				\
+	old_state;					\
+})
+
+#define test_and_clear_bit(bit, var)			\
+({							\
+	const NTFS_BOOL old_state = test_bit(bit, var);	\
+	clear_bit(bit, var);				\
+	old_state;					\
+})
+
+/* Memory allocation with logging. */
+extern void *ntfs_calloc(size_t size);
+extern void *ntfs_malloc(size_t size);
+
+__END_DECLS
+
+#endif /* defined _NTFS_SUPPORT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_time.h ./include/ntfs/ntfs_time.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_time.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_time.h	2007-10-06 17:04:28.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ * ntfstime.h - NTFS time related functions.  Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2005      Anton Altaparmakov
+ * Copyright (c) 2005-2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_NTFSTIME_H
+#define _NTFS_NTFSTIME_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_TIME_H 1
+#endif
+
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)
+
+/**
+ * ntfs2utc - Convert an NTFS time to Unix time
+ * @ntfs_time:  An NTFS time in 100ns units since 1601
+ *
+ * NTFS stores times as the number of 100ns intervals since January 1st 1601 at
+ * 00:00 UTC.  This system will not suffer from Y2K problems until ~57000AD.
+ *
+ * Return:  n  A Unix time (number of seconds since 1970)
+ */
+static __inline__ time_t ntfs2utc(sle64 ntfs_time)
+{
+	return (sle64_to_cpu(ntfs_time) - (NTFS_TIME_OFFSET)) / 10000000;
+}
+
+/**
+ * utc2ntfs - Convert Linux time to NTFS time
+ * @utc_time:  Linux time to convert to NTFS
+ *
+ * Convert the Linux time @utc_time to its corresponding NTFS time.
+ *
+ * Linux stores time in a long at present and measures it as the number of
+ * 1-second intervals since 1st January 1970, 00:00:00 UTC.
+ *
+ * NTFS uses Microsoft's standard time format which is stored in a s64 and is
+ * measured as the number of 100 nano-second intervals since 1st January 1601,
+ * 00:00:00 UTC.
+ *
+ * Return:  n  An NTFS time (100ns units since Jan 1601)
+ */
+static __inline__ sle64 utc2ntfs(time_t utc_time)
+{
+	/* Convert to 100ns intervals and then add the NTFS time offset. */
+	return cpu_to_sle64((s64)utc_time * 10000000 + NTFS_TIME_OFFSET);
+}
+
+__END_DECLS
+
+#endif /* _NTFS_NTFSTIME_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfstime.h ./include/ntfs/ntfstime.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfstime.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/ntfstime.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * ntfstime.h - NTFS time related functions.  Part of the Linux-NTFS project.
- *
- * Copyright (c) 2005      Anton Altaparmakov
- * Copyright (c) 2005-2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_NTFSTIME_H
-#define _NTFS_NTFSTIME_H
-
-#ifdef HAVE_TIME_H
-#include <time.h>
-#endif
-
-#include "types.h"
-
-#define NTFS_TIME_OFFSET ((s64)(369 * 365 + 89) * 24 * 3600 * 10000000)
-
-/**
- * ntfs2utc - Convert an NTFS time to Unix time
- * @ntfs_time:  An NTFS time in 100ns units since 1601
- *
- * NTFS stores times as the number of 100ns intervals since January 1st 1601 at
- * 00:00 UTC.  This system will not suffer from Y2K problems until ~57000AD.
- *
- * Return:  n  A Unix time (number of seconds since 1970)
- */
-static __inline__ time_t ntfs2utc(sle64 ntfs_time)
-{
-	return (sle64_to_cpu(ntfs_time) - (NTFS_TIME_OFFSET)) / 10000000;
-}
-
-/**
- * utc2ntfs - Convert Linux time to NTFS time
- * @utc_time:  Linux time to convert to NTFS
- *
- * Convert the Linux time @utc_time to its corresponding NTFS time.
- *
- * Linux stores time in a long at present and measures it as the number of
- * 1-second intervals since 1st January 1970, 00:00:00 UTC.
- *
- * NTFS uses Microsoft's standard time format which is stored in a s64 and is
- * measured as the number of 100 nano-second intervals since 1st January 1601,
- * 00:00:00 UTC.
- *
- * Return:  n  An NTFS time (100ns units since Jan 1601)
- */
-static __inline__ sle64 utc2ntfs(time_t utc_time)
-{
-	/* Convert to 100ns intervals and then add the NTFS time offset. */
-	return cpu_to_sle64((s64)utc_time * 10000000 + NTFS_TIME_OFFSET);
-}
-
-#endif /* _NTFS_NTFSTIME_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_types.h ./include/ntfs/ntfs_types.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_types.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_types.h	2007-10-06 17:06:23.000000000 +0200
@@ -0,0 +1,173 @@
+/*
+ * types.h - Misc type definitions not related to on-disk structure.  Part of
+ *	     the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c)      2006 Szabolcs Szakacsits
+ * Copyright (c)      2007 Yura Pakhuchiy
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_TYPES_H
+#define _NTFS_TYPES_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_STDINT_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_CDEFS_H 1
+#endif
+
+#if (defined HAVE_STDINT_H) || (! defined HAVE_CONFIG_H)
+#include <stdint.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+typedef uint8_t  u8;			/* Unsigned types of an exact size */
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+typedef int8_t  s8;			/* Signed types of an exact size */
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+
+#if defined(__CHECKER__) && !defined(NTFS_DO_NOT_CHECK_ENDIANS)
+	#undef __bitwise
+	#undef __force
+	#define __bitwise __attribute__((bitwise))
+	#define __force __attribute__((force))
+#else
+	#undef __bitwise
+	#undef __force
+	#define __bitwise
+	#define __force
+#endif
+
+typedef u16 __bitwise le16;
+typedef u32 __bitwise le32;
+typedef u64 __bitwise le64;
+
+/*
+ * Declare sle{16,32,64} to be unsigned because we do not want sign extension
+ * on BE architectures.
+ */
+typedef u16 __bitwise sle16;
+typedef u32 __bitwise sle32;
+typedef u64 __bitwise sle64;
+
+typedef u16 __bitwise be16;
+typedef u32 __bitwise be32;
+typedef u64 __bitwise be64;
+
+typedef le16 ntfschar;			/* 2-byte Unicode character type. */
+#define UCHAR_T_SIZE_BITS 1
+
+/*
+ * Clusters are signed 64-bit values on NTFS volumes.  We define two types, NTFS_LCN
+ * and NTFS_VCN, to allow for type checking and better code readability.
+ */
+typedef s64 NTFS_VCN;
+typedef sle64 NTFS_leVCN;
+typedef s64 NTFS_LCN;
+typedef sle64 NTFS_leLCN;
+
+/*
+ * The NTFS journal $LogFile uses log sequence numbers which are signed 64-bit
+ * values.  We define our own type NTFS_LSN, to allow for type checking and better
+ * code readability.
+ */
+typedef s64 NTFS_LSN;
+typedef sle64 NTFS_leLSN;
+
+/*
+ * Cygwin has a collision between our NTFS_BOOL and <windef.h>'s
+ * As long as this file will be included after <windows.h> we're fine.
+ */
+#ifndef _WINDEF_H
+/**
+ * enum NTFS_BOOL - These are just to make the code more readable...
+ */
+typedef enum {
+#ifndef FALSE
+	FALSE = 0,
+#endif
+#ifndef NO
+	NO = 0,
+#endif
+#ifndef ZERO
+	ZERO = 0,
+#endif
+#ifndef TRUE
+	TRUE = 1,
+#endif
+#ifndef YES
+	YES = 1,
+#endif
+#ifndef ONE
+	ONE = 1,
+#endif
+} NTFS_BOOL;
+#endif /* defined _WINDEF_H */
+
+/**
+ * enum NTFS_IGNORE_CASE_BOOL -
+ */
+typedef enum {
+	NTFS_CASE_SENSITIVE = 0,
+	NTFS_IGNORE_CASE = 1,
+} NTFS_IGNORE_CASE_BOOL;
+
+#define NTFS_STATUS_OK					(0)
+#define NTFS_STATUS_ERROR				(-1)
+#define NTFS_STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT	(-2)
+#define NTFS_STATUS_KEEP_SEARCHING			(-3)
+#define NTFS_STATUS_NOT_FOUND				(-4)
+
+#ifndef HAVE_SYS_CDEFS_H
+
+#if defined(__cplusplus)
+#define __BEGIN_DECLS   extern "C" {
+#define __END_DECLS     }
+#else
+#define __BEGIN_DECLS
+#define __END_DECLS
+#endif
+
+#else 		/* HAVE_SYS_CDEFS_H */
+#include <sys/cdefs.h>
+#endif 	/* !HAVE_SYS_CDEFS_H */
+
+#ifndef __GNUC__
+
+#ifndef __attribute__
+#define __attribute__(x)
+#endif
+
+#ifndef __inline__
+#define __inline__
+#endif
+
+#endif
+
+
+#endif /* defined _NTFS_TYPES_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_unistr.h ./include/ntfs/ntfs_unistr.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_unistr.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_unistr.h	2007-10-06 17:06:40.000000000 +0200
@@ -0,0 +1,73 @@
+/*
+ * unistr.h - Exports for Unicode string handling. Part of the Linux-NTFS
+ *	      project.
+ *
+ * Copyright (c) 2000-2006 Anton Altaparmakov
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_UNISTR_H
+#define _NTFS_UNISTR_H 1
+
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+
+__BEGIN_DECLS
+
+extern NTFS_BOOL ntfs_names_are_equal(const ntfschar *s1, size_t s1_len,
+		const ntfschar *s2, size_t s2_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const ntfschar *upcase, const u32 upcase_size);
+
+extern int ntfs_names_collate(const ntfschar *name1, const u32 name1_len,
+		const ntfschar *name2, const u32 name2_len,
+		const int err_val, const NTFS_IGNORE_CASE_BOOL ic,
+		const ntfschar *upcase, const u32 upcase_len);
+
+extern int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n);
+
+extern int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,
+		const ntfschar *upcase, const u32 upcase_size);
+
+extern u32 ntfs_ucsnlen(const ntfschar *s, u32 maxlen);
+
+extern ntfschar *ntfs_ucsndup(const ntfschar *s, u32 maxlen);
+
+extern void ntfs_name_upcase(ntfschar *name, u32 name_len,
+		const ntfschar *upcase, const u32 upcase_len);
+
+extern void ntfs_file_value_upcase(NTFS_FILE_NAME_ATTR *file_name_attr,
+		const ntfschar *upcase, const u32 upcase_len);
+
+extern int ntfs_file_values_compare(const NTFS_FILE_NAME_ATTR *file_name_attr1,
+		const NTFS_FILE_NAME_ATTR *file_name_attr2,
+		const int err_val, const NTFS_IGNORE_CASE_BOOL ic,
+		const ntfschar *upcase, const u32 upcase_len);
+
+extern int ntfs_ucstombs(const ntfschar *ins, const int ins_len, char **outs,
+		int outs_len);
+extern int ntfs_mbstoucs(const char *ins, ntfschar **outs, int outs_len);
+
+extern void ntfs_upcase_table_build(ntfschar *uc, u32 uc_len);
+
+extern ntfschar *ntfs_str2ucs(const char *s, int *len);
+
+extern void ntfs_ucsfree(ntfschar *ucs);
+
+__END_DECLS
+
+#endif /* defined _NTFS_UNISTR_H */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_version.h ./include/ntfs/ntfs_version.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_version.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_version.h	2007-10-06 17:06:56.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * version.h - Info about the NTFS library.  Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2005 Anton Altaparmakov
+ * Copyright (c) 2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_VERSION_H_
+#define _NTFS_VERSION_H_  1
+
+#include "ntfs_types.h"
+
+__BEGIN_DECLS
+
+extern const char *ntfs_libntfs_version(void);
+
+__END_DECLS
+
+#endif /* _NTFS_VERSION_H_ */
+
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/ntfs_volume.h ./include/ntfs/ntfs_volume.h
--- ../ntfsprogs-2.0.0/include/ntfs/ntfs_volume.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/ntfs/ntfs_volume.h	2007-10-06 17:07:45.000000000 +0200
@@ -0,0 +1,256 @@
+/*
+ * volume.h - Exports for NTFS volume handling. Part of the Linux-NTFS project.
+ *
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c) 2005-2007 Yura Pakhuchiy
+ * Copyright (c) 2004-2005 Richard Russon
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program (in the main directory of the Linux-NTFS
+ * distribution in the file COPYING); if not, write to the Free Software
+ * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _NTFS_VOLUME_H
+#define _NTFS_VOLUME_H 1
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#else
+#define HAVE_STDIO_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_MOUNT_H 1
+#define HAVE_MNTENT_H 1
+#endif
+
+#ifdef HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#ifdef HAVE_MNTENT_H
+#include <mntent.h>
+#endif
+
+/* Forward declaration */
+typedef struct _ntfs_volume ntfs_volume;
+
+#include "ntfs_list.h"
+#include "ntfs_types.h"
+#include "ntfs_support.h"
+#include "ntfs_device.h"
+#include "ntfs_inode.h"
+#include "ntfs_attrib.h"
+
+__BEGIN_DECLS
+
+/**
+ * enum ntfs_mount_flags -
+ *
+ * Flags for the ntfs_mount() function.
+ */
+typedef enum {
+	NTFS_MNT_RDONLY	 	= 1,
+	NTFS_MNT_FORENSIC	= 2,
+	NTFS_MNT_CASE_SENSITIVE	= 4,
+	NTFS_MNT_NOT_EXCLUSIVE	= 8,
+	NTFS_MNT_FORCE		= 16,
+	NTFS_MNT_INTERIX	= 32,
+} ntfs_mount_flags;
+
+/**
+ * enum ntfs_mounted_flags -
+ *
+ * Flags returned by the ntfs_check_if_mounted() function.
+ */
+typedef enum {
+	NTFS_MF_MOUNTED		= 1,	/* Device is mounted. */
+	NTFS_MF_ISROOT		= 2,	/* Device is mounted as system root. */
+	NTFS_MF_READONLY	= 4,	/* Device is mounted read-only. */
+} ntfs_mounted_flags;
+
+extern int ntfs_check_if_mounted(const char *file, unsigned long *mnt_flags);
+
+/**
+ * enum ntfs_volume_state_bits -
+ *
+ * Defined bits for the state field in the ntfs_volume structure.
+ */
+typedef enum {
+	NV_ReadOnly,		/* 1: Volume is read-only. */
+	NV_CaseSensitive,	/* 1: Volume is mounted case-sensitive. */
+	NV_LogFileEmpty,	/* 1: $logFile journal is empty. */
+	NV_NoATime,		/* 1: Do not update access time. */
+	NV_WasDirty,		/* 1: Volume was marked dirty before we mounted
+				      it. */
+	NV_ForensicMount,	/* 1: Mount is forensic, i.e. no modifications
+				      are to be done by mount/umount. */
+	NV_Interix,		/* 1: Make libntfs recognize Interix special
+				      files. */
+} ntfs_volume_state_bits;
+
+#define  test_nvol_flag(nv, flag)	 test_bit(NV_##flag, (nv)->state)
+#define   set_nvol_flag(nv, flag)	  set_bit(NV_##flag, (nv)->state)
+#define clear_nvol_flag(nv, flag)	clear_bit(NV_##flag, (nv)->state)
+
+#define NVolReadOnly(nv)		 test_nvol_flag(nv, ReadOnly)
+#define NVolSetReadOnly(nv)		  set_nvol_flag(nv, ReadOnly)
+#define NVolClearReadOnly(nv)		clear_nvol_flag(nv, ReadOnly)
+
+#define NVolCaseSensitive(nv)		 test_nvol_flag(nv, CaseSensitive)
+#define NVolSetCaseSensitive(nv)	  set_nvol_flag(nv, CaseSensitive)
+#define NVolClearCaseSensitive(nv)	clear_nvol_flag(nv, CaseSensitive)
+
+#define NVolLogFileEmpty(nv)		 test_nvol_flag(nv, LogFileEmpty)
+#define NVolSetLogFileEmpty(nv)		  set_nvol_flag(nv, LogFileEmpty)
+#define NVolClearLogFileEmpty(nv)	clear_nvol_flag(nv, LogFileEmpty)
+
+#define NVolWasDirty(nv)		 test_nvol_flag(nv, WasDirty)
+#define NVolSetWasDirty(nv)		  set_nvol_flag(nv, WasDirty)
+#define NVolClearWasDirty(nv)		clear_nvol_flag(nv, WasDirty)
+
+#define NVolForensicMount(nv)		 test_nvol_flag(nv, ForensicMount)
+#define NVolSetForensicMount(nv)	  set_nvol_flag(nv, ForensicMount)
+#define NVolClearForensicMount(nv)	clear_nvol_flag(nv, ForensicMount)
+
+#define NVolInterix(nv)			 test_nvol_flag(nv, Interix)
+#define NVolSetInterix(nv)		  set_nvol_flag(nv, Interix)
+#define NVolClearInterix(nv)		clear_nvol_flag(nv, Interix)
+
+/*
+ * NTFS version 1.1 and 1.2 are used by Windows NT4.
+ * NTFS version 2.x is used by Windows 2000 Beta
+ * NTFS version 3.0 is used by Windows 2000.
+ * NTFS version 3.1 is used by Windows XP, 2003 and Vista.
+ */
+
+#define NTFS_V1_1(major, minor) ((major) == 1 && (minor) == 1)
+#define NTFS_V1_2(major, minor) ((major) == 1 && (minor) == 2)
+#define NTFS_V2_X(major, minor) ((major) == 2)
+#define NTFS_V3_0(major, minor) ((major) == 3 && (minor) == 0)
+#define NTFS_V3_1(major, minor) ((major) == 3 && (minor) == 1)
+
+#define NTFS_BUF_SIZE 8192
+
+#define NTFS_INODE_CACHE_SIZE 512 /* WARNING: This should be power of 2. */
+#define NTFS_INODE_CACHE_SIZE_BITS (NTFS_INODE_CACHE_SIZE - 1)
+
+/**
+ * struct _ntfs_volume - structure describing an open volume in memory.
+ */
+struct _ntfs_volume {
+	union {
+		struct ntfs_device *dev;	/* NTFS device associated with
+						   the volume. */
+		void *sb;	/* For kernel porting compatibility. */
+	};
+	char *vol_name;		/* Name of the volume. */
+	unsigned long state;	/* NTFS specific flags describing this volume.
+				   See ntfs_volume_state_bits above. */
+
+	ntfs_inode *vol_ni;	/* ntfs_inode structure for NTFS_FILE_Volume. */
+	u8 major_ver;		/* Ntfs major version of volume. */
+	u8 minor_ver;		/* Ntfs minor version of volume. */
+	le16 flags;		/* Bit array of VOLUME_* flags. */
+	NTFS_GUID guid;		/* The volume guid if present (otherwise it is
+				   a NULL guid). */
+
+	u16 sector_size;	/* Byte size of a sector. */
+	u8 sector_size_bits;	/* Log(2) of the byte size of a sector. */
+	u32 cluster_size;	/* Byte size of a cluster. */
+	u32 mft_record_size;	/* Byte size of a mft record. */
+	u32 indx_record_size;	/* Byte size of a INDX record. */
+	u8 cluster_size_bits;	/* Log(2) of the byte size of a cluster. */
+	u8 mft_record_size_bits;/* Log(2) of the byte size of a mft record. */
+	u8 indx_record_size_bits;/* Log(2) of the byte size of a INDX record. */
+
+	/* Variables used by the cluster and mft allocators. */
+	u8 mft_zone_multiplier;	/* Initial mft zone multiplier. */
+	s64 mft_data_pos;	/* Mft record number at which to allocate the
+				   next mft record. */
+	NTFS_LCN mft_zone_start;	/* First cluster of the mft zone. */
+	NTFS_LCN mft_zone_end;	/* First cluster beyond the mft zone. */
+	NTFS_LCN mft_zone_pos;	/* Current position in the mft zone. */
+	NTFS_LCN data1_zone_pos;	/* Current position in the first data zone. */
+	NTFS_LCN data2_zone_pos;	/* Current position in the second data zone. */
+
+	s64 nr_clusters;	/* Volume size in clusters, hence also the
+				   number of bits in lcn_bitmap. */
+	ntfs_inode *lcnbmp_ni;	/* ntfs_inode structure for NTFS_FILE_Bitmap. */
+	ntfs_attr *lcnbmp_na;	/* ntfs_attr structure for the data attribute
+				   of NTFS_FILE_Bitmap. Each bit represents a
+				   cluster on the volume, bit 0 representing
+				   lcn 0 and so on. A set bit means that the
+				   cluster and vice versa. */
+
+	NTFS_LCN mft_lcn;		/* Logical cluster number of the data attribute
+				   for NTFS_FILE_MFT. */
+	ntfs_inode *mft_ni;	/* ntfs_inode structure for NTFS_FILE_MFT. */
+	ntfs_attr *mft_na;	/* ntfs_attr structure for the data attribute
+				   of NTFS_FILE_MFT. */
+	ntfs_attr *mftbmp_na;	/* ntfs_attr structure for the bitmap attribute
+				   of NTFS_FILE_MFT. Each bit represents an mft
+				   record in the $DATA attribute, bit 0
+				   representing mft record 0 and so on. A set
+				   bit means that the mft record is in use and
+				   vice versa. */
+
+	int mftmirr_size;	/* Size of the NTFS_FILE_MFTMirr in mft records. */
+	NTFS_LCN mftmirr_lcn;	/* Logical cluster number of the data attribute
+				   for NTFS_FILE_MFTMirr. */
+	ntfs_inode *mftmirr_ni;	/* ntfs_inode structure for NTFS_FILE_MFTMirr. */
+	ntfs_attr *mftmirr_na;	/* ntfs_attr structure for the data attribute
+				   of NTFS_FILE_MFTMirr. */
+
+	ntfschar *upcase;	/* Upper case equivalents of all 65536 2-byte
+				   Unicode characters. Obtained from
+				   NTFS_FILE_UpCase. */
+	u32 upcase_len;		/* Length in Unicode characters of the upcase
+				   table. */
+
+	NTFS_ATTR_DEF *attrdef;	/* Attribute definitions. Obtained from
+				   NTFS_FILE_AttrDef. */
+	s32 attrdef_len;	/* Size of the attribute definition table in
+				   bytes. */
+
+	long nr_free_clusters;	/* This two are self explaining. */
+	long nr_free_mft_records;
+
+	struct ntfs_list_head inode_cache[NTFS_INODE_CACHE_SIZE]; /* List of opened
+								inodes. */
+};
+
+extern ntfs_volume *ntfs_volume_alloc(void);
+
+extern ntfs_volume *ntfs_volume_startup(struct ntfs_device *dev,
+		ntfs_mount_flags flags);
+
+extern ntfs_volume *ntfs_device_mount(struct ntfs_device *dev,
+		ntfs_mount_flags flags);
+extern int ntfs_device_umount(ntfs_volume *vol, const NTFS_BOOL force);
+
+extern ntfs_volume *ntfs_mount(const char *name, ntfs_mount_flags flags);
+extern int ntfs_umount(ntfs_volume *vol, const NTFS_BOOL force);
+
+extern int ntfs_version_is_supported(ntfs_volume *vol);
+extern int ntfs_logfile_reset(ntfs_volume *vol);
+
+extern int ntfs_volume_write_flags(ntfs_volume *vol, const le16 flags);
+
+__END_DECLS
+
+#endif /* defined _NTFS_VOLUME_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/runlist.h ./include/ntfs/runlist.h
--- ../ntfsprogs-2.0.0/include/ntfs/runlist.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/runlist.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,90 +0,0 @@
-/*
- * runlist.h - Exports for runlist handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2002 Anton Altaparmakov
- * Copyright (c) 2002 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_RUNLIST_H
-#define _NTFS_RUNLIST_H
-
-#include "types.h"
-
-/* Forward declarations */
-typedef struct _runlist_element runlist_element;
-typedef runlist_element runlist;
-
-#include "attrib.h"
-#include "volume.h"
-
-/**
- * struct _runlist_element - in memory vcn to lcn mapping array element.
- * @vcn:	starting vcn of the current array element
- * @lcn:	starting lcn of the current array element
- * @length:	length in clusters of the current array element
- *
- * The last vcn (in fact the last vcn + 1) is reached when length == 0.
- *
- * When lcn == -1 this means that the count vcns starting at vcn are not
- * physically allocated (i.e. this is a hole / data is sparse).
- */
-struct _runlist_element {/* In memory vcn to lcn mapping structure element. */
-	VCN vcn;	/* vcn = Starting virtual cluster number. */
-	LCN lcn;	/* lcn = Starting logical cluster number. */
-	s64 length;	/* Run length in clusters. */
-};
-
-extern LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn);
-
-extern s64 ntfs_rl_pread(const ntfs_volume *vol, const runlist_element *rl,
-		const s64 pos, s64 count, void *b);
-extern s64 ntfs_rl_pwrite(const ntfs_volume *vol, const runlist_element *rl,
-		const s64 pos, s64 count, void *b);
-
-extern int ntfs_rl_fill_zero(const ntfs_volume *vol, const runlist *rl,
-		s64 pos, const s64 count);
-
-extern runlist_element *ntfs_runlists_merge(runlist_element *drl,
-		runlist_element *srl);
-
-extern runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,
-		const ATTR_RECORD *attr, runlist_element *old_rl);
-
-extern int ntfs_get_nr_significant_bytes(const s64 n);
-
-extern int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,
-		const runlist_element *rl, const VCN start_vcn);
-
-extern int ntfs_write_significant_bytes(u8 *dst, const u8 *dst_max,
-		const s64 n);
-
-extern int ntfs_mapping_pairs_build(const ntfs_volume *vol, u8 *dst,
-		const int dst_len, const runlist_element *rl,
-		const VCN start_vcn, VCN *const stop_vcn);
-
-extern int ntfs_rl_truncate(runlist **arl, const VCN start_vcn);
-
-extern int ntfs_rl_sparse(runlist *rl);
-extern s64 ntfs_rl_get_compressed_size(ntfs_volume *vol, runlist *rl);
-
-#ifdef NTFS_TEST
-int test_rl_main(int argc, char *argv[]);
-#endif
-
-#endif /* defined _NTFS_RUNLIST_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/security.h ./include/ntfs/security.h
--- ../ntfsprogs-2.0.0/include/ntfs/security.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/security.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/*
- * security.h - Exports for handling security/ACLs in NTFS.  Part of the
- *		Linux-NTFS project.
- *
- * Copyright (c) 2004 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_SECURITY_H
-#define _NTFS_SECURITY_H
-
-#include "types.h"
-#include "layout.h"
-
-extern const GUID *const zero_guid;
-
-extern BOOL ntfs_guid_is_zero(const GUID *guid);
-extern char *ntfs_guid_to_mbs(const GUID *guid, char *guid_str);
-
-/**
- * ntfs_sid_is_valid - determine if a SID is valid
- * @sid:	SID for which to determine if it is valid
- *
- * Determine if the SID pointed to by @sid is valid.
- *
- * Return TRUE if it is valid and FALSE otherwise.
- */
-static __inline__ BOOL ntfs_sid_is_valid(const SID *sid)
-{
-	if (!sid || sid->revision != SID_REVISION ||
-			sid->sub_authority_count > SID_MAX_SUB_AUTHORITIES)
-		return FALSE;
-	return TRUE;
-}
-
-extern int ntfs_sid_to_mbs_size(const SID *sid);
-extern char *ntfs_sid_to_mbs(const SID *sid, char *sid_str,
-		size_t sid_str_size);
-extern void ntfs_generate_guid(GUID *guid);
-
-#endif /* defined _NTFS_SECURITY_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/support.h ./include/ntfs/support.h
--- ../ntfsprogs-2.0.0/include/ntfs/support.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/support.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-/*
- * support.h - Various useful things. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2004 Anton Altaparmakov
- * Copyright (c)      2006 Szabolcs Szakacsits
- * Copyright (c)      2006 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_SUPPORT_H
-#define _NTFS_SUPPORT_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef HAVE_STDDEF_H
-#include <stddef.h>
-#endif
-
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-
-#include "logging.h"
-
-/*
- * Our mailing list. Use this define to prevent typos in email address.
- */
-#define NTFS_DEV_LIST	"linux-ntfs-dev@lists.sf.net"
-
-/*
- * Generic macro to convert pointers to values for comparison purposes.
- */
-#ifndef p2n
-#define p2n(p)		((ptrdiff_t)((ptrdiff_t*)(p)))
-#endif
-
-/*
- * The classic min and max macros.
- */
-#ifndef min
-#define min(a,b)	((a) <= (b) ? (a) : (b))
-#endif
-
-#ifndef max
-#define max(a,b)	((a) >= (b) ? (a) : (b))
-#endif
-
-/*
- * Useful macro for determining the offset of a struct member.
- */
-#ifndef offsetof
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-#endif
-
-/*
- * Round up and down @num to 2 in power of @order.
- */
-#define ROUND_UP(num,order)	(((num) + ((1 << (order)) - 1)) & \
-				~((1 << (order)) - 1))
-#define ROUND_DOWN(num,order)	((num) & ~((1 << (order)) - 1))
-
-/*
- * Simple bit operation macros. NOTE: These are NOT atomic.
- */
-#define test_bit(bit, var)	      ((var) & (1 << (bit)))
-#define set_bit(bit, var)	      (var) |= 1 << (bit)
-#define clear_bit(bit, var)	      (var) &= ~(1 << (bit))
-
-#define test_and_set_bit(bit, var)			\
-({							\
-	const BOOL old_state = test_bit(bit, var);	\
-	set_bit(bit, var);				\
-	old_state;					\
-})
-
-#define test_and_clear_bit(bit, var)			\
-({							\
-	const BOOL old_state = test_bit(bit, var);	\
-	clear_bit(bit, var);				\
-	old_state;					\
-})
-
-/* Memory allocation with logging. */
-extern void *ntfs_calloc(size_t size);
-extern void *ntfs_malloc(size_t size);
-
-#endif /* defined _NTFS_SUPPORT_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/types.h ./include/ntfs/types.h
--- ../ntfsprogs-2.0.0/include/ntfs/types.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/types.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-/*
- * types.h - Misc type definitions not related to on-disk structure.  Part of
- *	     the Linux-NTFS project.
- *
- * Copyright (c) 2000-2004 Anton Altaparmakov
- * Copyright (c)      2006 Szabolcs Szakacsits
- * Copyright (c)      2007 Yura Pakhuchiy
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_TYPES_H
-#define _NTFS_TYPES_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#if HAVE_STDINT_H || !HAVE_CONFIG_H
-#include <stdint.h>
-#endif
-#ifdef HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-typedef uint8_t  u8;			/* Unsigned types of an exact size */
-typedef uint16_t u16;
-typedef uint32_t u32;
-typedef uint64_t u64;
-
-typedef int8_t  s8;			/* Signed types of an exact size */
-typedef int16_t s16;
-typedef int32_t s32;
-typedef int64_t s64;
-
-#if defined(__CHECKER__) && !defined(NTFS_DO_NOT_CHECK_ENDIANS)
-	#undef __bitwise
-	#undef __force
-	#define __bitwise __attribute__((bitwise))
-	#define __force __attribute__((force))
-#else
-	#undef __bitwise
-	#undef __force
-	#define __bitwise
-	#define __force
-#endif
-
-typedef u16 __bitwise le16;
-typedef u32 __bitwise le32;
-typedef u64 __bitwise le64;
-
-/*
- * Declare sle{16,32,64} to be unsigned because we do not want sign extension
- * on BE architectures.
- */
-typedef u16 __bitwise sle16;
-typedef u32 __bitwise sle32;
-typedef u64 __bitwise sle64;
-
-typedef u16 __bitwise be16;
-typedef u32 __bitwise be32;
-typedef u64 __bitwise be64;
-
-typedef le16 ntfschar;			/* 2-byte Unicode character type. */
-#define UCHAR_T_SIZE_BITS 1
-
-/*
- * Clusters are signed 64-bit values on NTFS volumes.  We define two types, LCN
- * and VCN, to allow for type checking and better code readability.
- */
-typedef s64 VCN;
-typedef sle64 leVCN;
-typedef s64 LCN;
-typedef sle64 leLCN;
-
-/*
- * The NTFS journal $LogFile uses log sequence numbers which are signed 64-bit
- * values.  We define our own type LSN, to allow for type checking and better
- * code readability.
- */
-typedef s64 LSN;
-typedef sle64 leLSN;
-
-/*
- * Cygwin has a collision between our BOOL and <windef.h>'s
- * As long as this file will be included after <windows.h> we're fine.
- */
-#ifndef _WINDEF_H
-/**
- * enum BOOL - These are just to make the code more readable...
- */
-typedef enum {
-#ifndef FALSE
-	FALSE = 0,
-#endif
-#ifndef NO
-	NO = 0,
-#endif
-#ifndef ZERO
-	ZERO = 0,
-#endif
-#ifndef TRUE
-	TRUE = 1,
-#endif
-#ifndef YES
-	YES = 1,
-#endif
-#ifndef ONE
-	ONE = 1,
-#endif
-} BOOL;
-#endif /* defined _WINDEF_H */
-
-/**
- * enum IGNORE_CASE_BOOL -
- */
-typedef enum {
-	CASE_SENSITIVE = 0,
-	IGNORE_CASE = 1,
-} IGNORE_CASE_BOOL;
-
-#define STATUS_OK				(0)
-#define STATUS_ERROR				(-1)
-#define STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT	(-2)
-#define STATUS_KEEP_SEARCHING			(-3)
-#define STATUS_NOT_FOUND			(-4)
-
-#endif /* defined _NTFS_TYPES_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/unistr.h ./include/ntfs/unistr.h
--- ../ntfsprogs-2.0.0/include/ntfs/unistr.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/unistr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
- * unistr.h - Exports for Unicode string handling. Part of the Linux-NTFS
- *	      project.
- *
- * Copyright (c) 2000-2006 Anton Altaparmakov
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_UNISTR_H
-#define _NTFS_UNISTR_H
-
-#include "types.h"
-#include "layout.h"
-
-extern BOOL ntfs_names_are_equal(const ntfschar *s1, size_t s1_len,
-		const ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,
-		const ntfschar *upcase, const u32 upcase_size);
-
-extern int ntfs_names_collate(const ntfschar *name1, const u32 name1_len,
-		const ntfschar *name2, const u32 name2_len,
-		const int err_val, const IGNORE_CASE_BOOL ic,
-		const ntfschar *upcase, const u32 upcase_len);
-
-extern int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n);
-
-extern int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,
-		const ntfschar *upcase, const u32 upcase_size);
-
-extern u32 ntfs_ucsnlen(const ntfschar *s, u32 maxlen);
-
-extern ntfschar *ntfs_ucsndup(const ntfschar *s, u32 maxlen);
-
-extern void ntfs_name_upcase(ntfschar *name, u32 name_len,
-		const ntfschar *upcase, const u32 upcase_len);
-
-extern void ntfs_file_value_upcase(FILE_NAME_ATTR *file_name_attr,
-		const ntfschar *upcase, const u32 upcase_len);
-
-extern int ntfs_file_values_compare(const FILE_NAME_ATTR *file_name_attr1,
-		const FILE_NAME_ATTR *file_name_attr2,
-		const int err_val, const IGNORE_CASE_BOOL ic,
-		const ntfschar *upcase, const u32 upcase_len);
-
-extern int ntfs_ucstombs(const ntfschar *ins, const int ins_len, char **outs,
-		int outs_len);
-extern int ntfs_mbstoucs(const char *ins, ntfschar **outs, int outs_len);
-
-extern void ntfs_upcase_table_build(ntfschar *uc, u32 uc_len);
-
-extern ntfschar *ntfs_str2ucs(const char *s, int *len);
-
-extern void ntfs_ucsfree(ntfschar *ucs);
-
-#endif /* defined _NTFS_UNISTR_H */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/version.h ./include/ntfs/version.h
--- ../ntfsprogs-2.0.0/include/ntfs/version.h	2007-09-26 20:28:40.000000000 +0200
+++ ./include/ntfs/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-/*
- * version.h - Info about the NTFS library.  Part of the Linux-NTFS project.
- *
- * Copyright (c) 2005 Anton Altaparmakov
- * Copyright (c) 2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_VERSION_H_
-#define _NTFS_VERSION_H_
-
-extern const char *ntfs_libntfs_version(void);
-
-#endif /* _NTFS_VERSION_H_ */
-
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/include/ntfs/volume.h ./include/ntfs/volume.h
--- ../ntfsprogs-2.0.0/include/ntfs/volume.h	2007-09-27 14:32:20.000000000 +0200
+++ ./include/ntfs/volume.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,247 +0,0 @@
-/*
- * volume.h - Exports for NTFS volume handling. Part of the Linux-NTFS project.
- *
- * Copyright (c) 2000-2004 Anton Altaparmakov
- * Copyright (c) 2005-2007 Yura Pakhuchiy
- * Copyright (c) 2004-2005 Richard Russon
- *
- * This program/include file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program/include file is distributed in the hope that it will be
- * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program (in the main directory of the Linux-NTFS
- * distribution in the file COPYING); if not, write to the Free Software
- * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _NTFS_VOLUME_H
-#define _NTFS_VOLUME_H
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#ifdef HAVE_STDIO_H
-#include <stdio.h>
-#endif
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#ifdef HAVE_SYS_MOUNT_H
-#include <sys/mount.h>
-#endif
-#ifdef HAVE_MNTENT_H
-#include <mntent.h>
-#endif
-
-/* Forward declaration */
-typedef struct _ntfs_volume ntfs_volume;
-
-#include "list.h"
-#include "types.h"
-#include "support.h"
-#include "device.h"
-#include "inode.h"
-#include "attrib.h"
-
-/**
- * enum ntfs_mount_flags -
- *
- * Flags for the ntfs_mount() function.
- */
-typedef enum {
-	NTFS_MNT_RDONLY	 	= 1,
-	NTFS_MNT_FORENSIC	= 2,
-	NTFS_MNT_CASE_SENSITIVE	= 4,
-	NTFS_MNT_NOT_EXCLUSIVE	= 8,
-	NTFS_MNT_FORCE		= 16,
-	NTFS_MNT_INTERIX	= 32,
-} ntfs_mount_flags;
-
-/**
- * enum ntfs_mounted_flags -
- *
- * Flags returned by the ntfs_check_if_mounted() function.
- */
-typedef enum {
-	NTFS_MF_MOUNTED		= 1,	/* Device is mounted. */
-	NTFS_MF_ISROOT		= 2,	/* Device is mounted as system root. */
-	NTFS_MF_READONLY	= 4,	/* Device is mounted read-only. */
-} ntfs_mounted_flags;
-
-extern int ntfs_check_if_mounted(const char *file, unsigned long *mnt_flags);
-
-/**
- * enum ntfs_volume_state_bits -
- *
- * Defined bits for the state field in the ntfs_volume structure.
- */
-typedef enum {
-	NV_ReadOnly,		/* 1: Volume is read-only. */
-	NV_CaseSensitive,	/* 1: Volume is mounted case-sensitive. */
-	NV_LogFileEmpty,	/* 1: $logFile journal is empty. */
-	NV_NoATime,		/* 1: Do not update access time. */
-	NV_WasDirty,		/* 1: Volume was marked dirty before we mounted
-				      it. */
-	NV_ForensicMount,	/* 1: Mount is forensic, i.e. no modifications
-				      are to be done by mount/umount. */
-	NV_Interix,		/* 1: Make libntfs recognize Interix special
-				      files. */
-} ntfs_volume_state_bits;
-
-#define  test_nvol_flag(nv, flag)	 test_bit(NV_##flag, (nv)->state)
-#define   set_nvol_flag(nv, flag)	  set_bit(NV_##flag, (nv)->state)
-#define clear_nvol_flag(nv, flag)	clear_bit(NV_##flag, (nv)->state)
-
-#define NVolReadOnly(nv)		 test_nvol_flag(nv, ReadOnly)
-#define NVolSetReadOnly(nv)		  set_nvol_flag(nv, ReadOnly)
-#define NVolClearReadOnly(nv)		clear_nvol_flag(nv, ReadOnly)
-
-#define NVolCaseSensitive(nv)		 test_nvol_flag(nv, CaseSensitive)
-#define NVolSetCaseSensitive(nv)	  set_nvol_flag(nv, CaseSensitive)
-#define NVolClearCaseSensitive(nv)	clear_nvol_flag(nv, CaseSensitive)
-
-#define NVolLogFileEmpty(nv)		 test_nvol_flag(nv, LogFileEmpty)
-#define NVolSetLogFileEmpty(nv)		  set_nvol_flag(nv, LogFileEmpty)
-#define NVolClearLogFileEmpty(nv)	clear_nvol_flag(nv, LogFileEmpty)
-
-#define NVolWasDirty(nv)		 test_nvol_flag(nv, WasDirty)
-#define NVolSetWasDirty(nv)		  set_nvol_flag(nv, WasDirty)
-#define NVolClearWasDirty(nv)		clear_nvol_flag(nv, WasDirty)
-
-#define NVolForensicMount(nv)		 test_nvol_flag(nv, ForensicMount)
-#define NVolSetForensicMount(nv)	  set_nvol_flag(nv, ForensicMount)
-#define NVolClearForensicMount(nv)	clear_nvol_flag(nv, ForensicMount)
-
-#define NVolInterix(nv)			 test_nvol_flag(nv, Interix)
-#define NVolSetInterix(nv)		  set_nvol_flag(nv, Interix)
-#define NVolClearInterix(nv)		clear_nvol_flag(nv, Interix)
-
-/*
- * NTFS version 1.1 and 1.2 are used by Windows NT4.
- * NTFS version 2.x is used by Windows 2000 Beta
- * NTFS version 3.0 is used by Windows 2000.
- * NTFS version 3.1 is used by Windows XP, 2003 and Vista.
- */
-
-#define NTFS_V1_1(major, minor) ((major) == 1 && (minor) == 1)
-#define NTFS_V1_2(major, minor) ((major) == 1 && (minor) == 2)
-#define NTFS_V2_X(major, minor) ((major) == 2)
-#define NTFS_V3_0(major, minor) ((major) == 3 && (minor) == 0)
-#define NTFS_V3_1(major, minor) ((major) == 3 && (minor) == 1)
-
-#define NTFS_BUF_SIZE 8192
-
-#define NTFS_INODE_CACHE_SIZE 512 /* WARNING: This should be power of 2. */
-#define NTFS_INODE_CACHE_SIZE_BITS (NTFS_INODE_CACHE_SIZE - 1)
-
-/**
- * struct _ntfs_volume - structure describing an open volume in memory.
- */
-struct _ntfs_volume {
-	union {
-		struct ntfs_device *dev;	/* NTFS device associated with
-						   the volume. */
-		void *sb;	/* For kernel porting compatibility. */
-	};
-	char *vol_name;		/* Name of the volume. */
-	unsigned long state;	/* NTFS specific flags describing this volume.
-				   See ntfs_volume_state_bits above. */
-
-	ntfs_inode *vol_ni;	/* ntfs_inode structure for FILE_Volume. */
-	u8 major_ver;		/* Ntfs major version of volume. */
-	u8 minor_ver;		/* Ntfs minor version of volume. */
-	le16 flags;		/* Bit array of VOLUME_* flags. */
-	GUID guid;		/* The volume guid if present (otherwise it is
-				   a NULL guid). */
-
-	u16 sector_size;	/* Byte size of a sector. */
-	u8 sector_size_bits;	/* Log(2) of the byte size of a sector. */
-	u32 cluster_size;	/* Byte size of a cluster. */
-	u32 mft_record_size;	/* Byte size of a mft record. */
-	u32 indx_record_size;	/* Byte size of a INDX record. */
-	u8 cluster_size_bits;	/* Log(2) of the byte size of a cluster. */
-	u8 mft_record_size_bits;/* Log(2) of the byte size of a mft record. */
-	u8 indx_record_size_bits;/* Log(2) of the byte size of a INDX record. */
-
-	/* Variables used by the cluster and mft allocators. */
-	u8 mft_zone_multiplier;	/* Initial mft zone multiplier. */
-	s64 mft_data_pos;	/* Mft record number at which to allocate the
-				   next mft record. */
-	LCN mft_zone_start;	/* First cluster of the mft zone. */
-	LCN mft_zone_end;	/* First cluster beyond the mft zone. */
-	LCN mft_zone_pos;	/* Current position in the mft zone. */
-	LCN data1_zone_pos;	/* Current position in the first data zone. */
-	LCN data2_zone_pos;	/* Current position in the second data zone. */
-
-	s64 nr_clusters;	/* Volume size in clusters, hence also the
-				   number of bits in lcn_bitmap. */
-	ntfs_inode *lcnbmp_ni;	/* ntfs_inode structure for FILE_Bitmap. */
-	ntfs_attr *lcnbmp_na;	/* ntfs_attr structure for the data attribute
-				   of FILE_Bitmap. Each bit represents a
-				   cluster on the volume, bit 0 representing
-				   lcn 0 and so on. A set bit means that the
-				   cluster and vice versa. */
-
-	LCN mft_lcn;		/* Logical cluster number of the data attribute
-				   for FILE_MFT. */
-	ntfs_inode *mft_ni;	/* ntfs_inode structure for FILE_MFT. */
-	ntfs_attr *mft_na;	/* ntfs_attr structure for the data attribute
-				   of FILE_MFT. */
-	ntfs_attr *mftbmp_na;	/* ntfs_attr structure for the bitmap attribute
-				   of FILE_MFT. Each bit represents an mft
-				   record in the $DATA attribute, bit 0
-				   representing mft record 0 and so on. A set
-				   bit means that the mft record is in use and
-				   vice versa. */
-
-	int mftmirr_size;	/* Size of the FILE_MFTMirr in mft records. */
-	LCN mftmirr_lcn;	/* Logical cluster number of the data attribute
-				   for FILE_MFTMirr. */
-	ntfs_inode *mftmirr_ni;	/* ntfs_inode structure for FILE_MFTMirr. */
-	ntfs_attr *mftmirr_na;	/* ntfs_attr structure for the data attribute
-				   of FILE_MFTMirr. */
-
-	ntfschar *upcase;	/* Upper case equivalents of all 65536 2-byte
-				   Unicode characters. Obtained from
-				   FILE_UpCase. */
-	u32 upcase_len;		/* Length in Unicode characters of the upcase
-				   table. */
-
-	ATTR_DEF *attrdef;	/* Attribute definitions. Obtained from
-				   FILE_AttrDef. */
-	s32 attrdef_len;	/* Size of the attribute definition table in
-				   bytes. */
-
-	long nr_free_clusters;	/* This two are self explaining. */
-	long nr_free_mft_records;
-
-	struct list_head inode_cache[NTFS_INODE_CACHE_SIZE]; /* List of opened
-								inodes. */
-};
-
-extern ntfs_volume *ntfs_volume_alloc(void);
-
-extern ntfs_volume *ntfs_volume_startup(struct ntfs_device *dev,
-		ntfs_mount_flags flags);
-
-extern ntfs_volume *ntfs_device_mount(struct ntfs_device *dev,
-		ntfs_mount_flags flags);
-extern int ntfs_device_umount(ntfs_volume *vol, const BOOL force);
-
-extern ntfs_volume *ntfs_mount(const char *name, ntfs_mount_flags flags);
-extern int ntfs_umount(ntfs_volume *vol, const BOOL force);
-
-extern int ntfs_version_is_supported(ntfs_volume *vol);
-extern int ntfs_logfile_reset(ntfs_volume *vol);
-
-extern int ntfs_volume_write_flags(ntfs_volume *vol, const le16 flags);
-
-#endif /* defined _NTFS_VOLUME_H */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/attrib.c ./libntfs/attrib.c
--- ../ntfsprogs-2.0.0/libntfs/attrib.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/attrib.c	2007-10-06 16:48:07.000000000 +0200
@@ -39,27 +39,27 @@
 #include <errno.h>
 #endif

-#include "compat.h"
-#include "attrib.h"
-#include "attrlist.h"
-#include "device.h"
-#include "mft.h"
-#include "debug.h"
-#include "mst.h"
-#include "volume.h"
-#include "types.h"
-#include "layout.h"
-#include "inode.h"
-#include "runlist.h"
-#include "lcnalloc.h"
-#include "dir.h"
-#include "compress.h"
-#include "bitmap.h"
-#include "logging.h"
-#include "support.h"
-#include "crypto.h"
+#include "ntfs_compat.h"
+#include "ntfs_attrib.h"
+#include "ntfs_attrlist.h"
+#include "ntfs_device.h"
+#include "ntfs_mft.h"
+#include "ntfs_debug.h"
+#include "ntfs_mst.h"
+#include "ntfs_volume.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_inode.h"
+#include "ntfs_runlist.h"
+#include "ntfs_lcnalloc.h"
+#include "ntfs_dir.h"
+#include "ntfs_compress.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_logging.h"
+#include "ntfs_support.h"
+#include "ntfs_crypto.h"

-ntfschar AT_UNNAMED[] = { const_cpu_to_le16('\0') };
+ntfschar NTFS_AT_UNNAMED[] = { const_cpu_to_le16('\0') };

 /**
  * ntfs_get_attribute_value_length - Find the length of an attribute
@@ -69,7 +69,7 @@
  *
  * Returns:
  */
-s64 ntfs_get_attribute_value_length(const ATTR_RECORD *a)
+s64 ntfs_get_attribute_value_length(const NTFS_ATTR_RECORD *a)
 {
 	if (!a) {
 		errno = EINVAL;
@@ -92,9 +92,9 @@
  * Returns:
  */
 s64 ntfs_get_attribute_value(const ntfs_volume *vol,
-		const ATTR_RECORD *a, u8 *b)
+		const NTFS_ATTR_RECORD *a, u8 *b)
 {
-	runlist *rl;
+	ntfs_runlist *rl;
 	s64 total, r;
 	int i;

@@ -109,7 +109,7 @@
 	 * attribute.  Windows does not complain about invalid flags and chkdsk
 	 * does not detect or fix them so we need to cope with it, too.
 	 */
-	if (a->type != AT_ATTRIBUTE_LIST && a->flags) {
+	if (a->type != NTFS_AT_ATTRIBUTE_LIST && a->flags) {
 		ntfs_log_error("Non-zero (%04x) attribute flags. Cannot handle "
 			       "this yet.\n", le16_to_cpu(a->flags));
 		errno = EOPNOTSUPP;
@@ -140,7 +140,7 @@
 	/*
 	 * FIXME: What about attribute lists?!? (AIA)
 	 */
-	/* Decompress the mapping pairs array into a runlist. */
+	/* Decompress the mapping pairs array into a ntfs_runlist. */
 	rl = ntfs_mapping_pairs_decompress(vol, a, NULL);
 	if (!rl) {
 		errno = EINVAL;
@@ -148,7 +148,7 @@
 	}
 	/*
 	 * FIXED: We were overflowing here in a nasty fashion when we
-	 * reach the last cluster in the runlist as the buffer will
+	 * reach the last cluster in the ntfs_runlist as the buffer will
 	 * only be big enough to hold data_size bytes while we are
 	 * reading in allocated_size bytes which is usually larger
 	 * than data_size, since the actual data is unlikely to have a
@@ -157,7 +157,7 @@
 	 * when the data_size was more than one run smaller than the
 	 * allocated size which happens with Windows XP sometimes.
 	 */
-	/* Now load all clusters in the runlist into b. */
+	/* Now load all clusters in the ntfs_runlist into b. */
 	for (i = 0, total = 0; rl[i].length; i++) {
 		if (total + (rl[i].length << vol->cluster_size_bits) >=
 				sle64_to_cpu(a->data_size)) {
@@ -274,7 +274,7 @@
  * Initialize the ntfs attribute @na with @ni, @type, @name, and @name_len.
  */
 static void __ntfs_attr_init(ntfs_attr *na, ntfs_inode *ni,
-		const ATTR_TYPES type, ntfschar *name, const u32 name_len)
+		const NTFS_ATTR_TYPES type, ntfschar *name, const u32 name_len)
 {
 	na->rl = NULL;
 	na->ni = ni;
@@ -301,8 +301,8 @@
  *
  * Final initialization for an ntfs attribute.
  */
-void ntfs_attr_init(ntfs_attr *na, const BOOL non_resident,
-		const BOOL compressed, const BOOL encrypted, const BOOL sparse,
+void ntfs_attr_init(ntfs_attr *na, const NTFS_BOOL non_resident,
+		const NTFS_BOOL compressed, const NTFS_BOOL encrypted, const NTFS_BOOL sparse,
 		const s64 allocated_size, const s64 data_size,
 		const s64 initialized_size, const s64 compressed_size,
 		const u8 compression_unit)
@@ -337,26 +337,26 @@
  * ntfs_attr_open - open an ntfs attribute for access
  * @ni:		open ntfs inode in which the ntfs attribute resides
  * @type:	attribute type
- * @name:	attribute name in little endian Unicode or AT_UNNAMED or NULL
+ * @name:	attribute name in little endian Unicode or NTFS_AT_UNNAMED or NULL
  * @name_len:	length of attribute @name in Unicode characters (if @name given)
  *
  * Allocate a new ntfs attribute structure, initialize it with @ni, @type,
  * @name, and @name_len, then return it. Return NULL on error with
  * errno set to the error code.
  *
- * If @name is AT_UNNAMED look specifically for an unnamed attribute.  If you
+ * If @name is NTFS_AT_UNNAMED look specifically for an unnamed attribute.  If you
  * do not care whether the attribute is named or not set @name to NULL.  In
  * both those cases @name_len is not used at all.
  */
-ntfs_attr *ntfs_attr_open(ntfs_inode *ni, const ATTR_TYPES type,
+ntfs_attr *ntfs_attr_open(ntfs_inode *ni, const NTFS_ATTR_TYPES type,
 		ntfschar *name, u32 name_len)
 {
 	ntfs_attr_search_ctx *ctx;
 	ntfs_attr *na;
-	ATTR_RECORD *a;
-	struct list_head *pos;
+	NTFS_ATTR_RECORD *a;
+	struct ntfs_list_head *pos;
 	int err;
-	BOOL cs;
+	NTFS_BOOL cs;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x.\n",
 		(unsigned long long)ni->mft_no, type);
@@ -365,10 +365,10 @@
 		return NULL;
 	}
 	/* Check cache, maybe this attribute already opened? */
-	list_for_each(pos, &ni->attr_cache) {
+	ntfs_list_for_each(pos, &ni->attr_cache) {
 		ntfs_attr *tmp_na;

-		tmp_na = list_entry(pos, ntfs_attr, list_entry);
+		tmp_na = ntfs_list_entry(pos, ntfs_attr, ntfs_list_entry);
 		if (tmp_na->type == type && tmp_na->name_len == name_len &&
 				!ntfs_ucsncmp(tmp_na->name, name, name_len)) {
 			ntfs_log_trace("Found this attribute in cache, "
@@ -382,7 +382,7 @@
 	na = calloc(sizeof(ntfs_attr), 1);
 	if (!na)
 		return NULL;
-	if (name && name != AT_UNNAMED && name != NTFS_INDEX_I30) {
+	if (name && name != NTFS_AT_UNNAMED && name != NTFS_INDEX_I30) {
 		name = ntfs_ucsndup(name, name_len);
 		if (!name) {
 			err = errno;
@@ -408,9 +408,9 @@
 	 * attribute.  Windows does not complain about invalid flags and chkdsk
 	 * does not detect or fix them so we need to cope with it, too.
 	 */
-	if (type == AT_ATTRIBUTE_LIST)
+	if (type == NTFS_AT_ATTRIBUTE_LIST)
 		a->flags = 0;
-	cs = (a->flags & (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE)) ? 1 : 0;
+	cs = (a->flags & (NTFS_ATTR_IS_COMPRESSED | NTFS_ATTR_IS_SPARSE)) ? 1 : 0;
 	if (!name) {
 		if (a->name_length) {
 			name = ntfs_ucsndup((ntfschar*)((u8*)a + le16_to_cpu(
@@ -421,15 +421,15 @@
 			}
 			name_len = a->name_length;
 		} else {
-			name = AT_UNNAMED;
+			name = NTFS_AT_UNNAMED;
 			name_len = 0;
 		}
 	}
 	__ntfs_attr_init(na, ni, type, name, name_len);
 	if (a->non_resident) {
-		ntfs_attr_init(na, TRUE, (a->flags & ATTR_IS_COMPRESSED)? 1 : 0,
-				(a->flags & ATTR_IS_ENCRYPTED) ? 1 : 0,
-				(a->flags & ATTR_IS_SPARSE) ? 1 : 0,
+		ntfs_attr_init(na, TRUE, (a->flags & NTFS_ATTR_IS_COMPRESSED)? 1 : 0,
+				(a->flags & NTFS_ATTR_IS_ENCRYPTED) ? 1 : 0,
+				(a->flags & NTFS_ATTR_IS_SPARSE) ? 1 : 0,
 				sle64_to_cpu(a->allocated_size),
 				sle64_to_cpu(a->data_size),
 				sle64_to_cpu(a->initialized_size),
@@ -437,15 +437,15 @@
 				cs ? a->compression_unit : 0);
 	} else {
 		s64 l = le32_to_cpu(a->value_length);
-		ntfs_attr_init(na, FALSE, (a->flags & ATTR_IS_COMPRESSED) ? 1:0,
-				(a->flags & ATTR_IS_ENCRYPTED) ? 1 : 0,
-				(a->flags & ATTR_IS_SPARSE) ? 1 : 0,
+		ntfs_attr_init(na, FALSE, (a->flags & NTFS_ATTR_IS_COMPRESSED) ? 1:0,
+				(a->flags & NTFS_ATTR_IS_ENCRYPTED) ? 1 : 0,
+				(a->flags & NTFS_ATTR_IS_SPARSE) ? 1 : 0,
 				(l + 7) & ~7, l, l, cs ? (l + 7) & ~7 : 0, 0);
 	}
 	ntfs_attr_put_search_ctx(ctx);
 	if (NAttrEncrypted(na))
 		ntfs_crypto_attr_open(na);
-	list_add_tail(&na->list_entry, &ni->attr_cache);
+	ntfs_list_add_tail(&na->ntfs_list_entry, &ni->attr_cache);
 	na->nr_references = 1;
 	return na;
 put_err_out:
@@ -474,36 +474,36 @@
 		return;
 	}
 	ntfs_log_trace("There are no more references left to this attribute\n");
-	list_del(&na->list_entry);
+	ntfs_list_del(&na->ntfs_list_entry);
 	if (NAttrEncrypted(na))
 		ntfs_crypto_attr_close(na);
 	if (NAttrNonResident(na) && na->rl)
 		free(na->rl);
 	/* Don't release if using an internal constant. */
-	if (na->name != AT_UNNAMED && na->name != NTFS_INDEX_I30)
+	if (na->name != NTFS_AT_UNNAMED && na->name != NTFS_INDEX_I30)
 		free(na->name);
 	free(na);
 }

 /**
- * ntfs_attr_map_runlist - map (a part of) a runlist of an ntfs attribute
- * @na:		ntfs attribute for which to map (part of) a runlist
- * @vcn:	map runlist part containing this vcn
+ * ntfs_attr_map_runlist - map (a part of) a ntfs_runlist of an ntfs attribute
+ * @na:		ntfs attribute for which to map (part of) a ntfs_runlist
+ * @vcn:	map ntfs_runlist part containing this vcn
  *
- * Map the part of a runlist containing the @vcn of the ntfs attribute @na.
+ * Map the part of a ntfs_runlist containing the @vcn of the ntfs attribute @na.
  *
  * Return 0 on success and -1 on error with errno set to the error code.
  */
-int ntfs_attr_map_runlist(ntfs_attr *na, VCN vcn)
+int ntfs_attr_map_runlist(ntfs_attr *na, NTFS_VCN vcn)
 {
-	LCN lcn;
+	NTFS_LCN lcn;
 	ntfs_attr_search_ctx *ctx;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x, vcn 0x%llx.\n",
 		(unsigned long long)na->ni->mft_no, na->type, (long long)vcn);

 	lcn = ntfs_rl_vcn_to_lcn(na->rl, vcn);
-	if (lcn >= 0 || lcn == LCN_HOLE || lcn == LCN_ENOENT)
+	if (lcn >= 0 || lcn == NTFS_LCN_HOLE || lcn == NTFS_LCN_ENOENT)
 		return 0;

 	ctx = ntfs_attr_get_search_ctx(na->ni, NULL);
@@ -511,11 +511,11 @@
 		return -1;

 	/* Find the attribute in the mft record. */
-	if (!ntfs_attr_lookup(na->type, na->name, na->name_len, CASE_SENSITIVE,
+	if (!ntfs_attr_lookup(na->type, na->name, na->name_len, NTFS_CASE_SENSITIVE,
 			vcn, NULL, 0, ctx)) {
-		runlist_element *rl;
+		ntfs_runlist_element *rl;

-		/* Decode the runlist. */
+		/* Decode the ntfs_runlist. */
 		rl = ntfs_mapping_pairs_decompress(na->ni->vol, ctx->attr,
 				na->rl);
 		if (rl) {
@@ -529,20 +529,20 @@
 }

 /**
- * ntfs_attr_map_runlist_range - map (a part of) a runlist of an ntfs attribute
- * @na:		ntfs attribute for which to map (part of) a runlist
- * @from_vcn:	map runlist part starting this vcn
- * @to_vcn:	map runlist part ending this vcn
+ * ntfs_attr_map_runlist_range - map (a part of) a ntfs_runlist of an ntfs attribute
+ * @na:		ntfs attribute for which to map (part of) a ntfs_runlist
+ * @from_vcn:	map ntfs_runlist part starting this vcn
+ * @to_vcn:	map ntfs_runlist part ending this vcn
  *
- * Map the part of a runlist from containing the @from_vcn to containing the
+ * Map the part of a ntfs_runlist from containing the @from_vcn to containing the
  * @to_vcn of an ntfs attribute @na. It is OK for @to_vcn to be beyond last run.
  *
  * Return 0 on success and -1 on error with errno set to the error code.
  */
-int ntfs_attr_map_runlist_range(ntfs_attr *na, VCN from_vcn, VCN to_vcn)
+int ntfs_attr_map_runlist_range(ntfs_attr *na, NTFS_VCN from_vcn, NTFS_VCN to_vcn)
 {
 	ntfs_attr_search_ctx *ctx = NULL;
-	runlist *rl;
+	ntfs_runlist *rl;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x, "
 			"from_vcn 0x%llx, to_vcn 0x%llx.\n",
@@ -555,19 +555,19 @@

 	for (rl = na->rl; rl->vcn <= to_vcn;) {
 		/* Skip not interesting to us runs. */
-		if (rl->lcn >= 0 || rl->lcn == LCN_HOLE || (rl->vcn +
+		if (rl->lcn >= 0 || rl->lcn == NTFS_LCN_HOLE || (rl->vcn +
 					rl->length < from_vcn &&
-					rl->lcn == LCN_RL_NOT_MAPPED)) {
+					rl->lcn == NTFS_LCN_RL_NOT_MAPPED)) {
 			rl++;
 			continue;
 		}

-		/* We reached the end of runlist, just exit. */
-		if (rl->lcn == LCN_ENOENT)
+		/* We reached the end of ntfs_runlist, just exit. */
+		if (rl->lcn == NTFS_LCN_ENOENT)
 			break;

 		/* Check for errors. */
-		if (rl->lcn < 0 && rl->lcn != LCN_RL_NOT_MAPPED) {
+		if (rl->lcn < 0 && rl->lcn != NTFS_LCN_RL_NOT_MAPPED) {
 			errno = EIO;
 			goto err_out;
 		}
@@ -580,11 +580,11 @@
 		}
 		/* Find the attribute in the mft record. */
 		if (ntfs_attr_lookup(na->type, na->name, na->name_len,
-					CASE_SENSITIVE, rl->vcn, NULL, 0,
+					NTFS_CASE_SENSITIVE, rl->vcn, NULL, 0,
 					ctx))
 			goto err_out;

-		/* Decode the runlist. */
+		/* Decode the ntfs_runlist. */
 		rl = ntfs_mapping_pairs_decompress(na->ni->vol, ctx->attr,
 				na->rl);
 		if (!rl)
@@ -602,23 +602,23 @@
 }

 /**
- * ntfs_attr_map_whole_runlist - map the whole runlist of an ntfs attribute
- * @na:		ntfs attribute for which to map the runlist
+ * ntfs_attr_map_whole_runlist - map the whole ntfs_runlist of an ntfs attribute
+ * @na:		ntfs attribute for which to map the ntfs_runlist
  *
- * Map the whole runlist of the ntfs attribute @na.  For an attribute made up
+ * Map the whole ntfs_runlist of the ntfs attribute @na.  For an attribute made up
  * of only one attribute extent this is the same as calling
  * ntfs_attr_map_runlist(na, 0) but for an attribute with multiple extents this
- * will map the runlist fragments from each of the extents thus giving access
+ * will map the ntfs_runlist fragments from each of the extents thus giving access
  * to the entirety of the disk allocation of an attribute.
  *
  * Return 0 on success and -1 on error with errno set to the error code.
  */
 int ntfs_attr_map_whole_runlist(ntfs_attr *na)
 {
-	VCN next_vcn, last_vcn, highest_vcn;
+	NTFS_VCN next_vcn, last_vcn, highest_vcn;
 	ntfs_attr_search_ctx *ctx;
 	ntfs_volume *vol = na->ni->vol;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	int err;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x.\n",
@@ -632,20 +632,20 @@
 	next_vcn = last_vcn = highest_vcn = 0;
 	a = NULL;
 	while (1) {
-		runlist_element *rl;
+		ntfs_runlist_element *rl;

 		int not_mapped = 0;
-		if (ntfs_rl_vcn_to_lcn(na->rl, next_vcn) == LCN_RL_NOT_MAPPED)
+		if (ntfs_rl_vcn_to_lcn(na->rl, next_vcn) == NTFS_LCN_RL_NOT_MAPPED)
 			not_mapped = 1;

 		if (ntfs_attr_lookup(na->type, na->name, na->name_len,
-				CASE_SENSITIVE, next_vcn, NULL, 0, ctx))
+				NTFS_CASE_SENSITIVE, next_vcn, NULL, 0, ctx))
 			break;

 		a = ctx->attr;

 		if (not_mapped) {
-			/* Decode the runlist. */
+			/* Decode the ntfs_runlist. */
 			rl = ntfs_mapping_pairs_decompress(na->ni->vol,
 								a, na->rl);
 			if (!rl)
@@ -717,11 +717,11 @@

 /**
  * ntfs_attr_vcn_to_lcn - convert a vcn into a lcn given an ntfs attribute
- * @na:		ntfs attribute whose runlist to use for conversion
+ * @na:		ntfs attribute whose ntfs_runlist to use for conversion
  * @vcn:	vcn to convert
  *
  * Convert the virtual cluster number @vcn of an attribute into a logical
- * cluster number (lcn) of a device using the runlist @na->rl to map vcns to
+ * cluster number (lcn) of a device using the ntfs_runlist @na->rl to map vcns to
  * their corresponding lcns.
  *
  * If the @vcn is not mapped yet, attempt to map the attribute extent
@@ -731,23 +731,23 @@
  *
  * Return value		Meaning / Description
  * ==========================================
- *  -1 = LCN_HOLE	Hole / not allocated on disk.
- *  -3 = LCN_ENOENT	There is no such vcn in the attribute.
- *  -4 = LCN_EINVAL	Input parameter error.
- *  -5 = LCN_EIO	Corrupt fs, disk i/o error, or not enough memory.
+ *  -1 = NTFS_LCN_HOLE	Hole / not allocated on disk.
+ *  -3 = NTFS_LCN_ENOENT	There is no such vcn in the attribute.
+ *  -4 = NTFS_LCN_EINVAL	Input parameter error.
+ *  -5 = NTFS_LCN_EIO	Corrupt fs, disk i/o error, or not enough memory.
  */
-LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const VCN vcn)
+NTFS_LCN ntfs_attr_vcn_to_lcn(ntfs_attr *na, const NTFS_VCN vcn)
 {
-	LCN lcn;
-	BOOL is_retry = FALSE;
+	NTFS_LCN lcn;
+	NTFS_BOOL is_retry = FALSE;

 	if (!na || !NAttrNonResident(na) || vcn < 0)
-		return (LCN)LCN_EINVAL;
+		return (NTFS_LCN)NTFS_LCN_EINVAL;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x.\n", (unsigned long
 			long)na->ni->mft_no, na->type);
 retry:
-	/* Convert vcn to lcn. If that fails map the runlist and retry once. */
+	/* Convert vcn to lcn. If that fails map the ntfs_runlist and retry once. */
 	lcn = ntfs_rl_vcn_to_lcn(na->rl, vcn);
 	if (lcn >= 0)
 		return lcn;
@@ -756,40 +756,40 @@
 		goto retry;
 	}
 	/*
-	 * If the attempt to map the runlist failed, or we are getting
-	 * LCN_RL_NOT_MAPPED despite having mapped the attribute extent
+	 * If the attempt to map the ntfs_runlist failed, or we are getting
+	 * NTFS_LCN_RL_NOT_MAPPED despite having mapped the attribute extent
 	 * successfully, something is really badly wrong...
 	 */
-	if (!is_retry || lcn == (LCN)LCN_RL_NOT_MAPPED)
-		return (LCN)LCN_EIO;
+	if (!is_retry || lcn == (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED)
+		return (NTFS_LCN)NTFS_LCN_EIO;
 	/* lcn contains the appropriate error code. */
 	return lcn;
 }

 /**
- * ntfs_attr_find_vcn - find a vcn in the runlist of an ntfs attribute
- * @na:		ntfs attribute whose runlist to search
+ * ntfs_attr_find_vcn - find a vcn in the ntfs_runlist of an ntfs attribute
+ * @na:		ntfs attribute whose ntfs_runlist to search
  * @vcn:	vcn to find
  *
- * Find the virtual cluster number @vcn in the runlist of the ntfs attribute
- * @na and return the the address of the runlist element containing the @vcn.
+ * Find the virtual cluster number @vcn in the ntfs_runlist of the ntfs attribute
+ * @na and return the the address of the ntfs_runlist element containing the @vcn.
  *
- * Note you need to distinguish between the lcn of the returned runlist
- * element being >= 0 and LCN_HOLE. In the later case you have to return zeroes
- * on read and allocate clusters on write. You need to update the runlist, the
+ * Note you need to distinguish between the lcn of the returned ntfs_runlist
+ * element being >= 0 and NTFS_LCN_HOLE. In the later case you have to return zeroes
+ * on read and allocate clusters on write. You need to update the ntfs_runlist, the
  * attribute itself as well as write the modified mft record to disk.
  *
  * If there is an error return NULL with errno set to the error code. The
  * following error codes are defined:
  *	EINVAL		Input parameter error.
- *	ENOENT		There is no such vcn in the runlist.
+ *	ENOENT		There is no such vcn in the ntfs_runlist.
  *	ENOMEM		Not enough memory.
  *	EIO		I/O error or corrupt metadata.
  */
-runlist_element *ntfs_attr_find_vcn(ntfs_attr *na, const VCN vcn)
+ntfs_runlist_element *ntfs_attr_find_vcn(ntfs_attr *na, const NTFS_VCN vcn)
 {
-	runlist_element *rl;
-	BOOL is_retry = FALSE;
+	ntfs_runlist_element *rl;
+	NTFS_BOOL is_retry = FALSE;

 	if (!na || !NAttrNonResident(na) || vcn < 0) {
 		errno = EINVAL;
@@ -807,19 +807,19 @@
 		goto map_rl;
 	while (rl->length) {
 		if (vcn < rl[1].vcn) {
-			if (rl->lcn >= (LCN)LCN_HOLE)
+			if (rl->lcn >= (NTFS_LCN)NTFS_LCN_HOLE)
 				return rl;
 			break;
 		}
 		rl++;
 	}
 	switch (rl->lcn) {
-	case (LCN)LCN_RL_NOT_MAPPED:
+	case (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED:
 		goto map_rl;
-	case (LCN)LCN_ENOENT:
+	case (NTFS_LCN)NTFS_LCN_ENOENT:
 		errno = ENOENT;
 		break;
-	case (LCN)LCN_EINVAL:
+	case (NTFS_LCN)NTFS_LCN_EINVAL:
 		errno = EINVAL;
 		break;
 	default:
@@ -828,7 +828,7 @@
 	}
 	return NULL;
 map_rl:
-	/* The @vcn is in an unmapped region, map the runlist and retry. */
+	/* The @vcn is in an unmapped region, map the ntfs_runlist and retry. */
 	if (!is_retry && !ntfs_attr_map_runlist(na, vcn)) {
 		is_retry = TRUE;
 		goto retry;
@@ -867,7 +867,7 @@
 {
 	s64 br, to_read, ofs, total, total2;
 	ntfs_volume *vol;
-	runlist_element *rl;
+	ntfs_runlist_element *rl;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x, pos 0x%llx, "
 			"count 0x%llx.\n", (unsigned long long)na->ni->mft_no,
@@ -937,7 +937,7 @@
 		count -= total2;
 		memset((u8*)b + count, 0, total2);
 	}
-	/* Find the runlist element containing the vcn. */
+	/* Find the ntfs_runlist element containing the vcn. */
 	rl = ntfs_attr_find_vcn(na, pos >> vol->cluster_size_bits);
 	if (!rl) {
 		/*
@@ -956,7 +956,7 @@
 	 */
 	ofs = pos - (rl->vcn << vol->cluster_size_bits);
 	for (; count; rl++, ofs = 0) {
-		if (rl->lcn == LCN_RL_NOT_MAPPED) {
+		if (rl->lcn == NTFS_LCN_RL_NOT_MAPPED) {
 			rl = ntfs_attr_find_vcn(na, rl->vcn);
 			if (!rl) {
 				if (errno == ENOENT)
@@ -968,8 +968,8 @@
 		}
 		if (!rl->length)
 			goto rl_err_out;
-		if (rl->lcn < (LCN)0) {
-			if (rl->lcn != (LCN)LCN_HOLE)
+		if (rl->lcn < (NTFS_LCN)0) {
+			if (rl->lcn != (NTFS_LCN)NTFS_LCN_HOLE)
 				goto rl_err_out;
 			/* It is a hole, just zero the matching @b range. */
 			to_read = min(count, (rl->length <<
@@ -1037,10 +1037,10 @@
 s64 ntfs_attr_pwrite(ntfs_attr *na, const s64 pos, s64 count, const void *b)
 {
 	s64 written, to_write, ofs, total, old_initialized_size, old_data_size;
-	VCN update_from = -1;
+	NTFS_VCN update_from = -1;
 	ntfs_volume *vol;
 	ntfs_attr_search_ctx *ctx = NULL;
-	runlist_element *rl;
+	ntfs_runlist_element *rl;
 	int eo;
 	struct {
 		unsigned int undo_initialized_size	: 1;
@@ -1122,7 +1122,7 @@
 	/* Handle writes beyond initialized_size. */
 	if (pos + count > na->initialized_size) {
 		/*
-		 * Map runlist between initialized size and place we start
+		 * Map ntfs_runlist between initialized size and place we start
 		 * writing at.
 		 */
 		if (ntfs_attr_map_runlist_range(na, na->initialized_size >>
@@ -1166,7 +1166,7 @@
 		 */
 		need_to.undo_initialized_size = 1;
 	}
-	/* Find the runlist element containing the vcn. */
+	/* Find the ntfs_runlist element containing the vcn. */
 	rl = ntfs_attr_find_vcn(na, pos >> vol->cluster_size_bits);
 	if (!rl) {
 		/*
@@ -1185,7 +1185,7 @@
 	 */
 	ofs = pos - (rl->vcn << vol->cluster_size_bits);
 	for (; count; rl++, ofs = 0) {
-		if (rl->lcn == LCN_RL_NOT_MAPPED) {
+		if (rl->lcn == NTFS_LCN_RL_NOT_MAPPED) {
 			rl = ntfs_attr_find_vcn(na, rl->vcn);
 			if (!rl) {
 				if (errno == ENOENT)
@@ -1199,12 +1199,12 @@
 			errno = EIO;
 			goto rl_err_out;
 		}
-		if (rl->lcn < (LCN)0) {
-			LCN lcn_seek_from = -1;
-			runlist *rlc;
-			VCN cur_vcn, from_vcn;
+		if (rl->lcn < (NTFS_LCN)0) {
+			NTFS_LCN lcn_seek_from = -1;
+			ntfs_runlist *rlc;
+			NTFS_VCN cur_vcn, from_vcn;

-			if (rl->lcn != (LCN)LCN_HOLE) {
+			if (rl->lcn != (NTFS_LCN)NTFS_LCN_HOLE) {
 				errno = EIO;
 				goto rl_err_out;
 			}
@@ -1218,19 +1218,19 @@
 			ntfs_log_trace("Instantiate hole with vcn 0x%llx.\n",
 					cur_vcn);
 			/*
-			 * Map whole runlist to be able update mapping pairs
+			 * Map whole ntfs_runlist to be able update mapping pairs
 			 * later.
 			 */
 			if (ntfs_attr_map_whole_runlist(na))
 				goto err_out;
 			/*
-			 * Restore @rl, it probably get lost during runlist
+			 * Restore @rl, it probably get lost during ntfs_runlist
 			 * mapping.
 			 */
 			rl = ntfs_attr_find_vcn(na, cur_vcn);
 			if (!rl) {
 				ntfs_log_error("BUG! Failed to find run after "
-						"mapping whole runlist. Please "
+						"mapping whole ntfs_runlist. Please "
 						"report to the %s.\n",
 						NTFS_DEV_LIST);
 				errno = EIO;
@@ -1268,7 +1268,7 @@
 						((ofs + to_write - 1) >>
 						vol->cluster_size_bits) + 1 +
 						rl->vcn - from_vcn,
-						lcn_seek_from, DATA_ZONE);
+						lcn_seek_from, NTFS_DATA_ZONE);
 			if (!rlc) {
 				eo = errno;
 				ntfs_log_trace("Failed to allocate clusters "
@@ -1310,9 +1310,9 @@
 			/* If leaved part of the hole go to the next run. */
 			if (rl->lcn < 0)
 				rl++;
-			/* Now LCN shoudn't be less than 0. */
+			/* Now NTFS_LCN shoudn't be less than 0. */
 			if (rl->lcn < 0) {
-				ntfs_log_error("BUG! LCN is lesser than 0. "
+				ntfs_log_error("BUG! NTFS_LCN is lesser than 0. "
 						"Please report to the %s.\n",
 						NTFS_DEV_LIST);
 				errno = EIO;
@@ -1602,7 +1602,7 @@
  * @type:	attribute type to find
  * @name:	attribute name to find (optional, i.e. NULL means don't care)
  * @name_len:	attribute name length (only needed if @name present)
- * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)
+ * @ic:		NTFS_IGNORE_CASE or NTFS_CASE_SENSITIVE (ignored if @name not present)
  * @val:	attribute value to find (optional, resident attributes only)
  * @val_len:	attribute value length
  * @ctx:	search context with mft record and attribute to search from
@@ -1625,26 +1625,26 @@
  * If @ctx->is_first is TRUE, the search begins with @ctx->attr itself. If it
  * is FALSE, the search begins after @ctx->attr.
  *
- * If @type is AT_UNUSED, return the first found attribute, i.e. one can
- * enumerate all attributes by setting @type to AT_UNUSED and then calling
+ * If @type is NTFS_AT_UNUSED, return the first found attribute, i.e. one can
+ * enumerate all attributes by setting @type to NTFS_AT_UNUSED and then calling
  * ntfs_attr_find() repeatedly until it returns -1 with errno set to ENOENT to
  * indicate that there are no more entries. During the enumeration, each
  * successful call of ntfs_attr_find() will return the next attribute in the
  * mft record @ctx->mrec.
  *
- * If @type is AT_END, seek to the end and return -1 with errno set to ENOENT.
- * AT_END is not a valid attribute, its length is zero for example, thus it is
+ * If @type is NTFS_AT_END, seek to the end and return -1 with errno set to ENOENT.
+ * NTFS_AT_END is not a valid attribute, its length is zero for example, thus it is
  * safer to return error instead of success in this case. This also allows us
  * to interoperate cleanly with ntfs_external_attr_find().
  *
- * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present
- * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,
+ * If @name is NTFS_AT_UNNAMED search for an unnamed attribute. If @name is present
+ * but not NTFS_AT_UNNAMED search for a named attribute matching @name. Otherwise,
  * match both named and unnamed attributes.
  *
- * If @ic is IGNORE_CASE, the @name comparison is not case sensitive and
+ * If @ic is NTFS_IGNORE_CASE, the @name comparison is not case sensitive and
  * @ctx->ntfs_ino must be set to the ntfs inode to which the mft record
  * @ctx->mrec belongs. This is so we can get at the ntfs volume and hence at
- * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case
+ * the upcase table. If @ic is NTFS_CASE_SENSITIVE, the comparison is case
  * sensitive. When @name is present, @name_len is the @name length in Unicode
  * characters.
  *
@@ -1667,11 +1667,11 @@
  * Warning: Never use @val when looking for attribute types which can be
  *	    non-resident as this most likely will result in a crash!
  */
-static int ntfs_attr_find(const ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
+static int ntfs_attr_find(const NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
 		const u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	ntfs_volume *vol;
 	ntfschar *upcase;
 	u32 upcase_len;
@@ -1683,7 +1683,7 @@
 		upcase = vol->upcase;
 		upcase_len = vol->upcase_len;
 	} else {
-		if (name && name != AT_UNNAMED) {
+		if (name && name != NTFS_AT_UNNAMED) {
 			errno = EINVAL;
 			return -1;
 		}
@@ -1699,32 +1699,32 @@
 		a = ctx->attr;
 		ctx->is_first = FALSE;
 	} else
-		a = (ATTR_RECORD*)((char*)ctx->attr +
+		a = (NTFS_ATTR_RECORD*)((char*)ctx->attr +
 				le32_to_cpu(ctx->attr->length));
-	for (;;	a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a->length))) {
+	for (;;	a = (NTFS_ATTR_RECORD*)((char*)a + le32_to_cpu(a->length))) {
 		if (p2n(a) < p2n(ctx->mrec) || (char*)a > (char*)ctx->mrec +
 				le32_to_cpu(ctx->mrec->bytes_allocated))
 			break;
 		ctx->attr = a;
-		if (((type != AT_UNUSED) && (le32_to_cpu(a->type) >
+		if (((type != NTFS_AT_UNUSED) && (le32_to_cpu(a->type) >
 				le32_to_cpu(type))) ||
-				(a->type == AT_END)) {
+				(a->type == NTFS_AT_END)) {
 			errno = ENOENT;
 			return -1;
 		}
 		if (!a->length)
 			break;
 		/* If this is an enumeration return this attribute. */
-		if (type == AT_UNUSED)
+		if (type == NTFS_AT_UNUSED)
 			return 0;
 		if (a->type != type)
 			continue;
 		/*
-		 * If @name is AT_UNNAMED we want an unnamed attribute.
+		 * If @name is NTFS_AT_UNNAMED we want an unnamed attribute.
 		 * If @name is present, compare the two names.
 		 * Otherwise, match any attribute.
 		 */
-		if (name == AT_UNNAMED) {
+		if (name == NTFS_AT_UNNAMED) {
 			/* The search failed if the found attribute is named. */
 			if (a->name_length) {
 				errno = ENOENT;
@@ -1738,7 +1738,7 @@
 			rc = ntfs_names_collate(name, name_len,
 					(ntfschar*)((char*)a +
 					le16_to_cpu(a->name_offset)),
-					a->name_length, 1, IGNORE_CASE,
+					a->name_length, 1, NTFS_IGNORE_CASE,
 					upcase, upcase_len);
 			/*
 			 * If @name collates before a->name, there is no
@@ -1754,7 +1754,7 @@
 			rc = ntfs_names_collate(name, name_len,
 					(ntfschar*)((char*)a +
 					le16_to_cpu(a->name_offset)),
-					a->name_length, 1, CASE_SENSITIVE,
+					a->name_length, 1, NTFS_CASE_SENSITIVE,
 					upcase, upcase_len);
 			if (rc == -1) {
 				errno = ENOENT;
@@ -1806,7 +1806,7 @@
  * @type:	attribute type to find
  * @name:	attribute name to find (optional, i.e. NULL means don't care)
  * @name_len:	attribute name length (only needed if @name present)
- * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)
+ * @ic:		NTFS_IGNORE_CASE or NTFS_CASE_SENSITIVE (ignored if @name not present)
  * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)
  * @val:	attribute value to find (optional, resident attributes only)
  * @val_len:	attribute value length
@@ -1820,21 +1820,21 @@
  * if the attribute is in a different mft record/inode, find the attribute in
  * there and return it.
  *
- * If @type is AT_UNUSED, return the first found attribute, i.e. one can
- * enumerate all attributes by setting @type to AT_UNUSED and then calling
+ * If @type is NTFS_AT_UNUSED, return the first found attribute, i.e. one can
+ * enumerate all attributes by setting @type to NTFS_AT_UNUSED and then calling
  * ntfs_external_attr_find() repeatedly until it returns -1 with errno set to
  * ENOENT to indicate that there are no more entries. During the enumeration,
  * each successful call of ntfs_external_attr_find() will return the next
  * attribute described by the attribute list of the base mft record described
  * by the search context @ctx.
  *
- * If @type is AT_END, seek to the end of the base mft record ignoring the
- * attribute list completely and return -1 with errno set to ENOENT.  AT_END is
+ * If @type is NTFS_AT_END, seek to the end of the base mft record ignoring the
+ * attribute list completely and return -1 with errno set to ENOENT.  NTFS_AT_END is
  * not a valid attribute, its length is zero for example, thus it is safer to
  * return error instead of success in this case.
  *
- * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present
- * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,
+ * If @name is NTFS_AT_UNNAMED search for an unnamed attribute. If @name is present
+ * but not NTFS_AT_UNNAMED search for a named attribute matching @name. Otherwise,
  * match both named and unnamed attributes.
  *
  * On first search @ctx->ntfs_ino must be the inode of the base mft record and
@@ -1862,7 +1862,7 @@
  * @ctx->al_entry points to the position within @ctx->base_ntfs_ino->attr_list
  * at which the new attribute's attribute list entry should be inserted.  The
  * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.
- * The only exception to this is when @type is AT_END, in which case
+ * The only exception to this is when @type is NTFS_AT_END, in which case
  * @ctx->al_entry is set to NULL also (see above).
  *
  * The following error codes are defined:
@@ -1871,19 +1871,19 @@
  *	EIO	I/O error or corrupt data structures found.
  *	ENOMEM	Not enough memory to allocate necessary buffers.
  */
-static int ntfs_external_attr_find(ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const VCN lowest_vcn, const u8 *val, const u32 val_len,
+static int ntfs_external_attr_find(NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_VCN lowest_vcn, const u8 *val, const u32 val_len,
 		ntfs_attr_search_ctx *ctx)
 {
 	ntfs_inode *base_ni, *ni;
 	ntfs_volume *vol;
-	ATTR_LIST_ENTRY *al_entry, *next_al_entry;
+	NTFS_ATTR_LIST_ENTRY *al_entry, *next_al_entry;
 	u8 *al_start, *al_end;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	ntfschar *al_name;
 	u32 al_name_len;
-	BOOL is_first_search = FALSE;
+	NTFS_BOOL is_first_search = FALSE;

 	ni = ctx->ntfs_ino;
 	base_ni = ctx->base_ntfs_ino;
@@ -1896,13 +1896,13 @@
 	}
 	if (ni == base_ni)
 		ctx->base_attr = ctx->attr;
-	if (type == AT_END)
+	if (type == NTFS_AT_END)
 		goto not_found;
 	vol = base_ni->vol;
 	al_start = base_ni->attr_list;
 	al_end = al_start + base_ni->attr_list_size;
 	if (!ctx->al_entry) {
-		ctx->al_entry = (ATTR_LIST_ENTRY*)al_start;
+		ctx->al_entry = (NTFS_ATTR_LIST_ENTRY*)al_start;
 		is_first_search = TRUE;
 	}
 	/*
@@ -1917,12 +1917,12 @@
 		 * the attribute list itself, need to return the attribute list
 		 * attribute.
 		 */
-		if ((type == AT_UNUSED) && is_first_search &&
+		if ((type == NTFS_AT_UNUSED) && is_first_search &&
 				le32_to_cpu(al_entry->type) >
-				le32_to_cpu(AT_ATTRIBUTE_LIST))
+				le32_to_cpu(NTFS_AT_ATTRIBUTE_LIST))
 			goto find_attr_list_attr;
 	} else {
-		al_entry = (ATTR_LIST_ENTRY*)((char*)ctx->al_entry +
+		al_entry = (NTFS_ATTR_LIST_ENTRY*)((char*)ctx->al_entry +
 				le16_to_cpu(ctx->al_entry->length));
 		/*
 		 * If this is an enumeration and the attribute list attribute
@@ -1930,10 +1930,10 @@
 		 * attribute list attribute from the base mft record as it is
 		 * not listed in the attribute list itself.
 		 */
-		if ((type == AT_UNUSED) && le32_to_cpu(ctx->al_entry->type) <
-				le32_to_cpu(AT_ATTRIBUTE_LIST) &&
+		if ((type == NTFS_AT_UNUSED) && le32_to_cpu(ctx->al_entry->type) <
+				le32_to_cpu(NTFS_AT_ATTRIBUTE_LIST) &&
 				le32_to_cpu(al_entry->type) >
-				le32_to_cpu(AT_ATTRIBUTE_LIST)) {
+				le32_to_cpu(NTFS_AT_ATTRIBUTE_LIST)) {
 			int rc;
 find_attr_list_attr:

@@ -1948,12 +1948,12 @@
 			ctx->mrec = ctx->base_mrec;
 			ctx->is_first = TRUE;
 			/* Sanity checks are performed elsewhere. */
-			ctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +
+			ctx->attr = (NTFS_ATTR_RECORD*)((u8*)ctx->mrec +
 					le16_to_cpu(ctx->mrec->attrs_offset));

 			/* Find the attribute list attribute. */
-			rc = ntfs_attr_find(AT_ATTRIBUTE_LIST, NULL, 0,
-					IGNORE_CASE, NULL, 0, ctx);
+			rc = ntfs_attr_find(NTFS_AT_ATTRIBUTE_LIST, NULL, 0,
+					NTFS_IGNORE_CASE, NULL, 0, ctx);

 			/*
 			 * Setup the search context so the correct
@@ -1992,9 +1992,9 @@
 		if ((u8*)al_entry + 6 > al_end || (u8*)al_entry +
 				le16_to_cpu(al_entry->length) > al_end)
 			break;
-		next_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +
+		next_al_entry = (NTFS_ATTR_LIST_ENTRY*)((u8*)al_entry +
 				le16_to_cpu(al_entry->length));
-		if (type != AT_UNUSED) {
+		if (type != NTFS_AT_UNUSED) {
 			if (le32_to_cpu(al_entry->type) > le32_to_cpu(type))
 				goto not_found;
 			if (type != al_entry->type)
@@ -2006,14 +2006,14 @@
 		 * If !@type we want the attribute represented by this
 		 * attribute list entry.
 		 */
-		if (type == AT_UNUSED)
+		if (type == NTFS_AT_UNUSED)
 			goto is_enumeration;
 		/*
-		 * If @name is AT_UNNAMED we want an unnamed attribute.
+		 * If @name is NTFS_AT_UNNAMED we want an unnamed attribute.
 		 * If @name is present, compare the two names.
 		 * Otherwise, match any attribute.
 		 */
-		if (name == AT_UNNAMED) {
+		if (name == NTFS_AT_UNNAMED) {
 			if (al_name_len)
 				goto not_found;
 		} else if (name && !ntfs_names_are_equal(al_name, al_name_len,
@@ -2022,7 +2022,7 @@
 			register int rc;

 			rc = ntfs_names_collate(name, name_len, al_name,
-					al_name_len, 1, IGNORE_CASE,
+					al_name_len, 1, NTFS_IGNORE_CASE,
 					vol->upcase, vol->upcase_len);
 			/*
 			 * If @name collates before al_name, there is no
@@ -2034,7 +2034,7 @@
 			if (rc)
 				continue;
 			/*
-			 * FIXME: Reverse engineering showed 0, IGNORE_CASE but
+			 * FIXME: Reverse engineering showed 0, NTFS_IGNORE_CASE but
 			 * that is inconsistent with ntfs_attr_find(). The
 			 * subsequent rc checks were also different. Perhaps I
 			 * made a mistake in one of the two. Need to recheck
@@ -2042,7 +2042,7 @@
 			 * on... (AIA)
 			 */
 			rc = ntfs_names_collate(name, name_len, al_name,
-					al_name_len, 1, CASE_SENSITIVE,
+					al_name_len, 1, NTFS_CASE_SENSITIVE,
 					vol->upcase, vol->upcase_len);
 			if (rc == -1)
 				goto not_found;
@@ -2067,12 +2067,12 @@
 					next_al_entry +
 					next_al_entry->name_offset),
 					next_al_entry->name_length,
-					al_name, al_name_len, CASE_SENSITIVE,
+					al_name, al_name_len, NTFS_CASE_SENSITIVE,
 					vol->upcase, vol->upcase_len))
 			continue;
 is_enumeration:
-		if (MREF_LE(al_entry->mft_reference) == ni->mft_no) {
-			if (MSEQNO_LE(al_entry->mft_reference) !=
+		if (NTFS_MREF_LE(al_entry->mft_reference) == ni->mft_no) {
+			if (NTFS_MSEQNO_LE(al_entry->mft_reference) !=
 					le16_to_cpu(
 					ni->mrec->sequence_number)) {
 				ntfs_log_debug("Found stale mft reference in "
@@ -2081,7 +2081,7 @@
 			}
 		} else { /* Mft references do not match. */
 			/* Do we want the base record back? */
-			if (MREF_LE(al_entry->mft_reference) ==
+			if (NTFS_MREF_LE(al_entry->mft_reference) ==
 					base_ni->mft_no) {
 				ni = ctx->ntfs_ino = base_ni;
 				ctx->mrec = ctx->base_mrec;
@@ -2098,7 +2098,7 @@
 				ctx->mrec = ni->mrec;
 			}
 		}
-		a = ctx->attr = (ATTR_RECORD*)((char*)ctx->mrec +
+		a = ctx->attr = (NTFS_ATTR_RECORD*)((char*)ctx->mrec +
 				le16_to_cpu(ctx->mrec->attrs_offset));
 		/*
 		 * ctx->ntfs_ino, ctx->mrec, and ctx->attr now point to the
@@ -2121,7 +2121,7 @@
 		if ((char*)a < (char*)ctx->mrec || (char*)a > (char*)ctx->mrec +
 				le32_to_cpu(ctx->mrec->bytes_allocated))
 			break;
-		if (a->type == AT_END)
+		if (a->type == NTFS_AT_END)
 			continue;
 		if (!a->length)
 			break;
@@ -2137,7 +2137,7 @@
 		if (!ntfs_names_are_equal((ntfschar*)((char*)a +
 				le16_to_cpu(a->name_offset)),
 				a->name_length, al_name,
-				al_name_len, CASE_SENSITIVE,
+				al_name_len, NTFS_CASE_SENSITIVE,
 				vol->upcase, vol->upcase_len))
 			break;
 		ctx->attr = a;
@@ -2146,7 +2146,7 @@
 		 * have found it! Also, if !@type, it is an enumeration, so we
 		 * want the current attribute.
 		 */
-		if ((type == AT_UNUSED) || !val || (!a->non_resident &&
+		if ((type == NTFS_AT_UNUSED) || !val || (!a->non_resident &&
 				le32_to_cpu(a->value_length) == val_len &&
 				!memcmp((char*)a + le16_to_cpu(a->value_offset),
 				val, val_len))) {
@@ -2154,7 +2154,7 @@
 		}
 do_next_attr:
 		/* Proceed to the next attribute in the current mft record. */
-		a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
+		a = (NTFS_ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
 		goto do_next_attr_loop;
 	}
 	if (ni != base_ni) {
@@ -2167,13 +2167,13 @@
 	return -1;
 not_found:
 	/*
-	 * If we were looking for AT_END or we were enumerating and reached the
+	 * If we were looking for NTFS_AT_END or we were enumerating and reached the
 	 * end, we reset the search context @ctx and use ntfs_attr_find() to
 	 * seek to the end of the base mft record.
 	 */
-	if (type == AT_UNUSED || type == AT_END) {
+	if (type == NTFS_AT_UNUSED || type == NTFS_AT_END) {
 		ntfs_attr_reinit_search_ctx(ctx);
-		return ntfs_attr_find(AT_END, name, name_len, ic, val, val_len,
+		return ntfs_attr_find(NTFS_AT_END, name, name_len, ic, val, val_len,
 				ctx);
 	}
 	/*
@@ -2190,7 +2190,7 @@
 	 * the call to ntfs_attr_find() below.
 	 */
 	ctx->mrec = ctx->base_mrec;
-	ctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +
+	ctx->attr = (NTFS_ATTR_RECORD*)((u8*)ctx->mrec +
 			le16_to_cpu(ctx->mrec->attrs_offset));
 	ctx->is_first = TRUE;
 	ctx->ntfs_ino = ctx->base_ntfs_ino;
@@ -2220,7 +2220,7 @@
  * @type:	attribute type to find
  * @name:	attribute name to find (optional, i.e. NULL means don't care)
  * @name_len:	attribute name length (only needed if @name present)
- * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)
+ * @ic:		NTFS_IGNORE_CASE or NTFS_CASE_SENSITIVE (ignored if @name not present)
  * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)
  * @val:	attribute value to find (optional, resident attributes only)
  * @val_len:	attribute value length
@@ -2233,22 +2233,22 @@
  * This function transparently handles attribute lists and @ctx is used to
  * continue searches where they were left off at.
  *
- * If @type is AT_UNUSED, return the first found attribute, i.e. one can
- * enumerate all attributes by setting @type to AT_UNUSED and then calling
+ * If @type is NTFS_AT_UNUSED, return the first found attribute, i.e. one can
+ * enumerate all attributes by setting @type to NTFS_AT_UNUSED and then calling
  * ntfs_attr_lookup() repeatedly until it returns -1 with errno set to ENOENT
  * to indicate that there are no more entries. During the enumeration, each
  * successful call of ntfs_attr_lookup() will return the next attribute, with
  * the current attribute being described by the search context @ctx.
  *
- * If @type is AT_END, seek to the end of the base mft record ignoring the
- * attribute list completely and return -1 with errno set to ENOENT.  AT_END is
+ * If @type is NTFS_AT_END, seek to the end of the base mft record ignoring the
+ * attribute list completely and return -1 with errno set to ENOENT.  NTFS_AT_END is
  * not a valid attribute, its length is zero for example, thus it is safer to
  * return error instead of success in this case.  It should never be needed to
  * do this, but we implement the functionality because it allows for simpler
  * code inside ntfs_external_attr_find().
  *
- * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present
- * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,
+ * If @name is NTFS_AT_UNNAMED search for an unnamed attribute. If @name is present
+ * but not NTFS_AT_UNNAMED search for a named attribute matching @name. Otherwise,
  * match both named and unnamed attributes.
  *
  * After finishing with the attribute/mft record you need to call
@@ -2272,7 +2272,7 @@
  * @ctx->al_entry points to the position within @ctx->base_ntfs_ino->attr_list
  * at which the new attribute's attribute list entry should be inserted.  The
  * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.
- * The only exception to this is when @type is AT_END, in which case
+ * The only exception to this is when @type is NTFS_AT_END, in which case
  * @ctx->al_entry is set to NULL also (see above).
  *
  *
@@ -2282,15 +2282,15 @@
  *	EIO	I/O error or corrupt data structures found.
  *	ENOMEM	Not enough memory to allocate necessary buffers.
  */
-int ntfs_attr_lookup(const ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const VCN lowest_vcn, const u8 *val, const u32 val_len,
+int ntfs_attr_lookup(const NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_VCN lowest_vcn, const u8 *val, const u32 val_len,
 		ntfs_attr_search_ctx *ctx)
 {
 	ntfs_volume *vol;
 	ntfs_inode *base_ni;

-	if (!ctx || !ctx->mrec || !ctx->attr || (name && name != AT_UNNAMED &&
+	if (!ctx || !ctx->mrec || !ctx->attr || (name && name != NTFS_AT_UNNAMED &&
 			(!ctx->ntfs_ino || !(vol = ctx->ntfs_ino->vol) ||
 			!vol->upcase || !vol->upcase_len))) {
 		errno = EINVAL;
@@ -2300,7 +2300,7 @@
 		base_ni = ctx->base_ntfs_ino;
 	else
 		base_ni = ctx->ntfs_ino;
-	if (!base_ni || !NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)
+	if (!base_ni || !NInoAttrList(base_ni) || type == NTFS_AT_ATTRIBUTE_LIST)
 		return ntfs_attr_find(type, name, name_len, ic, val, val_len,
 				ctx);
 	return ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,
@@ -2316,13 +2316,13 @@
  * Initialize the attribute search context @ctx with @ni and @mrec.
  */
 static void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,
-		ntfs_inode *ni, MFT_RECORD *mrec)
+		ntfs_inode *ni, NTFS_MFT_RECORD *mrec)
 {
 	if (!mrec)
 		mrec = ni->mrec;
 	ctx->mrec = mrec;
 	/* Sanity checks are performed elsewhere. */
-	ctx->attr = (ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec->attrs_offset));
+	ctx->attr = (NTFS_ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec->attrs_offset));
 	ctx->is_first = TRUE;
 	ctx->ntfs_ino = ni;
 	ctx->al_entry = NULL;
@@ -2346,7 +2346,7 @@
 		/* No attribute list. */
 		ctx->is_first = TRUE;
 		/* Sanity checks are performed elsewhere. */
-		ctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +
+		ctx->attr = (NTFS_ATTR_RECORD*)((u8*)ctx->mrec +
 				le16_to_cpu(ctx->mrec->attrs_offset));
 		/*
 		 * This needs resetting due to ntfs_external_attr_find() which
@@ -2374,7 +2374,7 @@
  * implications!!!  For example it is no longer safe to call ntfs_attr_lookup()
  * if you
  */
-ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)
+ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, NTFS_MFT_RECORD *mrec)
 {
 	ntfs_attr_search_ctx *ctx;

@@ -2414,10 +2414,10 @@
  *	ENOENT	- The attribute @type is not specified in $AttrDef.
  *	EINVAL	- Invalid parameters (e.g. @vol is not valid).
  */
-ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,
-		const ATTR_TYPES type)
+NTFS_ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,
+		const NTFS_ATTR_TYPES type)
 {
-	ATTR_DEF *ad;
+	NTFS_ATTR_DEF *ad;

 	if (!vol || !vol->attrdef || !type) {
 		errno = EINVAL;
@@ -2454,10 +2454,10 @@
  *	ENOENT	- The attribute @type is not specified in $AttrDef.
  *	EINVAL	- Invalid parameters (e.g. @size is < 0 or @vol is not valid).
  */
-int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPES type,
+int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const NTFS_ATTR_TYPES type,
 		const s64 size)
 {
-	ATTR_DEF *ad;
+	NTFS_ATTR_DEF *ad;

 	if (size < 0) {
 		errno = EINVAL;
@@ -2468,7 +2468,7 @@
 	 * $ATTRIBUTE_LIST should be not greater than 0x40000, but this is not
 	 * listed in the AttrDef.
 	 */
-	if (type == AT_ATTRIBUTE_LIST && size > 0x40000) {
+	if (type == NTFS_AT_ATTRIBUTE_LIST && size > 0x40000) {
 		errno = ERANGE;
 		return -1;
 	}
@@ -2503,16 +2503,16 @@
  *	ENOENT	- The attribute @type is not specified in $AttrDef.
  *	EINVAL	- Invalid parameters (e.g. @vol is not valid).
  */
-int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPES type)
+int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const NTFS_ATTR_TYPES type)
 {
-	ATTR_DEF *ad;
+	NTFS_ATTR_DEF *ad;

 	/* Find the attribute definition record in $AttrDef. */
 	ad = ntfs_attr_find_in_attrdef(vol, type);
 	if (!ad)
 		return -1;
 	/* Check the flags and return the result. */
-	if (ad->flags & ATTR_DEF_RESIDENT) {
+	if (ad->flags & NTFS_ATTR_DEF_RESIDENT) {
 		ntfs_log_trace("Attribute can't be non-resident\n");
 		errno = EPERM;
 		return -1;
@@ -2542,13 +2542,13 @@
  *	    check for this here as we don't know which inode's $Bitmap is being
  *	    asked about so the caller needs to special case this.
  */
-int ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPES type)
+int ntfs_attr_can_be_resident(const ntfs_volume *vol, const NTFS_ATTR_TYPES type)
 {
 	if (!vol || !vol->attrdef || !type) {
 		errno = EINVAL;
 		return -1;
 	}
-	if (type != AT_INDEX_ALLOCATION)
+	if (type != NTFS_AT_INDEX_ALLOCATION)
 		return 0;

 	ntfs_log_trace("Attribute can't be resident\n");
@@ -2570,7 +2570,7 @@
  *		  caller has to make space before calling this.
  *	EINVAL	- Input parameters were faulty.
  */
-int ntfs_make_room_for_attr(MFT_RECORD *m, u8 *pos, u32 size)
+int ntfs_make_room_for_attr(NTFS_MFT_RECORD *m, u8 *pos, u32 size)
 {
 	u32 biu;

@@ -2626,14 +2626,14 @@
  *	EEXIST	- Attribute of such type and with same name already exists.
  *	EIO	- I/O error occurred or damaged filesystem.
  */
-int ntfs_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,
+int ntfs_resident_attr_record_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
 			ntfschar *name, u8 name_len, u8 *val, u32 size,
-			ATTR_FLAGS flags)
+			NTFS_ATTR_FLAGS flags)
 {
 	ntfs_attr_search_ctx *ctx;
 	u32 length;
-	ATTR_RECORD *a;
-	MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
+	NTFS_MFT_RECORD *m;
 	int err, offset;
 	ntfs_inode *base_ni;

@@ -2662,7 +2662,7 @@
 	 * attribute in @ni->mrec, not any extent inode in case if @ni is base
 	 * file record.
 	 */
-	if (!ntfs_attr_find(type, name, name_len, CASE_SENSITIVE, val, size,
+	if (!ntfs_attr_find(type, name, name_len, NTFS_CASE_SENSITIVE, val, size,
 			ctx)) {
 		err = EEXIST;
 		ntfs_log_trace("Attribute already present.\n");
@@ -2676,7 +2676,7 @@
 	m = ctx->mrec;

 	/* Make room for attribute. */
-	length = offsetof(ATTR_RECORD, resident_end) +
+	length = offsetof(NTFS_ATTR_RECORD, resident_end) +
 				((name_len * sizeof(ntfschar) + 7) & ~7) +
 				((size + 7) & ~7);
 	if (ntfs_make_room_for_attr(ctx->mrec, (u8*) ctx->attr, length)) {
@@ -2691,7 +2691,7 @@
 	a->length = cpu_to_le32(length);
 	a->non_resident = 0;
 	a->name_length = name_len;
-	a->name_offset = cpu_to_le16(offsetof(ATTR_RECORD, resident_end));
+	a->name_offset = cpu_to_le16(offsetof(NTFS_ATTR_RECORD, resident_end));
 	a->flags = flags;
 	a->instance = m->next_attr_instance;
 	a->value_length = cpu_to_le32(size);
@@ -2700,8 +2700,8 @@
 		memcpy((u8*)a + le16_to_cpu(a->value_offset), val, size);
 	else
 		memset((u8*)a + le16_to_cpu(a->value_offset), 0, size);
-	if (type == AT_FILE_NAME)
-		a->resident_flags = RESIDENT_ATTR_IS_INDEXED;
+	if (type == NTFS_AT_FILE_NAME)
+		a->resident_flags = NTFS_RESIDENT_ATTR_IS_INDEXED;
 	else
 		a->resident_flags = 0;
 	if (name_len)
@@ -2713,7 +2713,7 @@
 		base_ni = ni->base_ni;
 	else
 		base_ni = ni;
-	if (type != AT_ATTRIBUTE_LIST && NInoAttrList(base_ni)) {
+	if (type != NTFS_AT_ATTRIBUTE_LIST && NInoAttrList(base_ni)) {
 		if (ntfs_attrlist_entry_add(ni, a)) {
 			err = errno;
 			ntfs_attr_record_resize(m, a, 0);
@@ -2749,14 +2749,14 @@
  *		  name already exists.
  *	EIO	- I/O error occurred or damaged filesystem.
  */
-int ntfs_non_resident_attr_record_add(ntfs_inode *ni, ATTR_TYPES type,
-		ntfschar *name, u8 name_len, VCN lowest_vcn, int dataruns_size,
-		ATTR_FLAGS flags)
+int ntfs_non_resident_attr_record_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
+		ntfschar *name, u8 name_len, NTFS_VCN lowest_vcn, int dataruns_size,
+		NTFS_ATTR_FLAGS flags)
 {
 	ntfs_attr_search_ctx *ctx;
 	u32 length;
-	ATTR_RECORD *a;
-	MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
+	NTFS_MFT_RECORD *m;
 	ntfs_inode *base_ni;
 	int err, offset;

@@ -2789,7 +2789,7 @@
 	 * attribute in @ni->mrec, not any extent inode in case if @ni is base
 	 * file record.
 	 */
-	if (!ntfs_attr_find(type, name, name_len, CASE_SENSITIVE, NULL, 0,
+	if (!ntfs_attr_find(type, name, name_len, NTFS_CASE_SENSITIVE, NULL, 0,
 			ctx)) {
 		err = EEXIST;
 		ntfs_log_trace("Attribute already present.\n");
@@ -2804,9 +2804,9 @@

 	/* Make room for attribute. */
 	dataruns_size = (dataruns_size + 7) & ~7;
-	length = offsetof(ATTR_RECORD, compressed_size) + ((sizeof(ntfschar) *
+	length = offsetof(NTFS_ATTR_RECORD, compressed_size) + ((sizeof(ntfschar) *
 			name_len + 7) & ~7) + dataruns_size +
-			((flags & (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE)) ?
+			((flags & (NTFS_ATTR_IS_COMPRESSED | NTFS_ATTR_IS_SPARSE)) ?
 			sizeof(a->compressed_size) : 0);
 	if (ntfs_make_room_for_attr(ctx->mrec, (u8*) ctx->attr, length)) {
 		err = errno;
@@ -2819,14 +2819,14 @@
 	a->length = cpu_to_le32(length);
 	a->non_resident = 1;
 	a->name_length = name_len;
-	a->name_offset = cpu_to_le16(offsetof(ATTR_RECORD, compressed_size) +
-			((flags & (ATTR_IS_COMPRESSED | ATTR_IS_SPARSE)) ?
+	a->name_offset = cpu_to_le16(offsetof(NTFS_ATTR_RECORD, compressed_size) +
+			((flags & (NTFS_ATTR_IS_COMPRESSED | NTFS_ATTR_IS_SPARSE)) ?
 			sizeof(a->compressed_size) : 0));
 	a->flags = flags;
 	a->instance = m->next_attr_instance;
 	a->lowest_vcn = cpu_to_sle64(lowest_vcn);
 	a->mapping_pairs_offset = cpu_to_le16(length - dataruns_size);
-	a->compression_unit = (flags & ATTR_IS_COMPRESSED) ? 4 : 0;
+	a->compression_unit = (flags & NTFS_ATTR_IS_COMPRESSED) ? 4 : 0;
 	/* If @lowest_vcn == 0, than setup empty attribute. */
 	if (!lowest_vcn) {
 		a->highest_vcn = cpu_to_sle64(-1);
@@ -2845,7 +2845,7 @@
 		base_ni = ni->base_ni;
 	else
 		base_ni = ni;
-	if (type != AT_ATTRIBUTE_LIST && NInoAttrList(base_ni)) {
+	if (type != NTFS_AT_ATTRIBUTE_LIST && NInoAttrList(base_ni)) {
 		if (ntfs_attrlist_entry_add(ni, a)) {
 			err = errno;
 			ntfs_attr_record_resize(m, a, 0);
@@ -2861,7 +2861,7 @@
 	 * update of attribute list.
 	 */
 	ntfs_attr_reinit_search_ctx(ctx);
-	if (ntfs_attr_lookup(type, name, name_len, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(type, name, name_len, NTFS_CASE_SENSITIVE,
 					lowest_vcn, NULL, 0, ctx)) {
 		err = errno;
 		ntfs_log_trace("Attribute lookup failed. Probably leaving "
@@ -2894,7 +2894,7 @@
 int ntfs_attr_record_rm(ntfs_attr_search_ctx *ctx)
 {
 	ntfs_inode *base_ni, *ni;
-	ATTR_TYPES type;
+	NTFS_ATTR_TYPES type;
 	int err;

 	if (!ctx || !ctx->ntfs_ino || !ctx->mrec || !ctx->attr) {
@@ -2916,7 +2916,7 @@
 	if (ntfs_attr_record_resize(ctx->mrec, ctx->attr, 0)) {
 		ntfs_log_trace("Couldn't remove attribute record. "
 				"Bug or damaged MFT record.\n");
-		if (NInoAttrList(base_ni) && type != AT_ATTRIBUTE_LIST)
+		if (NInoAttrList(base_ni) && type != NTFS_AT_ATTRIBUTE_LIST)
 			if (ntfs_attrlist_entry_add(ni, ctx->attr))
 				ntfs_log_trace("Rollback failed. Leaving "
 						"inconsistent metadata.\n");
@@ -2929,7 +2929,7 @@
 	 * Remove record from $ATTRIBUTE_LIST if present and we don't want
 	 * delete $ATTRIBUTE_LIST itself.
 	 */
-	if (NInoAttrList(base_ni) && type != AT_ATTRIBUTE_LIST) {
+	if (NInoAttrList(base_ni) && type != NTFS_AT_ATTRIBUTE_LIST) {
 		if (ntfs_attrlist_entry_rm(ctx)) {
 			ntfs_log_trace("Couldn't delete record from "
 					"$ATTRIBUTE_LIST.\n");
@@ -2938,7 +2938,7 @@
 	}

 	/* Post $ATTRIBUTE_LIST delete setup. */
-	if (type == AT_ATTRIBUTE_LIST) {
+	if (type == NTFS_AT_ATTRIBUTE_LIST) {
 		if (NInoAttrList(base_ni) && base_ni->attr_list)
 			free(base_ni->attr_list);
 		base_ni->attr_list = NULL;
@@ -2960,13 +2960,13 @@
 			return 0;
 	}

-	if (type == AT_ATTRIBUTE_LIST || !NInoAttrList(base_ni))
+	if (type == NTFS_AT_ATTRIBUTE_LIST || !NInoAttrList(base_ni))
 		return 0;

 	/* Remove attribute list if we don't need it any more. */
 	if (!ntfs_attrlist_need(base_ni)) {
 		ntfs_attr_reinit_search_ctx(ctx);
-		if (ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, CASE_SENSITIVE,
+		if (ntfs_attr_lookup(NTFS_AT_ATTRIBUTE_LIST, NULL, 0, NTFS_CASE_SENSITIVE,
 				0, NULL, 0, ctx)) {
 			/*
 			 * FIXME: Should we succeed here? Definitely something
@@ -2979,20 +2979,20 @@
 		}
 		/* Deallocate clusters. */
 		if (ctx->attr->non_resident) {
-			runlist *al_rl;
+			ntfs_runlist *al_rl;

 			al_rl = ntfs_mapping_pairs_decompress(base_ni->vol,
 					ctx->attr, NULL);
 			if (!al_rl) {
 				ntfs_log_trace("Couldn't decompress attribute "
-						"list runlist. Succeed "
+						"list ntfs_runlist. Succeed "
 						"anyway.\n");
 				return 0;
 			}
 			if (ntfs_cluster_free_from_rl(base_ni->vol, al_rl)) {
 				ntfs_log_trace("Leaking clusters! Run chkdsk. "
 						"Couldn't free clusters from "
-						"attribute list runlist.\n");
+						"attribute list ntfs_runlist.\n");
 			}
 			free(al_rl);
 		}
@@ -3032,22 +3032,22 @@
  *
  * If on one of this steps attribute list is needed but not present, than it is
  * added transparently to caller. So, this function should not be called with
- * @type == AT_ATTRIBUTE_LIST, if you really need to add attribute list call
+ * @type == NTFS_AT_ATTRIBUTE_LIST, if you really need to add attribute list call
  * ntfs_inode_add_attrlist instead.
  *
  * On success return 0. On error return -1 with errno set to the error code.
  */
-int ntfs_attr_add(ntfs_inode *ni, ATTR_TYPES type,
+int ntfs_attr_add(ntfs_inode *ni, NTFS_ATTR_TYPES type,
 		ntfschar *name, u8 name_len, u8 *val, s64 size)
 {
 	u32 attr_rec_size;
 	int err, i, offset;
-	BOOL is_resident = TRUE;
-	BOOL always_non_resident = FALSE, always_resident = FALSE;
+	NTFS_BOOL is_resident = TRUE;
+	NTFS_BOOL always_non_resident = FALSE, always_resident = FALSE;
 	ntfs_inode *attr_ni;
 	ntfs_attr *na;

-	if (!ni || size < 0 || type == AT_ATTRIBUTE_LIST) {
+	if (!ni || size < 0 || type == NTFS_AT_ATTRIBUTE_LIST) {
 		ntfs_log_trace("Invalid arguments passed.\n");
 		errno = EINVAL;
 		return -1;
@@ -3107,11 +3107,11 @@
 retry:
 	/* Calculate attribute record size. */
 	if (is_resident)
-		attr_rec_size = offsetof(ATTR_RECORD, resident_end) +
+		attr_rec_size = offsetof(NTFS_ATTR_RECORD, resident_end) +
 				ROUND_UP(name_len * sizeof(ntfschar), 3) +
 				ROUND_UP(size, 3);
 	else /* We add 8 for space for mapping pairs. */
-		attr_rec_size = offsetof(ATTR_RECORD, non_resident_end) +
+		attr_rec_size = offsetof(NTFS_ATTR_RECORD, non_resident_end) +
 				ROUND_UP(name_len * sizeof(ntfschar), 3) + 8;

 	/*
@@ -3176,12 +3176,12 @@
 	 */
 	if (always_resident || (!always_non_resident && size < 256)) {
 		is_resident = TRUE;
-		attr_rec_size = offsetof(ATTR_RECORD, resident_end) +
+		attr_rec_size = offsetof(NTFS_ATTR_RECORD, resident_end) +
 				ROUND_UP(name_len * sizeof(ntfschar), 3) +
 				ROUND_UP(size, 3);
 	} else { /* We add 8 for space for mapping pairs. */
 		is_resident = FALSE;
-		attr_rec_size = offsetof(ATTR_RECORD, non_resident_end) +
+		attr_rec_size = offsetof(NTFS_ATTR_RECORD, non_resident_end) +
 				ROUND_UP(name_len * sizeof(ntfschar), 3) + 8;
 	}

@@ -3236,7 +3236,7 @@
 rm_attr_err_out:
 	/* Remove just added attribute. */
 	if (ntfs_attr_record_resize(attr_ni->mrec,
-			(ATTR_RECORD*)((u8*)attr_ni->mrec + offset), 0)) {
+			(NTFS_ATTR_RECORD*)((u8*)attr_ni->mrec + offset), 0)) {
 		ntfs_log_trace("Failed to remove just added attribute.\n");
 	}
 free_err_out:
@@ -3297,7 +3297,7 @@
 		return -1;
 	}
 	while (!ntfs_attr_lookup(na->type, na->name, na->name_len,
-				CASE_SENSITIVE, 0, NULL, 0, ctx)) {
+				NTFS_CASE_SENSITIVE, 0, NULL, 0, ctx)) {
 		if (ntfs_attr_record_rm(ctx)) {
 			ntfs_log_trace("Failed to remove attribute extent. "
 					"Leaving inconsistent metadata.\n");
@@ -3334,7 +3334,7 @@
  * Warning: If you make a record smaller without having copied all the data you
  *	    are interested in the data may be overwritten!
  */
-int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)
+int ntfs_attr_record_resize(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a, u32 new_size)
 {
 	ntfs_log_trace("Entering for new_size %u.\n", (unsigned) new_size);
 	/* Align to 8 bytes, just in case the caller hasn't. */
@@ -3355,7 +3355,7 @@
 		/* Adjust @m to reflect the change in used space. */
 		m->bytes_in_use = cpu_to_le32(new_muse);
 		/* Adjust @a to reflect the new size. */
-		if (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))
+		if (new_size >= offsetof(NTFS_ATTR_REC, length) + sizeof(a->length))
 			a->length = cpu_to_le32(new_size);
 	}
 	return 0;
@@ -3375,7 +3375,7 @@
  *	ENOSPC	- Not enough space in the mft record @m to perform the resize.
  * Note that on error no modifications have been performed whatsoever.
  */
-int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,
+int ntfs_resident_attr_value_resize(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a,
 		const u32 new_size)
 {
 	ntfs_log_trace("Entering for new size %u.\n", (unsigned)new_size);
@@ -3428,7 +3428,7 @@
 int ntfs_attr_record_move_to(ntfs_attr_search_ctx *ctx, ntfs_inode *ni)
 {
 	ntfs_attr_search_ctx *nctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	int err;

 	if (!ctx || !ctx->attr || !ctx->ntfs_ino || !ni) {
@@ -3466,7 +3466,7 @@
 	 * file record.
 	 */
 	if (!ntfs_attr_find(a->type, (ntfschar*)((u8*)a + le16_to_cpu(
-			a->name_offset)), a->name_length, CASE_SENSITIVE, NULL,
+			a->name_offset)), a->name_length, NTFS_CASE_SENSITIVE, NULL,
 			0, nctx)) {
 		ntfs_log_trace("Attribute of such type, with same name already "
 				"present in this MFT record.\n");
@@ -3496,7 +3496,7 @@

 	/* Update attribute list. */
 	ctx->al_entry->mft_reference =
-		MK_LE_MREF(ni->mft_no, le16_to_cpu(ni->mrec->sequence_number));
+		NTFS_MK_LE_MREF(ni->mft_no, le16_to_cpu(ni->mrec->sequence_number));
 	ctx->al_entry->instance = nctx->attr->instance;
 	ntfs_attrlist_mark_dirty(ni);

@@ -3524,7 +3524,7 @@
 int ntfs_attr_record_move_away(ntfs_attr_search_ctx *ctx, int extra)
 {
 	ntfs_inode *base_ni, *ni;
-	MFT_RECORD *m;
+	NTFS_MFT_RECORD *m;
 	int i;

 	if (!ctx || !ctx->attr || !ctx->ntfs_ino || extra < 0) {
@@ -3569,7 +3569,7 @@

 		/*
 		 * ntfs_attr_record_move_to can fail if extent with other lowest
-		 * VCN already present in inode we trying move record to. So,
+		 * NTFS_VCN already present in inode we trying move record to. So,
 		 * do not return error.
 		 */
 		if (!ntfs_attr_record_move_to(ctx, ni))
@@ -3616,8 +3616,8 @@
 {
 	s64 new_allocated_size, bw;
 	ntfs_volume *vol = na->ni->vol;
-	ATTR_REC *a = ctx->attr;
-	runlist *rl;
+	NTFS_ATTR_REC *a = ctx->attr;
+	ntfs_runlist *rl;
 	int mp_size, mp_ofs, name_ofs, arec_size;

 	ntfs_log_trace("Entering for inode 0x%llx, attr 0x%x.\n", (unsigned long
@@ -3653,7 +3653,7 @@
 	if (new_allocated_size > 0) {
 		/* Start by allocating clusters to hold the attribute value. */
 		rl = ntfs_cluster_alloc(vol, 0, new_allocated_size >>
-				vol->cluster_size_bits, -1, DATA_ZONE);
+				vol->cluster_size_bits, -1, NTFS_DATA_ZONE);
 		if (!rl) {
 			if (errno != ENOSPC) {
 				ntfs_log_trace("Eeek!  Failed to allocate "
@@ -3700,7 +3700,7 @@
 		goto cluster_free_err_out;
 	}
 	/* Calculate new offsets for the name and the mapping pairs array. */
-	name_ofs = (sizeof(ATTR_REC) - sizeof(a->compressed_size) + 7) & ~7;
+	name_ofs = (sizeof(NTFS_ATTR_REC) - sizeof(a->compressed_size) + 7) & ~7;
 	mp_ofs = (name_ofs + a->name_length * sizeof(ntfschar) + 7) & ~7;
 	/*
 	 * Determine the size of the resident part of the non-resident
@@ -3731,8 +3731,8 @@
 	a->name_offset = cpu_to_le16(name_ofs);

 	/* Update the flags to match the in-memory ones. */
-	a->flags &= ~(ATTR_IS_SPARSE | ATTR_IS_ENCRYPTED |
-			ATTR_COMPRESSION_MASK);
+	a->flags &= ~(NTFS_ATTR_IS_SPARSE | NTFS_ATTR_IS_ENCRYPTED |
+			NTFS_ATTR_COMPRESSION_MASK);

 	/* Setup the fields specific to non-resident attributes. */
 	a->lowest_vcn = cpu_to_sle64(0);
@@ -3754,7 +3754,7 @@
 		// FIXME: Eeek! We need rollback! (AIA)
 		ntfs_log_trace("Eeek!  Failed to build mapping pairs.  Leaving "
 				"corrupt attribute record on disk.  In memory "
-				"runlist is still intact!  Error code is %i.  "
+				"ntfs_runlist is still intact!  Error code is %i.  "
 				"FIXME:  Need to rollback instead!\n", errno);
 		return -1;
 	}
@@ -3838,7 +3838,7 @@
 			na->allocated_size = ROUND_UP(newsize, 3);
 			if (NAttrCompressed(na) || NAttrSparse(na))
 				na->compressed_size = na->allocated_size;
-			if (na->type == AT_DATA && na->name == AT_UNNAMED) {
+			if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED) {
 				na->ni->data_size = na->data_size;
 				na->ni->allocated_size = na->allocated_size;
 				NInoFileNameSetDirty(na->ni);
@@ -3870,9 +3870,9 @@

 	/* Try to make other attributes non-resident and retry each time. */
 	ntfs_attr_init_search_ctx(ctx, NULL, na->ni->mrec);
-	while (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
+	while (!ntfs_attr_lookup(NTFS_AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
 		ntfs_attr *tna;
-		ATTR_RECORD *a;
+		NTFS_ATTR_RECORD *a;

 		a = ctx->attr;
 		if (a->non_resident)
@@ -3882,7 +3882,7 @@
 		 * Check out whether convert is reasonable. Assume that mapping
 		 * pairs will take 8 bytes.
 		 */
-		if (le32_to_cpu(a->length) <= offsetof(ATTR_RECORD,
+		if (le32_to_cpu(a->length) <= offsetof(NTFS_ATTR_RECORD,
 				compressed_size) + ROUND_UP(a->name_length *
 				sizeof(ntfschar), 3) + 8)
 			continue;
@@ -3911,9 +3911,9 @@
 	}

 	/* We can't move out attribute list, thus move out others. */
-	if (na->type == AT_ATTRIBUTE_LIST) {
+	if (na->type == NTFS_AT_ATTRIBUTE_LIST) {
 		ntfs_attr_put_search_ctx(ctx);
-		if (ntfs_inode_free_space(na->ni, offsetof(ATTR_RECORD,
+		if (ntfs_inode_free_space(na->ni, offsetof(NTFS_ATTR_RECORD,
 				non_resident_end) + 8)) {
 			ntfs_log_trace("Couldn't free space in the MFT record "
 					"to make attribute list non "
@@ -3930,7 +3930,7 @@

 	/* Point search context back to attribute which we need resize. */
 	ntfs_attr_init_search_ctx(ctx, na->ni, NULL);
-	if (ntfs_attr_lookup(na->type, na->name, na->name_len, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(na->type, na->name, na->name_len, NTFS_CASE_SENSITIVE,
 			0, NULL, 0, ctx)) {
 		ntfs_log_trace("Attribute lookup failed.\n");
 		err = errno;
@@ -3941,13 +3941,13 @@
 	 * Force index allocation creation instead of moving out index root
 	 * from the base MFT record.
 	 */
-	if (na->type == AT_INDEX_ROOT && na->data_size > sizeof(INDEX_ROOT) +
-			sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN)) {
-		INDEX_ROOT *ir;
+	if (na->type == NTFS_AT_INDEX_ROOT && na->data_size > sizeof(NTFS_INDEX_ROOT) +
+			sizeof(NTFS_INDEX_ENTRY_HEADER) + sizeof(NTFS_VCN)) {
+		NTFS_INDEX_ROOT *ir;

-		ir = (INDEX_ROOT*)((u8*)ctx->attr +
+		ir = (NTFS_INDEX_ROOT*)((u8*)ctx->attr +
 				le16_to_cpu(ctx->attr->value_offset));
-		if (!(ir->index.flags & LARGE_INDEX)) {
+		if (!(ir->index.flags & NTFS_LARGE_INDEX)) {
 			err = EOVERFLOW;
 			goto put_err_out;
 		}
@@ -4033,7 +4033,7 @@
 static int ntfs_attr_make_resident(ntfs_attr *na, ntfs_attr_search_ctx *ctx)
 {
 	ntfs_volume *vol = na->ni->vol;
-	ATTR_REC *a = ctx->attr;
+	NTFS_ATTR_REC *a = ctx->attr;
 	int name_ofs, val_ofs;
 	s64 arec_size, bytes_read;

@@ -4057,7 +4057,7 @@
 	}

 	/* Make sure this is not $MFT/$BITMAP or Windows will not boot! */
-	if (na->type == AT_BITMAP && na->ni->mft_no == FILE_MFT) {
+	if (na->type == NTFS_AT_BITMAP && na->ni->mft_no == NTFS_FILE_MFT) {
 		errno = EPERM;
 		return -1;
 	}
@@ -4098,7 +4098,7 @@
 		return -1;
 	}

-	/* Read and cache the whole runlist if not already done. */
+	/* Read and cache the whole ntfs_runlist if not already done. */
 	if (ntfs_attr_map_whole_runlist(na))
 		return -1;

@@ -4132,8 +4132,8 @@
 	 * but at least it serves as a reminder that there may be attributes
 	 * for which we do need to set this flag. (AIA)
 	 */
-	if (a->type == AT_FILE_NAME)
-		a->resident_flags = RESIDENT_ATTR_IS_INDEXED;
+	if (a->type == NTFS_AT_FILE_NAME)
+		a->resident_flags = NTFS_RESIDENT_ATTR_IS_INDEXED;
 	else
 		a->resident_flags = 0;
 	a->reservedR = 0;
@@ -4160,7 +4160,7 @@
 				na->data_size - na->initialized_size);

 	/*
-	 * Deallocate clusters from the runlist.
+	 * Deallocate clusters from the ntfs_runlist.
 	 *
 	 * NOTE: We can use ntfs_cluster_free() because we have already mapped
 	 * the whole run list and thus it doesn't matter that the attribute
@@ -4172,7 +4172,7 @@
 				"clusters.\n");
 	}

-	/* Throw away the now unused runlist. */
+	/* Throw away the now unused ntfs_runlist. */
 	free(na->rl);
 	na->rl = NULL;

@@ -4192,17 +4192,17 @@
 /**
  * ntfs_attr_update_mapping_pairs - update mapping pairs for ntfs attribute
  * @na:		non-resident ntfs open attribute for which we need update
- * @from_vcn:	update runlist starting this VCN
+ * @from_vcn:	update ntfs_runlist starting this NTFS_VCN
  *
  * Build mapping pairs from @na->rl and write them to the disk. Also, this
  * function updates sparse bit, allocated and compressed size (allocates/frees
  * space for this field if required).
  *
- * @na->allocated_size should be set to correct value for the new runlist before
+ * @na->allocated_size should be set to correct value for the new ntfs_runlist before
  * call to this function. Vice-versa @na->compressed_size will be calculated and
  * set to correct value during this function.
  *
- * New runlist should be fully formed starting @from_vcn. Runs before @from_vcn
+ * New ntfs_runlist should be fully formed starting @from_vcn. Runs before @from_vcn
  * can be mapped or not, but on-disk structures should not be modified before
  * call to this function so they can be mapped if necessary.
  *
@@ -4221,15 +4221,15 @@
  *	ENOSPC - There is no enough space in base mft to resize $ATTRIBUTE_LIST
  *		 or there is no free MFT records left to allocate.
  */
-int ntfs_attr_update_mapping_pairs(ntfs_attr *na, VCN from_vcn)
+int ntfs_attr_update_mapping_pairs(ntfs_attr *na, NTFS_VCN from_vcn)
 {
 	ntfs_attr_search_ctx *ctx;
 	ntfs_inode *ni, *base_ni;
-	MFT_RECORD *m;
-	ATTR_RECORD *a;
-	VCN stop_vcn;
+	NTFS_MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
+	NTFS_VCN stop_vcn;
 	int err, mp_size, cur_max_mp_size, exp_max_mp_size;
-	BOOL finished_build;
+	NTFS_BOOL finished_build;

 retry:
 	if (!na || !na->rl) {
@@ -4263,34 +4263,34 @@
 	stop_vcn = 0;
 	finished_build = FALSE;
 	while (!ntfs_attr_lookup(na->type, na->name, na->name_len,
-				CASE_SENSITIVE, ctx->is_first ? 0 : from_vcn,
+				NTFS_CASE_SENSITIVE, ctx->is_first ? 0 : from_vcn,
 				NULL, 0, ctx)) {
 		a = ctx->attr;
 		m = ctx->mrec;
 		/*
-		 * If runlist is updating not from the beginning, then set
+		 * If ntfs_runlist is updating not from the beginning, then set
 		 * @stop_vcn properly, i.e. to the lowest vcn of record that
 		 * contain @from_vcn. Also we do not need @from_vcn anymore,
 		 * set it to 0 to make ntfs_attr_lookup enumerate attributes.
 		 */
 		if (from_vcn && a->lowest_vcn) {
-			LCN first_lcn;
+			NTFS_LCN first_lcn;

 			stop_vcn = sle64_to_cpu(a->lowest_vcn);
 			from_vcn = 0;
 			/*
 			 * Check whether the first run we need to update is
-			 * the last run in runlist, if so, then deallocate
+			 * the last run in ntfs_runlist, if so, then deallocate
 			 * all attribute extents starting this one.
 			 */
 			first_lcn = ntfs_rl_vcn_to_lcn(na->rl, stop_vcn);
-			if (first_lcn == LCN_EINVAL) {
-				ntfs_log_trace("BUG! Incorrect runlist.\n");
+			if (first_lcn == NTFS_LCN_EINVAL) {
+				ntfs_log_trace("BUG! Incorrect ntfs_runlist.\n");
 				err = EIO;
 				goto put_err_out;
 			}
-			if (first_lcn == LCN_ENOENT ||
-					first_lcn == LCN_RL_NOT_MAPPED)
+			if (first_lcn == NTFS_LCN_ENOENT ||
+					first_lcn == NTFS_LCN_RL_NOT_MAPPED)
 				finished_build = TRUE;
 		}

@@ -4333,44 +4333,44 @@
 			/* Update allocated size. */
 			a->allocated_size = cpu_to_sle64(na->allocated_size);
 			/*
-			 * Check whether part of runlist we are updating is
+			 * Check whether part of ntfs_runlist we are updating is
 			 * sparse.
 			 */
 			sparse = ntfs_rl_sparse(na->rl);
 			if (sparse == -1) {
-				ntfs_log_trace("Bad runlist.\n");
+				ntfs_log_trace("Bad ntfs_runlist.\n");
 				err = errno;
 				goto put_err_out;
 			}
 			/*
 			 * If new part or on-disk attribute is not sparse, then
-			 * we should fully map runlist to make final decision.
+			 * we should fully map ntfs_runlist to make final decision.
 			 */
-			if (sparse || (a->flags & ATTR_IS_SPARSE)) {
+			if (sparse || (a->flags & NTFS_ATTR_IS_SPARSE)) {
 				if (from_vcn && ntfs_attr_map_runlist_range(na,
 						0, from_vcn - 1)) {
-					ntfs_log_trace("Failed to map runlist "
+					ntfs_log_trace("Failed to map ntfs_runlist "
 							"before @from_vcn.\n");
 					err = errno;
 					goto put_err_out;
 				}
 				/*
-				 * Reconsider whether whole runlist is sparse
+				 * Reconsider whether whole ntfs_runlist is sparse
 				 * if new part is not.
 				 */
 				if (!sparse) {
 					sparse = ntfs_rl_sparse(na->rl);
 					if (sparse == -1) {
 						ntfs_log_trace("Bad "
-								"runlist.\n");
+								"ntfs_runlist.\n");
 						err = errno;
 						goto put_err_out;
 					}
 				}
 			}
 			/* Attribute becomes sparse/compressed. */
-			if (sparse && !(a->flags & (ATTR_IS_SPARSE |
-							ATTR_IS_COMPRESSED))) {
+			if (sparse && !(a->flags & (NTFS_ATTR_IS_SPARSE |
+							NTFS_ATTR_IS_COMPRESSED))) {
 				/*
 				 * We need to move attribute to another mft
 				 * record, if attribute is to small to add
@@ -4410,7 +4410,7 @@
 					goto put_err_out;
 				}
 				NAttrSetSparse(na);
-				a->flags |= ATTR_IS_SPARSE;
+				a->flags |= NTFS_ATTR_IS_SPARSE;
 				a->compression_unit = 4; /* Windows set it so,
 							    even if attribute
 							    is not actually
@@ -4430,10 +4430,10 @@
 				from_vcn = 0;
 			}
 			/* Attribute becomes normal. */
-			if (!sparse && (a->flags & ATTR_IS_SPARSE) &&
-					!(a->flags & ATTR_IS_COMPRESSED)) {
+			if (!sparse && (a->flags & NTFS_ATTR_IS_SPARSE) &&
+					!(a->flags & NTFS_ATTR_IS_COMPRESSED)) {
 				NAttrClearSparse(na);
-				a->flags &= ~ATTR_IS_SPARSE;
+				a->flags &= ~NTFS_ATTR_IS_SPARSE;
 				a->compression_unit = 0;
 				memmove((u8*)a + le16_to_cpu(a->name_offset) -
 					8, (u8*)a + le16_to_cpu(a->name_offset),
@@ -4459,7 +4459,7 @@
 				from_vcn = 0;
 			}
 			/* Update compressed size if required. */
-			if (sparse || (a->flags & ATTR_IS_COMPRESSED)) {
+			if (sparse || (a->flags & NTFS_ATTR_IS_COMPRESSED)) {
 				s64 new_compr_size;

 				new_compr_size = ntfs_rl_get_compressed_size(
@@ -4479,7 +4479,7 @@
 			 * Set FILE_NAME dirty flag, to update sparse bit and
 			 * allocated size in the index.
 			 */
-			if (na->type == AT_DATA && na->name == AT_UNNAMED) {
+			if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED) {
 				if (sparse)
 					na->ni->allocated_size =
 							na->compressed_size;
@@ -4531,7 +4531,7 @@
 			 * in the base mft record. Try to move out other
 			 * attributes and try again.
 			 */
-			if (na->type == AT_ATTRIBUTE_LIST) {
+			if (na->type == NTFS_AT_ATTRIBUTE_LIST) {
 				ntfs_attr_put_search_ctx(ctx);
 				if (ntfs_inode_free_space(na->ni, mp_size -
 							cur_max_mp_size)) {
@@ -4589,7 +4589,7 @@
 		ntfs_inode_mark_dirty(ctx->ntfs_ino);
 		if ((ctx->ntfs_ino->nr_extents == -1 ||
 					NInoAttrList(ctx->ntfs_ino)) &&
-					ctx->attr->type != AT_ATTRIBUTE_LIST) {
+					ctx->attr->type != NTFS_AT_ATTRIBUTE_LIST) {
 			ctx->al_entry->lowest_vcn = cpu_to_sle64(stop_vcn);
 			ntfs_attrlist_mark_dirty(ctx->ntfs_ino);
 		}
@@ -4631,7 +4631,7 @@
 		ntfs_attr_reinit_search_ctx(ctx);
 		ntfs_log_trace("Deallocate marked extents.\n");
 		while (!ntfs_attr_lookup(na->type, na->name, na->name_len,
-				CASE_SENSITIVE, 0, NULL, 0, ctx)) {
+				NTFS_CASE_SENSITIVE, 0, NULL, 0, ctx)) {
 			if (sle64_to_cpu(ctx->attr->highest_vcn) !=
 							NTFS_VCN_DELETE_MARK)
 				continue;
@@ -4681,7 +4681,7 @@
 		 */
 		cur_max_mp_size = le32_to_cpu(m->bytes_allocated) -
 				le32_to_cpu(m->bytes_in_use) -
-				(offsetof(ATTR_RECORD, compressed_size) +
+				(offsetof(NTFS_ATTR_RECORD, compressed_size) +
 				((NAttrCompressed(na) || NAttrSparse(na)) ?
 				sizeof(a->compressed_size) : 0)) -
 				((sizeof(ntfschar) * na->name_len + 7) & ~7);
@@ -4699,7 +4699,7 @@
 			}
 			goto put_err_out;
 		}
-		a = (ATTR_RECORD*)((u8*)m + err);
+		a = (NTFS_ATTR_RECORD*)((u8*)m + err);

 		err = ntfs_mapping_pairs_build(na->ni->vol, (u8*)a +
 			le16_to_cpu(a->mapping_pairs_offset), mp_size, na->rl,
@@ -4746,7 +4746,7 @@
 {
 	ntfs_volume *vol;
 	ntfs_attr_search_ctx *ctx;
-	VCN first_free_vcn;
+	NTFS_VCN first_free_vcn;
 	s64 nr_freed_clusters;
 	int err;

@@ -4791,11 +4791,11 @@
 			return -1;
 		}

-		/* Truncate the runlist itself. */
+		/* Truncate the ntfs_runlist itself. */
 		if (ntfs_rl_truncate(&na->rl, first_free_vcn)) {
 			err = errno;
 			/*
-			 * Failed to truncate the runlist, so just throw it
+			 * Failed to truncate the ntfs_runlist, so just throw it
 			 * away, it will be mapped afresh on next use.
 			 */
 			free(na->rl);
@@ -4807,7 +4807,7 @@

 		/* Prepare to mapping pairs update. */
 		na->allocated_size = first_free_vcn << vol->cluster_size_bits;
-		/* Write mapping pairs for new runlist. */
+		/* Write mapping pairs for new ntfs_runlist. */
 		if (ntfs_attr_update_mapping_pairs(na, first_free_vcn)) {
 			ntfs_log_trace("Eeek! Mapping pairs update failed. "
 					"Leaving inconsistent metadata. "
@@ -4822,7 +4822,7 @@
 		ntfs_log_trace("Couldn't get attribute search context.\n");
 		return -1;
 	}
-	if (ntfs_attr_lookup(na->type, na->name, na->name_len, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(na->type, na->name, na->name_len, NTFS_CASE_SENSITIVE,
 			0, NULL, 0, ctx)) {
 		err = errno;
 		if (err == ENOENT)
@@ -4840,7 +4840,7 @@
 		ctx->attr->initialized_size = cpu_to_sle64(newsize);
 	}
 	/* Update data size in the index. */
-	if (na->type == AT_DATA && na->name == AT_UNNAMED) {
+	if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED) {
 		na->ni->data_size = na->data_size;
 		NInoFileNameSetDirty(na->ni);
 	}
@@ -4882,12 +4882,12 @@
  *	ENOSPC - There is no enough space in base mft to resize $ATTRIBUTE_LIST.
  */
 static int ntfs_non_resident_attr_expand(ntfs_attr *na, const s64 newsize,
-		BOOL sparse)
+		NTFS_BOOL sparse)
 {
-	VCN first_free_vcn;
+	NTFS_VCN first_free_vcn;
 	ntfs_volume *vol;
 	ntfs_attr_search_ctx *ctx;
-	runlist *rl, *rln;
+	ntfs_runlist *rl, *rln;
 	s64 org_alloc_size;
 	int err;

@@ -4921,10 +4921,10 @@
 	 * clusters if there is a change.
 	 */
 	if ((na->allocated_size >> vol->cluster_size_bits) < first_free_vcn) {
-		/* Map required part of runlist. */
+		/* Map required part of ntfs_runlist. */
 		if (ntfs_attr_map_runlist(na, na->allocated_size >>
 					vol->cluster_size_bits)) {
-			ntfs_log_error("Failed to map runlist.\n");
+			ntfs_log_error("Failed to map ntfs_runlist.\n");
 			return -1;
 		}

@@ -4932,28 +4932,28 @@
 		 * If we extend $DATA attribute on NTFS 3+ volume, we can add
 		 * sparse runs instead of real allocation of clusters.
 		 */
-		if (na->type == AT_DATA && vol->major_ver >= 3 && sparse) {
+		if (na->type == NTFS_AT_DATA && vol->major_ver >= 3 && sparse) {
 			rl = ntfs_malloc(0x1000);
 			if (!rl)
 				return -1;

 			rl[0].vcn = (na->allocated_size >>
 					vol->cluster_size_bits);
-			rl[0].lcn = LCN_HOLE;
+			rl[0].lcn = NTFS_LCN_HOLE;
 			rl[0].length = first_free_vcn -
 				(na->allocated_size >> vol->cluster_size_bits);
 			rl[1].vcn = first_free_vcn;
-			rl[1].lcn = LCN_ENOENT;
+			rl[1].lcn = NTFS_LCN_ENOENT;
 			rl[1].length = 0;
 		} else {
 			/*
-			 * Determine first after last LCN of attribute.
-			 * We will start seek clusters from this LCN to avoid
+			 * Determine first after last NTFS_LCN of attribute.
+			 * We will start seek clusters from this NTFS_LCN to avoid
 			 * fragmentation.  If there are no valid LCNs in the
 			 * attribute let the cluster allocator choose the
-			 * starting LCN.
+			 * starting NTFS_LCN.
 			 */
-			LCN lcn_seek_from;
+			NTFS_LCN lcn_seek_from;

 			lcn_seek_from = -1;
 			if (na->rl->length) {
@@ -4961,13 +4961,13 @@
 				for (rl = na->rl; (rl + 1)->length; rl++)
 					;
 				/*
-				 * If the last LCN is a hole or similar seek
-				 * back to last valid LCN.
+				 * If the last NTFS_LCN is a hole or similar seek
+				 * back to last valid NTFS_LCN.
 				 */
 				while (rl->lcn < 0 && rl != na->rl)
 					rl--;
 				/*
-				 * Only set lcn_seek_from it the LCN is valid.
+				 * Only set lcn_seek_from it the NTFS_LCN is valid.
 				 */
 				if (rl->lcn >= 0)
 					lcn_seek_from = rl->lcn + rl->length;
@@ -4977,14 +4977,14 @@
 					vol->cluster_size_bits, first_free_vcn -
 					(na->allocated_size >>
 					vol->cluster_size_bits), lcn_seek_from,
-					DATA_ZONE);
+					NTFS_DATA_ZONE);
 			if (!rl) {
 				ntfs_log_trace("Cluster allocation failed.\n");
 				return -1;
 			}
 		}

-		/* Append new clusters to attribute runlist. */
+		/* Append new clusters to attribute ntfs_runlist. */
 		rln = ntfs_runlists_merge(na->rl, rl);
 		if (!rln) {
 			/* Failed, free just allocated clusters. */
@@ -4999,7 +4999,7 @@

 		/* Prepare to mapping pairs update. */
 		na->allocated_size = first_free_vcn << vol->cluster_size_bits;
-		/* Write mapping pairs for new runlist. */
+		/* Write mapping pairs for new ntfs_runlist. */
 		if (ntfs_attr_update_mapping_pairs(na, org_alloc_size >>
 				vol->cluster_size_bits)) {
 			err = errno;
@@ -5018,7 +5018,7 @@
 		goto rollback;
 	}

-	if (ntfs_attr_lookup(na->type, na->name, na->name_len, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(na->type, na->name, na->name_len, NTFS_CASE_SENSITIVE,
 			0, NULL, 0, ctx)) {
 		err = errno;
 		ntfs_log_trace("Lookup of first attribute extent failed.\n");
@@ -5035,7 +5035,7 @@
 	na->data_size = newsize;
 	ctx->attr->data_size = cpu_to_sle64(newsize);
 	/* Update data size in the index. */
-	if (na->type == AT_DATA && na->name == AT_UNNAMED) {
+	if (na->type == NTFS_AT_DATA && na->name == NTFS_AT_UNNAMED) {
 		na->ni->data_size = na->data_size;
 		NInoFileNameSetDirty(na->ni);
 	}
@@ -5051,16 +5051,16 @@
 		ntfs_log_trace("Eeek!  Leaking clusters.  Run chkdsk!\n");
 		err = EIO;
 	}
-	/* Now, truncate the runlist itself. */
+	/* Now, truncate the ntfs_runlist itself. */
 	if (ntfs_rl_truncate(&na->rl, org_alloc_size >>
 			vol->cluster_size_bits)) {
 		/*
-		 * Failed to truncate the runlist, so just throw it away, it
+		 * Failed to truncate the ntfs_runlist, so just throw it away, it
 		 * will be mapped afresh on next use.
 		 */
 		free(na->rl);
 		na->rl = NULL;
-		ntfs_log_trace("Couldn't truncate runlist. Rollback failed.\n");
+		ntfs_log_trace("Couldn't truncate ntfs_runlist. Rollback failed.\n");
 	} else {
 		/* Prepare to mapping pairs update. */
 		na->allocated_size = org_alloc_size;
@@ -5104,12 +5104,12 @@
  *			  @newsize bytes length.
  *	EOPNOTSUPP	- The desired resize is not implemented yet.
  */
-int __ntfs_attr_truncate(ntfs_attr *na, const s64 newsize, BOOL sparse)
+int __ntfs_attr_truncate(ntfs_attr *na, const s64 newsize, NTFS_BOOL sparse)
 {
 	int ret;

 	if (!na || newsize < 0 ||
-			(na->ni->mft_no == FILE_MFT && na->type == AT_DATA)) {
+			(na->ni->mft_no == NTFS_FILE_MFT && na->type == NTFS_AT_DATA)) {
 		ntfs_log_trace("Invalid arguments passed.\n");
 		errno = EINVAL;
 		return -1;
@@ -5166,12 +5166,12 @@
  * ntfs_attr_readall - read the entire data from an ntfs attribute
  * @ni:		open ntfs inode in which the ntfs attribute resides
  * @type:	attribute type
- * @name:	attribute name in little endian Unicode or AT_UNNAMED or NULL
+ * @name:	attribute name in little endian Unicode or NTFS_AT_UNNAMED or NULL
  * @name_len:	length of attribute @name in Unicode characters (if @name given)
  * @data_size:	if non-NULL then store here the data size
  *
  * This function will read the entire content of an ntfs attribute.
- * If @name is AT_UNNAMED then look specifically for an unnamed attribute.
+ * If @name is NTFS_AT_UNNAMED then look specifically for an unnamed attribute.
  * If @name is NULL then the attribute could be either named or not.
  * In both those cases @name_len is not used at all.
  *
@@ -5181,7 +5181,7 @@
  *
  * On error NULL is returned with errno set to the error code.
  */
-void *ntfs_attr_readall(ntfs_inode *ni, const ATTR_TYPES type,
+void *ntfs_attr_readall(ntfs_inode *ni, const NTFS_ATTR_TYPES type,
 			ntfschar *name, u32 name_len, s64 *data_size)
 {
 	ntfs_attr *na;
@@ -5214,7 +5214,7 @@
 /**
  * ntfs_attr_exist - FIXME: description
  */
-int ntfs_attr_exist(ntfs_inode *ni, const ATTR_TYPES type, ntfschar *name,
+int ntfs_attr_exist(ntfs_inode *ni, const NTFS_ATTR_TYPES type, ntfschar *name,
 		u32 name_len)
 {
 	ntfs_attr_search_ctx *ctx;
@@ -5226,7 +5226,7 @@
 	if (!ctx)
 		return 0;

-	ret = ntfs_attr_lookup(type, name, name_len, CASE_SENSITIVE, 0, NULL, 0,
+	ret = ntfs_attr_lookup(type, name, name_len, NTFS_CASE_SENSITIVE, 0, NULL, 0,
 			       ctx);

 	ntfs_attr_put_search_ctx(ctx);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/attrlist.c ./libntfs/attrlist.c
--- ../ntfsprogs-2.0.0/libntfs/attrlist.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/attrlist.c	2007-10-06 16:48:08.000000000 +0200
@@ -35,13 +35,13 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "layout.h"
-#include "attrib.h"
-#include "attrlist.h"
-#include "debug.h"
-#include "unistr.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_attrib.h"
+#include "ntfs_attrlist.h"
+#include "ntfs_debug.h"
+#include "ntfs_unistr.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_attrlist_need - check whether inode need attribute list
@@ -58,7 +58,7 @@
  */
 int ntfs_attrlist_need(ntfs_inode *ni)
 {
-	ATTR_LIST_ENTRY *ale;
+	NTFS_ATTR_LIST_ENTRY *ale;

 	if (!ni) {
 		ntfs_log_trace("Invalid arguments.\n");
@@ -81,11 +81,11 @@
 	}

 	errno = 0;
-	ale = (ATTR_LIST_ENTRY *)ni->attr_list;
+	ale = (NTFS_ATTR_LIST_ENTRY *)ni->attr_list;
 	while ((u8*)ale < ni->attr_list + ni->attr_list_size) {
-		if (MREF_LE(ale->mft_reference) != ni->mft_no)
+		if (NTFS_MREF_LE(ale->mft_reference) != ni->mft_no)
 			return 1;
-		ale = (ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale->length));
+		ale = (NTFS_ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale->length));
 	}
 	return 0;
 }
@@ -102,10 +102,10 @@
  *	EIO	- I/O error occurred or damaged filesystem.
  *	EEXIST	- Such attribute already present in attribute list.
  */
-int ntfs_attrlist_entry_add(ntfs_inode *ni, ATTR_RECORD *attr)
+int ntfs_attrlist_entry_add(ntfs_inode *ni, NTFS_ATTR_RECORD *attr)
 {
-	ATTR_LIST_ENTRY *ale;
-	leMFT_REF mref;
+	NTFS_ATTR_LIST_ENTRY *ale;
+	NTFS_leMFT_REF mref;
 	ntfs_attr *na = NULL;
 	ntfs_attr_search_ctx *ctx;
 	u8 *new_al;
@@ -121,7 +121,7 @@
 		return -1;
 	}

-	mref = MK_LE_MREF(ni->mft_no, le16_to_cpu(ni->mrec->sequence_number));
+	mref = NTFS_MK_LE_MREF(ni->mft_no, le16_to_cpu(ni->mrec->sequence_number));

 	if (ni->nr_extents == -1)
 		ni = ni->base_ni;
@@ -133,7 +133,7 @@
 	}

 	/* Determine size and allocate memory for new attribute list. */
-	entry_len = (sizeof(ATTR_LIST_ENTRY) + sizeof(ntfschar) *
+	entry_len = (sizeof(NTFS_ATTR_LIST_ENTRY) + sizeof(ntfschar) *
 			attr->name_length + 7) & ~7;
 	new_al = malloc(ni->attr_list_size + entry_len);
 	if (!new_al) {
@@ -151,7 +151,7 @@
 	}
 	if (!ntfs_attr_lookup(attr->type, (attr->name_length) ? (ntfschar*)
 			((u8*)attr + le16_to_cpu(attr->name_offset)) :
-			AT_UNNAMED, attr->name_length, CASE_SENSITIVE,
+			NTFS_AT_UNNAMED, attr->name_length, NTFS_CASE_SENSITIVE,
 			(attr->non_resident) ? sle64_to_cpu(attr->lowest_vcn) :
 			0, (attr->non_resident) ? NULL : ((u8*)attr +
 			le16_to_cpu(attr->value_offset)), (attr->non_resident) ?
@@ -165,7 +165,7 @@
 			goto err_out;
 		}
 		/* Add new entry after this extent. */
-		ale = (ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +
+		ale = (NTFS_ATTR_LIST_ENTRY*)((u8*)ctx->al_entry +
 				le16_to_cpu(ctx->al_entry->length));
 	} else {
 		/* Check for real errors. */
@@ -184,12 +184,12 @@
 	/* Determine new entry offset. */
 	entry_offset = ((u8 *)ale - ni->attr_list);
 	/* Set pointer to new entry. */
-	ale = (ATTR_LIST_ENTRY *)(new_al + entry_offset);
+	ale = (NTFS_ATTR_LIST_ENTRY *)(new_al + entry_offset);
 	/* Form new entry. */
 	ale->type = attr->type;
 	ale->length = cpu_to_le16(entry_len);
 	ale->name_length = attr->name_length;
-	ale->name_offset = offsetof(ATTR_LIST_ENTRY, name);
+	ale->name_offset = offsetof(NTFS_ATTR_LIST_ENTRY, name);
 	if (attr->non_resident)
 		ale->lowest_vcn = attr->lowest_vcn;
 	else
@@ -202,7 +202,7 @@
 			attr->name_length * sizeof(ntfschar));

 	/* Resize $ATTRIBUTE_LIST to new length. */
-	na = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		err = errno;
 		ntfs_log_trace("Failed to open $ATTRIBUTE_LIST attribute.\n");
@@ -219,7 +219,7 @@
 	memcpy(new_al + entry_offset + entry_len, ni->attr_list +
 			entry_offset, ni->attr_list_size - entry_offset);

-	/* Set new runlist. */
+	/* Set new ntfs_runlist. */
 	free(ni->attr_list);
 	ni->attr_list = new_al;
 	ni->attr_list_size = ni->attr_list_size + entry_len;
@@ -249,7 +249,7 @@
 	int new_al_len;
 	ntfs_inode *base_ni;
 	ntfs_attr *na;
-	ATTR_LIST_ENTRY *ale;
+	NTFS_ATTR_LIST_ENTRY *ale;
 	int err;

 	if (!ctx || !ctx->ntfs_ino || !ctx->al_entry) {
@@ -285,7 +285,7 @@
 	}

 	/* Reisze $ATTRIBUTE_LIST to new length. */
-	na = ntfs_attr_open(base_ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);
+	na = ntfs_attr_open(base_ni, NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		err = errno;
 		ntfs_log_trace("Failed to open $ATTRIBUTE_LIST attribute.\n");
@@ -302,7 +302,7 @@
 	memcpy(new_al + ((u8*)ale - base_ni->attr_list), (u8*)ale + le16_to_cpu(
 		ale->length), new_al_len - ((u8*)ale - base_ni->attr_list));

-	/* Set new runlist. */
+	/* Set new ntfs_runlist. */
 	free(base_ni->attr_list);
 	base_ni->attr_list = new_al;
 	base_ni->attr_list_size = new_al_len;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/bitmap.c ./libntfs/bitmap.c
--- ../ntfsprogs-2.0.0/libntfs/bitmap.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/bitmap.c	2007-10-06 16:48:08.000000000 +0200
@@ -37,11 +37,11 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "attrib.h"
-#include "bitmap.h"
-#include "debug.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_debug.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_bitmap_set_bits_in_run - set a run of bits in a bitmap to a value
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/bootsect.c ./libntfs/bootsect.c
--- ../ntfsprogs-2.0.0/libntfs/bootsect.c	2007-09-27 15:32:37.000000000 +0200
+++ ./libntfs/bootsect.c	2007-10-06 16:48:08.000000000 +0200
@@ -37,10 +37,10 @@
 #include <errno.h>
 #endif

-#include "compat.h"
-#include "bootsect.h"
-#include "debug.h"
-#include "logging.h"
+#include "ntfs_compat.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_debug.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_boot_sector_is_ntfs - check if buffer contains a valid ntfs boot sector
@@ -56,8 +56,8 @@
  *
  * Return TRUE if @b contains a valid ntfs boot sector and FALSE if not.
  */
-BOOL ntfs_boot_sector_is_ntfs(NTFS_BOOT_SECTOR *b,
-		const BOOL silent __attribute__((unused)))
+NTFS_BOOL ntfs_boot_sector_is_ntfs(NTFS_BOOT_SECTOR *b,
+		const NTFS_BOOL silent __attribute__((unused)))
 {
 	u32 i;

@@ -206,13 +206,13 @@

 	vol->mft_lcn = sle64_to_cpu(bs->mft_lcn);
 	vol->mftmirr_lcn = sle64_to_cpu(bs->mftmirr_lcn);
-	ntfs_log_debug("MFT LCN = 0x%llx\n", vol->mft_lcn);
-	ntfs_log_debug("MFTMirr LCN = 0x%llx\n", vol->mftmirr_lcn);
+	ntfs_log_debug("MFT NTFS_LCN = 0x%llx\n", vol->mft_lcn);
+	ntfs_log_debug("MFTMirr NTFS_LCN = 0x%llx\n", vol->mftmirr_lcn);
 	if (vol->mft_lcn > vol->nr_clusters ||
 			vol->mftmirr_lcn > vol->nr_clusters) {
 		ntfs_log_debug("Error: %s is not a valid NTFS partition!\n",
 				vol->dev->d_name);
-		ntfs_log_debug("($Mft LCN or $MftMirr LCN is greater than the "
+		ntfs_log_debug("($Mft NTFS_LCN or $MftMirr NTFS_LCN is greater than the "
 				"number of clusters!)\n");
 		return -1;
 	}
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/collate.c ./libntfs/collate.c
--- ../ntfsprogs-2.0.0/libntfs/collate.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/collate.c	2007-10-06 16:48:08.000000000 +0200
@@ -28,10 +28,10 @@
 #include <string.h>
 #endif

-#include "collate.h"
-#include "debug.h"
-#include "unistr.h"
-#include "logging.h"
+#include "ntfs_collate.h"
+#include "ntfs_debug.h"
+#include "ntfs_unistr.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_collate_binary - Which of two binary objects should be listed first
@@ -121,10 +121,10 @@

 	ntfs_log_trace("Entering.\n");
 	rc = ntfs_file_values_compare(data1, data2, NTFS_COLLATION_ERROR,
-			IGNORE_CASE, vol->upcase, vol->upcase_len);
+			NTFS_IGNORE_CASE, vol->upcase, vol->upcase_len);
 	if (!rc)
 		rc = ntfs_file_values_compare(data1, data2,
-				NTFS_COLLATION_ERROR, CASE_SENSITIVE,
+				NTFS_COLLATION_ERROR, NTFS_CASE_SENSITIVE,
 				vol->upcase, vol->upcase_len);
 	ntfs_log_trace("Done, returning %i.\n", rc);
 	return rc;
@@ -157,13 +157,13 @@
  *
  * Return TRUE if @cr is supported. FALSE otherwise.
  */
-BOOL ntfs_is_collation_rule_supported(COLLATION_RULES cr)
+NTFS_BOOL ntfs_is_collation_rule_supported(NTFS_COLLATION_RULES cr)
 {
-	return (cr == COLLATION_BINARY || cr == COLLATION_NTOFS_ULONG ||
-			cr == COLLATION_FILE_NAME);
+	return (cr == NTFS_COLLATION_BINARY || cr == NTFS_COLLATION_NTOFS_ULONG ||
+			cr == NTFS_COLLATION_FILE_NAME);
 	/*
-	 * FIXME:  At the moment we only support COLLATION_BINARY,
-	 * COLLATION_NTOFS_ULONG and COLLATION_FILE_NAME.
+	 * FIXME:  At the moment we only support NTFS_COLLATION_BINARY,
+	 * NTFS_COLLATION_NTOFS_ULONG and NTFS_COLLATION_FILE_NAME.
 	 * The correct future implementation of this function should be:
 	 *
 	 * u32 i = le32_to_cpu(cr);
@@ -189,7 +189,7 @@
  *
  * Return NTFS_COLLATION_ERROR if error occurred.
  */
-int ntfs_collate(ntfs_volume *vol, COLLATION_RULES cr,
+int ntfs_collate(ntfs_volume *vol, NTFS_COLLATION_RULES cr,
 		const void *data1, size_t data1_len,
 		const void *data2, size_t data2_len)
 {
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/compat.c ./libntfs/compat.c
--- ../ntfsprogs-2.0.0/libntfs/compat.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/compat.c	2007-10-06 16:48:08.000000000 +0200
@@ -26,7 +26,7 @@
 #include "config.h"
 #endif

-#include "compat.h"
+#include "ntfs_compat.h"

 /* TODO: Add check for FFS in the configure script... (AIA) */

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/compress.c ./libntfs/compress.c
--- ../ntfsprogs-2.0.0/libntfs/compress.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/compress.c	2007-10-06 16:48:08.000000000 +0200
@@ -38,14 +38,14 @@
 #include <errno.h>
 #endif

-#include "attrib.h"
-#include "debug.h"
-#include "volume.h"
-#include "types.h"
-#include "layout.h"
-#include "runlist.h"
-#include "compress.h"
-#include "logging.h"
+#include "ntfs_attrib.h"
+#include "ntfs_debug.h"
+#include "ntfs_volume.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_runlist.h"
+#include "ntfs_compress.h"
+#include "ntfs_logging.h"

 /**
  * enum ntfs_compression_constants - constants used in the compression code
@@ -261,8 +261,8 @@
  * code.  Might be a bit confusing to debug but there really should never be
  * errors coming from here.
  */
-static BOOL ntfs_is_cb_compressed(ntfs_attr *na,
-		runlist_element *rl, VCN cb_start_vcn, int cb_clusters)
+static NTFS_BOOL ntfs_is_cb_compressed(ntfs_attr *na,
+		ntfs_runlist_element *rl, NTFS_VCN cb_start_vcn, int cb_clusters)
 {
 	/*
 	 * The simplest case: the run starting at @cb_start_vcn contains
@@ -274,11 +274,11 @@
 	while (cb_clusters > 0) {
 		/* Go to the next run. */
 		rl++;
-		/* Map the next runlist fragment if it is not mapped. */
-		if (rl->lcn < LCN_HOLE || !rl->length) {
+		/* Map the next ntfs_runlist fragment if it is not mapped. */
+		if (rl->lcn < NTFS_LCN_HOLE || !rl->length) {
 			cb_start_vcn = rl->vcn;
 			rl = ntfs_attr_find_vcn(na, rl->vcn);
-			if (!rl || rl->lcn < LCN_HOLE || !rl->length)
+			if (!rl || rl->lcn < NTFS_LCN_HOLE || !rl->length)
 				return TRUE;
 			/*
 			 * If the runs were merged need to deal with the
@@ -288,7 +288,7 @@
 				goto restart;
 		}
 		/* If the current run is sparse, the cb is compressed. */
-		if (rl->lcn == LCN_HOLE)
+		if (rl->lcn == NTFS_LCN_HOLE)
 			return TRUE;
 		/* If the whole cb is not sparse, it is not compressed. */
 		if (rl->length >= cb_clusters)
@@ -324,9 +324,9 @@
 {
 	s64 br, to_read, ofs, total, total2;
 	u64 cb_size_mask;
-	VCN start_vcn, vcn, end_vcn;
+	NTFS_VCN start_vcn, vcn, end_vcn;
 	ntfs_volume *vol;
-	runlist_element *rl;
+	ntfs_runlist_element *rl;
 	u8 *dest, *cb, *cb_pos, *cb_end;
 	u32 cb_size;
 	int err;
@@ -414,7 +414,7 @@

 	/* Check whether the compression block is sparse. */
 	rl = ntfs_attr_find_vcn(na, vcn);
-	if (!rl || rl->lcn < LCN_HOLE) {
+	if (!rl || rl->lcn < NTFS_LCN_HOLE) {
 		free(cb);
 		free(dest);
 		if (total)
@@ -423,7 +423,7 @@
 		errno = EIO;
 		return -1;
 	}
-	if (rl->lcn == LCN_HOLE) {
+	if (rl->lcn == NTFS_LCN_HOLE) {
 		/* Sparse cb, zero out destination range overlapping the cb. */
 		ntfs_log_debug("Found sparse compression block.\n");
 		to_read = min(count, cb_size - ofs);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/crypto.c ./libntfs/crypto.c
--- ../ntfsprogs-2.0.0/libntfs/crypto.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/crypto.c	2007-10-06 16:48:07.000000000 +0200
@@ -57,13 +57,13 @@
 #include <errno.h>
 #endif

-#include "attrib.h"
-#include "types.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
-#include "layout.h"
-#include "crypto.h"
+#include "ntfs_attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
+#include "ntfs_layout.h"
+#include "ntfs_crypto.h"

 #ifdef ENABLE_CRYPTO

@@ -306,7 +306,7 @@
 	char purpose_oid[100];
 	size_t purpose_oid_size = sizeof(purpose_oid);
 	size_t tp_size;
-	BOOL have_thumbprint = FALSE;
+	NTFS_BOOL have_thumbprint = FALSE;

 	rsa_key = malloc(sizeof(ntfs_rsa_private_key_t));
 	if (!rsa_key) {
@@ -782,14 +782,14 @@
 #ifdef NTFS_TEST
 /*
  * Do not remove this test code from this file!  (AIA)
- * It would be nice to move all tests (these and runlist) out of the library
+ * It would be nice to move all tests (these and ntfs_runlist) out of the library
  * (at least, into the separate file{,s}), so they would not annoy eyes.  (Yura)
  */

 /**
  * ntfs_desx_key_expand_test
  */
-static BOOL ntfs_desx_key_expand_test(void)
+static NTFS_BOOL ntfs_desx_key_expand_test(void)
 {
 	const u8 known_desx_on_disk_key[16] = {
 		0xa1, 0xf9, 0xe0, 0xb2, 0x53, 0x23, 0x9e, 0x8f,
@@ -810,7 +810,7 @@
 		u32 u32[2];
 	} test_des_key;
 	gcry_error_t err;
-	BOOL res;
+	NTFS_BOOL res;

 	err = ntfs_desx_key_expand(known_desx_on_disk_key, test_des_key.u32,
 			&test_out_whitening, &test_in_whitening);
@@ -830,7 +830,7 @@
 /**
  * ntfs_des_test
  */
-static BOOL ntfs_des_test(void)
+static NTFS_BOOL ntfs_des_test(void)
 {
 	const u8 known_des_key[8] = {
 		0x27, 0xd1, 0x93, 0x09, 0xcb, 0x78, 0x93, 0x1f
@@ -884,7 +884,7 @@
 /**
  * ntfs_desx_key_expand_test
  */
-static inline BOOL ntfs_desx_key_expand_test(void)
+static inline NTFS_BOOL ntfs_desx_key_expand_test(void)
 {
 	return TRUE;
 }
@@ -892,7 +892,7 @@
 /**
  * ntfs_des_test
  */
-static inline BOOL ntfs_des_test(void)
+static inline NTFS_BOOL ntfs_des_test(void)
 {
 	return TRUE;
 }
@@ -1019,12 +1019,12 @@
 /**
  * ntfs_df_array_fek_get
  */
-static ntfs_fek *ntfs_df_array_fek_get(EFS_DF_ARRAY_HEADER *df_array,
+static ntfs_fek *ntfs_df_array_fek_get(NTFS_EFS_DF_ARRAY_HEADER *df_array,
 		ntfs_rsa_private_key_t *rsa_key)
 {
-	EFS_DF_HEADER *df_header;
-	EFS_DF_CREDENTIAL_HEADER *df_cred;
-	EFS_DF_CERT_THUMBPRINT_HEADER *df_cert;
+	NTFS_EFS_DF_HEADER *df_header;
+	NTFS_EFS_DF_CREDENTIAL_HEADER *df_cred;
+	NTFS_EFS_DF_CERT_THUMBPRINT_HEADER *df_cert;
 	u8 *fek_buf;
 	ntfs_fek *fek;
 	u32 df_count, fek_size;
@@ -1033,17 +1033,17 @@
 	df_count = le32_to_cpu(df_array->df_count);
 	if (!df_count)
 		ntfs_log_error("There are no elements in the DF array.\n");
-	df_header = (EFS_DF_HEADER*)(df_array + 1);
-	for (i = 0; i < df_count; i++, df_header = (EFS_DF_HEADER*)(
+	df_header = (NTFS_EFS_DF_HEADER*)(df_array + 1);
+	for (i = 0; i < df_count; i++, df_header = (NTFS_EFS_DF_HEADER*)(
 			(u8*)df_header + le32_to_cpu(df_header->df_length))) {
-		df_cred = (EFS_DF_CREDENTIAL_HEADER*)((u8*)df_header +
+		df_cred = (NTFS_EFS_DF_CREDENTIAL_HEADER*)((u8*)df_header +
 				le32_to_cpu(df_header->cred_header_offset));
 		if (df_cred->type != NTFS_CRED_TYPE_CERT_THUMBPRINT) {
 			ntfs_log_debug("Credential type is not certificate "
 					"thumbprint, skipping DF entry.\n");
 			continue;
 		}
-		df_cert = (EFS_DF_CERT_THUMBPRINT_HEADER*)((u8*)df_cred +
+		df_cert = (NTFS_EFS_DF_CERT_THUMBPRINT_HEADER*)((u8*)df_cred +
 				le32_to_cpu(
 				df_cred->cert_thumbprint_header_offset));
 		if (le32_to_cpu(df_cert->thumbprint_size) != thumbprint_size) {
@@ -1089,12 +1089,12 @@
 static ntfs_fek *ntfs_inode_fek_get(ntfs_inode *inode,
 		ntfs_rsa_private_key_t *rsa_key)
 {
-	EFS_ATTR_HEADER *efs;
-	EFS_DF_ARRAY_HEADER *df_array = NULL;
+	NTFS_EFS_ATTR_HEADER *efs;
+	NTFS_EFS_DF_ARRAY_HEADER *df_array = NULL;
 	ntfs_fek *fek = NULL;

 	/* Obtain the $EFS contents. */
-	efs = ntfs_attr_readall(inode, AT_LOGGED_UTILITY_STREAM, NTFS_EFS, 4,
+	efs = ntfs_attr_readall(inode, NTFS_AT_LOGGED_UTILITY_STREAM, NTFS_EFS, 4,
 			NULL);
 	if (!efs) {
 		ntfs_log_perror("Failed to read $EFS attribute");
@@ -1106,14 +1106,14 @@
 	 */
 	if (rsa_key->df_type == DF_TYPE_DDF) {
 		if (efs->offset_to_ddf_array)
-			df_array = (EFS_DF_ARRAY_HEADER*)((u8*)efs +
+			df_array = (NTFS_EFS_DF_ARRAY_HEADER*)((u8*)efs +
 					le32_to_cpu(efs->offset_to_ddf_array));
 		else
 			ntfs_log_error("There are no entries in the DDF "
 					"array.\n");
 	} else if (rsa_key->df_type == DF_TYPE_DRF) {
 		if (efs->offset_to_drf_array)
-			df_array = (EFS_DF_ARRAY_HEADER*)((u8*)efs +
+			df_array = (NTFS_EFS_DF_ARRAY_HEADER*)((u8*)efs +
 					le32_to_cpu(efs->offset_to_drf_array));
 		else
 			ntfs_log_error("There are no entries in the DRF "
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/debug.c ./libntfs/debug.c
--- ../ntfsprogs-2.0.0/libntfs/debug.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/debug.c	2007-10-06 16:48:08.000000000 +0200
@@ -27,44 +27,44 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "runlist.h"
-#include "debug.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_runlist.h"
+#include "ntfs_debug.h"
+#include "ntfs_logging.h"

 #ifdef DEBUG
 /**
- * ntfs_debug_runlist_dump - Dump a runlist.
+ * ntfs_debug_runlist_dump - Dump a ntfs_runlist.
  * @rl:
  *
  * Description...
  *
  * Returns:
  */
-void ntfs_debug_runlist_dump(const runlist_element *rl)
+void ntfs_debug_runlist_dump(const ntfs_runlist_element *rl)
 {
 	int i = 0;
-	const char *lcn_str[5] = { "LCN_HOLE         ", "LCN_RL_NOT_MAPPED",
-				   "LCN_ENOENT       ", "LCN_EINVAL       ",
+	const char *lcn_str[5] = { "NTFS_LCN_HOLE         ", "NTFS_LCN_RL_NOT_MAPPED",
+				   "NTFS_LCN_ENOENT       ", "NTFS_LCN_EINVAL       ",
 				   "LCN_unknown      " };

-	ntfs_log_debug("NTFS-fs DEBUG: Dumping runlist (values in hex):\n");
+	ntfs_log_debug("NTFS-fs DEBUG: Dumping ntfs_runlist (values in hex):\n");
 	if (!rl) {
 		ntfs_log_debug("Run list not present.\n");
 		return;
 	}
-	ntfs_log_debug("VCN              LCN               Run length\n");
+	ntfs_log_debug("NTFS_VCN              NTFS_LCN               Run length\n");
 	do {
-		LCN lcn = (rl + i)->lcn;
+		NTFS_LCN lcn = (rl + i)->lcn;

-		if (lcn < (LCN)0) {
+		if (lcn < (NTFS_LCN)0) {
 			int idx = -lcn - 1;

-			if (idx > -LCN_EINVAL - 1)
+			if (idx > -NTFS_LCN_EINVAL - 1)
 				idx = 4;
-			ntfs_log_debug("%-16llx %s %-16llx%s\n", rl[i].vcn, lcn_str[idx], rl[i].length, rl[i].length ? "" : " (runlist end)");
+			ntfs_log_debug("%-16llx %s %-16llx%s\n", rl[i].vcn, lcn_str[idx], rl[i].length, rl[i].length ? "" : " (ntfs_runlist end)");
 		} else
-			ntfs_log_debug("%-16llx %-16llx  %-16llx%s\n", rl[i].vcn, rl[i].lcn, rl[i].length, rl[i].length ? "" : " (runlist end)");
+			ntfs_log_debug("%-16llx %-16llx  %-16llx%s\n", rl[i].vcn, rl[i].lcn, rl[i].length, rl[i].length ? "" : " (ntfs_runlist end)");
 	} while (rl[i++].length);
 }

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/device.c ./libntfs/device.c
--- ../ntfsprogs-2.0.0/libntfs/device.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/device.c	2007-10-06 16:48:07.000000000 +0200
@@ -63,11 +63,11 @@
 #include <linux/hdreg.h>
 #endif

-#include "types.h"
-#include "mst.h"
-#include "debug.h"
-#include "device.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_mst.h"
+#include "ntfs_debug.h"
+#include "ntfs_device.h"
+#include "ntfs_logging.h"

 #if defined(linux) && defined(_IO) && !defined(BLKGETSIZE)
 #define BLKGETSIZE	_IO(0x12,96)  /* Get device size in 512-byte blocks. */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/dir.c ./libntfs/dir.c
--- ../ntfsprogs-2.0.0/libntfs/dir.c	2007-09-27 14:48:49.000000000 +0200
+++ ./libntfs/dir.c	2007-10-06 16:48:08.000000000 +0200
@@ -42,17 +42,17 @@
 #include <sys/sysmacros.h>
 #endif

-#include "types.h"
-#include "debug.h"
-#include "attrib.h"
-#include "inode.h"
-#include "dir.h"
-#include "volume.h"
-#include "mft.h"
-#include "index.h"
-#include "ntfstime.h"
-#include "lcnalloc.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_debug.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_dir.h"
+#include "ntfs_volume.h"
+#include "ntfs_mft.h"
+#include "ntfs_index.h"
+#include "ntfs_time.h"
+#include "ntfs_lcnalloc.h"
+#include "ntfs_logging.h"

 /*
  * The little endian Unicode strings "$I30", "$SII", "$SDH", "$O"
@@ -102,14 +102,14 @@
 u64 ntfs_inode_lookup_by_name(ntfs_inode *dir_ni, const ntfschar *uname,
 		const int uname_len)
 {
-	VCN vcn;
+	NTFS_VCN vcn;
 	u64 mref = 0;
 	s64 br;
 	ntfs_volume *vol = dir_ni->vol;
 	ntfs_attr_search_ctx *ctx;
-	INDEX_ROOT *ir;
-	INDEX_ENTRY *ie;
-	INDEX_ALLOCATION *ia;
+	NTFS_INDEX_ROOT *ir;
+	NTFS_INDEX_ENTRY *ie;
+	NTFS_INDEX_ALLOCATION *ia;
 	u8 *index_end;
 	ntfs_attr *ia_na;
 	int eo, rc;
@@ -126,7 +126,7 @@
 		return -1;

 	/* Find the index root attribute in the mft record. */
-	if (ntfs_attr_lookup(AT_INDEX_ROOT, NTFS_INDEX_I30, 4, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4, NTFS_CASE_SENSITIVE,
 				0, NULL, 0, ctx)) {
 		ntfs_log_perror("Index root attribute missing in directory "
 				"inode 0x%llx", (unsigned long long)dir_ni->
@@ -134,7 +134,7 @@
 		goto put_err_out;
 	}
 	/* Get to the index root value. */
-	ir = (INDEX_ROOT*)((u8*)ctx->attr +
+	ir = (NTFS_INDEX_ROOT*)((u8*)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));
 	index_block_size = le32_to_cpu(ir->index_block_size);
 	if (index_block_size < NTFS_BLOCK_SIZE ||
@@ -145,16 +145,16 @@
 	}
 	index_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);
 	/* The first index entry. */
-	ie = (INDEX_ENTRY*)((u8*)&ir->index +
+	ie = (NTFS_INDEX_ENTRY*)((u8*)&ir->index +
 			le32_to_cpu(ir->index.entries_offset));
 	/*
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (NTFS_INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +
-				sizeof(INDEX_ENTRY_HEADER) > index_end ||
+				sizeof(NTFS_INDEX_ENTRY_HEADER) > index_end ||
 				(u8*)ie + le16_to_cpu(ie->key_length) >
 				index_end)
 			goto put_err_out;
@@ -162,7 +162,7 @@
 		 * The last entry cannot contain a name. It can however contain
 		 * a pointer to a child node in the B+tree so we just break out.
 		 */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->flags & NTFS_INDEX_ENTRY_END)
 			break;
 		/*
 		 * We perform a case sensitive comparison and if that matches
@@ -174,7 +174,7 @@
 		if (ntfs_names_are_equal(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length,
-				CASE_SENSITIVE, vol->upcase, vol->upcase_len)) {
+				NTFS_CASE_SENSITIVE, vol->upcase, vol->upcase_len)) {
 found_it:
 			/*
 			 * We have a perfect match, so we don't need to care
@@ -195,7 +195,7 @@
 				ntfs_names_are_equal(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length,
-				IGNORE_CASE, vol->upcase, vol->upcase_len))
+				NTFS_IGNORE_CASE, vol->upcase, vol->upcase_len))
 			mref = le64_to_cpu(ie->indexed_file);
 		/*
 		 * Not a perfect match, need to do full blown collation so we
@@ -204,7 +204,7 @@
 		rc = ntfs_names_collate(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length, 1,
-				IGNORE_CASE, vol->upcase, vol->upcase_len);
+				NTFS_IGNORE_CASE, vol->upcase, vol->upcase_len);
 		/*
 		 * If uname collates before the name of the current entry, there
 		 * is definitely no such name in this index but we might need to
@@ -223,7 +223,7 @@
 		rc = ntfs_names_collate(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length, 1,
-				CASE_SENSITIVE, vol->upcase, vol->upcase_len);
+				NTFS_CASE_SENSITIVE, vol->upcase, vol->upcase_len);
 		if (rc == -1)
 			break;
 		if (rc)
@@ -241,7 +241,7 @@
 	 * ENOENT, unless we have got the mft reference of a matching name
 	 * cached in mref in which case return mref.
 	 */
-	if (!(ie->flags & INDEX_ENTRY_NODE)) {
+	if (!(ie->flags & NTFS_INDEX_ENTRY_NODE)) {
 		ntfs_attr_put_search_ctx(ctx);
 		if (mref)
 			return mref;
@@ -251,7 +251,7 @@
 	} /* Child node present, descend into it. */

 	/* Open the index allocation attribute. */
-	ia_na = ntfs_attr_open(dir_ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
+	ia_na = ntfs_attr_open(dir_ni, NTFS_AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
 	if (!ia_na) {
 		ntfs_log_perror("Failed to open index allocation attribute. "
 				"Directory inode 0x%llx is corrupt or driver "
@@ -260,7 +260,7 @@
 	}

 	/* Allocate a buffer for the current index block. */
-	ia = (INDEX_ALLOCATION*)malloc(index_block_size);
+	ia = (NTFS_INDEX_ALLOCATION*)malloc(index_block_size);
 	if (!ia) {
 		ntfs_log_perror("Failed to allocate buffer for index block");
 		ntfs_attr_close(ia_na);
@@ -293,15 +293,15 @@
 	}

 	if (sle64_to_cpu(ia->index_block_vcn) != vcn) {
-		ntfs_log_debug("Actual VCN (0x%llx) of index buffer is "
-				"different from expected VCN (0x%llx).\n",
+		ntfs_log_debug("Actual NTFS_VCN (0x%llx) of index buffer is "
+				"different from expected NTFS_VCN (0x%llx).\n",
 				(long long)sle64_to_cpu(ia->index_block_vcn),
 				(long long)vcn);
 		errno = EIO;
 		goto close_err_out;
 	}
 	if (le32_to_cpu(ia->index.allocated_size) + 0x18 != index_block_size) {
-		ntfs_log_debug("Index buffer (VCN 0x%llx) of directory inode "
+		ntfs_log_debug("Index buffer (NTFS_VCN 0x%llx) of directory inode "
 				"0x%llx has a size (%u) differing from the "
 				"directory specified size (%u).\n",
 				(long long)vcn, (unsigned long long)dir_ni->
@@ -313,7 +313,7 @@
 	}
 	index_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);
 	if (index_end > (u8*)ia + index_block_size) {
-		ntfs_log_debug("Size of index buffer (VCN 0x%llx) of directory "
+		ntfs_log_debug("Size of index buffer (NTFS_VCN 0x%llx) of directory "
 				"inode 0x%llx exceeds maximum size.\n",
 				(long long)vcn, (unsigned long long)dir_ni->
 				mft_no);
@@ -322,17 +322,17 @@
 	}

 	/* The first index entry. */
-	ie = (INDEX_ENTRY*)((u8*)&ia->index +
+	ie = (NTFS_INDEX_ENTRY*)((u8*)&ia->index +
 			le32_to_cpu(ia->index.entries_offset));
 	/*
 	 * Iterate similar to above big loop but applied to index buffer, thus
 	 * loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (NTFS_INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
 		/* Bounds check. */
 		if ((u8*)ie < (u8*)ia || (u8*)ie +
-				sizeof(INDEX_ENTRY_HEADER) > index_end ||
+				sizeof(NTFS_INDEX_ENTRY_HEADER) > index_end ||
 				(u8*)ie + le16_to_cpu(ie->key_length) >
 				index_end) {
 			ntfs_log_debug("Index entry out of bounds in directory "
@@ -345,7 +345,7 @@
 		 * The last entry cannot contain a name. It can however contain
 		 * a pointer to a child node in the B+tree so we just break out.
 		 */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->flags & NTFS_INDEX_ENTRY_END)
 			break;
 		/*
 		 * We perform a case sensitive comparison and if that matches
@@ -357,7 +357,7 @@
 		if (ntfs_names_are_equal(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length,
-				CASE_SENSITIVE, vol->upcase, vol->upcase_len)) {
+				NTFS_CASE_SENSITIVE, vol->upcase, vol->upcase_len)) {
 found_it2:
 			/*
 			 * We have a perfect match, so we don't need to care
@@ -380,7 +380,7 @@
 				ntfs_names_are_equal(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length,
-				IGNORE_CASE, vol->upcase, vol->upcase_len))
+				NTFS_IGNORE_CASE, vol->upcase, vol->upcase_len))
 			mref = le64_to_cpu(ie->indexed_file);
 		/*
 		 * Not a perfect match, need to do full blown collation so we
@@ -389,7 +389,7 @@
 		rc = ntfs_names_collate(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length, 1,
-				IGNORE_CASE, vol->upcase, vol->upcase_len);
+				NTFS_IGNORE_CASE, vol->upcase, vol->upcase_len);
 		/*
 		 * If uname collates before the name of the current entry, there
 		 * is definitely no such name in this index but we might need to
@@ -408,7 +408,7 @@
 		rc = ntfs_names_collate(uname, uname_len,
 				(ntfschar*)&ie->key.file_name.file_name,
 				ie->key.file_name.file_name_length, 1,
-				CASE_SENSITIVE, vol->upcase, vol->upcase_len);
+				NTFS_CASE_SENSITIVE, vol->upcase, vol->upcase_len);
 		if (rc == -1)
 			break;
 		if (rc)
@@ -424,8 +424,8 @@
 	 * We have finished with this index buffer without success. Check for
 	 * the presence of a child node.
 	 */
-	if (ie->flags & INDEX_ENTRY_NODE) {
-		if ((ia->index.flags & NODE_MASK) == LEAF_NODE) {
+	if (ie->flags & NTFS_INDEX_ENTRY_NODE) {
+		if ((ia->index.flags & NTFS_NODE_MASK) == NTFS_LEAF_NODE) {
 			ntfs_log_debug("Index entry with child node found in a "
 					"leaf node in directory inode "
 					"0x%llx.\n",
@@ -503,7 +503,7 @@
 	if (parent) {
 		ni = parent;
 	} else
-		inum = FILE_root;
+		inum = NTFS_FILE_root;
 	unicode = calloc(1, MAX_PATH);
 	ascii = strdup(pathname);
 	if (!unicode || !ascii) {
@@ -545,7 +545,7 @@
 			err = ENOENT;
 			goto close;
 		}
-		inum = MREF(inum);
+		inum = NTFS_MREF(inum);
 		if (ni != parent)
 			ntfs_inode_close(ni);
 		ni = NULL;
@@ -606,21 +606,21 @@
  * Pass information specifying the current directory entry @ie to the @filldir
  * callback.
  */
-static int ntfs_filldir(ntfs_volume *vol, s64 *pos, INDEX_ENTRY *ie,
+static int ntfs_filldir(ntfs_volume *vol, s64 *pos, NTFS_INDEX_ENTRY *ie,
 		void *dirent, ntfs_filldir_t filldir)
 {
-	FILE_NAME_ATTR *fn = &ie->key.file_name;
+	NTFS_FILE_NAME_ATTR *fn = &ie->key.file_name;
 	unsigned dt_type;

 	ntfs_log_trace("Entering.\n");

 	/* Skip root directory self reference entry. */
-	if (MREF_LE(ie->indexed_file) == FILE_root)
+	if (NTFS_MREF_LE(ie->indexed_file) == NTFS_FILE_root)
 		return 0;
-	if (ie->key.file_name.file_attributes & FILE_ATTR_I30_INDEX_PRESENT)
+	if (ie->key.file_name.file_attributes & NTFS_FILE_ATTR_I30_INDEX_PRESENT)
 		dt_type = NTFS_DT_DIR;
 	else {
-		if (NVolInterix(vol) && fn->file_attributes & FILE_ATTR_SYSTEM)
+		if (NVolInterix(vol) && fn->file_attributes & NTFS_FILE_ATTR_SYSTEM)
 			dt_type = NTFS_DT_UNKNOWN;
 		else
 			dt_type = NTFS_DT_REG;
@@ -648,24 +648,24 @@
  * Return the mft reference of the parent directory on success or -1 on error
  * with errno set to the error code.
  */
-static MFT_REF ntfs_mft_get_parent_ref(ntfs_inode *ni)
+static NTFS_MFT_REF ntfs_mft_get_parent_ref(ntfs_inode *ni)
 {
-	MFT_REF mref;
+	NTFS_MFT_REF mref;
 	ntfs_attr_search_ctx *ctx;
-	FILE_NAME_ATTR *fn;
+	NTFS_FILE_NAME_ATTR *fn;
 	int eo;

 	ntfs_log_trace("Entering.\n");

 	if (!ni) {
 		errno = EINVAL;
-		return ERR_MREF(-1);
+		return NTFS_ERR_MREF(-1);
 	}

 	ctx = ntfs_attr_get_search_ctx(ni, NULL);
 	if (!ctx)
-		return ERR_MREF(-1);
-	if (ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
+		return NTFS_ERR_MREF(-1);
+	if (ntfs_attr_lookup(NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
 		ntfs_log_debug("No file name found in inode 0x%llx. Corrupt "
 				"inode.\n", (unsigned long long)ni->mft_no);
 		goto err_out;
@@ -676,7 +676,7 @@
 				(unsigned long long)ni->mft_no);
 		goto io_err_out;
 	}
-	fn = (FILE_NAME_ATTR*)((u8*)ctx->attr +
+	fn = (NTFS_FILE_NAME_ATTR*)((u8*)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));
 	if ((u8*)fn +	le32_to_cpu(ctx->attr->value_length) >
 			(u8*)ctx->attr + le32_to_cpu(ctx->attr->length)) {
@@ -693,7 +693,7 @@
 	eo = errno;
 	ntfs_attr_put_search_ctx(ctx);
 	errno = eo;
-	return ERR_MREF(-1);
+	return NTFS_ERR_MREF(-1);
 }

 /**
@@ -720,9 +720,9 @@
 	ntfs_attr *ia_na, *bmp_na = NULL;
 	ntfs_attr_search_ctx *ctx = NULL;
 	u8 *index_end, *bmp = NULL;
-	INDEX_ROOT *ir;
-	INDEX_ENTRY *ie;
-	INDEX_ALLOCATION *ia = NULL;
+	NTFS_INDEX_ROOT *ir;
+	NTFS_INDEX_ENTRY *ie;
+	NTFS_INDEX_ALLOCATION *ia = NULL;
 	int rc, ir_pos, bmp_buf_size, bmp_buf_pos, eo;
 	u32 index_block_size, index_vcn_size;
 	u8 index_block_size_bits, index_vcn_size_bits;
@@ -734,7 +734,7 @@
 		return -1;
 	}

-	if (!(dir_ni->mrec->flags & MFT_RECORD_IS_DIRECTORY)) {
+	if (!(dir_ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY)) {
 		errno = ENOTDIR;
 		return -1;
 	}
@@ -745,7 +745,7 @@
 			(unsigned long long)dir_ni->mft_no, (long long)*pos);

 	/* Open the index allocation attribute. */
-	ia_na = ntfs_attr_open(dir_ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
+	ia_na = ntfs_attr_open(dir_ni, NTFS_AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
 	if (!ia_na) {
 		if (errno != ENOENT) {
 			ntfs_log_perror("Failed to open index allocation "
@@ -766,8 +766,8 @@

 	/* Emulate . and .. for all directories. */
 	if (!*pos) {
-		rc = filldir(dirent, dotdot, 1, FILE_NAME_POSIX, *pos,
-				MK_MREF(dir_ni->mft_no,
+		rc = filldir(dirent, dotdot, 1, NTFS_FILE_NAME_POSIX, *pos,
+				NTFS_MK_MREF(dir_ni->mft_no,
 				le16_to_cpu(dir_ni->mrec->sequence_number)),
 				NTFS_DT_DIR);
 		if (rc)
@@ -775,15 +775,15 @@
 		++*pos;
 	}
 	if (*pos == 1) {
-		MFT_REF parent_mref;
+		NTFS_MFT_REF parent_mref;

 		parent_mref = ntfs_mft_get_parent_ref(dir_ni);
-		if (parent_mref == ERR_MREF(-1)) {
+		if (parent_mref == NTFS_ERR_MREF(-1)) {
 			ntfs_log_perror("Parent directory not found");
 			goto dir_err_out;
 		}

-		rc = filldir(dirent, dotdot, 2, FILE_NAME_POSIX, *pos,
+		rc = filldir(dirent, dotdot, 2, NTFS_FILE_NAME_POSIX, *pos,
 				parent_mref, NTFS_DT_DIR);
 		if (rc)
 			goto err_out;
@@ -797,7 +797,7 @@
 	/* Get the offset into the index root attribute. */
 	ir_pos = (int)*pos;
 	/* Find the index root attribute in the mft record. */
-	if (ntfs_attr_lookup(AT_INDEX_ROOT, NTFS_INDEX_I30, 4, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4, NTFS_CASE_SENSITIVE,
 				0, NULL, 0, ctx)) {
 		ntfs_log_debug("Index root attribute missing in directory "
 				"inode 0x%llx.\n", (unsigned long long)dir_ni->
@@ -805,7 +805,7 @@
 		goto dir_err_out;
 	}
 	/* Get to the index root value. */
-	ir = (INDEX_ROOT*)((u8*)ctx->attr +
+	ir = (NTFS_INDEX_ROOT*)((u8*)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));

 	/* Determine the size of a vcn in the directory index. */
@@ -834,24 +834,24 @@

 	index_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);
 	/* The first index entry. */
-	ie = (INDEX_ENTRY*)((u8*)&ir->index +
+	ie = (NTFS_INDEX_ENTRY*)((u8*)&ir->index +
 			le32_to_cpu(ir->index.entries_offset));
 	/*
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry or until filldir tells us it has had enough
 	 * or signals an error (both covered by the rc test).
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (NTFS_INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
 		ntfs_log_debug("In index root, offset 0x%x.\n",
 				(u8*)ie - (u8*)ir);
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +
-				sizeof(INDEX_ENTRY_HEADER) > index_end ||
+				sizeof(NTFS_INDEX_ENTRY_HEADER) > index_end ||
 				(u8*)ie + le16_to_cpu(ie->key_length) >
 				index_end)
 			goto dir_err_out;
 		/* The last entry cannot contain a name. */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->flags & NTFS_INDEX_ENTRY_END)
 			break;
 		/* Skip index root entry if continuing previous readdir. */
 		if (ir_pos > (u8*)ie - (u8*)ir)
@@ -882,13 +882,13 @@
 		goto done;

 	/* Allocate a buffer for the current index block. */
-	ia = (INDEX_ALLOCATION*)malloc(index_block_size);
+	ia = (NTFS_INDEX_ALLOCATION*)malloc(index_block_size);
 	if (!ia) {
 		ntfs_log_perror("Failed to allocate buffer for index block");
 		goto err_out;
 	}

-	bmp_na = ntfs_attr_open(dir_ni, AT_BITMAP, NTFS_INDEX_I30, 4);
+	bmp_na = ntfs_attr_open(dir_ni, NTFS_AT_BITMAP, NTFS_INDEX_I30, 4);
 	if (!bmp_na) {
 		ntfs_log_perror("Failed to open index bitmap attribute");
 		goto dir_err_out;
@@ -959,8 +959,8 @@
 	ia_start = ia_pos & ~(s64)(index_block_size - 1);
 	if (sle64_to_cpu(ia->index_block_vcn) != ia_start >>
 			index_vcn_size_bits) {
-		ntfs_log_debug("Actual VCN (0x%llx) of index buffer is "
-				"different from expected VCN (0x%llx) in "
+		ntfs_log_debug("Actual NTFS_VCN (0x%llx) of index buffer is "
+				"different from expected NTFS_VCN (0x%llx) in "
 				"inode 0x%llx.\n",
 				(long long)sle64_to_cpu(ia->index_block_vcn),
 				(long long)ia_start >> index_vcn_size_bits,
@@ -968,7 +968,7 @@
 		goto dir_err_out;
 	}
 	if (le32_to_cpu(ia->index.allocated_size) + 0x18 != index_block_size) {
-		ntfs_log_debug("Index buffer (VCN 0x%llx) of directory inode "
+		ntfs_log_debug("Index buffer (NTFS_VCN 0x%llx) of directory inode "
 				"0x%llx has a size (%u) differing from the "
 				"directory specified size (%u).\n",
 				(long long)ia_start >> index_vcn_size_bits,
@@ -979,26 +979,26 @@
 	}
 	index_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);
 	if (index_end > (u8*)ia + index_block_size) {
-		ntfs_log_debug("Size of index buffer (VCN 0x%llx) of directory "
+		ntfs_log_debug("Size of index buffer (NTFS_VCN 0x%llx) of directory "
 				"inode 0x%llx exceeds maximum size.\n",
 				(long long)ia_start >> index_vcn_size_bits,
 				(unsigned long long)dir_ni->mft_no);
 		goto dir_err_out;
 	}
 	/* The first index entry. */
-	ie = (INDEX_ENTRY*)((u8*)&ia->index +
+	ie = (NTFS_INDEX_ENTRY*)((u8*)&ia->index +
 			le32_to_cpu(ia->index.entries_offset));
 	/*
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry or until ntfs_filldir tells us it has had
 	 * enough or signals an error (both covered by the rc test).
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (NTFS_INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
 		ntfs_log_debug("In index allocation, offset 0x%llx.\n",
 				(long long)ia_start + ((u8*)ie - (u8*)ia));
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ia || (u8*)ie +
-				sizeof(INDEX_ENTRY_HEADER) > index_end ||
+				sizeof(NTFS_INDEX_ENTRY_HEADER) > index_end ||
 				(u8*)ie + le16_to_cpu(ie->key_length) >
 				index_end) {
 			ntfs_log_debug("Index entry out of bounds in directory "
@@ -1007,7 +1007,7 @@
 			goto dir_err_out;
 		}
 		/* The last entry cannot contain a name. */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->flags & NTFS_INDEX_ENTRY_END)
 			break;
 		/* Skip index entry if continuing previous readdir. */
 		if (ia_pos - ia_start > (u8*)ie - (u8*)ia)
@@ -1094,12 +1094,12 @@
 {
 	ntfs_inode *ni;
 	int rollback_data = 0, rollback_sd = 0;
-	FILE_NAME_ATTR *fn = NULL;
-	STANDARD_INFORMATION *si = NULL;
-	SECURITY_DESCRIPTOR_ATTR *sd = NULL;
-	ACL *acl;
-	ACCESS_ALLOWED_ACE *ace;
-	SID *sid;
+	NTFS_FILE_NAME_ATTR *fn = NULL;
+	NTFS_STANDARD_INFORMATION *si = NULL;
+	NTFS_SECURITY_DESCRIPTOR_ATTR *sd = NULL;
+	NTFS_ACL *acl;
+	NTFS_ACCESS_ALLOWED_ACE *ace;
+	NTFS_SID *sid;
 	int err, fn_len, si_len, sd_len;

 	ntfs_log_trace("Entering.\n");
@@ -1111,7 +1111,7 @@
 		return NULL;
 	}
 	/* FIXME: Reparse points requires special handling. */
-	if (dir_ni->flags & FILE_ATTR_REPARSE_POINT) {
+	if (dir_ni->flags & NTFS_FILE_ATTR_REPARSE_POINT) {
 		errno = EOPNOTSUPP;
 		return NULL;
 	}
@@ -1123,10 +1123,10 @@
 		return NULL;
 	}
 	/*
-	 * Create STANDARD_INFORMATION attribute. Write STANDARD_INFORMATION
+	 * Create NTFS_STANDARD_INFORMATION attribute. Write NTFS_STANDARD_INFORMATION
 	 * version 1.2, windows will upgrade it to version 3 if needed.
 	 */
-	si_len = offsetof(STANDARD_INFORMATION, v1_end);
+	si_len = offsetof(NTFS_STANDARD_INFORMATION, v1_end);
 	si = calloc(1, si_len);
 	if (!si) {
 		err = errno;
@@ -1138,25 +1138,25 @@
 	si->last_mft_change_time = utc2ntfs(ni->last_mft_change_time);
 	si->last_access_time = utc2ntfs(ni->last_access_time);
 	if (!S_ISREG(type) && !S_ISDIR(type)) {
-		si->file_attributes = FILE_ATTR_SYSTEM;
-		ni->flags = FILE_ATTR_SYSTEM;
+		si->file_attributes = NTFS_FILE_ATTR_SYSTEM;
+		ni->flags = NTFS_FILE_ATTR_SYSTEM;
 	}
-	/* Add STANDARD_INFORMATION to inode. */
-	if (ntfs_attr_add(ni, AT_STANDARD_INFORMATION, AT_UNNAMED, 0,
+	/* Add NTFS_STANDARD_INFORMATION to inode. */
+	if (ntfs_attr_add(ni, NTFS_AT_STANDARD_INFORMATION, NTFS_AT_UNNAMED, 0,
 			(u8*)si, si_len)) {
 		err = errno;
-		ntfs_log_error("Failed to add STANDARD_INFORMATION "
+		ntfs_log_error("Failed to add NTFS_STANDARD_INFORMATION "
 				"attribute.\n");
 		goto err_out;
 	}
-	/* Create SECURITY_DESCRIPTOR attribute (everyone has full access). */
+	/* Create NTFS_SECURITY_DESCRIPTOR attribute (everyone has full access). */
 	/*
 	 * Calculate security descriptor length. We have 2 sub-authorities in
-	 * owner and group SIDs, but structure SID contain only one, so add
-	 * 4 bytes to every SID.
+	 * owner and group SIDs, but structure NTFS_SID contain only one, so add
+	 * 4 bytes to every NTFS_SID.
 	 */
-	sd_len = sizeof(SECURITY_DESCRIPTOR_ATTR) + 2 * (sizeof(SID) + 4) +
-		sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE);
+	sd_len = sizeof(NTFS_SECURITY_DESCRIPTOR_ATTR) + 2 * (sizeof(NTFS_SID) + 4) +
+		sizeof(NTFS_ACL) + sizeof(NTFS_ACCESS_ALLOWED_ACE);
 	sd = calloc(1, sd_len);
 	if (!sd) {
 		err = errno;
@@ -1164,61 +1164,61 @@
 		goto err_out;
 	}
 	sd->revision = 1;
-	sd->control = SE_DACL_PRESENT | SE_SELF_RELATIVE;
-	sid = (SID*)((u8*)sd + sizeof(SECURITY_DESCRIPTOR_ATTR));
+	sd->control = NTFS_SE_DACL_PRESENT | NTFS_SE_SELF_RELATIVE;
+	sid = (NTFS_SID*)((u8*)sd + sizeof(NTFS_SECURITY_DESCRIPTOR_ATTR));
 	sd->owner = cpu_to_le32((u8*)sid - (u8*)sd);
 	sid->revision = 1;
 	sid->sub_authority_count = 2;
 	sid->sub_authority[0] = cpu_to_le32(32);
 	sid->sub_authority[1] = cpu_to_le32(544);
 	sid->identifier_authority.value[5] = 5;
-	sid = (SID*)((u8*)sid + sizeof(SID) + 4);
+	sid = (NTFS_SID*)((u8*)sid + sizeof(NTFS_SID) + 4);
 	sd->group = cpu_to_le32((u8*)sid - (u8*)sd);
 	sid->revision = 1;
 	sid->sub_authority_count = 2;
 	sid->sub_authority[0] = cpu_to_le32(32);
 	sid->sub_authority[1] = cpu_to_le32(544);
 	sid->identifier_authority.value[5] = 5;
-	acl = (ACL*)((u8*)sid + sizeof(SID) + 4);
+	acl = (NTFS_ACL*)((u8*)sid + sizeof(NTFS_SID) + 4);
 	sd->dacl = cpu_to_le32((u8*)acl - (u8*)sd);
 	acl->revision = 2;
-	acl->size = cpu_to_le16(sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE));
+	acl->size = cpu_to_le16(sizeof(NTFS_ACL) + sizeof(NTFS_ACCESS_ALLOWED_ACE));
 	acl->ace_count = cpu_to_le16(1);
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)acl + sizeof(ACL));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
-	ace->flags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
-	ace->size = cpu_to_le16(sizeof(ACCESS_ALLOWED_ACE));
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)acl + sizeof(NTFS_ACL));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
+	ace->flags = NTFS_OBJECT_INHERIT_ACE | NTFS_CONTAINER_INHERIT_ACE;
+	ace->size = cpu_to_le16(sizeof(NTFS_ACCESS_ALLOWED_ACE));
 	ace->mask = cpu_to_le32(0x1f01ff); /* FIXME */
 	ace->sid.revision = 1;
 	ace->sid.sub_authority_count = 1;
 	ace->sid.sub_authority[0] = 0;
 	ace->sid.identifier_authority.value[5] = 1;
-	/* Add SECURITY_DESCRIPTOR attribute to inode. */
-	if (ntfs_attr_add(ni, AT_SECURITY_DESCRIPTOR, AT_UNNAMED, 0,
+	/* Add NTFS_SECURITY_DESCRIPTOR attribute to inode. */
+	if (ntfs_attr_add(ni, NTFS_AT_SECURITY_DESCRIPTOR, NTFS_AT_UNNAMED, 0,
 			(u8*)sd, sd_len)) {
 		err = errno;
-		ntfs_log_error("Failed to add SECURITY_DESCRIPTOR "
+		ntfs_log_error("Failed to add NTFS_SECURITY_DESCRIPTOR "
 				"attribute.\n");
 		goto err_out;
 	}
 	rollback_sd = 1;
-	/* Add DATA/INDEX_ROOT attribute. */
+	/* Add DATA/NTFS_INDEX_ROOT attribute. */
 	if (S_ISDIR(type)) {
-		INDEX_ROOT *ir = NULL;
-		INDEX_ENTRY *ie;
+		NTFS_INDEX_ROOT *ir = NULL;
+		NTFS_INDEX_ENTRY *ie;
 		int ir_len, index_len;

-		/* Create INDEX_ROOT attribute. */
-		index_len = sizeof(INDEX_HEADER) + sizeof(INDEX_ENTRY_HEADER);
-		ir_len = offsetof(INDEX_ROOT, index) + index_len;
+		/* Create NTFS_INDEX_ROOT attribute. */
+		index_len = sizeof(NTFS_INDEX_HEADER) + sizeof(NTFS_INDEX_ENTRY_HEADER);
+		ir_len = offsetof(NTFS_INDEX_ROOT, index) + index_len;
 		ir = calloc(1, ir_len);
 		if (!ir) {
 			err = errno;
 			ntfs_log_error("Not enough memory.\n");
 			goto err_out;
 		}
-		ir->type = AT_FILE_NAME;
-		ir->collation_rule = COLLATION_FILE_NAME;
+		ir->type = NTFS_AT_FILE_NAME;
+		ir->collation_rule = NTFS_COLLATION_FILE_NAME;
 		ir->index_block_size = cpu_to_le32(ni->vol->indx_record_size);
 		if (ni->vol->cluster_size <= ni->vol->indx_record_size)
 			ir->clusters_per_index_block =
@@ -1228,30 +1228,30 @@
 			ir->clusters_per_index_block =
 					ni->vol->indx_record_size >>
 					ni->vol->sector_size_bits;
-		ir->index.entries_offset = cpu_to_le32(sizeof(INDEX_HEADER));
+		ir->index.entries_offset = cpu_to_le32(sizeof(NTFS_INDEX_HEADER));
 		ir->index.index_length = cpu_to_le32(index_len);
 		ir->index.allocated_size = cpu_to_le32(index_len);
-		ie = (INDEX_ENTRY*)((u8*)ir + sizeof(INDEX_ROOT));
-		ie->length = cpu_to_le16(sizeof(INDEX_ENTRY_HEADER));
+		ie = (NTFS_INDEX_ENTRY*)((u8*)ir + sizeof(NTFS_INDEX_ROOT));
+		ie->length = cpu_to_le16(sizeof(NTFS_INDEX_ENTRY_HEADER));
 		ie->key_length = 0;
-		ie->flags = INDEX_ENTRY_END;
-		/* Add INDEX_ROOT attribute to inode. */
-		if (ntfs_attr_add(ni, AT_INDEX_ROOT, NTFS_INDEX_I30, 4,
+		ie->flags = NTFS_INDEX_ENTRY_END;
+		/* Add NTFS_INDEX_ROOT attribute to inode. */
+		if (ntfs_attr_add(ni, NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4,
 				(u8*)ir, ir_len)) {
 			err = errno;
 			free(ir);
-			ntfs_log_error("Failed to add INDEX_ROOT attribute.\n");
+			ntfs_log_error("Failed to add NTFS_INDEX_ROOT attribute.\n");
 			goto err_out;
 		}
 		free(ir);
 	} else {
-		INTX_FILE *data;
+		NTFS_INTX_FILE *data;
 		int data_len;

 		switch (type) {
 			case S_IFBLK:
 			case S_IFCHR:
-				data_len = offsetof(INTX_FILE, device_end);
+				data_len = offsetof(NTFS_INTX_FILE, device_end);
 				data = ntfs_malloc(data_len);
 				if (!data) {
 					err = errno;
@@ -1260,19 +1260,19 @@
 				data->major = cpu_to_le64(major(dev));
 				data->minor = cpu_to_le64(minor(dev));
 				if (type == S_IFBLK)
-					data->magic = INTX_BLOCK_DEVICE;
+					data->magic = NTFS_INTX_BLOCK_DEVICE;
 				if (type == S_IFCHR)
-					data->magic = INTX_CHARACTER_DEVICE;
+					data->magic = NTFS_INTX_CHARACTER_DEVICE;
 				break;
 			case S_IFLNK:
-				data_len = sizeof(INTX_FILE_TYPES) +
+				data_len = sizeof(NTFS_INTX_FILE_TYPES) +
 						target_len * sizeof(ntfschar);
 				data = ntfs_malloc(data_len);
 				if (!data) {
 					err = errno;
 					goto err_out;
 				}
-				data->magic = INTX_SYMBOLIC_LINK;
+				data->magic = NTFS_INTX_SYMBOLIC_LINK;
 				memcpy(data->target, target,
 						target_len * sizeof(ntfschar));
 				break;
@@ -1286,7 +1286,7 @@
 				break;
 		}
 		/* Add DATA attribute to inode. */
-		if (ntfs_attr_add(ni, AT_DATA, AT_UNNAMED, 0, (u8*)data,
+		if (ntfs_attr_add(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0, (u8*)data,
 				data_len)) {
 			err = errno;
 			free(data);
@@ -1297,33 +1297,33 @@
 		free(data);
 	}
 	/* Create FILE_NAME attribute. */
-	fn_len = sizeof(FILE_NAME_ATTR) + name_len * sizeof(ntfschar);
+	fn_len = sizeof(NTFS_FILE_NAME_ATTR) + name_len * sizeof(ntfschar);
 	fn = ntfs_calloc(fn_len);
 	if (!fn) {
 		err = errno;
 		goto err_out;
 	}
-	fn->parent_directory = MK_LE_MREF(dir_ni->mft_no,
+	fn->parent_directory = NTFS_MK_LE_MREF(dir_ni->mft_no,
 			le16_to_cpu(dir_ni->mrec->sequence_number));
 	fn->file_name_length = name_len;
-	fn->file_name_type = FILE_NAME_POSIX;
+	fn->file_name_type = NTFS_FILE_NAME_POSIX;
 	if (S_ISDIR(type))
-		fn->file_attributes = FILE_ATTR_I30_INDEX_PRESENT;
+		fn->file_attributes = NTFS_FILE_ATTR_I30_INDEX_PRESENT;
 	if (!S_ISREG(type) && !S_ISDIR(type))
-		fn->file_attributes = FILE_ATTR_SYSTEM;
+		fn->file_attributes = NTFS_FILE_ATTR_SYSTEM;
 	fn->creation_time = utc2ntfs(ni->creation_time);
 	fn->last_data_change_time = utc2ntfs(ni->last_data_change_time);
 	fn->last_mft_change_time = utc2ntfs(ni->last_mft_change_time);
 	fn->last_access_time = utc2ntfs(ni->last_access_time);
 	memcpy(fn->file_name, name, name_len * sizeof(ntfschar));
 	/* Add FILE_NAME attribute to inode. */
-	if (ntfs_attr_add(ni, AT_FILE_NAME, AT_UNNAMED, 0, (u8*)fn, fn_len)) {
+	if (ntfs_attr_add(ni, NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, (u8*)fn, fn_len)) {
 		err = errno;
 		ntfs_log_error("Failed to add FILE_NAME attribute.\n");
 		goto err_out;
 	}
 	/* Add FILE_NAME attribute to index. */
-	if (ntfs_index_add_filename(dir_ni, fn, MK_MREF(ni->mft_no,
+	if (ntfs_index_add_filename(dir_ni, fn, NTFS_MK_MREF(ni->mft_no,
 			le16_to_cpu(ni->mrec->sequence_number)))) {
 		err = errno;
 		ntfs_log_perror("Failed to add entry to the index");
@@ -1332,7 +1332,7 @@
 	/* Set hard links count and directory flag. */
 	ni->mrec->link_count = cpu_to_le16(1);
 	if (S_ISDIR(type))
-		ni->mrec->flags |= MFT_RECORD_IS_DIRECTORY;
+		ni->mrec->flags |= NTFS_MFT_RECORD_IS_DIRECTORY;
 	ntfs_inode_mark_dirty(ni);
 	/* Done! */
 	free(fn);
@@ -1345,7 +1345,7 @@
 	if (rollback_sd) {
 		ntfs_attr *na;

-		na = ntfs_attr_open(ni, AT_SECURITY_DESCRIPTOR, AT_UNNAMED, 0);
+		na = ntfs_attr_open(ni, NTFS_AT_SECURITY_DESCRIPTOR, NTFS_AT_UNNAMED, 0);
 		if (!na)
 			ntfs_log_perror("Failed to open SD (0x50) attribute of "
 					" inode 0x%llx. Run chkdsk.\n",
@@ -1358,7 +1358,7 @@
 	if (rollback_data) {
 		ntfs_attr *na;

-		na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 		if (!na)
 			ntfs_log_perror("Failed to open data attribute of "
 					" inode 0x%llx. Run chkdsk.\n",
@@ -1445,9 +1445,9 @@
 	ntfs_attr_search_ctx *actx = NULL;
 	ntfs_index_context *ictx = NULL;
 	ntfs_inode *ni;
-	FILE_NAME_ATTR *fn = NULL;
-	BOOL looking_for_dos_name = FALSE, looking_for_win32_name = FALSE;
-	BOOL case_sensitive_match = TRUE;
+	NTFS_FILE_NAME_ATTR *fn = NULL;
+	NTFS_BOOL looking_for_dos_name = FALSE, looking_for_win32_name = FALSE;
+	NTFS_BOOL case_sensitive_match = TRUE;
 	int err = 0;

 	ntfs_log_trace("Entering.\n");
@@ -1476,39 +1476,39 @@
 	if (!actx)
 		goto err_out;
 search:
-	while (!ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, CASE_SENSITIVE,
+	while (!ntfs_attr_lookup(NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, NTFS_CASE_SENSITIVE,
 			0, NULL, 0, actx)) {
 		errno = 0;
-		fn = (FILE_NAME_ATTR*)((u8*)actx->attr +
+		fn = (NTFS_FILE_NAME_ATTR*)((u8*)actx->attr +
 				le16_to_cpu(actx->attr->value_offset));
 		ntfs_log_trace("Found filename with instance number %d.\n",
 				le16_to_cpu(actx->attr->instance));
 		if (looking_for_dos_name) {
-			if (fn->file_name_type == FILE_NAME_DOS)
+			if (fn->file_name_type == NTFS_FILE_NAME_DOS)
 				break;
 			else
 				continue;
 		}
 		if (looking_for_win32_name) {
-			if  (fn->file_name_type == FILE_NAME_WIN32)
+			if  (fn->file_name_type == NTFS_FILE_NAME_WIN32)
 				break;
 			else
 				continue;
 		}
-		if (dir_ni->mft_no == MREF_LE(fn->parent_directory) &&
+		if (dir_ni->mft_no == NTFS_MREF_LE(fn->parent_directory) &&
 				ntfs_names_are_equal(fn->file_name,
 				fn->file_name_length, name,
 				name_len, case_sensitive_match ?
-				CASE_SENSITIVE : IGNORE_CASE, ni->vol->upcase,
+				NTFS_CASE_SENSITIVE : NTFS_IGNORE_CASE, ni->vol->upcase,
 				ni->vol->upcase_len)) {
-			if (fn->file_name_type == FILE_NAME_WIN32) {
+			if (fn->file_name_type == NTFS_FILE_NAME_WIN32) {
 				looking_for_dos_name = TRUE;
 				ntfs_attr_reinit_search_ctx(actx);
 				ntfs_log_trace("Restart search. "
 						"Looking for DOS name.\n");
 				continue;
 			}
-			if (fn->file_name_type == FILE_NAME_DOS)
+			if (fn->file_name_type == NTFS_FILE_NAME_DOS)
 				looking_for_dos_name = TRUE;
 			break;
 		}
@@ -1530,10 +1530,10 @@
 		goto err_out;
 	}
 	/* If deleting directory check it to be empty. */
-	if (ni->mrec->flags & MFT_RECORD_IS_DIRECTORY) {
+	if (ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY) {
 		ntfs_attr *na;

-		na = ntfs_attr_open(ni, AT_INDEX_ROOT, NTFS_INDEX_I30, 4);
+		na = ntfs_attr_open(ni, NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4);
 		if (!na) {
 			ntfs_log_error("Corrupt directory or library bug.\n");
 			errno = EIO;
@@ -1545,11 +1545,11 @@
 		 * because we delete it first in file which have both WIN32 and
 		 * DOS names).
 		 */
-		if ((na->data_size != sizeof(INDEX_ROOT) + sizeof(
-				INDEX_ENTRY_HEADER)) && (le16_to_cpu(
+		if ((na->data_size != sizeof(NTFS_INDEX_ROOT) + sizeof(
+				NTFS_INDEX_ENTRY_HEADER)) && (le16_to_cpu(
 				ni->mrec->link_count) == 1 ||
 				(le16_to_cpu(ni->mrec->link_count) == 2 &&
-				fn->file_name_type == FILE_NAME_DOS))) {
+				fn->file_name_type == NTFS_FILE_NAME_DOS))) {
 			ntfs_attr_close(na);
 			ntfs_log_error("Directory is not empty.\n");
 			errno = ENOTEMPTY;
@@ -1573,15 +1573,15 @@
 	if (ntfs_index_lookup(fn, le32_to_cpu(actx->attr->value_length), ictx))
 		goto err_out;
 	/* Set namespace to POSIX for WIN32 name. */
-	if (fn->file_name_type == FILE_NAME_WIN32) {
-		fn->file_name_type = FILE_NAME_POSIX;
+	if (fn->file_name_type == NTFS_FILE_NAME_WIN32) {
+		fn->file_name_type = NTFS_FILE_NAME_POSIX;
 		ntfs_inode_mark_dirty(actx->ntfs_ino);
-		((FILE_NAME_ATTR*)ictx->data)->file_name_type = FILE_NAME_POSIX;
+		((NTFS_FILE_NAME_ATTR*)ictx->data)->file_name_type = NTFS_FILE_NAME_POSIX;
 		ntfs_index_entry_mark_dirty(ictx);
 	}
 	/* Do not support reparse point deletion yet. */
-	if (((FILE_NAME_ATTR*)ictx->data)->file_attributes &
-			FILE_ATTR_REPARSE_POINT) {
+	if (((NTFS_FILE_NAME_ATTR*)ictx->data)->file_attributes &
+			NTFS_FILE_ATTR_REPARSE_POINT) {
 		errno = EOPNOTSUPP;
 		goto err_out;
 	}
@@ -1616,13 +1616,13 @@
 	ntfs_attr_reinit_search_ctx(actx);
 	while (!ntfs_attrs_walk(actx)) {
 		if (actx->attr->non_resident) {
-			runlist *rl;
+			ntfs_runlist *rl;

 			rl = ntfs_mapping_pairs_decompress(ni->vol, actx->attr,
 					NULL);
 			if (!rl) {
 				err = errno;
-				ntfs_log_error("Failed to decompress runlist.  "
+				ntfs_log_error("Failed to decompress ntfs_runlist.  "
 						"Leaving inconsistent "
 						"metadata.\n");
 				continue;
@@ -1689,7 +1689,7 @@
  */
 int ntfs_link(ntfs_inode *ni, ntfs_inode *dir_ni, ntfschar *name, u8 name_len)
 {
-	FILE_NAME_ATTR *fn = NULL;
+	NTFS_FILE_NAME_ATTR *fn = NULL;
 	int fn_len, err;

 	ntfs_log_trace("Entering.\n");
@@ -1701,24 +1701,24 @@
 		goto err_out;
 	}
 	/* FIXME: Reparse points requires special handling. */
-	if (ni->flags & FILE_ATTR_REPARSE_POINT) {
+	if (ni->flags & NTFS_FILE_ATTR_REPARSE_POINT) {
 		err = EOPNOTSUPP;
 		goto err_out;
 	}
 	/* Create FILE_NAME attribute. */
-	fn_len = sizeof(FILE_NAME_ATTR) + name_len * sizeof(ntfschar);
+	fn_len = sizeof(NTFS_FILE_NAME_ATTR) + name_len * sizeof(ntfschar);
 	fn = ntfs_calloc(fn_len);
 	if (!fn) {
 		err = errno;
 		goto err_out;
 	}
-	fn->parent_directory = MK_LE_MREF(dir_ni->mft_no,
+	fn->parent_directory = NTFS_MK_LE_MREF(dir_ni->mft_no,
 			le16_to_cpu(dir_ni->mrec->sequence_number));
 	fn->file_name_length = name_len;
-	fn->file_name_type = FILE_NAME_POSIX;
+	fn->file_name_type = NTFS_FILE_NAME_POSIX;
 	fn->file_attributes = ni->flags;
-	if (ni->mrec->flags & MFT_RECORD_IS_DIRECTORY)
-		fn->file_attributes |= FILE_ATTR_I30_INDEX_PRESENT;
+	if (ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY)
+		fn->file_attributes |= NTFS_FILE_ATTR_I30_INDEX_PRESENT;
 	fn->allocated_size = cpu_to_sle64(ni->allocated_size);
 	fn->data_size = cpu_to_sle64(ni->data_size);
 	fn->creation_time = utc2ntfs(ni->creation_time);
@@ -1727,14 +1727,14 @@
 	fn->last_access_time = utc2ntfs(ni->last_access_time);
 	memcpy(fn->file_name, name, name_len * sizeof(ntfschar));
 	/* Add FILE_NAME attribute to index. */
-	if (ntfs_index_add_filename(dir_ni, fn, MK_MREF(ni->mft_no,
+	if (ntfs_index_add_filename(dir_ni, fn, NTFS_MK_MREF(ni->mft_no,
 			le16_to_cpu(ni->mrec->sequence_number)))) {
 		err = errno;
 		ntfs_log_error("Failed to add entry to the index.\n");
 		goto err_out;
 	}
 	/* Add FILE_NAME attribute to inode. */
-	if (ntfs_attr_add(ni, AT_FILE_NAME, AT_UNNAMED, 0, (u8*)fn, fn_len)) {
+	if (ntfs_attr_add(ni, NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, (u8*)fn, fn_len)) {
 		ntfs_index_context *ictx;

 		err = errno;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/gnome-vfs-method.c ./libntfs/gnome-vfs-method.c
--- ../ntfsprogs-2.0.0/libntfs/gnome-vfs-method.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/gnome-vfs-method.c	2007-10-06 16:48:08.000000000 +0200
@@ -25,22 +25,22 @@

 #undef FALSE
 #undef TRUE
-#include "types.h"		/* for 'FALSE'/'TRUE' libntfs definition */
+#include "ntfs_types.h"		/* for 'FALSE'/'TRUE' libntfs definition */
 #define FALSE FALSE
 #define TRUE TRUE

-#include "gnome-vfs-method.h"	/* self */
+#include "ntfs_gnome-vfs-method.h"	/* self */
 #include <libgnomevfs/gnome-vfs-method.h>
 #include <glib/gmessages.h>
-#include "gnome-vfs-module.h"
+#include "ntfs_gnome-vfs-module.h"
 #include <glib/ghash.h>
 #ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 #include <libgnomevfs/gnome-vfs-utils.h>

-#include "volume.h"
-#include "dir.h"
+#include "ntfs_volume.h"
+#include "ntfs_dir.h"

 static GnomeVFSMethod GnomeVFSMethod_static;
 G_LOCK_DEFINE_STATIC(GnomeVFSMethod_static);
@@ -182,7 +182,7 @@
 static GnomeVFSResult inode_open_by_pathname(ntfs_inode **inode_return,
 		ntfs_volume *volume, const gchar *pathname)
 {
-	MFT_REF mref;
+	NTFS_MFT_REF mref;
 	ntfs_inode *inode;
 	gchar *pathname_parse, *pathname_next;
 	int errint;
@@ -195,7 +195,7 @@
 	pathname = g_path_skip_root(pathname);
 	pathname_parse = g_alloca(strlen(pathname) + 1);
 	strcpy(pathname_parse, pathname);
-	mref = FILE_root;
+	mref = NTFS_FILE_root;
 	for (;;) {
 		ntfschar *pathname_parse_ucs2;
 		gchar *pathname_parse_unescaped;
@@ -232,7 +232,7 @@
 		mref = ntfs_inode_lookup_by_name(inode, pathname_parse_ucs2, i);
 		G_UNLOCK(libntfs);
 		g_free(pathname_parse_ucs2);
-		if ((MFT_REF)-1 == mref)
+		if ((NTFS_MFT_REF)-1 == mref)
 			return GNOME_VFS_ERROR_NOT_FOUND;
 		G_LOCK(libntfs);
 		errint = ntfs_inode_close(inode);
@@ -340,7 +340,7 @@
 		struct libntfs_directory *libntfs_directory /* dirent */,
 		const ntfschar *name, const int name_len,
 		const int name_type __attribute__((unused)),
-		const s64 pos, const MFT_REF mref, const unsigned dt_type)
+		const s64 pos, const NTFS_MFT_REF mref, const unsigned dt_type)
 {
 	GnomeVFSFileInfo *file_info;

@@ -350,7 +350,7 @@
 	g_return_val_if_fail(pos >= 0, -1);

 	/* system directory */
-	if (MREF(mref) != FILE_root && MREF(mref) < FILE_first_user)
+	if (NTFS_MREF(mref) != NTFS_FILE_root && NTFS_MREF(mref) < NTFS_FILE_first_user)
 		return 0;	/* continue traversal */

 	file_info = gnome_vfs_file_info_new();
@@ -397,8 +397,8 @@
 			int errint;

 			attr = ntfs_attr_open(inode,	/* ni */
-					AT_DATA,	/* type */
-					AT_UNNAMED,	/* name */
+					NTFS_AT_DATA,	/* type */
+					NTFS_AT_UNNAMED,	/* name */
 					0);		/* name_len */
 			/* FIXME: Check failed 'attr' open. */
 			if (attr) {
@@ -492,8 +492,8 @@
 		G_LOCK(libntfs);
 		libntfs_file->attr = ntfs_attr_open(
 				libntfs_file->inode,	/* ni */
-				AT_DATA,	/* type */
-				AT_UNNAMED,	/* name */
+				NTFS_AT_DATA,	/* type */
+				NTFS_AT_UNNAMED,	/* name */
 				0);	/* name_len */
 		G_UNLOCK(libntfs);
 		if (!libntfs_file->attr)
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/gnome-vfs-module.c ./libntfs/gnome-vfs-module.c
--- ../ntfsprogs-2.0.0/libntfs/gnome-vfs-module.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/gnome-vfs-module.c	2007-10-06 16:48:08.000000000 +0200
@@ -23,7 +23,7 @@

 #include "config.h"

-#include "gnome-vfs-method.h"
+#include "ntfs_gnome-vfs-method.h"
 #include <libgnomevfs/gnome-vfs-module.h>
 #include <glib/gmessages.h>
 #include <glib/gutils.h>	/* for g_atexit() */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/index.c ./libntfs/index.c
--- ../ntfsprogs-2.0.0/libntfs/index.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/index.c	2007-10-06 16:48:08.000000000 +0200
@@ -36,15 +36,15 @@
 #include <errno.h>
 #endif

-#include "attrib.h"
-#include "collate.h"
-#include "debug.h"
-#include "index.h"
-#include "mst.h"
-#include "dir.h"
-#include "logging.h"
-#include "bitmap.h"
-#include "support.h"
+#include "ntfs_attrib.h"
+#include "ntfs_collate.h"
+#include "ntfs_debug.h"
+#include "ntfs_index.h"
+#include "ntfs_mst.h"
+#include "ntfs_dir.h"
+#include "ntfs_logging.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_support.h"

 /**
  * ntfs_index_entry_mark_dirty - mark an index entry dirty
@@ -68,17 +68,17 @@
 		ictx->ib_dirty = TRUE;
 }

-static s64 ntfs_ib_vcn_to_pos(ntfs_index_context *icx, VCN vcn)
+static s64 ntfs_ib_vcn_to_pos(ntfs_index_context *icx, NTFS_VCN vcn)
 {
 	return vcn << icx->vcn_size_bits;
 }

-static VCN ntfs_ib_pos_to_vcn(ntfs_index_context *icx, s64 pos)
+static NTFS_VCN ntfs_ib_pos_to_vcn(ntfs_index_context *icx, s64 pos)
 {
 	return pos >> icx->vcn_size_bits;
 }

-static int ntfs_ib_write(ntfs_index_context *icx, VCN vcn, void *buf)
+static int ntfs_ib_write(ntfs_index_context *icx, NTFS_VCN vcn, void *buf)
 {
 	s64 ret;

@@ -90,19 +90,19 @@
 		ntfs_log_perror("Failed to write index block %lld of inode "
 				"%llu", (long long)vcn,
 				(unsigned long long)icx->ni->mft_no);
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;
 	}
-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

 static int ntfs_icx_ib_write(ntfs_index_context *icx)
 {
 		if (ntfs_ib_write(icx, icx->ib_vcn, icx->ib))
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;

 		icx->ib_dirty = FALSE;

-		return STATUS_OK;
+		return NTFS_STATUS_OK;
 }

 /**
@@ -193,44 +193,44 @@
 	};
 }

-static leVCN *ntfs_ie_get_vcn_addr(INDEX_ENTRY *ie)
+static NTFS_leVCN *ntfs_ie_get_vcn_addr(NTFS_INDEX_ENTRY *ie)
 {
-	return (leVCN *)((u8 *)ie + le16_to_cpu(ie->length) - sizeof(VCN));
+	return (NTFS_leVCN *)((u8 *)ie + le16_to_cpu(ie->length) - sizeof(NTFS_VCN));
 }

 /**
  *  Get the subnode vcn to which the index entry refers.
  */
-VCN ntfs_ie_get_vcn(INDEX_ENTRY *ie)
+NTFS_VCN ntfs_ie_get_vcn(NTFS_INDEX_ENTRY *ie)
 {
 	return sle64_to_cpup(ntfs_ie_get_vcn_addr(ie));
 }

-static INDEX_ENTRY *ntfs_ie_get_first(INDEX_HEADER *ih)
+static NTFS_INDEX_ENTRY *ntfs_ie_get_first(NTFS_INDEX_HEADER *ih)
 {
-	return (INDEX_ENTRY *)((u8 *)ih + le32_to_cpu(ih->entries_offset));
+	return (NTFS_INDEX_ENTRY *)((u8 *)ih + le32_to_cpu(ih->entries_offset));
 }

-static INDEX_ENTRY *ntfs_ie_get_next(INDEX_ENTRY *ie)
+static NTFS_INDEX_ENTRY *ntfs_ie_get_next(NTFS_INDEX_ENTRY *ie)
 {
-	return (INDEX_ENTRY *)((char *)ie + le16_to_cpu(ie->length));
+	return (NTFS_INDEX_ENTRY *)((char *)ie + le16_to_cpu(ie->length));
 }

-static u8 *ntfs_ie_get_end(INDEX_HEADER *ih)
+static u8 *ntfs_ie_get_end(NTFS_INDEX_HEADER *ih)
 {
 	/* FIXME: check if it isn't overflowing the index block size */
 	return (u8 *)ih + le32_to_cpu(ih->index_length);
 }

-static int ntfs_ie_end(INDEX_ENTRY *ie)
+static int ntfs_ie_end(NTFS_INDEX_ENTRY *ie)
 {
-	return (ie->flags & INDEX_ENTRY_END) ? 1 : 0;
+	return (ie->flags & NTFS_INDEX_ENTRY_END) ? 1 : 0;
 }

 /**
  *  Find the last entry in the index block
  */
-static INDEX_ENTRY *ntfs_ie_get_last(INDEX_ENTRY *ie, char *ies_end)
+static NTFS_INDEX_ENTRY *ntfs_ie_get_last(NTFS_INDEX_ENTRY *ie, char *ies_end)
 {
 	ntfs_log_trace("Entering.\n");

@@ -239,9 +239,9 @@
 	return ie;
 }

-static INDEX_ENTRY *ntfs_ie_get_by_pos(INDEX_HEADER *ih, int pos)
+static NTFS_INDEX_ENTRY *ntfs_ie_get_by_pos(NTFS_INDEX_HEADER *ih, int pos)
 {
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;

 	ntfs_log_trace("pos: %d\n", pos);

@@ -252,9 +252,9 @@
 	return ie;
 }

-static INDEX_ENTRY *ntfs_ie_prev(INDEX_HEADER *ih, INDEX_ENTRY *ie)
+static NTFS_INDEX_ENTRY *ntfs_ie_prev(NTFS_INDEX_HEADER *ih, NTFS_INDEX_ENTRY *ie)
 {
-	INDEX_ENTRY *ie_prev, *tmp;
+	NTFS_INDEX_ENTRY *ie_prev, *tmp;

 	ntfs_log_trace("Entering.\n");

@@ -268,13 +268,13 @@
 	return ie_prev;
 }

-char *ntfs_ie_filename_get(INDEX_ENTRY *ie)
+char *ntfs_ie_filename_get(NTFS_INDEX_ENTRY *ie)
 {
-	FILE_NAME_ATTR *fn;
+	NTFS_FILE_NAME_ATTR *fn;
 	char *name = NULL;
 	int name_len;

-	fn = (FILE_NAME_ATTR *)&ie->key;
+	fn = (NTFS_FILE_NAME_ATTR *)&ie->key;
 	name_len = ntfs_ucstombs(fn->file_name, fn->file_name_length, &name, 0);
 	if (name_len < 0) {
 		ntfs_log_perror("ntfs_ucstombs");
@@ -285,7 +285,7 @@
 	return NULL;
 }

-void ntfs_ie_filename_dump(INDEX_ENTRY *ie)
+void ntfs_ie_filename_dump(NTFS_INDEX_ENTRY *ie)
 {
 	char *s;

@@ -294,9 +294,9 @@
 	free(s);
 }

-void ntfs_ih_filename_dump(INDEX_HEADER *ih)
+void ntfs_ih_filename_dump(NTFS_INDEX_HEADER *ih)
 {
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;

 	ntfs_log_trace("Entering.\n");

@@ -307,10 +307,10 @@
 	}
 }

-static int ntfs_ih_numof_entries(INDEX_HEADER *ih)
+static int ntfs_ih_numof_entries(NTFS_INDEX_HEADER *ih)
 {
 	int n;
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;

 	ntfs_log_trace("Entering.\n");

@@ -320,17 +320,17 @@
 	return n;
 }

-static int ntfs_ih_one_entry(INDEX_HEADER *ih)
+static int ntfs_ih_one_entry(NTFS_INDEX_HEADER *ih)
 {
 	return (ntfs_ih_numof_entries(ih) == 1);
 }

-static int ntfs_ih_zero_entry(INDEX_HEADER *ih)
+static int ntfs_ih_zero_entry(NTFS_INDEX_HEADER *ih)
 {
 	return (ntfs_ih_numof_entries(ih) == 0);
 }

-static void ntfs_ie_delete(INDEX_HEADER *ih, INDEX_ENTRY *ie)
+static void ntfs_ie_delete(NTFS_INDEX_HEADER *ih, NTFS_INDEX_ENTRY *ie)
 {
 	u32 new_size;

@@ -342,7 +342,7 @@
 		new_size - ((u8 *)ie - (u8 *)ih));
 }

-static void ntfs_ie_set_vcn(INDEX_ENTRY *ie, VCN vcn)
+static void ntfs_ie_set_vcn(NTFS_INDEX_ENTRY *ie, NTFS_VCN vcn)
 {
 	*ntfs_ie_get_vcn_addr(ie) = cpu_to_sle64(vcn);
 }
@@ -350,7 +350,7 @@
 /**
  *  Insert @ie index entry at @pos entry. Used @ih values should be ok already.
  */
-static void ntfs_ie_insert(INDEX_HEADER *ih, INDEX_ENTRY *ie, INDEX_ENTRY *pos)
+static void ntfs_ie_insert(NTFS_INDEX_HEADER *ih, NTFS_INDEX_ENTRY *ie, NTFS_INDEX_ENTRY *pos)
 {
 	int ie_size = le16_to_cpu(ie->length);

@@ -363,9 +363,9 @@
 	memcpy(pos, ie, ie_size);
 }

-static INDEX_ENTRY *ntfs_ie_dup(INDEX_ENTRY *ie)
+static NTFS_INDEX_ENTRY *ntfs_ie_dup(NTFS_INDEX_ENTRY *ie)
 {
-	INDEX_ENTRY *dup;
+	NTFS_INDEX_ENTRY *dup;

 	ntfs_log_trace("Entering.\n");

@@ -375,26 +375,26 @@
 	return dup;
 }

-static INDEX_ENTRY *ntfs_ie_dup_novcn(INDEX_ENTRY *ie)
+static NTFS_INDEX_ENTRY *ntfs_ie_dup_novcn(NTFS_INDEX_ENTRY *ie)
 {
-	INDEX_ENTRY *dup;
+	NTFS_INDEX_ENTRY *dup;
 	int size = le16_to_cpu(ie->length);

 	ntfs_log_trace("Entering.\n");

-	if (ie->flags & INDEX_ENTRY_NODE)
-		size -= sizeof(VCN);
+	if (ie->flags & NTFS_INDEX_ENTRY_NODE)
+		size -= sizeof(NTFS_VCN);

 	dup = ntfs_malloc(size);
 	if (dup) {
 		memcpy(dup, ie, size);
-		dup->flags &= ~INDEX_ENTRY_NODE;
+		dup->flags &= ~NTFS_INDEX_ENTRY_NODE;
 		dup->length = cpu_to_le16(size);
 	}
 	return dup;
 }

-static int ntfs_ia_check(ntfs_index_context *icx, INDEX_BLOCK *ib, VCN vcn)
+static int ntfs_ia_check(ntfs_index_context *icx, NTFS_INDEX_BLOCK *ib, NTFS_VCN vcn)
 {
 	u32 ib_size = (unsigned)le32_to_cpu(ib->index.allocated_size) + 0x18;

@@ -410,8 +410,8 @@

 	if (sle64_to_cpu(ib->index_block_vcn) != vcn) {

-		ntfs_log_error("Corrupt index block: VCN (%lld) is different "
-			       "from expected VCN (%lld) in inode %llu\n",
+		ntfs_log_error("Corrupt index block: NTFS_VCN (%lld) is different "
+			       "from expected NTFS_VCN (%lld) in inode %llu\n",
 			       (long long)sle64_to_cpu(ib->index_block_vcn),
 			       (long long)vcn,
 			       (unsigned long long)icx->ni->mft_no);
@@ -420,7 +420,7 @@

 	if (ib_size != icx->block_size) {

-		ntfs_log_error("Corrupt index block : VCN (%lld) of inode %llu "
+		ntfs_log_error("Corrupt index block : NTFS_VCN (%lld) of inode %llu "
 			       "has a size (%u) differing from the index "
 			       "specified size (%u)\n", (long long)vcn,
 			       icx->ni->mft_no, (unsigned)ib_size,
@@ -430,34 +430,34 @@
 	return 0;
 }

-static INDEX_ROOT *ntfs_ir_lookup(ntfs_inode *ni, ntfschar *name,
+static NTFS_INDEX_ROOT *ntfs_ir_lookup(ntfs_inode *ni, ntfschar *name,
 				  u32 name_len, ntfs_attr_search_ctx **ctx)
 {
-	ATTR_RECORD *a;
-	INDEX_ROOT *ir = NULL;
+	NTFS_ATTR_RECORD *a;
+	NTFS_INDEX_ROOT *ir = NULL;

 	ntfs_log_trace("Entering.\n");

 	*ctx = ntfs_attr_get_search_ctx(ni, NULL);
 	if (!*ctx) {
-		ntfs_log_perror("Failed to get $INDEX_ROOT search context");
+		ntfs_log_perror("Failed to get $NTFS_INDEX_ROOT search context");
 		return NULL;
 	}

-	if (ntfs_attr_lookup(AT_INDEX_ROOT, name, name_len, CASE_SENSITIVE,
+	if (ntfs_attr_lookup(NTFS_AT_INDEX_ROOT, name, name_len, NTFS_CASE_SENSITIVE,
 			     0, NULL, 0, *ctx)) {
-		ntfs_log_perror("Failed to lookup $INDEX_ROOT");
+		ntfs_log_perror("Failed to lookup $NTFS_INDEX_ROOT");
 		goto err_out;
 	}

 	a = (*ctx)->attr;
 	if (a->non_resident) {
 		errno = EINVAL;
-		ntfs_log_perror("Non-resident $INDEX_ROOT detected");
+		ntfs_log_perror("Non-resident $NTFS_INDEX_ROOT detected");
 		goto err_out;
 	}

-	ir = (INDEX_ROOT *)((char *)a + le16_to_cpu(a->value_offset));
+	ir = (NTFS_INDEX_ROOT *)((char *)a + le16_to_cpu(a->value_offset));
 err_out:
 	if (!ir)
 		ntfs_attr_put_search_ctx(*ctx);
@@ -468,19 +468,19 @@
  * Find a key in the index block.
  *
  * Return values:
- *   STATUS_OK with errno set to ESUCCESS if we know for sure that the
+ *   NTFS_STATUS_OK with errno set to ESUCCESS if we know for sure that the
  *             entry exists and @ie_out points to this entry.
- *   STATUS_NOT_FOUND with errno set to ENOENT if we know for sure the
+ *   NTFS_STATUS_NOT_FOUND with errno set to ENOENT if we know for sure the
  *                    entry doesn't exist and @ie_out is the insertion point.
- *   STATUS_KEEP_SEARCHING if we can't answer the above question and
+ *   NTFS_STATUS_KEEP_SEARCHING if we can't answer the above question and
  *                         @vcn will contain the node index block.
- *   STATUS_ERROR with errno set if on unexpected error during lookup.
+ *   NTFS_STATUS_ERROR with errno set if on unexpected error during lookup.
  */
 static int ntfs_ie_lookup(const void *key, const int key_len,
-			  ntfs_index_context *icx, INDEX_HEADER *ih,
-			  VCN *vcn, INDEX_ENTRY **ie_out)
+			  ntfs_index_context *icx, NTFS_INDEX_HEADER *ih,
+			  NTFS_VCN *vcn, NTFS_INDEX_ENTRY **ie_out)
 {
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;
 	u8 *index_end;
 	int rc, item = 0;

@@ -494,13 +494,13 @@
 	 */
 	for (ie = ntfs_ie_get_first(ih); ; ie = ntfs_ie_get_next(ie)) {
 		/* Bounds checks. */
-		if ((u8 *)ie + sizeof(INDEX_ENTRY_HEADER) > index_end ||
+		if ((u8 *)ie + sizeof(NTFS_INDEX_ENTRY_HEADER) > index_end ||
 		    (u8 *)ie + le16_to_cpu(ie->length) > index_end) {
 			errno = ERANGE;
 			ntfs_log_error("Index entry out of bounds in inode "
 				       "%llu.\n",
 				       (unsigned long long)icx->ni->mft_no);
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;
 		}
 		/*
 		 * The last entry cannot contain a key.  It can however contain
@@ -518,7 +518,7 @@
 			ntfs_log_error("Collation error. Perhaps a filename "
 				       "contains invalid characters?\n");
 			errno = ERANGE;
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;
 		}
 		/*
 		 * If @key collates before the key of the current entry, there
@@ -532,7 +532,7 @@
 			*ie_out = ie;
 			errno = 0;
 			icx->parent_pos[icx->pindex] = item;
-			return STATUS_OK;
+			return NTFS_STATUS_OK;
 		}

 		item++;
@@ -542,11 +542,11 @@
 	 * presence of a child node and if not present return with errno ENOENT,
 	 * otherwise we will keep searching in another index block.
 	 */
-	if (!(ie->flags & INDEX_ENTRY_NODE)) {
+	if (!(ie->flags & NTFS_INDEX_ENTRY_NODE)) {
 		ntfs_log_debug("Index entry wasn't found.\n");
 		*ie_out = ie;
 		errno = ENOENT;
-		return STATUS_NOT_FOUND;
+		return NTFS_STATUS_NOT_FOUND;
 	}

 	/* Get the starting vcn of the index_block holding the child node. */
@@ -555,19 +555,19 @@
 		errno = EINVAL;
 		ntfs_log_perror("Negative vcn in inode %llu\n",
 				icx->ni->mft_no);
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;
 	}

 	ntfs_log_trace("Parent entry number %d\n", item);
 	icx->parent_pos[icx->pindex] = item;
-	return STATUS_KEEP_SEARCHING;
+	return NTFS_STATUS_KEEP_SEARCHING;
 }

 static ntfs_attr *ntfs_ia_open(ntfs_index_context *icx, ntfs_inode *ni)
 {
 	ntfs_attr *na;

-	na = ntfs_attr_open(ni, AT_INDEX_ALLOCATION, icx->name, icx->name_len);
+	na = ntfs_attr_open(ni, NTFS_AT_INDEX_ALLOCATION, icx->name, icx->name_len);
 	if (!na) {
 		ntfs_log_perror("Failed to open index allocation of inode "
 				"%llu", (unsigned long long)ni->mft_no);
@@ -576,7 +576,7 @@
 	return na;
 }

-static int ntfs_ib_read(ntfs_index_context *icx, VCN vcn, INDEX_BLOCK *dst)
+static int ntfs_ib_read(ntfs_index_context *icx, NTFS_VCN vcn, NTFS_INDEX_BLOCK *dst)
 {
 	s64 pos, ret;

@@ -603,12 +603,12 @@
 static int ntfs_icx_parent_inc(ntfs_index_context *icx)
 {
 	icx->pindex++;
-	if (icx->pindex >= MAX_PARENT_VCN) {
+	if (icx->pindex >= NTFS_MAX_PARENT_VCN) {
 		errno = EOPNOTSUPP;
-		ntfs_log_perror("Index is over %d level deep", MAX_PARENT_VCN);
-		return STATUS_ERROR;
+		ntfs_log_perror("Index is over %d level deep", NTFS_MAX_PARENT_VCN);
+		return NTFS_STATUS_ERROR;
 	}
-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

 static int ntfs_icx_parent_dec(ntfs_index_context *icx)
@@ -617,9 +617,9 @@
 	if (icx->pindex < 0) {
 		errno = EINVAL;
 		ntfs_log_perror("Corrupt index pointer (%d)", icx->pindex);
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;
 	}
-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

 /**
@@ -657,11 +657,11 @@
 int ntfs_index_lookup(const void *key, const int key_len,
 		ntfs_index_context *icx)
 {
-	VCN old_vcn, vcn;
+	NTFS_VCN old_vcn, vcn;
 	ntfs_inode *ni = icx->ni;
-	INDEX_ROOT *ir;
-	INDEX_ENTRY *ie;
-	INDEX_BLOCK *ib = NULL;
+	NTFS_INDEX_ROOT *ir;
+	NTFS_INDEX_ENTRY *ie;
+	NTFS_INDEX_BLOCK *ib = NULL;
 	ntfs_attr_search_ctx *actx;
 	int ret, err = 0;

@@ -702,13 +702,13 @@
 		goto err_out;
 	}

-	old_vcn = VCN_INDEX_ROOT_PARENT;
+	old_vcn = NTFS_VCN_INDEX_ROOT_PARENT;
 	/*
 	 * FIXME: check for both ir and ib that the first index entry is
 	 * within the index block.
 	 */
 	ret = ntfs_ie_lookup(key, key_len, icx, &ir->index, &vcn, &ie);
-	if (ret == STATUS_ERROR) {
+	if (ret == NTFS_STATUS_ERROR) {
 		err = errno;
 		goto err_out;
 	}
@@ -716,8 +716,8 @@
 	icx->actx = actx;
 	icx->ir = ir;

-	if (ret != STATUS_KEEP_SEARCHING) {
-		/* STATUS_OK or STATUS_NOT_FOUND */
+	if (ret != NTFS_STATUS_KEEP_SEARCHING) {
+		/* NTFS_STATUS_OK or NTFS_STATUS_NOT_FOUND */
 		err = errno;
 		icx->is_in_root = TRUE;
 		icx->parent_vcn[icx->pindex] = old_vcn;
@@ -743,25 +743,25 @@
 	}
 	old_vcn = vcn;

-	ntfs_log_debug("Descend into node with VCN %lld.\n", vcn);
+	ntfs_log_debug("Descend into node with NTFS_VCN %lld.\n", vcn);

 	if (ntfs_ib_read(icx, vcn, ib))
 		goto err_out;

 	ret = ntfs_ie_lookup(key, key_len, icx, &ib->index, &vcn, &ie);
-	if (ret != STATUS_KEEP_SEARCHING) {
+	if (ret != NTFS_STATUS_KEEP_SEARCHING) {
 		err = errno;
-		if (ret == STATUS_ERROR)
+		if (ret == NTFS_STATUS_ERROR)
 			goto err_out;

-		/* STATUS_OK or STATUS_NOT_FOUND */
+		/* NTFS_STATUS_OK or NTFS_STATUS_NOT_FOUND */
 		icx->is_in_root = FALSE;
 		icx->ib = ib;
 		icx->parent_vcn[icx->pindex] = icx->ib_vcn = vcn;
 		goto done;
 	}

-	if ((ib->index.flags & NODE_MASK) == LEAF_NODE) {
+	if ((ib->index.flags & NTFS_NODE_MASK) == NTFS_LEAF_NODE) {
 		ntfs_log_error("Index entry with child node found in a leaf "
 			       "node in inode 0x%llx.\n",
 			       (unsigned long long)ni->mft_no);
@@ -783,7 +783,7 @@
 	return -1;
 done:
 	icx->entry = ie;
-	icx->data = (u8 *)ie + offsetof(INDEX_ENTRY, key);
+	icx->data = (u8 *)ie + offsetof(NTFS_INDEX_ENTRY, key);
 	icx->data_len = le16_to_cpu(ie->key_length);
 	icx->max_depth = icx->pindex;
 	ntfs_log_trace("Done.\n");
@@ -794,11 +794,11 @@
 	return 0;
 }

-static INDEX_BLOCK *ntfs_ib_alloc(VCN ib_vcn, u32 ib_size,
-				  INDEX_HEADER_FLAGS node_type)
+static NTFS_INDEX_BLOCK *ntfs_ib_alloc(NTFS_VCN ib_vcn, u32 ib_size,
+				  NTFS_INDEX_HEADER_FLAGS node_type)
 {
-	INDEX_BLOCK *ib;
-	int ih_size = sizeof(INDEX_HEADER);
+	NTFS_INDEX_BLOCK *ib;
+	int ih_size = sizeof(NTFS_INDEX_HEADER);

 	ntfs_log_trace("Entering ib_vcn = %lld ib_size = %u\n", ib_vcn,
 			ib_size);
@@ -808,7 +808,7 @@
 		return NULL;

 	ib->magic = magic_INDX;
-	ib->usa_ofs = cpu_to_le16(sizeof(INDEX_BLOCK));
+	ib->usa_ofs = cpu_to_le16(sizeof(NTFS_INDEX_BLOCK));
 	ib->usa_count = cpu_to_le16(ib_size / NTFS_BLOCK_SIZE + 1);
 	/* Set USN to 1 */
 	*(le16 *)((char *)ib + le16_to_cpu(ib->usa_ofs)) = cpu_to_le16(1);
@@ -820,7 +820,7 @@
 			le16_to_cpu(ib->usa_count) * 2 + 7) & ~7);
 	ib->index.index_length = 0;
 	ib->index.allocated_size = cpu_to_le32(ib_size -
-					       (sizeof(INDEX_BLOCK) - ih_size));
+					       (sizeof(NTFS_INDEX_BLOCK) - ih_size));
 	ib->index.flags = node_type;
 	return ib;
 }
@@ -828,9 +828,9 @@
 /**
  *  Find the median by going through all the entries
  */
-static INDEX_ENTRY *ntfs_ie_get_median(INDEX_HEADER *ih)
+static NTFS_INDEX_ENTRY *ntfs_ie_get_median(NTFS_INDEX_HEADER *ih)
 {
-	INDEX_ENTRY *ie, *ie_start;
+	NTFS_INDEX_ENTRY *ie, *ie_start;
 	u8 *ie_end;
 	int i = 0, median;

@@ -856,7 +856,7 @@
 	return ie;
 }

-static s64 ntfs_ibm_vcn_to_pos(ntfs_index_context *icx, VCN vcn)
+static s64 ntfs_ibm_vcn_to_pos(ntfs_index_context *icx, NTFS_VCN vcn)
 {
 	return ntfs_ib_vcn_to_pos(icx, vcn) / icx->block_size;
 }
@@ -872,32 +872,32 @@

 	ntfs_log_trace("Entering.\n");

-	if (ntfs_attr_exist(icx->ni, AT_BITMAP, icx->name, icx->name_len))
-		return STATUS_OK;
+	if (ntfs_attr_exist(icx->ni, NTFS_AT_BITMAP, icx->name, icx->name_len))
+		return NTFS_STATUS_OK;
 	/*
-	 * AT_BITMAP must be at least 8 bytes.
+	 * NTFS_AT_BITMAP must be at least 8 bytes.
 	 */
 	memset(bmp, 0, sizeof(bmp));
-	if (ntfs_attr_add(icx->ni, AT_BITMAP, icx->name, icx->name_len,
+	if (ntfs_attr_add(icx->ni, NTFS_AT_BITMAP, icx->name, icx->name_len,
 			  bmp, sizeof(bmp))) {
-		ntfs_log_perror("Failed to add AT_BITMAP");
-		return STATUS_ERROR;
+		ntfs_log_perror("Failed to add NTFS_AT_BITMAP");
+		return NTFS_STATUS_ERROR;
 	}
-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

-static int ntfs_ibm_modify(ntfs_index_context *icx, VCN vcn, int set)
+static int ntfs_ibm_modify(ntfs_index_context *icx, NTFS_VCN vcn, int set)
 {
 	u8 byte;
 	s64 pos = ntfs_ibm_vcn_to_pos(icx, vcn);
 	u32 bpos = pos / 8;
 	u32 bit = 1 << (pos % 8);
 	ntfs_attr *na;
-	int ret = STATUS_ERROR;
+	int ret = NTFS_STATUS_ERROR;

 	ntfs_log_trace("%s vcn: %lld\n", set ? "set" : "clear", vcn);

-	na = ntfs_attr_open(icx->ni, AT_BITMAP,  icx->name, icx->name_len);
+	na = ntfs_attr_open(icx->ni, NTFS_AT_BITMAP,  icx->name, icx->name_len);
 	if (!na) {
 		ntfs_log_perror("Failed to open $BITMAP attribute");
 		return -1;
@@ -906,7 +906,7 @@
 	if (set) {
 		if (na->data_size < bpos + 1) {
 			if (ntfs_attr_truncate(na, (na->data_size + 8) & ~7)) {
-				ntfs_log_perror("Failed to truncate AT_BITMAP");
+				ntfs_log_perror("Failed to truncate NTFS_AT_BITMAP");
 				goto err_na;
 			}
 		}
@@ -927,24 +927,24 @@
 		goto err_na;
 	}

-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 err_na:
 	ntfs_attr_close(na);
 	return ret;
 }


-static int ntfs_ibm_set(ntfs_index_context *icx, VCN vcn)
+static int ntfs_ibm_set(ntfs_index_context *icx, NTFS_VCN vcn)
 {
 	return ntfs_ibm_modify(icx, vcn, 1);
 }

-static int ntfs_ibm_clear(ntfs_index_context *icx, VCN vcn)
+static int ntfs_ibm_clear(ntfs_index_context *icx, NTFS_VCN vcn)
 {
 	return ntfs_ibm_modify(icx, vcn, 0);
 }

-static VCN ntfs_ibm_get_free(ntfs_index_context *icx)
+static NTFS_VCN ntfs_ibm_get_free(ntfs_index_context *icx)
 {
 	u8 *bm;
 	int bit;
@@ -952,10 +952,10 @@

 	ntfs_log_trace("Entering.\n");

-	bm = ntfs_attr_readall(icx->ni, AT_BITMAP,  icx->name, icx->name_len,
+	bm = ntfs_attr_readall(icx->ni, NTFS_AT_BITMAP,  icx->name, icx->name_len,
 			       &size);
 	if (!bm)
-		return (VCN)-1;
+		return (NTFS_VCN)-1;

 	for (byte = 0; byte < size; byte++) {

@@ -975,29 +975,29 @@
 	ntfs_log_trace("allocated vcn: %lld\n", vcn);

 	if (ntfs_ibm_set(icx, vcn))
-		vcn = (VCN)-1;
+		vcn = (NTFS_VCN)-1;

 	free(bm);
 	return vcn;
 }

-static INDEX_BLOCK *ntfs_ir_to_ib(INDEX_ROOT *ir, VCN ib_vcn)
+static NTFS_INDEX_BLOCK *ntfs_ir_to_ib(NTFS_INDEX_ROOT *ir, NTFS_VCN ib_vcn)
 {
-	INDEX_BLOCK *ib;
-	INDEX_ENTRY *ie_last;
+	NTFS_INDEX_BLOCK *ib;
+	NTFS_INDEX_ENTRY *ie_last;
 	char *ies_start, *ies_end;
 	int i;

 	ntfs_log_trace("Entering.\n");

 	if (!(ib = ntfs_ib_alloc(ib_vcn, le32_to_cpu(ir->index_block_size),
-			LEAF_NODE)))
+			NTFS_LEAF_NODE)))
 		return NULL;

 	ies_start = (char *)ntfs_ie_get_first(&ir->index);
 	ies_end   = (char *)ntfs_ie_get_end(&ir->index);

-	ie_last = ntfs_ie_get_last((INDEX_ENTRY *)ies_start, ies_end);
+	ie_last = ntfs_ie_get_last((NTFS_INDEX_ENTRY *)ies_start, ies_end);
 	/*
 	 * Copy all entries, including the termination entry
 	 * as well, which can never have any data.
@@ -1011,38 +1011,38 @@
 	return ib;
 }

-static void ntfs_ir_nill(INDEX_ROOT *ir)
+static void ntfs_ir_nill(NTFS_INDEX_ROOT *ir)
 {
-	INDEX_ENTRY *ie_last;
+	NTFS_INDEX_ENTRY *ie_last;
 	char *ies_start, *ies_end;

 	ntfs_log_trace("Entering\n");
 	/* TODO: This function could be much simpler. */
 	ies_start = (char *)ntfs_ie_get_first(&ir->index);
 	ies_end   = (char *)ntfs_ie_get_end(&ir->index);
-	ie_last   = ntfs_ie_get_last((INDEX_ENTRY *)ies_start, ies_end);
+	ie_last   = ntfs_ie_get_last((NTFS_INDEX_ENTRY *)ies_start, ies_end);
 	/* Move the index root termination entry forward. */
 	if ((char *)ie_last > ies_start) {
 		memmove(ies_start, (char *)ie_last, le16_to_cpu(
 					ie_last->length));
-		ie_last = (INDEX_ENTRY *)ies_start;
+		ie_last = (NTFS_INDEX_ENTRY *)ies_start;
 	}
 }

-static int ntfs_ib_copy_tail(ntfs_index_context *icx, INDEX_BLOCK *src,
-			     INDEX_ENTRY *median, VCN new_vcn)
+static int ntfs_ib_copy_tail(ntfs_index_context *icx, NTFS_INDEX_BLOCK *src,
+			     NTFS_INDEX_ENTRY *median, NTFS_VCN new_vcn)
 {
 	u8 *ies_end;
-	INDEX_ENTRY *ie_head;		/* first entry after the median */
+	NTFS_INDEX_ENTRY *ie_head;		/* first entry after the median */
 	int tail_size, ret;
-	INDEX_BLOCK *dst;
+	NTFS_INDEX_BLOCK *dst;

 	ntfs_log_trace("Entering.\n");

 	dst = ntfs_ib_alloc(new_vcn, icx->block_size,
-			    src->index.flags & NODE_MASK);
+			    src->index.flags & NTFS_NODE_MASK);
 	if (!dst)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	ie_head = ntfs_ie_get_next(median);

@@ -1059,19 +1059,19 @@
 	return ret;
 }

-static int ntfs_ib_cut_tail(ntfs_index_context *icx, INDEX_BLOCK *src,
-			    INDEX_ENTRY *ie)
+static int ntfs_ib_cut_tail(ntfs_index_context *icx, NTFS_INDEX_BLOCK *src,
+			    NTFS_INDEX_ENTRY *ie)
 {
 	char *ies_start, *ies_end;
-	INDEX_ENTRY *ie_last;
+	NTFS_INDEX_ENTRY *ie_last;

 	ntfs_log_trace("Entering.\n");

 	ies_start = (char *)ntfs_ie_get_first(&src->index);
 	ies_end   = (char *)ntfs_ie_get_end(&src->index);

-	ie_last   = ntfs_ie_get_last((INDEX_ENTRY *)ies_start, ies_end);
-	if (ie_last->flags & INDEX_ENTRY_NODE)
+	ie_last   = ntfs_ie_get_last((NTFS_INDEX_ENTRY *)ies_start, ies_end);
+	if (ie_last->flags & NTFS_INDEX_ENTRY_NODE)
 		ntfs_ie_set_vcn(ie_last, ntfs_ie_get_vcn(ie));

 	memcpy(ie, ie_last, le16_to_cpu(ie_last->length));
@@ -1081,9 +1081,9 @@
 			le32_to_cpu(src->index.entries_offset));

 	if (ntfs_ib_write(icx, icx->parent_vcn[icx->pindex + 1], src))
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

 static int ntfs_ia_add(ntfs_index_context *icx)
@@ -1093,11 +1093,11 @@
 	if (ntfs_ibm_add(icx))
 		return -1;

-	if (!ntfs_attr_exist(icx->ni, AT_INDEX_ALLOCATION, icx->name,
+	if (!ntfs_attr_exist(icx->ni, NTFS_AT_INDEX_ALLOCATION, icx->name,
 				icx->name_len)) {
-		if (ntfs_attr_add(icx->ni, AT_INDEX_ALLOCATION, icx->name,
+		if (ntfs_attr_add(icx->ni, NTFS_AT_INDEX_ALLOCATION, icx->name,
 				  icx->name_len, NULL, 0)) {
-			ntfs_log_perror("Failed to add AT_INDEX_ALLOCATION");
+			ntfs_log_perror("Failed to add NTFS_AT_INDEX_ALLOCATION");
 			return -1;
 		}
 	}
@@ -1108,10 +1108,10 @@
 	return 0;
 }

-static INDEX_ROOT *ntfs_ir_lookup2(ntfs_inode *ni, ntfschar *name, u32 len)
+static NTFS_INDEX_ROOT *ntfs_ir_lookup2(ntfs_inode *ni, ntfschar *name, u32 len)
 {
 	ntfs_attr_search_ctx *ctx;
-	INDEX_ROOT *ir;
+	NTFS_INDEX_ROOT *ir;

 	ir = ntfs_ir_lookup(ni, name, len, &ctx);
 	if (ir)
@@ -1122,11 +1122,11 @@
 static int ntfs_ir_reparent(ntfs_index_context *icx)
 {
 	ntfs_attr_search_ctx *ctx;
-	INDEX_ROOT *ir;
-	INDEX_ENTRY *ie;
-	INDEX_BLOCK *ib = NULL;
-	VCN new_ib_vcn;
-	int ret = STATUS_ERROR;
+	NTFS_INDEX_ROOT *ir;
+	NTFS_INDEX_ENTRY *ie;
+	NTFS_INDEX_BLOCK *ib = NULL;
+	NTFS_VCN new_ib_vcn;
+	int ret = NTFS_STATUS_ERROR;

 	ntfs_log_trace("Entering.\n");

@@ -1154,23 +1154,23 @@
 	ntfs_ir_nill(ir);

 	ie = ntfs_ie_get_first(&ir->index);
-	ie->flags |= INDEX_ENTRY_NODE;
-	ie->length = cpu_to_le16(sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN));
+	ie->flags |= NTFS_INDEX_ENTRY_NODE;
+	ie->length = cpu_to_le16(sizeof(NTFS_INDEX_ENTRY_HEADER) + sizeof(NTFS_VCN));
 	ntfs_ie_set_vcn(ie, new_ib_vcn);

-	ir->index.flags = LARGE_INDEX;
+	ir->index.flags = NTFS_LARGE_INDEX;
 	ir->index.index_length = cpu_to_le32(le32_to_cpu(
 			ir->index.entries_offset) + le16_to_cpu(ie->length));
 	ir->index.allocated_size = ir->index.index_length;

 	if (ntfs_resident_attr_value_resize(ctx->mrec, ctx->attr,
-			sizeof(INDEX_ROOT) - sizeof(INDEX_HEADER) +
+			sizeof(NTFS_INDEX_ROOT) - sizeof(NTFS_INDEX_HEADER) +
 			le32_to_cpu(ir->index.allocated_size)))
 		/* FIXME: revert bitmap, index root */
 		goto err_out;
 	ntfs_inode_mark_dirty(ctx->ntfs_ino);

-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 err_out:
 	ntfs_attr_put_search_ctx(ctx);
 	free(ib);
@@ -1183,7 +1183,7 @@
 /**
  * ntfs_ir_truncate - Truncate index root attribute
  *
- * Returns STATUS_OK, STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT or STATUS_ERROR.
+ * Returns NTFS_STATUS_OK, NTFS_STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT or NTFS_STATUS_ERROR.
  */
 static int ntfs_ir_truncate(ntfs_index_context *icx, int data_size)
 {
@@ -1192,27 +1192,27 @@

 	ntfs_log_trace("Entering.\n");

-	na = ntfs_attr_open(icx->ni, AT_INDEX_ROOT, icx->name, icx->name_len);
+	na = ntfs_attr_open(icx->ni, NTFS_AT_INDEX_ROOT, icx->name, icx->name_len);
 	if (!na) {
-		ntfs_log_perror("Failed to open INDEX_ROOT");
-		return STATUS_ERROR;
+		ntfs_log_perror("Failed to open NTFS_INDEX_ROOT");
+		return NTFS_STATUS_ERROR;
 	}
 	/*
-	 *  INDEX_ROOT must be resident and its entries can be moved to
-	 *  INDEX_BLOCK, so ENOSPC isn't a real error.
+	 *  NTFS_INDEX_ROOT must be resident and its entries can be moved to
+	 *  NTFS_INDEX_BLOCK, so ENOSPC isn't a real error.
 	 */
-	ret = ntfs_attr_truncate(na, data_size + offsetof(INDEX_ROOT, index));
-	if (ret == STATUS_OK) {
+	ret = ntfs_attr_truncate(na, data_size + offsetof(NTFS_INDEX_ROOT, index));
+	if (ret == NTFS_STATUS_OK) {
 		icx->ir = ntfs_ir_lookup2(icx->ni, icx->name, icx->name_len);
 		if (!icx->ir)
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;

 		icx->ir->index.allocated_size = cpu_to_le32(data_size);
 	} else {
 		if (errno != ENOSPC && errno != EOVERFLOW)
-			ntfs_log_trace("Failed to truncate INDEX_ROOT");
+			ntfs_log_trace("Failed to truncate NTFS_INDEX_ROOT");
 		if (errno == EOVERFLOW)
-			ret = STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT;
+			ret = NTFS_STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT;
 	}

 	ntfs_attr_close(na);
@@ -1222,8 +1222,8 @@
 /**
  * ntfs_ir_make_space - Make more space for the index root attribute
  *
- * On success return STATUS_OK or STATUS_KEEP_SEARCHING.
- * On error return STATUS_ERROR.
+ * On success return NTFS_STATUS_OK or NTFS_STATUS_KEEP_SEARCHING.
+ * On error return NTFS_STATUS_ERROR.
  */
 static int ntfs_ir_make_space(ntfs_index_context *icx, int data_size)
 {
@@ -1232,12 +1232,12 @@
 	ntfs_log_trace("Entering.\n");

 	ret = ntfs_ir_truncate(icx, data_size);
-	if (ret == STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT) {
+	if (ret == NTFS_STATUS_RESIDENT_ATTRIBUTE_FILLED_MFT) {
 		ret = ntfs_ir_reparent(icx);
-		if (ret == STATUS_OK)
-			ret = STATUS_KEEP_SEARCHING;
+		if (ret == NTFS_STATUS_OK)
+			ret = NTFS_STATUS_KEEP_SEARCHING;
 		else
-			ntfs_log_perror("Failed to nodify INDEX_ROOT");
+			ntfs_log_perror("Failed to nodify NTFS_INDEX_ROOT");
 	}
 	return ret;
 }
@@ -1245,34 +1245,34 @@
 /*
  * NOTE: 'ie' must be a copy of a real index entry.
  */
-static int ntfs_ie_add_vcn(INDEX_ENTRY **ie)
+static int ntfs_ie_add_vcn(NTFS_INDEX_ENTRY **ie)
 {
-	INDEX_ENTRY *p, *old = *ie;
+	NTFS_INDEX_ENTRY *p, *old = *ie;

-	old->length = cpu_to_le16(le16_to_cpu(old->length) + sizeof(VCN));
+	old->length = cpu_to_le16(le16_to_cpu(old->length) + sizeof(NTFS_VCN));
 	p = realloc(old, le16_to_cpu(old->length));
 	if (!p)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

-	p->flags |= INDEX_ENTRY_NODE;
+	p->flags |= NTFS_INDEX_ENTRY_NODE;
 	*ie = p;
-	return STATUS_OK;
+	return NTFS_STATUS_OK;
 }

-static int ntfs_ih_insert(INDEX_HEADER *ih, INDEX_ENTRY *orig_ie, VCN new_vcn,
+static int ntfs_ih_insert(NTFS_INDEX_HEADER *ih, NTFS_INDEX_ENTRY *orig_ie, NTFS_VCN new_vcn,
 			  int pos)
 {
-	INDEX_ENTRY *ie_node, *ie;
-	int ret = STATUS_ERROR;
-	VCN old_vcn;
+	NTFS_INDEX_ENTRY *ie_node, *ie;
+	int ret = NTFS_STATUS_ERROR;
+	NTFS_VCN old_vcn;

 	ntfs_log_trace("Entering.\n");

 	ie = ntfs_ie_dup(orig_ie);
 	if (!ie)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

-	if (!(ie->flags & INDEX_ENTRY_NODE))
+	if (!(ie->flags & NTFS_INDEX_ENTRY_NODE))
 		if (ntfs_ie_add_vcn(&ie))
 			goto out;

@@ -1282,24 +1282,24 @@

 	ntfs_ie_insert(ih, ie, ie_node);
 	ntfs_ie_set_vcn(ie_node, old_vcn);
-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 out:
 	free(ie);
 	return ret;
 }

-static VCN ntfs_icx_parent_vcn(ntfs_index_context *icx)
+static NTFS_VCN ntfs_icx_parent_vcn(ntfs_index_context *icx)
 {
 	return icx->parent_vcn[icx->pindex];
 }

-static VCN ntfs_icx_parent_pos(ntfs_index_context *icx)
+static NTFS_VCN ntfs_icx_parent_pos(ntfs_index_context *icx)
 {
 	return icx->parent_pos[icx->pindex];
 }

-static int ntfs_ir_insert_median(ntfs_index_context *icx, INDEX_ENTRY *median,
-				 VCN new_vcn)
+static int ntfs_ir_insert_median(ntfs_index_context *icx, NTFS_INDEX_ENTRY *median,
+				 NTFS_VCN new_vcn)
 {
 	u32 new_size;
 	int ret;
@@ -1308,39 +1308,39 @@

 	icx->ir = ntfs_ir_lookup2(icx->ni, icx->name, icx->name_len);
 	if (!icx->ir)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	new_size = le32_to_cpu(icx->ir->index.index_length) +
 			le16_to_cpu(median->length);
-	if (!(median->flags & INDEX_ENTRY_NODE))
-		new_size += sizeof(VCN);
+	if (!(median->flags & NTFS_INDEX_ENTRY_NODE))
+		new_size += sizeof(NTFS_VCN);

 	ret = ntfs_ir_make_space(icx, new_size);
-	if (ret != STATUS_OK)
+	if (ret != NTFS_STATUS_OK)
 		return ret;

 	icx->ir = ntfs_ir_lookup2(icx->ni, icx->name, icx->name_len);
 	if (!icx->ir)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	return ntfs_ih_insert(&icx->ir->index, median, new_vcn,
 			      ntfs_icx_parent_pos(icx));
 }

-static int ntfs_ib_split(ntfs_index_context *icx, INDEX_BLOCK *ib);
+static int ntfs_ib_split(ntfs_index_context *icx, NTFS_INDEX_BLOCK *ib);

 /**
  * ntfs_ib_insert - insert an index block to an index context.
  *
- * On success return STATUS_OK or STATUS_KEEP_SEARCHING.
- * On error return STATUS_ERROR.
+ * On success return NTFS_STATUS_OK or NTFS_STATUS_KEEP_SEARCHING.
+ * On error return NTFS_STATUS_ERROR.
  */
-static int ntfs_ib_insert(ntfs_index_context *icx, INDEX_ENTRY *ie, VCN new_vcn)
+static int ntfs_ib_insert(ntfs_index_context *icx, NTFS_INDEX_ENTRY *ie, NTFS_VCN new_vcn)
 {
-	INDEX_BLOCK *ib;
+	NTFS_INDEX_BLOCK *ib;
 	u32 idx_size, allocated_size;
-	int err = STATUS_ERROR;
-	VCN old_vcn;
+	int err = NTFS_STATUS_ERROR;
+	NTFS_VCN old_vcn;

 	ntfs_log_trace("Entering.\n");

@@ -1355,11 +1355,11 @@

 	idx_size       = le32_to_cpu(ib->index.index_length);
 	allocated_size = le32_to_cpu(ib->index.allocated_size);
-	/* FIXME: sizeof(VCN) should be included only if ie has no VCN */
-	if (idx_size + le16_to_cpu(ie->length) + sizeof(VCN) > allocated_size) {
+	/* FIXME: sizeof(NTFS_VCN) should be included only if ie has no NTFS_VCN */
+	if (idx_size + le16_to_cpu(ie->length) + sizeof(NTFS_VCN) > allocated_size) {
 		err = ntfs_ib_split(icx, ib);
-		if (err == STATUS_OK)
-			err = STATUS_KEEP_SEARCHING;
+		if (err == NTFS_STATUS_OK)
+			err = NTFS_STATUS_KEEP_SEARCHING;
 		goto err_out;
 	}

@@ -1369,7 +1369,7 @@
 	if (ntfs_ib_write(icx, old_vcn, ib))
 		goto err_out;

-	err = STATUS_OK;
+	err = NTFS_STATUS_OK;
 err_out:
 	free(ib);
 	return err;
@@ -1378,38 +1378,38 @@
 /**
  * ntfs_ib_split - Split index allocation attribute
  *
- * On success return STATUS_OK or STATUS_KEEP_SEARCHING.
- * On error return is STATUS_ERROR.
+ * On success return NTFS_STATUS_OK or NTFS_STATUS_KEEP_SEARCHING.
+ * On error return is NTFS_STATUS_ERROR.
  */
-static int ntfs_ib_split(ntfs_index_context *icx, INDEX_BLOCK *ib)
+static int ntfs_ib_split(ntfs_index_context *icx, NTFS_INDEX_BLOCK *ib)
 {
-	INDEX_ENTRY *median;
-	VCN new_vcn;
+	NTFS_INDEX_ENTRY *median;
+	NTFS_VCN new_vcn;
 	int ret;

 	ntfs_log_trace("Entering.\n");

 	if (ntfs_icx_parent_dec(icx))
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	median  = ntfs_ie_get_median(&ib->index);
 	new_vcn = ntfs_ibm_get_free(icx);
 	if (new_vcn == -1)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	if (ntfs_ib_copy_tail(icx, ib, median, new_vcn)) {
 		ntfs_ibm_clear(icx, new_vcn);
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;
 	}

-	if (ntfs_icx_parent_vcn(icx) == VCN_INDEX_ROOT_PARENT)
+	if (ntfs_icx_parent_vcn(icx) == NTFS_VCN_INDEX_ROOT_PARENT)
 		ret = ntfs_ir_insert_median(icx, median, new_vcn);
 	else
 		ret = ntfs_ib_insert(icx, median, new_vcn);

 	ntfs_inode_mark_dirty(icx->actx->ntfs_ino);

-	if (ret != STATUS_OK) {
+	if (ret != NTFS_STATUS_OK) {
 		ntfs_ibm_clear(icx, new_vcn);
 		return ret;
 	}
@@ -1418,11 +1418,11 @@
 	return ret;
 }

-static int ntfs_ie_add(ntfs_index_context *icx, INDEX_ENTRY *ie)
+static int ntfs_ie_add(ntfs_index_context *icx, NTFS_INDEX_ENTRY *ie)
 {
-	INDEX_HEADER *ih;
+	NTFS_INDEX_HEADER *ih;
 	int allocated_size, new_size;
-	int ret = STATUS_ERROR;
+	int ret = NTFS_STATUS_ERROR;

 #ifdef DEBUG
 	char *fn;
@@ -1459,10 +1459,10 @@
 			       allocated_size, new_size);

 		if (icx->is_in_root) {
-			if (ntfs_ir_make_space(icx, new_size) == STATUS_ERROR)
+			if (ntfs_ir_make_space(icx, new_size) == NTFS_STATUS_ERROR)
 				goto err_out;
 		} else {
-			if (ntfs_ib_split(icx, icx->ib) == STATUS_ERROR)
+			if (ntfs_ib_split(icx, icx->ib) == NTFS_STATUS_ERROR)
 				goto err_out;
 		}
 		ntfs_inode_mark_dirty(icx->actx->ntfs_ino);
@@ -1472,7 +1472,7 @@
 	ntfs_ie_insert(ih, ie, icx->entry);
 	ntfs_index_entry_mark_dirty(icx);

-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 err_out:
 	ntfs_log_trace("%s\n", ret ? "Failed" : "Done");
 	return ret;
@@ -1486,9 +1486,9 @@
  *
  * Return 0 on success or -1 on error with errno set to the error code.
  */
-int ntfs_index_add_filename(ntfs_inode *ni, FILE_NAME_ATTR *fn, MFT_REF mref)
+int ntfs_index_add_filename(ntfs_inode *ni, NTFS_FILE_NAME_ATTR *fn, NTFS_MFT_REF mref)
 {
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;
 	ntfs_index_context *icx;
 	int fn_size, ie_size, ret = -1, err;

@@ -1501,8 +1501,8 @@
 	}

 	fn_size = (fn->file_name_length * sizeof(ntfschar)) +
-			sizeof(FILE_NAME_ATTR);
-	ie_size = (sizeof(INDEX_ENTRY_HEADER) + fn_size + 7) & ~7;
+			sizeof(NTFS_FILE_NAME_ATTR);
+	ie_size = (sizeof(NTFS_INDEX_ENTRY_HEADER) + fn_size + 7) & ~7;

 	ie = ntfs_calloc(ie_size);
 	if (!ie)
@@ -1527,21 +1527,21 @@
 	return ret;
 }

-static int ntfs_ih_takeout(ntfs_index_context *icx, INDEX_HEADER *ih,
-			   INDEX_ENTRY *ie, INDEX_BLOCK *ib)
+static int ntfs_ih_takeout(ntfs_index_context *icx, NTFS_INDEX_HEADER *ih,
+			   NTFS_INDEX_ENTRY *ie, NTFS_INDEX_BLOCK *ib)
 {
-	INDEX_ENTRY *ie_roam;
-	int ret = STATUS_ERROR;
+	NTFS_INDEX_ENTRY *ie_roam;
+	int ret = NTFS_STATUS_ERROR;

 	ntfs_log_trace("Entering.\n");

 	ie_roam = ntfs_ie_dup_novcn(ie);
 	if (!ie_roam)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	ntfs_ie_delete(ih, ie);

-	if (ntfs_icx_parent_vcn(icx) == VCN_INDEX_ROOT_PARENT)
+	if (ntfs_icx_parent_vcn(icx) == NTFS_VCN_INDEX_ROOT_PARENT)
 		ntfs_inode_mark_dirty(icx->actx->ntfs_ino);
 	else
 		if (ntfs_ib_write(icx, ntfs_icx_parent_vcn(icx), ib))
@@ -1559,21 +1559,21 @@
  * ntfs_ir_leafify -
  *
  * Used if an empty index block to be deleted has END entry as the parent
- * in the INDEX_ROOT which is the only one there.
+ * in the NTFS_INDEX_ROOT which is the only one there.
  */
-static void ntfs_ir_leafify(ntfs_index_context *icx, INDEX_HEADER *ih)
+static void ntfs_ir_leafify(ntfs_index_context *icx, NTFS_INDEX_HEADER *ih)
 {
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;

 	ntfs_log_trace("Entering.\n");

 	ie = ntfs_ie_get_first(ih);
-	ie->flags &= ~INDEX_ENTRY_NODE;
-	ie->length = cpu_to_le16(le16_to_cpu(ie->length) - sizeof(VCN));
+	ie->flags &= ~NTFS_INDEX_ENTRY_NODE;
+	ie->length = cpu_to_le16(le16_to_cpu(ie->length) - sizeof(NTFS_VCN));

 	ih->index_length = cpu_to_le32(le32_to_cpu(ih->index_length) -
-			sizeof(VCN));
-	ih->flags &= ~LARGE_INDEX;
+			sizeof(NTFS_VCN));
+	ih->flags &= ~NTFS_LARGE_INDEX;

 	/* Not fatal error */
 	ntfs_ir_truncate(icx, le32_to_cpu(ih->index_length));
@@ -1586,12 +1586,12 @@
  * ntfs_ih_reparent_end -
  *
  * Used if an empty index block to be deleted has END entry as the parent
- * in the INDEX_ROOT which is not the only one there.
+ * in the NTFS_INDEX_ROOT which is not the only one there.
  */
-static int ntfs_ih_reparent_end(ntfs_index_context *icx, INDEX_HEADER *ih,
-				INDEX_BLOCK *ib)
+static int ntfs_ih_reparent_end(ntfs_index_context *icx, NTFS_INDEX_HEADER *ih,
+				NTFS_INDEX_BLOCK *ib)
 {
-	INDEX_ENTRY *ie, *ie_prev;
+	NTFS_INDEX_ENTRY *ie, *ie_prev;

 	ntfs_log_trace("Entering.\n");

@@ -1604,25 +1604,25 @@

 static int ntfs_index_rm_leaf(ntfs_index_context *icx)
 {
-	INDEX_BLOCK *ib = NULL;
-	INDEX_HEADER *parent_ih;
-	INDEX_ENTRY *ie;
-	int ret = STATUS_ERROR;
+	NTFS_INDEX_BLOCK *ib = NULL;
+	NTFS_INDEX_HEADER *parent_ih;
+	NTFS_INDEX_ENTRY *ie;
+	int ret = NTFS_STATUS_ERROR;

 	ntfs_log_trace("pindex: %d\n", icx->pindex);

 	if (ntfs_icx_parent_dec(icx))
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	if (ntfs_ibm_clear(icx, icx->parent_vcn[icx->pindex + 1]))
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

-	if (ntfs_icx_parent_vcn(icx) == VCN_INDEX_ROOT_PARENT)
+	if (ntfs_icx_parent_vcn(icx) == NTFS_VCN_INDEX_ROOT_PARENT)
 		parent_ih = &icx->ir->index;
 	else {
 		ib = ntfs_malloc(icx->block_size);
 		if (!ib)
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;

 		if (ntfs_ib_read(icx, ntfs_icx_parent_vcn(icx), ib))
 			goto out;
@@ -1638,7 +1638,7 @@

 	if (ntfs_ih_zero_entry(parent_ih)) {

-		if (ntfs_icx_parent_vcn(icx) == VCN_INDEX_ROOT_PARENT) {
+		if (ntfs_icx_parent_vcn(icx) == NTFS_VCN_INDEX_ROOT_PARENT) {
 			ntfs_ir_leafify(icx, parent_ih);
 			goto ok;
 		}
@@ -1650,7 +1650,7 @@
 	if (ntfs_ih_reparent_end(icx, parent_ih, ib))
 		goto out;
 ok:
-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 out:
 	free(ib);
 	return ret;
@@ -1659,24 +1659,24 @@
 static int ntfs_index_rm_node(ntfs_index_context *icx)
 {
 	int entry_pos;
-	VCN vcn;
-	INDEX_BLOCK *ib = NULL;
-	INDEX_ENTRY *ie_succ, *ie, *entry = icx->entry;
-	INDEX_HEADER *ih;
+	NTFS_VCN vcn;
+	NTFS_INDEX_BLOCK *ib = NULL;
+	NTFS_INDEX_ENTRY *ie_succ, *ie, *entry = icx->entry;
+	NTFS_INDEX_HEADER *ih;
 	u32 new_size;
-	int delta, ret = STATUS_ERROR;
+	int delta, ret = NTFS_STATUS_ERROR;

 	ntfs_log_trace("Entering.\n");

 	if (!icx->ia_na) {
 		icx->ia_na = ntfs_ia_open(icx, icx->ni);
 		if (!icx->ia_na)
-			return STATUS_ERROR;
+			return NTFS_STATUS_ERROR;
 	}

 	ib = ntfs_malloc(icx->block_size);
 	if (!ib)
-		return STATUS_ERROR;
+		return NTFS_STATUS_ERROR;

 	ie_succ = ntfs_ie_get_next(icx->entry);
 	entry_pos = icx->parent_pos[icx->pindex]++;
@@ -1693,7 +1693,7 @@
 	icx->parent_vcn[icx->pindex] = vcn;
 	icx->parent_pos[icx->pindex] = 0;

-	if ((ib->index.flags & NODE_MASK) == INDEX_NODE)
+	if ((ib->index.flags & NTFS_NODE_MASK) == NTFS_INDEX_NODE)
 		goto descend;

 	if (ntfs_ih_zero_entry(&ib->index)) {
@@ -1723,7 +1723,7 @@
 		if (icx->is_in_root) {
 			if (ntfs_ir_truncate(icx, new_size)) {
 				errno = EOPNOTSUPP;
-				ntfs_log_perror("Denied to truncate INDEX_ROOT"
+				ntfs_log_perror("Denied to truncate NTFS_INDEX_ROOT"
 						" during entry removal");
 				goto out2;
 			}
@@ -1731,7 +1731,7 @@
 			entry = ntfs_ie_get_by_pos(ih, entry_pos);
 		} else if (new_size > le32_to_cpu(ih->allocated_size)) {
 			errno = EOPNOTSUPP;
-			ntfs_log_perror("Denied to split INDEX_BLOCK during "
+			ntfs_log_perror("Denied to split NTFS_INDEX_BLOCK during "
 					"entry removal");
 			goto out2;
 		}
@@ -1757,7 +1757,7 @@
 		if (ntfs_ib_write(icx, vcn, ib))
 			goto out2;

-	ret = STATUS_OK;
+	ret = NTFS_STATUS_OK;
 out2:
 	free(ie);
 out:
@@ -1777,7 +1777,7 @@
  */
 int ntfs_index_rm(ntfs_index_context *icx)
 {
-	INDEX_HEADER *ih;
+	NTFS_INDEX_HEADER *ih;
 	int err;

 	ntfs_log_trace("Entering.\n");
@@ -1792,7 +1792,7 @@
 	else
 		ih = &icx->ib->index;

-	if (icx->entry->flags & INDEX_ENTRY_NODE) {
+	if (icx->entry->flags & NTFS_INDEX_ENTRY_NODE) {

 		if (ntfs_index_rm_node(icx))
 			goto err_out;
@@ -1804,7 +1804,7 @@
 		if (icx->is_in_root) {
 			err = ntfs_ir_truncate(icx,
 					le32_to_cpu(ih->index_length));
-			if (err != STATUS_OK)
+			if (err != NTFS_STATUS_OK)
 				goto err_out;
 		} else
 			if (ntfs_icx_ib_write(icx))
@@ -1837,22 +1837,22 @@
  *
  * On error NULL is returned with errno set to the error code.
  */
-INDEX_ROOT *ntfs_index_root_get(ntfs_inode *ni, ATTR_RECORD *attr)
+NTFS_INDEX_ROOT *ntfs_index_root_get(ntfs_inode *ni, NTFS_ATTR_RECORD *attr)
 {
 	ntfs_attr_search_ctx *ctx;
 	ntfschar *name;
-	INDEX_ROOT *root = NULL;
+	NTFS_INDEX_ROOT *root = NULL;

 	name = (ntfschar *)((u8 *)attr + le16_to_cpu(attr->name_offset));

 	if (!ntfs_ir_lookup(ni, name, attr->name_length, &ctx))
 		return NULL;

-	root = ntfs_malloc(sizeof(INDEX_ROOT));
+	root = ntfs_malloc(sizeof(NTFS_INDEX_ROOT));
 	if (!root)
 		goto out;

-	*root = *((INDEX_ROOT *)((u8 *)ctx->attr +
+	*root = *((NTFS_INDEX_ROOT *)((u8 *)ctx->attr +
 				le16_to_cpu(ctx->attr->value_offset)));
 out:
 	ntfs_attr_put_search_ctx(ctx);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/inode.c ./libntfs/inode.c
--- ../ntfsprogs-2.0.0/libntfs/inode.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/inode.c	2007-10-06 16:48:08.000000000 +0200
@@ -35,19 +35,19 @@
 #include <errno.h>
 #endif

-#include "compat.h"
-#include "types.h"
-#include "attrib.h"
-#include "inode.h"
-#include "debug.h"
-#include "mft.h"
-#include "attrlist.h"
-#include "runlist.h"
-#include "lcnalloc.h"
-#include "index.h"
-#include "dir.h"
-#include "ntfstime.h"
-#include "logging.h"
+#include "ntfs_compat.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_debug.h"
+#include "ntfs_mft.h"
+#include "ntfs_attrlist.h"
+#include "ntfs_runlist.h"
+#include "ntfs_lcnalloc.h"
+#include "ntfs_index.h"
+#include "ntfs_dir.h"
+#include "ntfs_time.h"
+#include "ntfs_logging.h"

 /**
  * __ntfs_inode_allocate - Create and initialise an NTFS inode object
@@ -64,7 +64,7 @@
 	ni = (ntfs_inode*)calloc(1, sizeof(ntfs_inode));
 	if (ni) {
 		ni->vol = vol;
-		INIT_LIST_HEAD(&ni->attr_cache);
+		NTFS_INIT_LIST_HEAD(&ni->attr_cache);
 	}
 	return ni;
 }
@@ -106,7 +106,7 @@
  */
 void __ntfs_inode_add_to_cache(ntfs_inode *ni)
 {
-	list_add_tail(&ni->list_entry, &ni->vol->inode_cache[
+	ntfs_list_add_tail(&ni->ntfs_list_entry, &ni->vol->inode_cache[
 			ni->mft_no & NTFS_INODE_CACHE_SIZE_BITS]);
 	ni->nr_references = 1;
 }
@@ -134,27 +134,27 @@
  * Return a pointer to the ntfs_inode structure on success or NULL on error,
  * with errno set to the error code.
  */
-ntfs_inode *ntfs_inode_open(ntfs_volume *vol, const MFT_REF mref)
+ntfs_inode *ntfs_inode_open(ntfs_volume *vol, const NTFS_MFT_REF mref)
 {
 	s64 l;
 	ntfs_inode *ni;
 	ntfs_attr_search_ctx *ctx;
 	int err = 0;
-	STANDARD_INFORMATION *std_info;
-	struct list_head *pos;
+	NTFS_STANDARD_INFORMATION *std_info;
+	struct ntfs_list_head *pos;

-	ntfs_log_trace("Entering for inode 0x%llx.\n", MREF(mref));
+	ntfs_log_trace("Entering for inode 0x%llx.\n", NTFS_MREF(mref));
 	if (!vol) {
 		errno = EINVAL;
 		return NULL;
 	}
 	/* Check cache, maybe this inode already opened? */
-	list_for_each(pos, &vol->inode_cache[MREF(mref) &
+	ntfs_list_for_each(pos, &vol->inode_cache[NTFS_MREF(mref) &
 			NTFS_INODE_CACHE_SIZE_BITS]) {
 		ntfs_inode *tmp_ni;

-		tmp_ni = list_entry(pos, ntfs_inode, list_entry);
-		if (tmp_ni->mft_no == MREF(mref)) {
+		tmp_ni = ntfs_list_entry(pos, ntfs_inode, ntfs_list_entry);
+		if (tmp_ni->mft_no == NTFS_MREF(mref)) {
 			ntfs_log_trace("Found this inode in cache, increment "
 					"reference count and return it.\n");
 			tmp_ni->nr_references++;
@@ -167,23 +167,23 @@
 		return NULL;
 	if (ntfs_file_record_read(vol, mref, &ni->mrec, NULL))
 		goto err_out;
-	if (!(ni->mrec->flags & MFT_RECORD_IN_USE)) {
+	if (!(ni->mrec->flags & NTFS_MFT_RECORD_IN_USE)) {
 		err = ENOENT;
 		goto err_out;
 	}
-	ni->mft_no = MREF(mref);
+	ni->mft_no = NTFS_MREF(mref);
 	ctx = ntfs_attr_get_search_ctx(ni, NULL);
 	if (!ctx)
 		goto err_out;
 	/* Receive some basic information about inode. */
-	if (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,
-				0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {
+	if (ntfs_attr_lookup(NTFS_AT_STANDARD_INFORMATION, NTFS_AT_UNNAMED,
+				0, NTFS_CASE_SENSITIVE, 0, NULL, 0, ctx)) {
 		err = errno;
-		ntfs_log_trace("Failed to receive STANDARD_INFORMATION "
+		ntfs_log_trace("Failed to receive NTFS_STANDARD_INFORMATION "
 				"attribute.\n");
 		goto put_err_out;
 	}
-	std_info = (STANDARD_INFORMATION *)((u8 *)ctx->attr +
+	std_info = (NTFS_STANDARD_INFORMATION *)((u8 *)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));
 	ni->flags = std_info->file_attributes;
 	ni->creation_time = ntfs2utc(std_info->creation_time);
@@ -191,7 +191,7 @@
 	ni->last_mft_change_time = ntfs2utc(std_info->last_mft_change_time);
 	ni->last_access_time = ntfs2utc(std_info->last_access_time);
 	/* Set attribute list information. */
-	if (ntfs_attr_lookup(AT_ATTRIBUTE_LIST, AT_UNNAMED, 0, 0, 0, NULL, 0,
+	if (ntfs_attr_lookup(NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0,
 			ctx)) {
 		if (errno != ENOENT)
 			goto put_err_out;
@@ -218,7 +218,7 @@
 		goto put_err_out;
 	}
 get_size:
-	if (ntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
+	if (ntfs_attr_lookup(NTFS_AT_DATA, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
 		if (errno != ENOENT)
 			goto put_err_out;
 		/* Directory or special file. */
@@ -227,7 +227,7 @@
 		if (ctx->attr->non_resident) {
 			ni->data_size = sle64_to_cpu(ctx->attr->data_size);
 			if (ctx->attr->flags &
-					(ATTR_IS_COMPRESSED | ATTR_IS_SPARSE))
+					(NTFS_ATTR_IS_COMPRESSED | NTFS_ATTR_IS_SPARSE))
 				ni->allocated_size = sle64_to_cpu(
 						ctx->attr->compressed_size);
 			else
@@ -272,7 +272,7 @@
  * error, @ni has not been freed. The user should attempt to handle the error
  * and call ntfs_inode_close() again. The following error codes are defined:
  *
- *	EBUSY	@ni and/or its attribute list runlist is/are dirty and the
+ *	EBUSY	@ni and/or its attribute list ntfs_runlist is/are dirty and the
  *		attempt to write it/them to disk failed.
  *	EINVAL	@ni is invalid (probably it is an extent inode).
  *	EIO	I/O error while trying to write inode to disk.
@@ -297,7 +297,7 @@
 					"this inode.\n");
 	}
 	/* Check whether all attributes of this inode are closed. */
-	if (!list_empty(&ni->attr_cache))
+	if (!ntfs_list_empty(&ni->attr_cache))
 		ntfs_log_error("%s(): Not all attributes are closed. "
 				"We definitely have memory leak. "
 				"Continue anyway.\n", __FUNCTION__);
@@ -364,7 +364,7 @@
 	}
 	/* Remove inode from the list of opened inodes. */
 	if (ni->nr_extents != -1)
-		list_del(&ni->list_entry);
+		ntfs_list_del(&ni->ntfs_list_entry);
 	return __ntfs_inode_release(ni);
 }

@@ -393,9 +393,9 @@
  * Note, extent inodes are never closed directly. They are automatically
  * disposed off by the closing of the base inode.
  */
-ntfs_inode *ntfs_extent_inode_open(ntfs_inode *base_ni, const leMFT_REF mref)
+ntfs_inode *ntfs_extent_inode_open(ntfs_inode *base_ni, const NTFS_leMFT_REF mref)
 {
-	u64 mft_no = MREF_LE(mref);
+	u64 mft_no = NTFS_MREF_LE(mref);
 	ntfs_inode *ni;
 	ntfs_inode **extent_nis;
 	int i;
@@ -418,7 +418,7 @@
 			if (mft_no != ni->mft_no)
 				continue;
 			/* Verify the sequence number if given. */
-			seq_no = MSEQNO_LE(mref);
+			seq_no = NTFS_MSEQNO_LE(mref);
 			if (seq_no && seq_no != le16_to_cpu(
 					ni->mrec->sequence_number)) {
 				ntfs_log_debug("Found stale extent mft "
@@ -473,7 +473,7 @@
  */
 int ntfs_inode_attach_all_extents(ntfs_inode *ni)
 {
-	ATTR_LIST_ENTRY *ale;
+	NTFS_ATTR_LIST_ENTRY *ale;
 	u64 prev_attached = 0;

 	if (!ni) {
@@ -499,10 +499,10 @@

 	/* Walk through attribute list and attach all extents. */
 	errno = 0;
-	ale = (ATTR_LIST_ENTRY *)ni->attr_list;
+	ale = (NTFS_ATTR_LIST_ENTRY *)ni->attr_list;
 	while ((u8*)ale < ni->attr_list + ni->attr_list_size) {
-		if (ni->mft_no != MREF_LE(ale->mft_reference) &&
-				prev_attached != MREF_LE(ale->mft_reference)) {
+		if (ni->mft_no != NTFS_MREF_LE(ale->mft_reference) &&
+				prev_attached != NTFS_MREF_LE(ale->mft_reference)) {
 			if (!ntfs_extent_inode_open(ni, ale->mft_reference)) {
 				ntfs_log_trace("Couldn't attach extent "
 						"inode (attr type 0x%x "
@@ -510,9 +510,9 @@
 						le32_to_cpu(ale->type));
 				return -1;
 			}
-			prev_attached = MREF_LE(ale->mft_reference);
+			prev_attached = NTFS_MREF_LE(ale->mft_reference);
 		}
-		ale = (ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale->length));
+		ale = (NTFS_ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale->length));
 	}
 	return 0;
 }
@@ -526,7 +526,7 @@
 static int ntfs_inode_sync_standard_information(ntfs_inode *ni)
 {
 	ntfs_attr_search_ctx *ctx;
-	STANDARD_INFORMATION *std_info;
+	NTFS_STANDARD_INFORMATION *std_info;
 	int err;

 	ntfs_log_trace("Entering for inode 0x%llx.\n", (long long) ni->mft_no);
@@ -534,16 +534,16 @@
 	ctx = ntfs_attr_get_search_ctx(ni, NULL);
 	if (!ctx)
 		return -1;
-	if (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,
-				0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {
+	if (ntfs_attr_lookup(NTFS_AT_STANDARD_INFORMATION, NTFS_AT_UNNAMED,
+				0, NTFS_CASE_SENSITIVE, 0, NULL, 0, ctx)) {
 		err = errno;
-		ntfs_log_trace("Failed to receive STANDARD_INFORMATION "
+		ntfs_log_trace("Failed to receive NTFS_STANDARD_INFORMATION "
 				"attribute.\n");
 		ntfs_attr_put_search_ctx(ctx);
 		errno = err;
 		return -1;
 	}
-	std_info = (STANDARD_INFORMATION *)((u8 *)ctx->attr +
+	std_info = (NTFS_STANDARD_INFORMATION *)((u8 *)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));
 	std_info->file_attributes = ni->flags;
 	std_info->creation_time = utc2ntfs(ni->creation_time);
@@ -567,7 +567,7 @@
 	ntfs_attr_search_ctx *ctx = NULL;
 	ntfs_index_context *ictx;
 	ntfs_inode *index_ni;
-	FILE_NAME_ATTR *fn;
+	NTFS_FILE_NAME_ATTR *fn;
 	int err = 0;

 	ntfs_log_trace("Entering for inode 0x%llx.\n", (long long) ni->mft_no);
@@ -579,10 +579,10 @@
 		goto err_out;
 	}
 	/* Walk through all FILE_NAME attributes and update them. */
-	while (!ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0, ctx)) {
-		fn = (FILE_NAME_ATTR *)((u8 *)ctx->attr +
+	while (!ntfs_attr_lookup(NTFS_AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0, ctx)) {
+		fn = (NTFS_FILE_NAME_ATTR *)((u8 *)ctx->attr +
 				le16_to_cpu(ctx->attr->value_offset));
-		if (MREF_LE(fn->parent_directory) == ni->mft_no) {
+		if (NTFS_MREF_LE(fn->parent_directory) == ni->mft_no) {
 			/*
 			 * WARNING: We cheater here and obtain 2 attribute
 			 * search contexts for one inode (first we obtained
@@ -608,7 +608,7 @@
 			ntfs_inode_close(index_ni);
 			continue;
 		}
-		if (ntfs_index_lookup(fn, sizeof(FILE_NAME_ATTR), ictx)) {
+		if (ntfs_index_lookup(fn, sizeof(NTFS_FILE_NAME_ATTR), ictx)) {
 			if (!err) {
 				if (errno == ENOENT)
 					err = EIO;
@@ -621,10 +621,10 @@
 			continue;
 		}
 		/* Update flags and file size. */
-		fn = (FILE_NAME_ATTR *)ictx->data;
+		fn = (NTFS_FILE_NAME_ATTR *)ictx->data;
 		fn->file_attributes =
-				(fn->file_attributes & ~FILE_ATTR_VALID_FLAGS) |
-				(ni->flags & FILE_ATTR_VALID_FLAGS);
+				(fn->file_attributes & ~NTFS_FILE_ATTR_VALID_FLAGS) |
+				(ni->flags & NTFS_FILE_ATTR_VALID_FLAGS);
 		fn->allocated_size = cpu_to_sle64(ni->allocated_size);
 		fn->data_size = cpu_to_sle64(ni->data_size);
 		fn->creation_time = utc2ntfs(ni->creation_time);
@@ -686,7 +686,7 @@
 	ntfs_log_trace("Entering for inode 0x%llx.\n", (long long) ni->mft_no);

 	/* Update FILE_NAME's in the index. */
-	if ((ni->mrec->flags & MFT_RECORD_IN_USE) && ni->nr_extents != -1 &&
+	if ((ni->mrec->flags & NTFS_MFT_RECORD_IN_USE) && ni->nr_extents != -1 &&
 			NInoFileNameTestAndClearDirty(ni) &&
 			ntfs_inode_sync_file_name(ni)) {
 		if (!err || errno == EIO) {
@@ -699,11 +699,11 @@
 	}

 	/* Write out attribute list from cache to disk. */
-	if ((ni->mrec->flags & MFT_RECORD_IN_USE) && ni->nr_extents != -1 &&
+	if ((ni->mrec->flags & NTFS_MFT_RECORD_IN_USE) && ni->nr_extents != -1 &&
 			NInoAttrList(ni) && NInoAttrListTestAndClearDirty(ni)) {
 		ntfs_attr *na;

-		na = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);
+		na = ntfs_attr_open(ni, NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0);
 		if (!na) {
 			if (!err || errno == EIO) {
 				err = errno;
@@ -740,8 +740,8 @@

 	/* Write this inode out to the $MFT (and $MFTMirr if applicable). */
 	if (NInoTestAndClearDirty(ni)) {
-		/* Update STANDARD_INFORMATION. */
-		if ((ni->mrec->flags & MFT_RECORD_IN_USE) &&
+		/* Update NTFS_STANDARD_INFORMATION. */
+		if ((ni->mrec->flags & NTFS_MFT_RECORD_IN_USE) &&
 				ni->nr_extents != -1 &&
 				ntfs_inode_sync_standard_information(ni)) {
 			if (!err || errno == EIO) {
@@ -811,7 +811,7 @@
 	ntfs_attr_search_ctx *ctx;
 	u8 *al, *aln;
 	int al_len, al_allocated;
-	ATTR_LIST_ENTRY *ale;
+	NTFS_ATTR_LIST_ENTRY *ale;
 	ntfs_attr *na;

 	if (!ni) {
@@ -832,7 +832,7 @@
 	al_len = 0;
 	al = malloc(al_allocated);
 	NTFS_ON_DEBUG(memset(al, 0, 0x40)); /* Valgrind. */
-	ale = (ATTR_LIST_ENTRY *) al;
+	ale = (NTFS_ATTR_LIST_ENTRY *) al;
 	if (!al) {
 		ntfs_log_trace("Not enough memory.\n");
 		errno = ENOMEM;
@@ -847,14 +847,14 @@
 		goto err_out;
 	}
 	/* Walk through all attributes. */
-	while (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
-		if (ctx->attr->type == AT_ATTRIBUTE_LIST) {
+	while (!ntfs_attr_lookup(NTFS_AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
+		if (ctx->attr->type == NTFS_AT_ATTRIBUTE_LIST) {
 			err = EIO;
 			ntfs_log_trace("Attribute list already present.\n");
 			goto put_err_out;
 		}
 		/* Calculate new length of attribute list. */
-		al_len += (sizeof(ATTR_LIST_ENTRY) + sizeof(ntfschar) *
+		al_len += (sizeof(NTFS_ATTR_LIST_ENTRY) + sizeof(ntfschar) *
 					ctx->attr->name_length + 7) & ~7;
 		/* Allocate more memory if needed. */
 		while (al_len > al_allocated) {
@@ -867,12 +867,12 @@
 				err = ENOMEM;
 				goto put_err_out;
 			}
-			ale = (ATTR_LIST_ENTRY *)(aln + ((u8 *)ale - al));
+			ale = (NTFS_ATTR_LIST_ENTRY *)(aln + ((u8 *)ale - al));
 			al = aln;
 		}
 		/* Add attribute to attribute list. */
 		ale->type = ctx->attr->type;
-		ale->length = cpu_to_le16((sizeof(ATTR_LIST_ENTRY) +
+		ale->length = cpu_to_le16((sizeof(NTFS_ATTR_LIST_ENTRY) +
 			sizeof(ntfschar) * ctx->attr->name_length + 7) & ~7);
 		ale->name_length = ctx->attr->name_length;
 		ale->name_offset = (u8 *)ale->name - (u8 *)ale;
@@ -880,13 +880,13 @@
 			ale->lowest_vcn = ctx->attr->lowest_vcn;
 		else
 			ale->lowest_vcn = 0;
-		ale->mft_reference = MK_LE_MREF(ni->mft_no,
+		ale->mft_reference = NTFS_MK_LE_MREF(ni->mft_no,
 			le16_to_cpu(ni->mrec->sequence_number));
 		ale->instance = ctx->attr->instance;
 		memcpy(ale->name, (u8 *)ctx->attr +
 				le16_to_cpu(ctx->attr->name_offset),
 				ctx->attr->name_length * sizeof(ntfschar));
-		ale = (ATTR_LIST_ENTRY *)(al + al_len);
+		ale = (NTFS_ATTR_LIST_ENTRY *)(al + al_len);
 	}
 	/* Check for real error occurred. */
 	if (errno != ENOENT) {
@@ -912,9 +912,9 @@
 	/* Free space if there is not enough it for $ATTRIBUTE_LIST. */
 	if (le32_to_cpu(ni->mrec->bytes_allocated) -
 			le32_to_cpu(ni->mrec->bytes_in_use) <
-			offsetof(ATTR_RECORD, resident_end)) {
+			offsetof(NTFS_ATTR_RECORD, resident_end)) {
 		if (ntfs_inode_free_space(ni,
-				offsetof(ATTR_RECORD, resident_end))) {
+				offsetof(NTFS_ATTR_RECORD, resident_end))) {
 			/* Failed to free space. */
 			err = errno;
 			ntfs_log_trace("Failed to free space for "
@@ -925,14 +925,14 @@

 	/* Add $ATTRIBUTE_LIST to mft record. */
 	if (ntfs_resident_attr_record_add(ni,
-				AT_ATTRIBUTE_LIST, NULL, 0, NULL, 0, 0) < 0) {
+				NTFS_AT_ATTRIBUTE_LIST, NULL, 0, NULL, 0, 0) < 0) {
 		err = errno;
 		ntfs_log_trace("Couldn't add $ATTRIBUTE_LIST to MFT record.\n");
 		goto rollback;
 	}

 	/* Resize it. */
-	na = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		err = errno;
 		ntfs_log_trace("Failed to open just added $ATTRIBUTE_LIST.\n");
@@ -954,15 +954,15 @@
 	NInoClearAttrList(ni);
 	/* Remove $ATTRIBUTE_LIST record. */
 	ntfs_attr_reinit_search_ctx(ctx);
-	if (!ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0,
-				CASE_SENSITIVE, 0, NULL, 0, ctx)) {
+	if (!ntfs_attr_lookup(NTFS_AT_ATTRIBUTE_LIST, NULL, 0,
+				NTFS_CASE_SENSITIVE, 0, NULL, 0, ctx)) {
 		if (ntfs_attr_record_rm(ctx))
 			ntfs_log_trace("Rollback failed. Failed to remove attribute "
 					"list record.\n");
 	} else
 		ntfs_log_trace("Rollback failed. Couldn't find attribute list "
 				"record.\n");
-	/* Setup back in-memory runlist. */
+	/* Setup back in-memory ntfs_runlist. */
 	ni->attr_list = al;
 	ni->attr_list_size = al_len;
 	NInoSetAttrList(ni);
@@ -972,12 +972,12 @@
 	 * record and move them to it.
 	 */
 	ntfs_attr_reinit_search_ctx(ctx);
-	ale = (ATTR_LIST_ENTRY*)al;
+	ale = (NTFS_ATTR_LIST_ENTRY*)al;
 	while ((u8*)ale < al + al_len) {
-		if (MREF_LE(ale->mft_reference) != ni->mft_no) {
+		if (NTFS_MREF_LE(ale->mft_reference) != ni->mft_no) {
 			if (!ntfs_attr_lookup(ale->type, ale->name,
 						ale->name_length,
-						CASE_SENSITIVE,
+						NTFS_CASE_SENSITIVE,
 						sle64_to_cpu(ale->lowest_vcn),
 						NULL, 0, ctx)) {
 				if (ntfs_attr_record_move_to(ctx, ni))
@@ -988,7 +988,7 @@
 						"failed.\n");
 			ntfs_attr_reinit_search_ctx(ctx);
 		}
-		ale = (ATTR_LIST_ENTRY*)((u8*)ale + le16_to_cpu(ale->length));
+		ale = (NTFS_ATTR_LIST_ENTRY*)((u8*)ale + le16_to_cpu(ale->length));
 	}
 	/* Remove in-memory attribute list. */
 	ni->attr_list = NULL;
@@ -1037,12 +1037,12 @@
 	}

 	/*
-	 * Chkdsk complain if $STANDARD_INFORMATION is not in the base MFT
+	 * Chkdsk complain if $NTFS_STANDARD_INFORMATION is not in the base MFT
 	 * record. FIXME: I'm not sure in this, need to recheck. For now simply
-	 * do not move $STANDARD_INFORMATION at all.
+	 * do not move $NTFS_STANDARD_INFORMATION at all.
 	 *
-	 * Also we can't move $ATTRIBUTE_LIST from base MFT_RECORD, so position
-	 * search context on first attribute after $STANDARD_INFORMATION and
+	 * Also we can't move $ATTRIBUTE_LIST from base NTFS_MFT_RECORD, so position
+	 * search context on first attribute after $NTFS_STANDARD_INFORMATION and
 	 * $ATTRIBUTE_LIST.
 	 *
 	 * Why we reposition instead of simply skip this attributes during
@@ -1050,14 +1050,14 @@
 	 * list ntfs_attr_lookup will fail when it will try to find
 	 * $ATTRIBUTE_LIST.
 	 */
-	if (ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0, NULL,
+	if (ntfs_attr_lookup(NTFS_AT_FILE_NAME, NULL, 0, NTFS_CASE_SENSITIVE, 0, NULL,
 				0, ctx)) {
 		if (errno != ENOENT) {
 			err = errno;
 			ntfs_log_trace("Attribute lookup failed.\n");
 			goto put_err_out;
 		}
-		if (ctx->attr->type == AT_END) {
+		if (ctx->attr->type == NTFS_AT_END) {
 			err = ENOSPC;
 			goto put_err_out;
 		}
@@ -1071,7 +1071,7 @@
 		 * find next, because we don't need such.
 		 */
 		while (ctx->ntfs_ino->mft_no != ni->mft_no) {
-			if (ntfs_attr_lookup(AT_UNUSED, NULL, 0, CASE_SENSITIVE,
+			if (ntfs_attr_lookup(NTFS_AT_UNUSED, NULL, 0, NTFS_CASE_SENSITIVE,
 						0, NULL, 0, ctx)) {
 				err = errno;
 				if (errno != ENOENT) {
@@ -1099,18 +1099,18 @@
 		}

 		/*
-		 * Reposition to first attribute after $STANDARD_INFORMATION and
+		 * Reposition to first attribute after $NTFS_STANDARD_INFORMATION and
 		 * $ATTRIBUTE_LIST (see comments upwards).
 		 */
 		ntfs_attr_reinit_search_ctx(ctx);
-		if (ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, CASE_SENSITIVE, 0,
+		if (ntfs_attr_lookup(NTFS_AT_FILE_NAME, NULL, 0, NTFS_CASE_SENSITIVE, 0,
 				NULL, 0, ctx)) {
 			if (errno != ENOENT) {
 				err = errno;
 				ntfs_log_trace("Attribute lookup failed.\n");
 				break;
 			}
-			if (ctx->attr->type == AT_END) {
+			if (ctx->attr->type == NTFS_AT_END) {
 				err = ENOSPC;
 				break;
 			}
@@ -1140,7 +1140,7 @@
 		ntfs_log_error("%s(): Invalid arguments.\n", __FUNCTION__);
 		return;
 	}
-	if ((ni->mft_no < FILE_first_user && ni->mft_no != FILE_root) ||
+	if ((ni->mft_no < NTFS_FILE_first_user && ni->mft_no != NTFS_FILE_root) ||
 			NVolReadOnly(ni->vol) || !mask)
 		return;

@@ -1167,7 +1167,7 @@
  * On success return 1 if the file is $Badclus:$Bad, otherwise return 0.
  * On error return -1 with errno set to the error code.
  */
-int ntfs_inode_badclus_bad(u64 mft_no, ATTR_RECORD *attr)
+int ntfs_inode_badclus_bad(u64 mft_no, NTFS_ATTR_RECORD *attr)
 {
 	int len, ret = 0;
 	ntfschar *ustr;
@@ -1178,10 +1178,10 @@
 		return -1;
 	}

-	if (mft_no != FILE_BadClus)
+	if (mft_no != NTFS_FILE_BadClus)
 	       	return 0;

-	if (attr->type != AT_DATA)
+	if (attr->type != NTFS_AT_DATA)
 	       	return 0;

 	if ((ustr = ntfs_str2ucs("$Bad", &len)) == NULL) {
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/lcnalloc.c ./libntfs/lcnalloc.c
--- ../ntfsprogs-2.0.0/libntfs/lcnalloc.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/lcnalloc.c	2007-10-06 16:48:08.000000000 +0200
@@ -34,14 +34,14 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "attrib.h"
-#include "bitmap.h"
-#include "debug.h"
-#include "runlist.h"
-#include "volume.h"
-#include "lcnalloc.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_debug.h"
+#include "ntfs_runlist.h"
+#include "ntfs_volume.h"
+#include "ntfs_lcnalloc.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_cluster_alloc - allocate clusters on an ntfs volume
@@ -53,11 +53,11 @@
  *
  * Allocate @count clusters preferably starting at cluster @start_lcn or at the
  * current allocator position if @start_lcn is -1, on the mounted ntfs volume
- * @vol. @zone is either DATA_ZONE for allocation of normal clusters and
- * MFT_ZONE for allocation of clusters for the master file table, i.e. the
+ * @vol. @zone is either NTFS_DATA_ZONE for allocation of normal clusters and
+ * NTFS_MFT_ZONE for allocation of clusters for the master file table, i.e. the
  * $MFT/$DATA attribute.
  *
- * On success return a runlist describing the allocated cluster(s).
+ * On success return a ntfs_runlist describing the allocated cluster(s).
  *
  * On error return NULL with errno set to the error code.
  *
@@ -99,34 +99,34 @@
  * possible code paths. So at least for now, I am leaving the double logic -
  * better safe than sorry... (AIA)
  */
-runlist *ntfs_cluster_alloc(ntfs_volume *vol, VCN start_vcn, s64 count,
-		LCN start_lcn, const NTFS_CLUSTER_ALLOCATION_ZONES zone)
+ntfs_runlist *ntfs_cluster_alloc(ntfs_volume *vol, NTFS_VCN start_vcn, s64 count,
+		NTFS_LCN start_lcn, const NTFS_CLUSTER_ALLOCATION_ZONES zone)
 {
-	LCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;
-	LCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;
+	NTFS_LCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;
+	NTFS_LCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;
 	s64 clusters, br;
-	runlist *rl = NULL, *trl;
+	ntfs_runlist *rl = NULL, *trl;
 	u8 *buf, *byte;
 	int err = 0, rlpos, rlsize, buf_size;
 	u8 pass, done_zones, search_zone, need_writeback, bit;

 	ntfs_log_trace("Entering with count = 0x%llx, start_lcn = 0x%llx, zone = "
 			"%s_ZONE.\n", (long long)count, (long long)start_lcn,
-			zone == MFT_ZONE ? "MFT" : "DATA");
+			zone == NTFS_MFT_ZONE ? "MFT" : "DATA");
 	if (!vol || count < 0 || start_lcn < -1 || !vol->lcnbmp_na ||
-			(s8)zone < FIRST_ZONE || zone > LAST_ZONE) {
+			(s8)zone < NTFS_FIRST_ZONE || zone > NTFS_LAST_ZONE) {
 		ntfs_log_trace("Invalid arguments!\n");
 		errno = EINVAL;
 		return NULL;
 	}

-	/* Return empty runlist if @count == 0 */
+	/* Return empty ntfs_runlist if @count == 0 */
 	if (!count) {
 		rl = ntfs_malloc(0x1000);
 		if (!rl)
 			return NULL;
 		rl[0].vcn = start_vcn;
-		rl[0].lcn = LCN_RL_NOT_MAPPED;
+		rl[0].lcn = NTFS_LCN_RL_NOT_MAPPED;
 		rl[0].length = 0;
 		return rl;
 	}
@@ -140,10 +140,10 @@
 	 * position, otherwise use the requested @start_lcn but make sure it
 	 * lies outside the mft zone. Also set done_zones to 0 (no zones done)
 	 * and pass depending on whether we are starting inside a zone (1) or
-	 * at the beginning of a zone (2). If requesting from the MFT_ZONE,
+	 * at the beginning of a zone (2). If requesting from the NTFS_MFT_ZONE,
 	 * we either start at the current position within the mft zone or at
 	 * the specified position. If the latter is out of bounds then we start
-	 * at the beginning of the MFT_ZONE.
+	 * at the beginning of the NTFS_MFT_ZONE.
 	 */
 	done_zones = 0;
 	pass = 1;
@@ -155,7 +155,7 @@
 	 */
 	zone_start = start_lcn;
 	if (zone_start < 0) {
-		if (zone == DATA_ZONE)
+		if (zone == NTFS_DATA_ZONE)
 			zone_start = vol->data1_zone_pos;
 		else
 			zone_start = vol->mft_zone_pos;
@@ -166,7 +166,7 @@
 			 */
 			pass = 2;
 		}
-	} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&
+	} else if (zone == NTFS_DATA_ZONE && zone_start >= vol->mft_zone_start &&
 			zone_start < vol->mft_zone_end) {
 		zone_start = vol->mft_zone_end;
 		/*
@@ -174,7 +174,7 @@
 		 * pass in this zone is sufficient.
 		 */
 		pass = 2;
-	} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||
+	} else if (zone == NTFS_MFT_ZONE && (zone_start < vol->mft_zone_start ||
 			zone_start >= vol->mft_zone_end)) {
 		zone_start = vol->mft_lcn;
 		if (!vol->mft_zone_end)
@@ -185,10 +185,10 @@
 		 */
 		pass = 2;
 	}
-	if (zone == MFT_ZONE) {
+	if (zone == NTFS_MFT_ZONE) {
 		zone_end = vol->mft_zone_end;
 		search_zone = 1;
-	} else /* if (zone == DATA_ZONE) */ {
+	} else /* if (zone == NTFS_DATA_ZONE) */ {
 		/* Skip searching the mft zone. */
 		done_zones |= 1;
 		if (zone_start >= vol->mft_zone_end) {
@@ -268,13 +268,13 @@
 				continue;
 			}
 			/* Reallocate memory if necessary. */
-			if ((rlpos + 2) * (int)sizeof(runlist) >= rlsize) {
+			if ((rlpos + 2) * (int)sizeof(ntfs_runlist) >= rlsize) {
 				ntfs_log_trace("Reallocating space.\n");
 				if (!rl)
-					ntfs_log_trace("First free bit is at LCN = "
+					ntfs_log_trace("First free bit is at NTFS_LCN = "
 						"0x%llx.\n", (long long)(lcn + bmp_pos));
 				rlsize += 4096;
-				trl = (runlist*)realloc(rl, rlsize);
+				trl = (ntfs_runlist*)realloc(rl, rlsize);
 				if (!trl) {
 					err = ENOMEM;
 					ntfs_log_trace("Failed to allocate memory, "
@@ -333,7 +333,7 @@
 			}
 			/* Done? */
 			if (!--clusters) {
-				LCN tc;
+				NTFS_LCN tc;
 				/*
 				 * Update the current zone position. Positions
 				 * of already scanned zones have been updated
@@ -472,7 +472,7 @@
 						"zone.\n");
 				/* Update mft zone position. */
 				if (rlpos) {
-					LCN tc;
+					NTFS_LCN tc;
 					ntfs_log_trace("Before checks, vol->mft_zone_pos = 0x%llx.\n",
 							(long long) vol->mft_zone_pos);
 					tc = rl[rlpos - 1].lcn +
@@ -508,7 +508,7 @@
 						"zone.\n");
 				/* Update data1 zone position. */
 				if (rlpos) {
-					LCN tc;
+					NTFS_LCN tc;
 					ntfs_log_trace("Before checks, vol->data1_zone_pos = 0x%llx.\n",
 							(long long) vol->data1_zone_pos);
 					tc = rl[rlpos - 1].lcn +
@@ -542,7 +542,7 @@
 						"zone.\n");
 				/* Update data2 zone position. */
 				if (rlpos) {
-					LCN tc;
+					NTFS_LCN tc;
 					ntfs_log_trace("Before checks, vol->data2_zone_pos = 0x%llx.\n",
 							(long long) vol->data2_zone_pos);
 					tc = rl[rlpos - 1].lcn +
@@ -580,8 +580,8 @@
 		} /* done_zones == 7 */
 		ntfs_log_trace("All zones are finished.\n");
 		/*
-		 * All zones are finished! If DATA_ZONE, shrink mft zone. If
-		 * MFT_ZONE, we have really run out of space.
+		 * All zones are finished! If NTFS_DATA_ZONE, shrink mft zone. If
+		 * NTFS_MFT_ZONE, we have really run out of space.
 		 */
 		mft_zone_size = vol->mft_zone_end - vol->mft_zone_start;
 		ntfs_log_trace("vol->mft_zone_start = 0x%llx, vol->mft_zone_end = "
@@ -589,12 +589,12 @@
 				(long long)vol->mft_zone_start,
 				(long long)vol->mft_zone_end,
 				(long long)mft_zone_size);
-		if (zone == MFT_ZONE || mft_zone_size <= 0) {
+		if (zone == NTFS_MFT_ZONE || mft_zone_size <= 0) {
 			ntfs_log_trace("No free clusters left, going to err_ret.\n");
 			/* Really no more space left on device. */
 			err = ENOSPC;
 			goto err_ret;
-		} /* zone == DATA_ZONE && mft_zone_size > 0 */
+		} /* zone == NTFS_DATA_ZONE && mft_zone_size > 0 */
 		ntfs_log_trace("Shrinking mft zone.\n");
 		zone_end = vol->mft_zone_end;
 		mft_zone_size >>= 1;
@@ -632,9 +632,9 @@
 	ntfs_log_debug("After outer while loop.\n");
 done_ret:
 	ntfs_log_debug("At done_ret.\n");
-	/* Add runlist terminator element. */
+	/* Add ntfs_runlist terminator element. */
 	rl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;
-	rl[rlpos].lcn = LCN_RL_NOT_MAPPED;
+	rl[rlpos].lcn = NTFS_LCN_RL_NOT_MAPPED;
 	rl[rlpos].length = 0;
 	if (need_writeback) {
 		s64 bw;
@@ -686,14 +686,14 @@
 					(long long)rl[0].lcn,
 					(long long)count - clusters);
 		}
-		/* Add runlist terminator element. */
+		/* Add ntfs_runlist terminator element. */
 		rl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;
-		rl[rlpos].lcn = LCN_RL_NOT_MAPPED;
+		rl[rlpos].lcn = NTFS_LCN_RL_NOT_MAPPED;
 		rl[rlpos].length = 0;
 		/* Deallocate all allocated clusters. */
 		ntfs_log_trace("Deallocating allocated clusters.\n");
 		ntfs_cluster_free_from_rl(vol, rl);
-		/* Free the runlist. */
+		/* Free the ntfs_runlist. */
 		free(rl);
 		rl = NULL;
 	} else {
@@ -708,13 +708,13 @@
 }

 /**
- * ntfs_cluster_free_from_rl - free clusters from runlist
+ * ntfs_cluster_free_from_rl - free clusters from ntfs_runlist
  * @vol:	mounted ntfs volume on which to free the clusters
- * @rl:		runlist from which deallocate clusters
+ * @rl:		ntfs_runlist from which deallocate clusters
  *
  * On success return 0 and on error return -1 with errno set to the error code.
  */
-int ntfs_cluster_free_from_rl(ntfs_volume *vol, runlist *rl)
+int ntfs_cluster_free_from_rl(ntfs_volume *vol, ntfs_runlist *rl)
 {
 	ntfs_log_trace("Entering.\n");

@@ -737,22 +737,22 @@
 /**
  * ntfs_cluster_free - free clusters on an ntfs volume
  * @vol:	mounted ntfs volume on which to free the clusters
- * @na:		attribute whose runlist describes the clusters to free
+ * @na:		attribute whose ntfs_runlist describes the clusters to free
  * @start_vcn:	vcn in @rl at which to start freeing clusters
  * @count:	number of clusters to free or -1 for all clusters
  *
- * Free @count clusters starting at the cluster @start_vcn in the runlist
+ * Free @count clusters starting at the cluster @start_vcn in the ntfs_runlist
  * described by the attribute @na from the mounted ntfs volume @vol.
  *
- * If @count is -1, all clusters from @start_vcn to the end of the runlist
+ * If @count is -1, all clusters from @start_vcn to the end of the ntfs_runlist
  * are deallocated.
  *
  * On success return the number of deallocated clusters (not counting sparse
  * clusters) and on error return -1 with errno set to the error code.
  */
-int ntfs_cluster_free(ntfs_volume *vol, ntfs_attr *na, VCN start_vcn, s64 count)
+int ntfs_cluster_free(ntfs_volume *vol, ntfs_attr *na, NTFS_VCN start_vcn, s64 count)
 {
-	runlist *rl;
+	ntfs_runlist *rl;
 	s64 nr_freed, delta, to_free;

 	if (!vol || !vol->lcnbmp_na || !na || start_vcn < 0 ||
@@ -773,7 +773,7 @@
 			return -1;
 	}

-	if (rl->lcn < 0 && rl->lcn != LCN_HOLE) {
+	if (rl->lcn < 0 && rl->lcn != NTFS_LCN_HOLE) {
 		errno = EIO;
 		return -1;
 	}
@@ -786,7 +786,7 @@
 	if (count >= 0 && to_free > count)
 		to_free = count;

-	if (rl->lcn != LCN_HOLE) {
+	if (rl->lcn != NTFS_LCN_HOLE) {
 		/* Do the actual freeing of the clusters in this run. */
 		if (ntfs_bitmap_clear_run(vol->lcnbmp_na, rl->lcn + delta,
 				to_free))
@@ -810,10 +810,10 @@
 	for (; rl->length && count != 0; ++rl) {
 		// FIXME: Need to try ntfs_attr_map_runlist() for attribute
 		//	  list support! (AIA)
-		if (rl->lcn < 0 && rl->lcn != LCN_HOLE) {
+		if (rl->lcn < 0 && rl->lcn != NTFS_LCN_HOLE) {
 			// FIXME: Eeek! We need rollback! (AIA)
 			ntfs_log_trace("Eeek! invalid lcn (= %lli).  Should attempt "
-					"to map runlist!  Leaving inconsistent "
+					"to map ntfs_runlist!  Leaving inconsistent "
 					"metadata!\n", (long long)rl->lcn);
 			errno = EIO;
 			return -1;
@@ -824,7 +824,7 @@
 		if (count >= 0 && to_free > count)
 			to_free = count;

-		if (rl->lcn != LCN_HOLE) {
+		if (rl->lcn != NTFS_LCN_HOLE) {
 			/* Do the actual freeing of the clusters in the run. */
 			if (ntfs_bitmap_clear_run(vol->lcnbmp_na, rl->lcn,
 					to_free)) {
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/logfile.c ./libntfs/logfile.c
--- ../ntfsprogs-2.0.0/libntfs/logfile.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/logfile.c	2007-10-06 16:48:07.000000000 +0200
@@ -34,12 +34,12 @@
 #include <errno.h>
 #endif

-#include "attrib.h"
-#include "debug.h"
-#include "logfile.h"
-#include "volume.h"
-#include "mst.h"
-#include "logging.h"
+#include "ntfs_attrib.h"
+#include "ntfs_debug.h"
+#include "ntfs_logfile.h"
+#include "ntfs_volume.h"
+#include "ntfs_mst.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_check_restart_page_header - check the page header for consistency
@@ -52,11 +52,11 @@
  * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not
  * require the full restart page.
  */
-static BOOL ntfs_check_restart_page_header(RESTART_PAGE_HEADER *rp, s64 pos)
+static NTFS_BOOL ntfs_check_restart_page_header(NTFS_RESTART_PAGE_HEADER *rp, s64 pos)
 {
 	u32 logfile_system_page_size, logfile_log_page_size;
 	u16 ra_ofs, usa_count, usa_ofs, usa_end = 0;
-	BOOL have_usa = TRUE;
+	NTFS_BOOL have_usa = TRUE;

 	ntfs_log_trace("Entering.\n");
 	/*
@@ -109,7 +109,7 @@
 	/* Verify the position of the update sequence array. */
 	usa_ofs = le16_to_cpu(rp->usa_ofs);
 	usa_end = usa_ofs + usa_count * sizeof(u16);
-	if (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||
+	if (usa_ofs < sizeof(NTFS_RESTART_PAGE_HEADER) ||
 			usa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {
 		ntfs_log_error("$LogFile restart page specifies "
 				"inconsistent update sequence array offset.\n");
@@ -124,7 +124,7 @@
 	 */
 	ra_ofs = le16_to_cpu(rp->restart_area_offset);
 	if (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :
-			ra_ofs < sizeof(RESTART_PAGE_HEADER)) ||
+			ra_ofs < sizeof(NTFS_RESTART_PAGE_HEADER)) ||
 			ra_ofs > logfile_system_page_size) {
 		ntfs_log_error("$LogFile restart page specifies "
 				"inconsistent restart area offset.\n");
@@ -136,7 +136,7 @@
 	 */
 	if (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {
 		ntfs_log_error("$LogFile restart page is not modified "
-				"by chkdsk but a chkdsk LSN is specified.\n");
+				"by chkdsk but a chkdsk NTFS_LSN is specified.\n");
 		return FALSE;
 	}
 	ntfs_log_trace("Done.\n");
@@ -156,22 +156,22 @@
  * This function only needs NTFS_BLOCK_SIZE bytes in @rp, i.e. it does not
  * require the full restart page.
  */
-static BOOL ntfs_check_restart_area(RESTART_PAGE_HEADER *rp)
+static NTFS_BOOL ntfs_check_restart_area(NTFS_RESTART_PAGE_HEADER *rp)
 {
 	u64 file_size;
-	RESTART_AREA *ra;
+	NTFS_RESTART_AREA *ra;
 	u16 ra_ofs, ra_len, ca_ofs;
 	u8 fs_bits;

 	ntfs_log_trace("Entering.\n");
 	ra_ofs = le16_to_cpu(rp->restart_area_offset);
-	ra = (RESTART_AREA*)((u8*)rp + ra_ofs);
+	ra = (NTFS_RESTART_AREA*)((u8*)rp + ra_ofs);
 	/*
 	 * Everything before ra->file_size must be before the first word
 	 * protected by an update sequence number.  This ensures that it is
 	 * safe to access ra->client_array_offset.
 	 */
-	if (ra_ofs + offsetof(RESTART_AREA, file_size) >
+	if (ra_ofs + offsetof(NTFS_RESTART_AREA, file_size) >
 			NTFS_BLOCK_SIZE - sizeof(u16)) {
 		ntfs_log_error("$LogFile restart area specifies "
 				"inconsistent file offset.\n");
@@ -198,7 +198,7 @@
 	 * Also, the calculated length must not exceed the specified length.
 	 */
 	ra_len = ca_ofs + le16_to_cpu(ra->log_clients) *
-			sizeof(LOG_CLIENT_RECORD);
+			sizeof(NTFS_LOG_CLIENT_RECORD);
 	if ((u32)(ra_ofs + ra_len) > le32_to_cpu(rp->system_page_size) ||
 			(u32)(ra_ofs + le16_to_cpu(ra->restart_area_length)) >
 			le32_to_cpu(rp->system_page_size) ||
@@ -211,13 +211,13 @@
 	}
 	/*
 	 * The ra->client_free_list and ra->client_in_use_list must be either
-	 * LOGFILE_NO_CLIENT or less than ra->log_clients or they are
+	 * NTFS_LOGFILE_NO_CLIENT or less than ra->log_clients or they are
 	 * overflowing the client array.
 	 */
-	if ((ra->client_free_list != LOGFILE_NO_CLIENT &&
+	if ((ra->client_free_list != NTFS_LOGFILE_NO_CLIENT &&
 			le16_to_cpu(ra->client_free_list) >=
 			le16_to_cpu(ra->log_clients)) ||
-			(ra->client_in_use_list != LOGFILE_NO_CLIENT &&
+			(ra->client_in_use_list != NTFS_LOGFILE_NO_CLIENT &&
 			le16_to_cpu(ra->client_in_use_list) >=
 			le16_to_cpu(ra->log_clients))) {
 		ntfs_log_error("$LogFile restart area specifies "
@@ -271,16 +271,16 @@
  * function needs @rp->system_page_size bytes in @rp, i.e. it requires the full
  * restart page and the page must be multi sector transfer deprotected.
  */
-static BOOL ntfs_check_log_client_array(RESTART_PAGE_HEADER *rp)
+static NTFS_BOOL ntfs_check_log_client_array(NTFS_RESTART_PAGE_HEADER *rp)
 {
-	RESTART_AREA *ra;
-	LOG_CLIENT_RECORD *ca, *cr;
+	NTFS_RESTART_AREA *ra;
+	NTFS_LOG_CLIENT_RECORD *ca, *cr;
 	u16 nr_clients, idx;
-	BOOL in_free_list, idx_is_first;
+	NTFS_BOOL in_free_list, idx_is_first;

 	ntfs_log_trace("Entering.\n");
-	ra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
-	ca = (LOG_CLIENT_RECORD*)((u8*)ra +
+	ra = (NTFS_RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
+	ca = (NTFS_LOG_CLIENT_RECORD*)((u8*)ra +
 			le16_to_cpu(ra->client_array_offset));
 	/*
 	 * Check the ra->client_free_list first and then check the
@@ -294,7 +294,7 @@
 	idx = le16_to_cpu(ra->client_free_list);
 	in_free_list = TRUE;
 check_list:
-	for (idx_is_first = TRUE; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,
+	for (idx_is_first = TRUE; idx != NTFS_LOGFILE_NO_CLIENT_CPU; nr_clients--,
 			idx = le16_to_cpu(cr->next_client)) {
 		if (!nr_clients || idx >= le16_to_cpu(ra->log_clients))
 			goto err_out;
@@ -302,7 +302,7 @@
 		cr = ca + idx;
 		/* The first log client record must not have a prev_client. */
 		if (idx_is_first) {
-			if (cr->prev_client != LOGFILE_NO_CLIENT)
+			if (cr->prev_client != NTFS_LOGFILE_NO_CLIENT)
 				goto err_out;
 			idx_is_first = FALSE;
 		}
@@ -348,11 +348,11 @@
  *     EIO    - Failed to reading from $LogFile.
  */
 static int ntfs_check_and_load_restart_page(ntfs_attr *log_na,
-		RESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,
-		LSN *lsn)
+		NTFS_RESTART_PAGE_HEADER *rp, s64 pos, NTFS_RESTART_PAGE_HEADER **wrp,
+		NTFS_LSN *lsn)
 {
-	RESTART_AREA *ra;
-	RESTART_PAGE_HEADER *trp;
+	NTFS_RESTART_AREA *ra;
+	NTFS_RESTART_PAGE_HEADER *trp;
 	int err;

 	ntfs_log_trace("Entering.\n");
@@ -366,7 +366,7 @@
 		/* Error output already done inside the function. */
 		return EINVAL;
 	}
-	ra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
+	ra = (NTFS_RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
 	/*
 	 * Allocate a buffer to store the whole restart page so we can multi
 	 * sector transfer deprotect it.
@@ -419,7 +419,7 @@
 	 */
 	err = 0;
 	if (ntfs_is_rstr_record(rp->magic) &&
-			ra->client_in_use_list != LOGFILE_NO_CLIENT) {
+			ra->client_in_use_list != NTFS_LOGFILE_NO_CLIENT) {
 		if (!ntfs_check_log_client_array(trp)) {
 			err = EINVAL;
 			goto err_out;
@@ -458,16 +458,16 @@
  * if the $LogFile was created on a system with a different page size to ours
  * yet and mst deprotection would fail if our page size is smaller.
  */
-BOOL ntfs_check_logfile(ntfs_attr *log_na, RESTART_PAGE_HEADER **rp)
+NTFS_BOOL ntfs_check_logfile(ntfs_attr *log_na, NTFS_RESTART_PAGE_HEADER **rp)
 {
 	s64 size, pos;
-	LSN rstr1_lsn, rstr2_lsn;
+	NTFS_LSN rstr1_lsn, rstr2_lsn;
 	ntfs_volume *vol = log_na->ni->vol;
 	u8 *kaddr = NULL;
-	RESTART_PAGE_HEADER *rstr1_ph = NULL;
-	RESTART_PAGE_HEADER *rstr2_ph = NULL;
+	NTFS_RESTART_PAGE_HEADER *rstr1_ph = NULL;
+	NTFS_RESTART_PAGE_HEADER *rstr2_ph = NULL;
 	int log_page_size, log_page_mask, err;
-	BOOL logfile_is_empty = TRUE;
+	NTFS_BOOL logfile_is_empty = TRUE;
 	u8 log_page_bits;

 	ntfs_log_trace("Entering.\n");
@@ -476,9 +476,9 @@
 		goto is_empty;
 	size = log_na->data_size;
 	/* Make sure the file doesn't exceed the maximum allowed size. */
-	if (size > (s64)MaxLogFileSize)
-		size = MaxLogFileSize;
-	log_page_size = DefaultLogPageSize;
+	if (size > (s64)NTFS_MaxLogFileSize)
+		size = NTFS_MaxLogFileSize;
+	log_page_size = NTFS_DefaultLogPageSize;
 	log_page_mask = log_page_size - 1;
 	/*
 	 * Use generic_ffs() instead of ffs() to enable the compiler to
@@ -492,7 +492,7 @@
 	 * pages and the minimum number of log record pages.
 	 */
 	if (size < log_page_size * 2 || (size - log_page_size * 2) >>
-			log_page_bits < MinLogRecordPages) {
+			log_page_bits < NTFS_MinLogRecordPages) {
 		ntfs_log_error("$LogFile is too small.\n");
 		return FALSE;
 	}
@@ -547,7 +547,7 @@
 		 * deprotected restart page.
 		 */
 		err = ntfs_check_and_load_restart_page(log_na,
-				(RESTART_PAGE_HEADER*)kaddr, pos,
+				(NTFS_RESTART_PAGE_HEADER*)kaddr, pos,
 				!rstr1_ph ? &rstr1_ph : &rstr2_ph,
 				!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);
 		if (!err) {
@@ -646,9 +646,9 @@
  * is empty this function requires that NVolLogFileEmpty() is true otherwise an
  * empty volume will be reported as dirty.
  */
-BOOL ntfs_is_logfile_clean(ntfs_attr *log_na, RESTART_PAGE_HEADER *rp)
+NTFS_BOOL ntfs_is_logfile_clean(ntfs_attr *log_na, NTFS_RESTART_PAGE_HEADER *rp)
 {
-	RESTART_AREA *ra;
+	NTFS_RESTART_AREA *ra;

 	ntfs_log_trace("Entering.\n");
 	/* An empty $LogFile must have been clean before it got emptied. */
@@ -669,14 +669,14 @@
 		return FALSE;
 	}

-	ra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
+	ra = (NTFS_RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));
 	/*
 	 * If the $LogFile has active clients, i.e. it is open, and we do not
-	 * have the RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,
+	 * have the NTFS_RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,
 	 * we assume there was an unclean shutdown.
 	 */
-	if (ra->client_in_use_list != LOGFILE_NO_CLIENT &&
-			!(ra->flags & RESTART_VOLUME_IS_CLEAN)) {
+	if (ra->client_in_use_list != NTFS_LOGFILE_NO_CLIENT &&
+			!(ra->flags & NTFS_RESTART_VOLUME_IS_CLEAN)) {
 		ntfs_log_debug("Done.  $LogFile indicates a dirty shutdown.\n");
 		return FALSE;
 	}
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/logging.c ./libntfs/logging.c
--- ../ntfsprogs-2.0.0/libntfs/logging.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/logging.c	2007-10-06 16:48:08.000000000 +0200
@@ -42,7 +42,7 @@
 #include <syslog.h>
 #endif

-#include "logging.h"
+#include "ntfs_logging.h"

 #ifndef PATH_SEP
 #define PATH_SEP '/'
@@ -608,7 +608,7 @@
  * Returns:  TRUE  Option understood
  *          FALSE  Invalid log option
  */
-BOOL ntfs_log_parse_option(const char *option)
+NTFS_BOOL ntfs_log_parse_option(const char *option)
 {
 	if (strcmp(option, "--log-debug") == 0) {
 		ntfs_log_set_levels(NTFS_LOG_LEVEL_DEBUG);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/mft.c ./libntfs/mft.c
--- ../ntfsprogs-2.0.0/libntfs/mft.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/mft.c	2007-10-06 16:48:08.000000000 +0200
@@ -39,18 +39,18 @@
 #endif
 #include <time.h>

-#include "compat.h"
-#include "types.h"
-#include "device.h"
-#include "debug.h"
-#include "bitmap.h"
-#include "attrib.h"
-#include "inode.h"
-#include "volume.h"
-#include "layout.h"
-#include "lcnalloc.h"
-#include "mft.h"
-#include "logging.h"
+#include "ntfs_compat.h"
+#include "ntfs_types.h"
+#include "ntfs_device.h"
+#include "ntfs_debug.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_volume.h"
+#include "ntfs_layout.h"
+#include "ntfs_lcnalloc.h"
+#include "ntfs_mft.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_mft_records_read - read records from the mft from disk
@@ -73,18 +73,18 @@
  *
  * NOTE: @b has to be at least of size @count * vol->mft_record_size.
  */
-int ntfs_mft_records_read(const ntfs_volume *vol, const MFT_REF mref,
-		const s64 count, MFT_RECORD *b)
+int ntfs_mft_records_read(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		const s64 count, NTFS_MFT_RECORD *b)
 {
 	s64 br;
-	VCN m;
+	NTFS_VCN m;

-	ntfs_log_trace("Entering for inode 0x%llx.\n", MREF(mref));
+	ntfs_log_trace("Entering for inode 0x%llx.\n", NTFS_MREF(mref));
 	if (!vol || !vol->mft_na || !b || count < 0) {
 		errno = EINVAL;
 		return -1;
 	}
-	m = MREF(mref);
+	m = NTFS_MREF(mref);
 	/* Refuse to read non-allocated mft records. */
 	if (m + count > vol->mft_na->initialized_size >>
 			vol->mft_record_size_bits) {
@@ -130,20 +130,20 @@
  * record was successfully written, we write the appropriate mft records from
  * the copied buffer to the mft mirror, too.
  */
-int ntfs_mft_records_write(const ntfs_volume *vol, const MFT_REF mref,
-		const s64 count, MFT_RECORD *b)
+int ntfs_mft_records_write(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		const s64 count, NTFS_MFT_RECORD *b)
 {
 	s64 bw;
-	VCN m;
+	NTFS_VCN m;
 	void *bmirr = NULL;
 	int cnt = 0, res = 0;

-	ntfs_log_trace("Entering for inode 0x%llx.\n", MREF(mref));
+	ntfs_log_trace("Entering for inode 0x%llx.\n", NTFS_MREF(mref));
 	if (!vol || !vol->mft_na || vol->mftmirr_size <= 0 || !b || count < 0) {
 		errno = EINVAL;
 		return -1;
 	}
-	m = MREF(mref);
+	m = NTFS_MREF(mref);
 	/* Refuse to write non-allocated mft records. */
 	if (m + count > vol->mft_na->initialized_size >>
 			vol->mft_record_size_bits) {
@@ -217,7 +217,7 @@
  * Return 0 on success, or -1 on error, with errno set to the error code.
  *
  * The read mft record is checked for having the magic FILE,
- * and for having a matching sequence number (if MSEQNO(*@mref) != 0).
+ * and for having a matching sequence number (if NTFS_MSEQNO(*@mref) != 0).
  * If either of these fails, -1 is returned and errno is set to EIO. If you get
  * this, but you still want to read the mft record (e.g. in order to correct
  * it), use ntfs_mft_record_read() directly.
@@ -227,11 +227,11 @@
  * Note: We do not check if the mft record is flagged in use. The caller can
  *	 check if desired.
  */
-int ntfs_file_record_read(const ntfs_volume *vol, const MFT_REF mref,
-		MFT_RECORD **mrec, ATTR_RECORD **attr)
+int ntfs_file_record_read(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		NTFS_MFT_RECORD **mrec, NTFS_ATTR_RECORD **attr)
 {
-	MFT_RECORD *m;
-	ATTR_RECORD *a;
+	NTFS_MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
 	int err;

 	if (!vol || !mrec) {
@@ -240,7 +240,7 @@
 	}
 	m = *mrec;
 	if (!m) {
-		m = (MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
+		m = (NTFS_MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
 		if (!m)
 			return -1;
 	}
@@ -250,9 +250,9 @@
 	}
 	if (!ntfs_is_file_record(m->magic))
 		goto file_corrupt;
-	if (MSEQNO(mref) && MSEQNO(mref) != le16_to_cpu(m->sequence_number))
+	if (NTFS_MSEQNO(mref) && NTFS_MSEQNO(mref) != le16_to_cpu(m->sequence_number))
 		goto file_corrupt;
-	a = (ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
+	a = (NTFS_ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
 	if (p2n(a) < p2n(m) || (char*)a > (char*)m + vol->mft_record_size)
 		goto file_corrupt;
 	*mrec = m;
@@ -282,10 +282,10 @@
  *
  * On success return 0 and on error return -1 with errno set to the error code.
  */
-int ntfs_mft_record_layout(const ntfs_volume *vol, const MFT_REF mref,
-		MFT_RECORD *mrec)
+int ntfs_mft_record_layout(const ntfs_volume *vol, const NTFS_MFT_REF mref,
+		NTFS_MFT_RECORD *mrec)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;

 	if (!vol || !mrec) {
 		errno = EINVAL;
@@ -293,21 +293,21 @@
 	}
 	/* Aligned to 2-byte boundary. */
 	if (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))
-		mrec->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);
+		mrec->usa_ofs = cpu_to_le16((sizeof(NTFS_MFT_RECORD_OLD) + 1) & ~1);
 	else {
 		/* Abort if mref is > 32 bits. */
-		if (MREF(mref) & 0x0000ffff00000000ull) {
+		if (NTFS_MREF(mref) & 0x0000ffff00000000ull) {
 			ntfs_log_debug("Mft reference exceeds 32 bits!\n");
 			errno = ERANGE;
 			return -1;
 		}
-		mrec->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);
+		mrec->usa_ofs = cpu_to_le16((sizeof(NTFS_MFT_RECORD) + 1) & ~1);
 		/*
 		 * Set the NTFS 3.1+ specific fields while we know that the
 		 * volume version is 3.1+.
 		 */
 		mrec->reserved = cpu_to_le16(0);
-		mrec->mft_record_number = cpu_to_le32(MREF(mref));
+		mrec->mft_record_number = cpu_to_le32(NTFS_MREF(mref));
 	}
 	mrec->magic = magic_FILE;
 	if (vol->mft_record_size >= NTFS_BLOCK_SIZE)
@@ -338,10 +338,10 @@
 	mrec->bytes_in_use = cpu_to_le32((le16_to_cpu(mrec->attrs_offset) + 8 +
 			7) & ~7);
 	mrec->bytes_allocated = cpu_to_le32(vol->mft_record_size);
-	mrec->base_mft_record = cpu_to_le64((MFT_REF)0);
+	mrec->base_mft_record = cpu_to_le64((NTFS_MFT_REF)0);
 	mrec->next_attr_instance = cpu_to_le16(0);
-	a = (ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec->attrs_offset));
-	a->type = AT_END;
+	a = (NTFS_ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec->attrs_offset));
+	a->type = NTFS_AT_END;
 	a->length = cpu_to_le32(0);
 	/* Finally, clear the unused part of the mft record. */
 	memset((u8*)a + 8, 0, vol->mft_record_size - ((u8*)a + 8 - (u8*)mrec));
@@ -358,9 +358,9 @@
  *
  * On success return 0 and on error return -1 with errno set to the error code.
  */
-int ntfs_mft_record_format(const ntfs_volume *vol, const MFT_REF mref)
+int ntfs_mft_record_format(const ntfs_volume *vol, const NTFS_MFT_REF mref)
 {
-	MFT_RECORD *m;
+	NTFS_MFT_RECORD *m;
 	int err;

 	if (!vol || !vol->mft_na) {
@@ -554,13 +554,13 @@
  */
 static int ntfs_mft_bitmap_extend_allocation(ntfs_volume *vol)
 {
-	LCN lcn;
+	NTFS_LCN lcn;
 	s64 ll = 0; /* silence compiler warning */
 	ntfs_attr *mftbmp_na, *lcnbmp_na;
-	runlist_element *rl, *rl2 = NULL; /* silence compiler warning */
+	ntfs_runlist_element *rl, *rl2 = NULL; /* silence compiler warning */
 	ntfs_attr_search_ctx *ctx;
-	MFT_RECORD *m = NULL; /* silence compiler warning */
-	ATTR_RECORD *a = NULL; /* silence compiler warning */
+	NTFS_MFT_RECORD *m = NULL; /* silence compiler warning */
+	NTFS_ATTR_RECORD *a = NULL; /* silence compiler warning */
 	int ret, mp_size;
 	u32 old_alen = 0; /* silence compiler warning */
 	u8 b, tb;
@@ -610,14 +610,14 @@
 			return -1;
 		}
 		vol->nr_free_clusters--;
-		/* Update the mft bitmap runlist. */
+		/* Update the mft bitmap ntfs_runlist. */
 		rl->length++;
 		rl[1].vcn++;
 		status.added_cluster = 1;
 		ntfs_log_debug("Appending one cluster to mft bitmap.\n");
 	} else {
-		/* Allocate a cluster from the DATA_ZONE. */
-		rl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE);
+		/* Allocate a cluster from the NTFS_DATA_ZONE. */
+		rl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, NTFS_DATA_ZONE);
 		if (!rl2) {
 			ntfs_log_error("Failed to allocate a cluster for "
 					"the mft bitmap.\n");
@@ -638,13 +638,13 @@
 		mftbmp_na->rl = rl;
 		status.added_run = 1;
 		ntfs_log_debug("Adding one run to mft bitmap.\n");
-		/* Find the last run in the new runlist. */
+		/* Find the last run in the new ntfs_runlist. */
 		for (; rl[1].length; rl++)
 			;
 	}
 	/*
 	 * Update the attribute record as well.  Note: @rl is the last
-	 * (non-terminator) runlist element of mft bitmap.
+	 * (non-terminator) ntfs_runlist element of mft bitmap.
 	 */
 	ctx = ntfs_attr_get_search_ctx(mftbmp_na->ni, NULL);
 	if (!ctx) {
@@ -752,12 +752,12 @@
 undo_alloc:
 	ret = errno;
 	if (status.added_cluster) {
-		/* Truncate the last run in the runlist by one cluster. */
+		/* Truncate the last run in the ntfs_runlist by one cluster. */
 		rl->length--;
 		rl[1].vcn--;
 	} else if (status.added_run) {
 		lcn = rl->lcn;
-		/* Remove the last run from the runlist. */
+		/* Remove the last run from the ntfs_runlist. */
 		rl->lcn = rl[1].lcn;
 		rl->length = 0;
 	}
@@ -799,7 +799,7 @@
 	s64 old_data_size, old_initialized_size, ll;
 	ntfs_attr *mftbmp_na;
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	int err;

 	mftbmp_na = vol->mftbmp_na;
@@ -887,17 +887,17 @@
  */
 static int ntfs_mft_data_extend_allocation(ntfs_volume *vol)
 {
-	LCN lcn;
-	VCN old_last_vcn;
+	NTFS_LCN lcn;
+	NTFS_VCN old_last_vcn;
 	s64 min_nr, nr, ll = 0; /* silence compiler warning */
 	ntfs_attr *mft_na;
-	runlist_element *rl, *rl2;
+	ntfs_runlist_element *rl, *rl2;
 	ntfs_attr_search_ctx *ctx;
-	MFT_RECORD *m = NULL; /* silence compiler warning */
-	ATTR_RECORD *a = NULL; /* silence compiler warning */
+	NTFS_MFT_RECORD *m = NULL; /* silence compiler warning */
+	NTFS_ATTR_RECORD *a = NULL; /* silence compiler warning */
 	int err, mp_size;
 	u32 old_alen = 0; /* silence compiler warning */
-	BOOL mp_rebuilt = FALSE;
+	NTFS_BOOL mp_rebuilt = FALSE;

 	ntfs_log_debug("Extending mft data allocation.\n");
 	mft_na = vol->mft_na;
@@ -929,7 +929,7 @@
 			"%lli.\n", (long long)nr);
 	old_last_vcn = rl[1].vcn;
 	do {
-		rl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE);
+		rl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, NTFS_MFT_ZONE);
 		if (rl2)
 			break;
 		if (errno != ENOSPC || nr == min_nr) {
@@ -961,7 +961,7 @@
 	}
 	mft_na->rl = rl;
 	ntfs_log_debug("Allocated %lli clusters.\n", nr);
-	/* Find the last run in the new runlist. */
+	/* Find the last run in the new ntfs_runlist. */
 	for (; rl[1].length; rl++)
 		;
 	/* Update the attribute record as well. */
@@ -1031,7 +1031,7 @@
 	/*
 	 * We now have extended the mft data allocated_size by nr clusters.
 	 * Reflect this in the ntfs_attr structure and the attribute record.
-	 * @rl is the last (non-terminator) runlist element of mft data
+	 * @rl is the last (non-terminator) ntfs_runlist element of mft data
 	 * attribute.
 	 */
 	if (a->lowest_vcn) {
@@ -1082,7 +1082,7 @@
 				"attribute.%s\n", es);
 	if (ntfs_rl_truncate(&mft_na->rl, old_last_vcn))
 		ntfs_log_error("Failed to truncate mft data attribute "
-				"runlist.%s\n", es);
+				"ntfs_runlist.%s\n", es);
 	if (mp_rebuilt) {
 		if (ntfs_mapping_pairs_build(vol, (u8*)a +
 				le16_to_cpu(a->mapping_pairs_offset),
@@ -1189,8 +1189,8 @@
 	s64 ll, bit, old_data_initialized, old_data_size;
 	ntfs_attr *mft_na, *mftbmp_na;
 	ntfs_attr_search_ctx *ctx;
-	MFT_RECORD *m;
-	ATTR_RECORD *a;
+	NTFS_MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
 	ntfs_inode *ni;
 	int err;
 	le16 seq_no, usn;
@@ -1369,7 +1369,7 @@
 	 * is not zero as well as the update sequence number if it is not zero
 	 * or -1 (0xffff).
 	 */
-	m = (MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
 	if (!m)
 		goto undo_mftbmp_alloc;

@@ -1381,7 +1381,7 @@
 		goto undo_mftbmp_alloc;
 	}
 	/* Sanity check that the mft record is really not in use. */
-	if (ntfs_is_file_record(m->magic) && (m->flags & MFT_RECORD_IN_USE)) {
+	if (ntfs_is_file_record(m->magic) && (m->flags & NTFS_MFT_RECORD_IN_USE)) {
 		ntfs_log_error("Mft record 0x%llx was marked unused in "
 				"mft bitmap but is marked used itself.  "
 				"Corrupt filesystem or library bug!  "
@@ -1404,7 +1404,7 @@
 	if (usn && le16_to_cpu(usn) != 0xffff)
 		*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = usn;
 	/* Set the mft record itself in use. */
-	m->flags |= MFT_RECORD_IN_USE;
+	m->flags |= NTFS_MFT_RECORD_IN_USE;
 	/* Now need to open an ntfs inode for the mft record. */
 	ni = ntfs_inode_allocate(vol);
 	if (!ni) {
@@ -1424,7 +1424,7 @@
 	if (base_ni) {
 		ni->nr_extents = -1;
 		ni->base_ni = base_ni;
-		m->base_mft_record = MK_LE_MREF(base_ni->mft_no,
+		m->base_mft_record = NTFS_MK_LE_MREF(base_ni->mft_no,
 				le16_to_cpu(base_ni->mrec->sequence_number));
 		/*
 		 * Attach the extent inode to the base inode, reallocating
@@ -1513,7 +1513,7 @@
 	mft_no = ni->mft_no;

 	/* Mark the mft record as not in use. */
-	ni->mrec->flags &= ~MFT_RECORD_IN_USE;
+	ni->mrec->flags &= ~NTFS_MFT_RECORD_IN_USE;

 	/* Increment the sequence number, skipping zero, if it is not zero. */
 	old_seq_no = ni->mrec->sequence_number;
@@ -1550,7 +1550,7 @@
 		ntfs_log_debug("Eeek! Rollback failed in ntfs_mft_record_free().  "
 				"Leaving inconsistent metadata!\n");
 sync_rollback:
-	ni->mrec->flags |= MFT_RECORD_IN_USE;
+	ni->mrec->flags |= NTFS_MFT_RECORD_IN_USE;
 	ni->mrec->sequence_number = old_seq_no;
 	ntfs_inode_mark_dirty(ni);
 	errno = err;
@@ -1563,7 +1563,7 @@
  *
  * On success return 0 and on error return -1 with errno set.
  */
-int ntfs_mft_usn_dec(MFT_RECORD *mrec)
+int ntfs_mft_usn_dec(NTFS_MFT_RECORD *mrec)
 {
 	u16 usn;
 	le16 *usnp;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/misc.c ./libntfs/misc.c
--- ../ntfsprogs-2.0.0/libntfs/misc.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/misc.c	2007-10-06 16:48:07.000000000 +0200
@@ -27,8 +27,8 @@
 #include <stdlib.h>
 #endif

-#include "support.h"
-#include "logging.h"
+#include "ntfs_support.h"
+#include "ntfs_logging.h"

 /**
  * ntfs_calloc - A logging supported calloc(3)
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/mst.c ./libntfs/mst.c
--- ../ntfsprogs-2.0.0/libntfs/mst.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/mst.c	2007-10-06 16:48:07.000000000 +0200
@@ -28,7 +28,7 @@
 #include <errno.h>
 #endif

-#include "mst.h"
+#include "ntfs_mst.h"

 /**
  * ntfs_mst_post_read_fixup - deprotect multi sector transfer protected data
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/runlist.c ./libntfs/runlist.c
--- ../ntfsprogs-2.0.0/libntfs/runlist.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/runlist.c	2007-10-06 16:48:08.000000000 +0200
@@ -39,16 +39,16 @@
 #include <errno.h>
 #endif

-#include "compat.h"
-#include "types.h"
-#include "volume.h"
-#include "layout.h"
-#include "debug.h"
-#include "device.h"
-#include "logging.h"
+#include "ntfs_compat.h"
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
+#include "ntfs_layout.h"
+#include "ntfs_debug.h"
+#include "ntfs_device.h"
+#include "ntfs_logging.h"

 /**
- * ntfs_rl_mm - runlist memmove
+ * ntfs_rl_mm - ntfs_runlist memmove
  * @base:
  * @dst:
  * @src:
@@ -58,7 +58,7 @@
  *
  * Returns:
  */
-static __inline__ void ntfs_rl_mm(runlist_element *base, int dst, int src,
+static __inline__ void ntfs_rl_mm(ntfs_runlist_element *base, int dst, int src,
 		int size)
 {
 	if ((dst != src) && (size > 0))
@@ -66,7 +66,7 @@
 }

 /**
- * ntfs_rl_mc - runlist memory copy
+ * ntfs_rl_mc - ntfs_runlist memory copy
  * @dstbase:
  * @dst:
  * @srcbase:
@@ -77,8 +77,8 @@
  *
  * Returns:
  */
-static __inline__ void ntfs_rl_mc(runlist_element *dstbase, int dst,
-		runlist_element *srcbase, int src, int size)
+static __inline__ void ntfs_rl_mc(ntfs_runlist_element *dstbase, int dst,
+		ntfs_runlist_element *srcbase, int src, int size)
 {
 	if (size > 0)
 		memcpy(dstbase + dst, srcbase + src, size * sizeof(*dstbase));
@@ -86,9 +86,9 @@

 /**
  * ntfs_rl_realloc - Reallocate memory for runlists
- * @rl:		original runlist
- * @old_size:	number of runlist elements in the original runlist @rl
- * @new_size:	number of runlist elements we need space for
+ * @rl:		original ntfs_runlist
+ * @old_size:	number of ntfs_runlist elements in the original ntfs_runlist @rl
+ * @new_size:	number of ntfs_runlist elements we need space for
  *
  * As the runlists grow, more memory will be required. To prevent large
  * numbers of small reallocations of memory, this function returns a 4kiB block
@@ -100,11 +100,11 @@
  * On success, return a pointer to the newly allocated, or recycled, memory.
  * On error, return NULL with errno set to the error code.
  */
-static runlist_element *ntfs_rl_realloc(runlist_element *rl,
+static ntfs_runlist_element *ntfs_rl_realloc(ntfs_runlist_element *rl,
 		int old_size, int new_size)
 {
-	old_size = (old_size * sizeof(runlist_element) + 0xfff) & ~0xfff;
-	new_size = (new_size * sizeof(runlist_element) + 0xfff) & ~0xfff;
+	old_size = (old_size * sizeof(ntfs_runlist_element) + 0xfff) & ~0xfff;
+	new_size = (new_size * sizeof(ntfs_runlist_element) + 0xfff) & ~0xfff;
 	if (old_size == new_size)
 		return rl;
 	return realloc(rl, new_size);
@@ -112,8 +112,8 @@

 /**
  * ntfs_rl_are_mergeable - test if two runlists can be joined together
- * @dst:	original runlist
- * @src:	new runlist to test for mergeability with @dst
+ * @dst:	original ntfs_runlist
+ * @src:	new ntfs_runlist to test for mergeability with @dst
  *
  * Test if two runlists can be joined together. For this, their VCNs and LCNs
  * must be adjacent.
@@ -121,8 +121,8 @@
  * Return: TRUE   Success, the runlists can be merged.
  *	   FALSE  Failure, the runlists cannot be merged.
  */
-static BOOL ntfs_rl_are_mergeable(runlist_element *dst,
-		runlist_element *src)
+static NTFS_BOOL ntfs_rl_are_mergeable(ntfs_runlist_element *dst,
+		ntfs_runlist_element *src)
 {
 	if (!dst || !src) {
 		ntfs_log_debug("Eeek. ntfs_rl_are_mergeable() invoked with NULL "
@@ -131,7 +131,7 @@
 	}

 	/* We can merge unmapped regions even if they are misaligned. */
-	if ((dst->lcn == LCN_RL_NOT_MAPPED) && (src->lcn == LCN_RL_NOT_MAPPED))
+	if ((dst->lcn == NTFS_LCN_RL_NOT_MAPPED) && (src->lcn == NTFS_LCN_RL_NOT_MAPPED))
 		return TRUE;
 	/* If the runs are misaligned, we cannot merge them. */
 	if ((dst->vcn + dst->length) != src->vcn)
@@ -141,7 +141,7 @@
 		((dst->lcn + dst->length) == src->lcn))
 		return TRUE;
 	/* If we are merging two holes, we can merge them. */
-	if ((dst->lcn == LCN_HOLE) && (src->lcn == LCN_HOLE))
+	if ((dst->lcn == NTFS_LCN_HOLE) && (src->lcn == NTFS_LCN_HOLE))
 		return TRUE;
 	/* Cannot merge. */
 	return FALSE;
@@ -149,43 +149,43 @@

 /**
  * __ntfs_rl_merge - merge two runlists without testing if they can be merged
- * @dst:	original, destination runlist
- * @src:	new runlist to merge with @dst
+ * @dst:	original, destination ntfs_runlist
+ * @src:	new ntfs_runlist to merge with @dst
  *
- * Merge the two runlists, writing into the destination runlist @dst. The
+ * Merge the two runlists, writing into the destination ntfs_runlist @dst. The
  * caller must make sure the runlists can be merged or this will corrupt the
- * destination runlist.
+ * destination ntfs_runlist.
  */
-static __inline__ void __ntfs_rl_merge(runlist_element *dst,
-		runlist_element *src)
+static __inline__ void __ntfs_rl_merge(ntfs_runlist_element *dst,
+		ntfs_runlist_element *src)
 {
 	dst->length += src->length;
 }

 /**
- * ntfs_rl_append - append a runlist after a given element
- * @dst:	original runlist to be worked on
+ * ntfs_rl_append - append a ntfs_runlist after a given element
+ * @dst:	original ntfs_runlist to be worked on
  * @dsize:	number of elements in @dst (including end marker)
- * @src:	runlist to be inserted into @dst
+ * @src:	ntfs_runlist to be inserted into @dst
  * @ssize:	number of elements in @src (excluding end marker)
- * @loc:	append the new runlist @src after this element in @dst
+ * @loc:	append the new ntfs_runlist @src after this element in @dst
  *
- * Append the runlist @src after element @loc in @dst.  Merge the right end of
- * the new runlist, if necessary. Adjust the size of the hole before the
- * appended runlist.
+ * Append the ntfs_runlist @src after element @loc in @dst.  Merge the right end of
+ * the new ntfs_runlist, if necessary. Adjust the size of the hole before the
+ * appended ntfs_runlist.
  *
- * On success, return a pointer to the new, combined, runlist. Note, both
+ * On success, return a pointer to the new, combined, ntfs_runlist. Note, both
  * runlists @dst and @src are deallocated before returning so you cannot use
- * the pointers for anything any more. (Strictly speaking the returned runlist
+ * the pointers for anything any more. (Strictly speaking the returned ntfs_runlist
  * may be the same as @dst but this is irrelevant.)
  *
  * On error, return NULL, with errno set to the error code. Both runlists are
  * left unmodified.
  */
-static runlist_element *ntfs_rl_append(runlist_element *dst,
-		int dsize, runlist_element *src, int ssize, int loc)
+static ntfs_runlist_element *ntfs_rl_append(ntfs_runlist_element *dst,
+		int dsize, ntfs_runlist_element *src, int ssize, int loc)
 {
-	BOOL right = FALSE;	/* Right end of @src needs merging */
+	NTFS_BOOL right = FALSE;	/* Right end of @src needs merging */
 	int marker;		/* End of the inserted runs */

 	if (!dst || !src) {
@@ -223,37 +223,37 @@
 	dst[loc].length = dst[loc + 1].vcn - dst[loc].vcn;

 	/* We may have changed the length of the file, so fix the end marker */
-	if (dst[marker].lcn == LCN_ENOENT)
+	if (dst[marker].lcn == NTFS_LCN_ENOENT)
 		dst[marker].vcn = dst[marker-1].vcn + dst[marker-1].length;

 	return dst;
 }

 /**
- * ntfs_rl_insert - insert a runlist into another
- * @dst:	original runlist to be worked on
+ * ntfs_rl_insert - insert a ntfs_runlist into another
+ * @dst:	original ntfs_runlist to be worked on
  * @dsize:	number of elements in @dst (including end marker)
- * @src:	new runlist to be inserted
+ * @src:	new ntfs_runlist to be inserted
  * @ssize:	number of elements in @src (excluding end marker)
- * @loc:	insert the new runlist @src before this element in @dst
+ * @loc:	insert the new ntfs_runlist @src before this element in @dst
  *
- * Insert the runlist @src before element @loc in the runlist @dst. Merge the
- * left end of the new runlist, if necessary. Adjust the size of the hole
- * after the inserted runlist.
+ * Insert the ntfs_runlist @src before element @loc in the ntfs_runlist @dst. Merge the
+ * left end of the new ntfs_runlist, if necessary. Adjust the size of the hole
+ * after the inserted ntfs_runlist.
  *
- * On success, return a pointer to the new, combined, runlist. Note, both
+ * On success, return a pointer to the new, combined, ntfs_runlist. Note, both
  * runlists @dst and @src are deallocated before returning so you cannot use
- * the pointers for anything any more. (Strictly speaking the returned runlist
+ * the pointers for anything any more. (Strictly speaking the returned ntfs_runlist
  * may be the same as @dst but this is irrelevant.)
  *
  * On error, return NULL, with errno set to the error code. Both runlists are
  * left unmodified.
  */
-static runlist_element *ntfs_rl_insert(runlist_element *dst,
-		int dsize, runlist_element *src, int ssize, int loc)
+static ntfs_runlist_element *ntfs_rl_insert(ntfs_runlist_element *dst,
+		int dsize, ntfs_runlist_element *src, int ssize, int loc)
 {
-	BOOL left = FALSE;	/* Left end of @src needs merging */
-	BOOL disc = FALSE;	/* Discontinuity between @dst and @src */
+	NTFS_BOOL left = FALSE;	/* Left end of @src needs merging */
+	NTFS_BOOL disc = FALSE;	/* Discontinuity between @dst and @src */
 	int marker;		/* End of the inserted runs */

 	if (!dst || !src) {
@@ -288,7 +288,7 @@
 		return NULL;
 	/*
 	 * We are guaranteed to succeed from here so can start modifying the
-	 * original runlist.
+	 * original ntfs_runlist.
 	 */

 	if (left)
@@ -306,10 +306,10 @@
 	ntfs_rl_mm(dst, marker, loc, dsize - loc);
 	ntfs_rl_mc(dst, loc + disc, src, left, ssize - left);

-	/* Adjust the VCN of the first run after the insertion ... */
+	/* Adjust the NTFS_VCN of the first run after the insertion ... */
 	dst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;
 	/* ... and the length. */
-	if (dst[marker].lcn == LCN_HOLE || dst[marker].lcn == LCN_RL_NOT_MAPPED)
+	if (dst[marker].lcn == NTFS_LCN_HOLE || dst[marker].lcn == NTFS_LCN_RL_NOT_MAPPED)
 		dst[marker].length = dst[marker + 1].vcn - dst[marker].vcn;

 	/* Writing beyond the end of the file and there's a discontinuity. */
@@ -321,36 +321,36 @@
 			dst[loc].vcn = 0;
 			dst[loc].length = dst[loc + 1].vcn;
 		}
-		dst[loc].lcn = LCN_RL_NOT_MAPPED;
+		dst[loc].lcn = NTFS_LCN_RL_NOT_MAPPED;
 	}
 	return dst;
 }

 /**
- * ntfs_rl_replace - overwrite a runlist element with another runlist
- * @dst:	original runlist to be worked on
+ * ntfs_rl_replace - overwrite a ntfs_runlist element with another ntfs_runlist
+ * @dst:	original ntfs_runlist to be worked on
  * @dsize:	number of elements in @dst (including end marker)
- * @src:	new runlist to be inserted
+ * @src:	new ntfs_runlist to be inserted
  * @ssize:	number of elements in @src (excluding end marker)
- * @loc:	index in runlist @dst to overwrite with @src
+ * @loc:	index in ntfs_runlist @dst to overwrite with @src
  *
- * Replace the runlist element @dst at @loc with @src. Merge the left and
- * right ends of the inserted runlist, if necessary.
+ * Replace the ntfs_runlist element @dst at @loc with @src. Merge the left and
+ * right ends of the inserted ntfs_runlist, if necessary.
  *
- * On success, return a pointer to the new, combined, runlist. Note, both
+ * On success, return a pointer to the new, combined, ntfs_runlist. Note, both
  * runlists @dst and @src are deallocated before returning so you cannot use
- * the pointers for anything any more. (Strictly speaking the returned runlist
+ * the pointers for anything any more. (Strictly speaking the returned ntfs_runlist
  * may be the same as @dst but this is irrelevant.)
  *
  * On error, return NULL, with errno set to the error code. Both runlists are
  * left unmodified.
  */
-static runlist_element *ntfs_rl_replace(runlist_element *dst,
-		int dsize, runlist_element *src, int ssize, int loc)
+static ntfs_runlist_element *ntfs_rl_replace(ntfs_runlist_element *dst,
+		int dsize, ntfs_runlist_element *src, int ssize, int loc)
 {
 	signed delta;
-	BOOL left  = FALSE;	/* Left end of @src needs merging */
-	BOOL right = FALSE;	/* Right end of @src needs merging */
+	NTFS_BOOL left  = FALSE;	/* Left end of @src needs merging */
+	NTFS_BOOL right = FALSE;	/* Right end of @src needs merging */
 	int tail;		/* Start of tail of @dst */
 	int marker;		/* End of the inserted runs */

@@ -406,34 +406,34 @@
 	ntfs_rl_mc(dst, loc, src, left, ssize - left);

 	/* We may have changed the length of the file, so fix the end marker */
-	if (((dsize - tail) > 0) && (dst[marker].lcn == LCN_ENOENT))
+	if (((dsize - tail) > 0) && (dst[marker].lcn == NTFS_LCN_ENOENT))
 		dst[marker].vcn = dst[marker - 1].vcn + dst[marker - 1].length;

 	return dst;
 }

 /**
- * ntfs_rl_split - insert a runlist into the centre of a hole
- * @dst:	original runlist to be worked on
+ * ntfs_rl_split - insert a ntfs_runlist into the centre of a hole
+ * @dst:	original ntfs_runlist to be worked on
  * @dsize:	number of elements in @dst (including end marker)
- * @src:	new runlist to be inserted
+ * @src:	new ntfs_runlist to be inserted
  * @ssize:	number of elements in @src (excluding end marker)
- * @loc:	index in runlist @dst at which to split and insert @src
+ * @loc:	index in ntfs_runlist @dst at which to split and insert @src
  *
- * Split the runlist @dst at @loc into two and insert @new in between the two
+ * Split the ntfs_runlist @dst at @loc into two and insert @new in between the two
  * fragments. No merging of runlists is necessary. Adjust the size of the
  * holes either side.
  *
- * On success, return a pointer to the new, combined, runlist. Note, both
+ * On success, return a pointer to the new, combined, ntfs_runlist. Note, both
  * runlists @dst and @src are deallocated before returning so you cannot use
- * the pointers for anything any more. (Strictly speaking the returned runlist
+ * the pointers for anything any more. (Strictly speaking the returned ntfs_runlist
  * may be the same as @dst but this is irrelevant.)
  *
  * On error, return NULL, with errno set to the error code. Both runlists are
  * left unmodified.
  */
-static runlist_element *ntfs_rl_split(runlist_element *dst,
-		int dsize, runlist_element *src, int ssize, int loc)
+static ntfs_runlist_element *ntfs_rl_split(ntfs_runlist_element *dst,
+		int dsize, ntfs_runlist_element *src, int ssize, int loc)
 {
 	if (!dst || !src) {
 		ntfs_log_trace("Invoked with NULL pointer!\n");
@@ -465,12 +465,12 @@

 /**
  * ntfs_runlists_merge - merge two runlists into one
- * @drl:	original runlist to be worked on
- * @srl:	new runlist to be merged into @drl
+ * @drl:	original ntfs_runlist to be worked on
+ * @srl:	new ntfs_runlist to be merged into @drl
  *
  * First we sanity check the two runlists @srl and @drl to make sure that they
- * are sensible and can be merged. The runlist @srl must be either after the
- * runlist @drl or completely within a hole (or unmapped region) in @drl.
+ * are sensible and can be merged. The ntfs_runlist @srl must be either after the
+ * ntfs_runlist @drl or completely within a hole (or unmapped region) in @drl.
  *
  * Merging of runlists is necessary in two cases:
  *   1. When attribute lists are used and a further extent is being mapped.
@@ -481,31 +481,31 @@
  *	- split the hole in two and be inserted between the two fragments,
  *	- be appended at the end of a hole, or it can
  *	- replace the whole hole.
- * It can also be appended to the end of the runlist, which is just a variant
+ * It can also be appended to the end of the ntfs_runlist, which is just a variant
  * of the insert case.
  *
- * On success, return a pointer to the new, combined, runlist. Note, both
+ * On success, return a pointer to the new, combined, ntfs_runlist. Note, both
  * runlists @drl and @srl are deallocated before returning so you cannot use
- * the pointers for anything any more. (Strictly speaking the returned runlist
+ * the pointers for anything any more. (Strictly speaking the returned ntfs_runlist
  * may be the same as @dst but this is irrelevant.)
  *
  * On error, return NULL, with errno set to the error code. Both runlists are
  * left unmodified. The following error codes are defined:
- *	ENOMEM		Not enough memory to allocate runlist array.
+ *	ENOMEM		Not enough memory to allocate ntfs_runlist array.
  *	EINVAL		Invalid parameters were passed in.
  *	ERANGE		The runlists overlap and cannot be merged.
  */
-runlist_element *ntfs_runlists_merge(runlist_element *drl,
-		runlist_element *srl)
+ntfs_runlist_element *ntfs_runlists_merge(ntfs_runlist_element *drl,
+		ntfs_runlist_element *srl)
 {
 	int di, si;		/* Current index into @[ds]rl. */
-	int sstart;		/* First index with lcn > LCN_RL_NOT_MAPPED. */
+	int sstart;		/* First index with lcn > NTFS_LCN_RL_NOT_MAPPED. */
 	int dins;		/* Index into @drl at which to insert @srl. */
 	int dend, send;		/* Last index into @[ds]rl. */
 	int dfinal, sfinal;	/* The last index into @[ds]rl with
-				   lcn >= LCN_HOLE. */
+				   lcn >= NTFS_LCN_HOLE. */
 	int marker = 0;
-	VCN marker_vcn = 0;
+	NTFS_VCN marker_vcn = 0;

 	ntfs_log_debug("dst:\n");
 	ntfs_debug_runlist_dump(drl);
@@ -519,19 +519,19 @@
 	/* Check for the case where the first mapping is being done now. */
 	if (!drl) {
 		drl = srl;
-		/* Complete the source runlist if necessary. */
+		/* Complete the source ntfs_runlist if necessary. */
 		if (drl[0].vcn) {
-			/* Scan to the end of the source runlist. */
+			/* Scan to the end of the source ntfs_runlist. */
 			for (dend = 0; drl[dend].length; dend++)
 				;
 			dend++;
 			drl = ntfs_rl_realloc(drl, dend, dend + 1);
 			if (!drl)
 				return drl;
-			/* Insert start element at the front of the runlist. */
+			/* Insert start element at the front of the ntfs_runlist. */
 			ntfs_rl_mm(drl, 1, 0, dend);
 			drl[0].vcn = 0;
-			drl[0].lcn = LCN_RL_NOT_MAPPED;
+			drl[0].lcn = NTFS_LCN_RL_NOT_MAPPED;
 			drl[0].length = drl[1].vcn;
 		}
 		goto finished;
@@ -539,14 +539,14 @@

 	si = di = 0;

-	/* Skip any unmapped start element(s) in the source runlist. */
-	while (srl[si].length && srl[si].lcn < (LCN)LCN_HOLE)
+	/* Skip any unmapped start element(s) in the source ntfs_runlist. */
+	while (srl[si].length && srl[si].lcn < (NTFS_LCN)NTFS_LCN_HOLE)
 		si++;

-	/* Can't have an entirely unmapped source runlist. */
+	/* Can't have an entirely unmapped source ntfs_runlist. */
 	if (!srl[si].length) {
 		ntfs_log_debug("Eeek! ntfs_runlists_merge() received entirely "
-				"unmapped source runlist.\n");
+				"unmapped source ntfs_runlist.\n");
 		errno = EINVAL;
 		return NULL;
 	}
@@ -579,24 +579,24 @@
 	for (dend = di; drl[dend].length; dend++)
 		;

-	if (srl[send].lcn == (LCN)LCN_ENOENT)
+	if (srl[send].lcn == (NTFS_LCN)NTFS_LCN_ENOENT)
 		marker_vcn = srl[marker = send].vcn;

-	/* Scan to the last element with lcn >= LCN_HOLE. */
-	for (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)
+	/* Scan to the last element with lcn >= NTFS_LCN_HOLE. */
+	for (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < NTFS_LCN_HOLE; sfinal--)
 		;
-	for (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)
+	for (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < NTFS_LCN_HOLE; dfinal--)
 		;

 	{
-	BOOL start;
-	BOOL finish;
+	NTFS_BOOL start;
+	NTFS_BOOL finish;
 	int ds = dend + 1;		/* Number of elements in drl & srl */
 	int ss = sfinal - sstart + 1;

-	start  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */
+	start  = ((drl[dins].lcn <  NTFS_LCN_RL_NOT_MAPPED) ||    /* End of file   */
 		  (drl[dins].vcn == srl[sstart].vcn));	     /* Start of hole */
-	finish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */
+	finish = ((drl[dins].lcn >= NTFS_LCN_RL_NOT_MAPPED) &&    /* End of file   */
 		 ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */
 		  (srl[send - 1].vcn + srl[send - 1].length)));

@@ -637,22 +637,22 @@

 			if (drl[ds].vcn == marker_vcn) {
 				ntfs_log_debug("Old marker = %lli, replacing with "
-						"LCN_ENOENT.\n",
+						"NTFS_LCN_ENOENT.\n",
 						(long long)drl[ds].lcn);
-				drl[ds].lcn = (LCN)LCN_ENOENT;
+				drl[ds].lcn = (NTFS_LCN)NTFS_LCN_ENOENT;
 				goto finished;
 			}
 			/*
-			 * We need to create an unmapped runlist element in
+			 * We need to create an unmapped ntfs_runlist element in
 			 * @drl or extend an existing one before adding the
 			 * ENOENT terminator.
 			 */
-			if (drl[ds].lcn == (LCN)LCN_ENOENT) {
+			if (drl[ds].lcn == (NTFS_LCN)NTFS_LCN_ENOENT) {
 				ds--;
 				slots = 1;
 			}
-			if (drl[ds].lcn != (LCN)LCN_RL_NOT_MAPPED) {
-				/* Add an unmapped runlist element. */
+			if (drl[ds].lcn != (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED) {
+				/* Add an unmapped ntfs_runlist element. */
 				if (!slots) {
 					/* FIXME/TODO: We need to have the
 					 * extra memory already! (AIA)
@@ -667,7 +667,7 @@
 				if (slots != 1)
 					drl[ds].vcn = drl[ds - 1].vcn +
 							drl[ds - 1].length;
-				drl[ds].lcn = (LCN)LCN_RL_NOT_MAPPED;
+				drl[ds].lcn = (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED;
 				/* We now used up a slot. */
 				slots--;
 			}
@@ -683,7 +683,7 @@
 					goto critical_error;
 			}
 			drl[ds].vcn = marker_vcn;
-			drl[ds].lcn = (LCN)LCN_ENOENT;
+			drl[ds].lcn = (NTFS_LCN)NTFS_LCN_ENOENT;
 			drl[ds].length = (s64)0;
 		}
 	}
@@ -691,7 +691,7 @@

 finished:
 	/* The merge was completed successfully. */
-	ntfs_log_debug("Merged runlist:\n");
+	ntfs_log_debug("Merged ntfs_runlist:\n");
 	ntfs_debug_runlist_dump(drl);
 	return drl;

@@ -699,48 +699,48 @@
 	/* Critical error! We cannot afford to fail here. */
 	ntfs_log_perror("libntfs: Critical error");
 	ntfs_log_debug("Forcing segmentation fault!\n");
-	marker_vcn = ((runlist*)NULL)->lcn;
+	marker_vcn = ((ntfs_runlist*)NULL)->lcn;
 	return drl;
 }

 /**
- * ntfs_mapping_pairs_decompress - convert mapping pairs array to runlist
+ * ntfs_mapping_pairs_decompress - convert mapping pairs array to ntfs_runlist
  * @vol:	ntfs volume on which the attribute resides
  * @attr:	attribute record whose mapping pairs array to decompress
- * @old_rl:	optional runlist in which to insert @attr's runlist
+ * @old_rl:	optional ntfs_runlist in which to insert @attr's ntfs_runlist
  *
- * Decompress the attribute @attr's mapping pairs array into a runlist. On
- * success, return the decompressed runlist.
+ * Decompress the attribute @attr's mapping pairs array into a ntfs_runlist. On
+ * success, return the decompressed ntfs_runlist.
  *
- * If @old_rl is not NULL, decompressed runlist is inserted into the
- * appropriate place in @old_rl and the resultant, combined runlist is
+ * If @old_rl is not NULL, decompressed ntfs_runlist is inserted into the
+ * appropriate place in @old_rl and the resultant, combined ntfs_runlist is
  * returned. The original @old_rl is deallocated.
  *
  * On error, return NULL with errno set to the error code. @old_rl is left
  * unmodified in that case.
  *
  * The following error codes are defined:
- *	ENOMEM		Not enough memory to allocate runlist array.
- *	EIO		Corrupt runlist.
+ *	ENOMEM		Not enough memory to allocate ntfs_runlist array.
+ *	EIO		Corrupt ntfs_runlist.
  *	EINVAL		Invalid parameters were passed in.
  *	ERANGE		The two runlists overlap.
  *
  * FIXME: For now we take the conceptionally simplest approach of creating the
- * new runlist disregarding the already existing one and then splicing the
+ * new ntfs_runlist disregarding the already existing one and then splicing the
  * two into one, if that is possible (we check for overlap and discard the new
- * runlist if overlap present before returning NULL, with errno = ERANGE).
+ * ntfs_runlist if overlap present before returning NULL, with errno = ERANGE).
  */
-runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,
-		const ATTR_RECORD *attr, runlist_element *old_rl)
+ntfs_runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,
+		const NTFS_ATTR_RECORD *attr, ntfs_runlist_element *old_rl)
 {
-	VCN vcn;		/* Current vcn. */
-	LCN lcn;		/* Current lcn. */
+	NTFS_VCN vcn;		/* Current vcn. */
+	NTFS_LCN lcn;		/* Current lcn. */
 	s64 deltaxcn;		/* Change in [vl]cn. */
-	runlist_element *rl;	/* The output runlist. */
+	ntfs_runlist_element *rl;	/* The output ntfs_runlist. */
 	const u8 *buf;		/* Current position in mapping pairs array. */
 	const u8 *attr_end;	/* End of attribute. */
-	int err, rlsize;	/* Size of runlist buffer. */
-	u16 rlpos;		/* Current runlist position in units of
+	int err, rlsize;	/* Size of ntfs_runlist buffer. */
+	u16 rlpos;		/* Current ntfs_runlist position in units of
 				   runlist_elements. */
 	u8 b;			/* Current byte offset in buf. */

@@ -748,7 +748,7 @@
 			(unsigned)le32_to_cpu(attr->type));
 	/* Make sure attr exists and is non-resident. */
 	if (!attr || !attr->non_resident ||
-			sle64_to_cpu(attr->lowest_vcn) < (VCN)0) {
+			sle64_to_cpu(attr->lowest_vcn) < (NTFS_VCN)0) {
 		errno = EINVAL;
 		return NULL;
 	}
@@ -763,17 +763,17 @@
 		errno = EIO;
 		return NULL;
 	}
-	/* Current position in runlist array. */
+	/* Current position in ntfs_runlist array. */
 	rlpos = 0;
-	/* Allocate first 4kiB block and set current runlist size to 4kiB. */
+	/* Allocate first 4kiB block and set current ntfs_runlist size to 4kiB. */
 	rlsize = 0x1000;
 	rl = ntfs_malloc(rlsize);
 	if (!rl)
 		return NULL;
 	/* Insert unmapped starting element if necessary. */
 	if (vcn) {
-		rl->vcn = (VCN)0;
-		rl->lcn = (LCN)LCN_RL_NOT_MAPPED;
+		rl->vcn = (NTFS_VCN)0;
+		rl->lcn = (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED;
 		rl->length = vcn;
 		rlpos++;
 	}
@@ -783,7 +783,7 @@
 		 * not-mapped and terminator elements.
 		 */
 		if ((int)((rlpos + 3) * sizeof(*old_rl)) > rlsize) {
-			runlist_element *rl2;
+			ntfs_runlist_element *rl2;

 			rlsize += 0x1000;
 			rl2 = realloc(rl, rlsize);
@@ -795,7 +795,7 @@
 			}
 			rl = rl2;
 		}
-		/* Enter the current vcn into the current runlist element. */
+		/* Enter the current vcn into the current ntfs_runlist element. */
 		rl[rlpos].vcn = vcn;
 		/*
 		 * Get the change in vcn, i.e. the run length in clusters.
@@ -824,7 +824,7 @@
 			goto err_out;
 		}
 		/*
-		 * Enter the current run length into the current runlist
+		 * Enter the current run length into the current ntfs_runlist
 		 * element.
 		 */
 		rl[rlpos].length = deltaxcn;
@@ -833,10 +833,10 @@
 		/*
 		 * There might be no lcn change at all, as is the case for
 		 * sparse clusters on NTFS 3.0+, in which case we set the lcn
-		 * to LCN_HOLE.
+		 * to NTFS_LCN_HOLE.
 		 */
 		if (!(*buf & 0xf0))
-			rl[rlpos].lcn = (LCN)LCN_HOLE;
+			rl[rlpos].lcn = (NTFS_LCN)NTFS_LCN_HOLE;
 		else {
 			/* Get the lcn change which really can be negative. */
 			u8 b2 = *buf & 0xf;
@@ -856,22 +856,22 @@
 			 * can investigate it further!
 			 */
 			if (vol->major_ver < 3) {
-				if (deltaxcn == (LCN)-1)
+				if (deltaxcn == (NTFS_LCN)-1)
 					ntfs_log_debug("lcn delta == -1\n");
-				if (lcn == (LCN)-1)
+				if (lcn == (NTFS_LCN)-1)
 					ntfs_log_debug("lcn == -1\n");
 			}
 #endif
 			/* Check lcn is not below -1. */
-			if (lcn < (LCN)-1) {
-				ntfs_log_debug("Invalid LCN < -1 in mapping pairs "
+			if (lcn < (NTFS_LCN)-1) {
+				ntfs_log_debug("Invalid NTFS_LCN < -1 in mapping pairs "
 						"array.\n");
 				goto err_out;
 			}
-			/* Enter the current lcn into the runlist element. */
+			/* Enter the current lcn into the ntfs_runlist element. */
 			rl[rlpos].lcn = lcn;
 		}
-		/* Get to the next runlist element. */
+		/* Get to the next ntfs_runlist element. */
 		rlpos++;
 		/* Increment the buffer position to the next mapping pair. */
 		buf += (*buf & 0xf) + ((*buf >> 4) & 0xf) + 1;
@@ -880,7 +880,7 @@
 		goto io_error;
 	/*
 	 * If there is a highest_vcn specified, it must be equal to the final
-	 * vcn in the runlist - 1, or something has gone badly wrong.
+	 * vcn in the ntfs_runlist - 1, or something has gone badly wrong.
 	 */
 	deltaxcn = sle64_to_cpu(attr->highest_vcn);
 	if (deltaxcn && vcn - 1 != deltaxcn) {
@@ -889,21 +889,21 @@
 				"attribute.\n");
 		goto err_out;
 	}
-	/* Setup not mapped runlist element if this is the base extent. */
+	/* Setup not mapped ntfs_runlist element if this is the base extent. */
 	if (!attr->lowest_vcn) {
-		VCN max_cluster;
+		NTFS_VCN max_cluster;

 		max_cluster = ((sle64_to_cpu(attr->allocated_size) +
 				vol->cluster_size - 1) >>
 				vol->cluster_size_bits) - 1;
 		/*
 		 * A highest_vcn of zero means this is a single extent
-		 * attribute so simply terminate the runlist with LCN_ENOENT).
+		 * attribute so simply terminate the ntfs_runlist with NTFS_LCN_ENOENT).
 		 */
 		if (deltaxcn) {
 			/*
 			 * If there is a difference between the highest_vcn and
-			 * the highest cluster, the runlist is either corrupt
+			 * the highest cluster, the ntfs_runlist is either corrupt
 			 * or, more likely, there are more extents following
 			 * this one.
 			 */
@@ -914,7 +914,7 @@
 						(long long)max_cluster);
 				rl[rlpos].vcn = vcn;
 				vcn += rl[rlpos].length = max_cluster - deltaxcn;
-				rl[rlpos].lcn = (LCN)LCN_RL_NOT_MAPPED;
+				rl[rlpos].lcn = (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED;
 				rlpos++;
 			} else if (deltaxcn > max_cluster) {
 				ntfs_log_debug("Corrupt attribute. deltaxcn = "
@@ -924,14 +924,14 @@
 				goto mpa_err;
 			}
 		}
-		rl[rlpos].lcn = (LCN)LCN_ENOENT;
+		rl[rlpos].lcn = (NTFS_LCN)NTFS_LCN_ENOENT;
 	} else /* Not the base extent. There may be more extents to follow. */
-		rl[rlpos].lcn = (LCN)LCN_RL_NOT_MAPPED;
+		rl[rlpos].lcn = (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED;

-	/* Setup terminating runlist element. */
+	/* Setup terminating ntfs_runlist element. */
 	rl[rlpos].vcn = vcn;
 	rl[rlpos].length = (s64)0;
-	/* If no existing runlist was specified, we are done. */
+	/* If no existing ntfs_runlist was specified, we are done. */
 	if (!old_rl) {
 		ntfs_log_debug("Mapping pairs array successfully decompressed:\n");
 		ntfs_debug_runlist_dump(rl);
@@ -955,70 +955,70 @@
 }

 /**
- * ntfs_rl_vcn_to_lcn - convert a vcn into a lcn given a runlist
- * @rl:		runlist to use for conversion
+ * ntfs_rl_vcn_to_lcn - convert a vcn into a lcn given a ntfs_runlist
+ * @rl:		ntfs_runlist to use for conversion
  * @vcn:	vcn to convert
  *
  * Convert the virtual cluster number @vcn of an attribute into a logical
- * cluster number (lcn) of a device using the runlist @rl to map vcns to their
+ * cluster number (lcn) of a device using the ntfs_runlist @rl to map vcns to their
  * corresponding lcns.
  *
  * Since lcns must be >= 0, we use negative return values with special meaning:
  *
  * Return value			Meaning / Description
  * ==================================================
- *  -1 = LCN_HOLE		Hole / not allocated on disk.
- *  -2 = LCN_RL_NOT_MAPPED	This is part of the runlist which has not been
- *				inserted into the runlist yet.
- *  -3 = LCN_ENOENT		There is no such vcn in the attribute.
- *  -4 = LCN_EINVAL		Input parameter error.
+ *  -1 = NTFS_LCN_HOLE		Hole / not allocated on disk.
+ *  -2 = NTFS_LCN_RL_NOT_MAPPED	This is part of the ntfs_runlist which has not been
+ *				inserted into the ntfs_runlist yet.
+ *  -3 = NTFS_LCN_ENOENT		There is no such vcn in the attribute.
+ *  -4 = NTFS_LCN_EINVAL		Input parameter error.
  */
-LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)
+NTFS_LCN ntfs_rl_vcn_to_lcn(const ntfs_runlist_element *rl, const NTFS_VCN vcn)
 {
 	int i;

-	if (vcn < (VCN)0)
-		return (LCN)LCN_EINVAL;
+	if (vcn < (NTFS_VCN)0)
+		return (NTFS_LCN)NTFS_LCN_EINVAL;
 	/*
-	 * If rl is NULL, assume that we have found an unmapped runlist. The
+	 * If rl is NULL, assume that we have found an unmapped ntfs_runlist. The
 	 * caller can then attempt to map it and fail appropriately if
 	 * necessary.
 	 */
 	if (!rl)
-		return (LCN)LCN_RL_NOT_MAPPED;
+		return (NTFS_LCN)NTFS_LCN_RL_NOT_MAPPED;

 	/* Catch out of lower bounds vcn. */
 	if (vcn < rl[0].vcn)
-		return (LCN)LCN_ENOENT;
+		return (NTFS_LCN)NTFS_LCN_ENOENT;

 	for (i = 0; rl[i].length; i++) {
 		if (vcn < rl[i+1].vcn) {
-			if (rl[i].lcn >= (LCN)0)
+			if (rl[i].lcn >= (NTFS_LCN)0)
 				return rl[i].lcn + (vcn - rl[i].vcn);
 			return rl[i].lcn;
 		}
 	}
 	/*
 	 * The terminator element is setup to the correct value, i.e. one of
-	 * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.
+	 * NTFS_LCN_HOLE, NTFS_LCN_RL_NOT_MAPPED, or NTFS_LCN_ENOENT.
 	 */
-	if (rl[i].lcn < (LCN)0)
+	if (rl[i].lcn < (NTFS_LCN)0)
 		return rl[i].lcn;
 	/* Just in case... We could replace this with BUG() some day. */
-	return (LCN)LCN_ENOENT;
+	return (NTFS_LCN)NTFS_LCN_ENOENT;
 }

 /**
  * ntfs_rl_pread - gather read from disk
  * @vol:	ntfs volume to read from
- * @rl:		runlist specifying where to read the data from
- * @pos:	byte position within runlist @rl at which to begin the read
+ * @rl:		ntfs_runlist specifying where to read the data from
+ * @pos:	byte position within ntfs_runlist @rl at which to begin the read
  * @count:	number of bytes to read
  * @b:		data buffer into which to read from disk
  *
  * This function will read @count bytes from the volume @vol to the data buffer
- * @b gathering the data as specified by the runlist @rl. The read begins at
- * offset @pos into the runlist @rl.
+ * @b gathering the data as specified by the ntfs_runlist @rl. The read begins at
+ * offset @pos into the ntfs_runlist @rl.
  *
  * On success, return the number of successfully read bytes. If this number is
  * lower than @count this means that the read reached end of file or that an
@@ -1032,7 +1032,7 @@
  * NOTE: If we encounter EOF while reading we return EIO because we assume that
  * the run list must point to valid locations within the ntfs volume.
  */
-s64 ntfs_rl_pread(const ntfs_volume *vol, const runlist_element *rl,
+s64 ntfs_rl_pread(const ntfs_volume *vol, const ntfs_runlist_element *rl,
 		const s64 pos, s64 count, void *b)
 {
 	s64 bytes_read, to_read, ofs, total;
@@ -1053,8 +1053,8 @@
 	for (total = 0LL; count; rl++, ofs = 0) {
 		if (!rl->length)
 			goto rl_err_out;
-		if (rl->lcn < (LCN)0) {
-			if (rl->lcn != (LCN)LCN_HOLE)
+		if (rl->lcn < (NTFS_LCN)0) {
+			if (rl->lcn != (NTFS_LCN)NTFS_LCN_HOLE)
 				goto rl_err_out;
 			/* It is a hole. Just fill buffer @b with zeroes. */
 			to_read = min(count, (rl->length <<
@@ -1098,14 +1098,14 @@
 /**
  * ntfs_rl_pwrite - scatter write to disk
  * @vol:	ntfs volume to write to
- * @rl:		runlist specifying where to write the data to
- * @pos:	byte position within runlist @rl at which to begin the write
+ * @rl:		ntfs_runlist specifying where to write the data to
+ * @pos:	byte position within ntfs_runlist @rl at which to begin the write
  * @count:	number of bytes to write
  * @b:		data buffer to write to disk
  *
  * This function will write @count bytes from data buffer @b to the volume @vol
- * scattering the data as specified by the runlist @rl. The write begins at
- * offset @pos into the runlist @rl.
+ * scattering the data as specified by the ntfs_runlist @rl. The write begins at
+ * offset @pos into the ntfs_runlist @rl.
  *
  * On success, return the number of successfully written bytes. If this number
  * is lower than @count this means that the write has been interrupted in
@@ -1116,7 +1116,7 @@
  * appropriately to the return code of ntfs_pwrite(), or to to EINVAL in case
  * of invalid arguments.
  */
-s64 ntfs_rl_pwrite(const ntfs_volume *vol, const runlist_element *rl,
+s64 ntfs_rl_pwrite(const ntfs_volume *vol, const ntfs_runlist_element *rl,
 		const s64 pos, s64 count, void *b)
 {
 	s64 written, to_write, ofs, total;
@@ -1137,11 +1137,11 @@
 	for (total = 0LL; count; rl++, ofs = 0) {
 		if (!rl->length)
 			goto rl_err_out;
-		if (rl->lcn < (LCN)0) {
+		if (rl->lcn < (NTFS_LCN)0) {
 			s64 t;
 			int cnt;

-			if (rl->lcn != (LCN)LCN_HOLE)
+			if (rl->lcn != (NTFS_LCN)NTFS_LCN_HOLE)
 				goto rl_err_out;
 			/*
 			 * It is a hole. Check if the buffer is zero in this
@@ -1211,13 +1211,13 @@
 /**
  * ntfs_rl_fill_zero - fill given region with zeroes
  * @vol:	ntfs volume to write to
- * @rl:		runlist specifying where to write zeroes to
- * @pos:	byte position within runlist @rl at which to begin the zeroing
+ * @rl:		ntfs_runlist specifying where to write zeroes to
+ * @pos:	byte position within ntfs_runlist @rl at which to begin the zeroing
  * @count:	number of bytes to fill with zeros
  *
  * Return 0 on success and -1 on error with errno set to the error code.
  */
-int ntfs_rl_fill_zero(const ntfs_volume *vol, const runlist *rl, s64 pos,
+int ntfs_rl_fill_zero(const ntfs_volume *vol, const ntfs_runlist *rl, s64 pos,
 		const s64 count)
 {
 	char *buf;
@@ -1284,11 +1284,11 @@
 /**
  * ntfs_get_size_for_mapping_pairs - get bytes needed for mapping pairs array
  * @vol:	ntfs volume (needed for the ntfs version)
- * @rl:		runlist for which to determine the size of the mapping pairs
+ * @rl:		ntfs_runlist for which to determine the size of the mapping pairs
  * @start_vcn:	vcn at which to start the mapping pairs array
  *
- * Walk the runlist @rl and calculate the size in bytes of the mapping pairs
- * array corresponding to the runlist @rl, starting at vcn @start_vcn.  This
+ * Walk the ntfs_runlist @rl and calculate the size in bytes of the mapping pairs
+ * array corresponding to the ntfs_runlist @rl, starting at vcn @start_vcn.  This
  * for example allows us to allocate a buffer of the right size when building
  * the mapping pairs array.
  *
@@ -1299,12 +1299,12 @@
  *	EINVAL	- Run list contains unmapped elements. Make sure to only pass
  *		  fully mapped runlists to this function.
  *		- @start_vcn is invalid.
- *	EIO	- The runlist is corrupt.
+ *	EIO	- The ntfs_runlist is corrupt.
  */
 int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,
-		const runlist_element *rl, const VCN start_vcn)
+		const ntfs_runlist_element *rl, const NTFS_VCN start_vcn)
 {
-	LCN prev_lcn;
+	NTFS_LCN prev_lcn;
 	int rls;

 	if (start_vcn < 0) {
@@ -1322,7 +1322,7 @@
 		}
 		return 1;
 	}
-	/* Skip to runlist element containing @start_vcn. */
+	/* Skip to ntfs_runlist element containing @start_vcn. */
 	while (rl->length && start_vcn >= rl[1].vcn)
 		rl++;
 	if ((!rl->length && start_vcn > rl->vcn) || start_vcn < rl->vcn) {
@@ -1337,7 +1337,7 @@
 		s64 delta;

 		/* We know rl->length != 0 already. */
-		if (rl->length < 0 || rl->lcn < LCN_HOLE)
+		if (rl->length < 0 || rl->lcn < NTFS_LCN_HOLE)
 			goto err_out;
 		delta = start_vcn - rl->vcn;
 		/* Header byte + length. */
@@ -1356,12 +1356,12 @@
 			/* Change in lcn. */
 			rls += ntfs_get_nr_significant_bytes(prev_lcn);
 		}
-		/* Go to next runlist element. */
+		/* Go to next ntfs_runlist element. */
 		rl++;
 	}
 	/* Do the full runs. */
 	for (; rl->length; rl++) {
-		if (rl->length < 0 || rl->lcn < LCN_HOLE)
+		if (rl->length < 0 || rl->lcn < NTFS_LCN_HOLE)
 			goto err_out;
 		/* Header byte + length. */
 		rls += 1 + ntfs_get_nr_significant_bytes(rl->length);
@@ -1381,7 +1381,7 @@
 	}
 	return rls;
 err_out:
-	if (rl->lcn == LCN_RL_NOT_MAPPED)
+	if (rl->lcn == NTFS_LCN_RL_NOT_MAPPED)
 		errno = EINVAL;
 	else
 		errno = EIO;
@@ -1399,7 +1399,7 @@
  * @dest_max, the maximum position within @dst to which we are allowed to
  * write.
  *
- * This is used when building the mapping pairs array of a runlist to compress
+ * This is used when building the mapping pairs array of a ntfs_runlist to compress
  * a given logical cluster number (lcn) or a specific run length to the minimum
  * size possible.
  *
@@ -1440,15 +1440,15 @@
 }

 /**
- * ntfs_mapping_pairs_build - build the mapping pairs array from a runlist
+ * ntfs_mapping_pairs_build - build the mapping pairs array from a ntfs_runlist
  * @vol:	ntfs volume (needed for the ntfs version)
  * @dst:	destination buffer to which to write the mapping pairs array
  * @dst_len:	size of destination buffer @dst in bytes
- * @rl:		runlist for which to build the mapping pairs array
+ * @rl:		ntfs_runlist for which to build the mapping pairs array
  * @start_vcn:	vcn at which to start the mapping pairs array
  * @stop_vcn:	first vcn outside destination buffer on success or ENOSPC error
  *
- * Create the mapping pairs array from the runlist @rl, starting at vcn
+ * Create the mapping pairs array from the ntfs_runlist @rl, starting at vcn
  * @start_vcn and save the array in @dst.  @dst_len is the size of @dst in
  * bytes and it should be at least equal to the value obtained by calling
  * ntfs_get_size_for_mapping_pairs().
@@ -1467,14 +1467,14 @@
  *	EINVAL	- Run list contains unmapped elements. Make sure to only pass
  *		  fully mapped runlists to this function.
  *		- @start_vcn is invalid.
- *	EIO	- The runlist is corrupt.
+ *	EIO	- The ntfs_runlist is corrupt.
  *	ENOSPC	- The destination buffer is too small.
  */
 int ntfs_mapping_pairs_build(const ntfs_volume *vol, u8 *dst,
-		const int dst_len, const runlist_element *rl,
-		const VCN start_vcn, VCN *const stop_vcn)
+		const int dst_len, const ntfs_runlist_element *rl,
+		const NTFS_VCN start_vcn, NTFS_VCN *const stop_vcn)
 {
-	LCN prev_lcn;
+	NTFS_LCN prev_lcn;
 	u8 *dst_max, *dst_next;
 	s8 len_len, lcn_len;

@@ -1493,7 +1493,7 @@
 		*dst = 0;
 		return 0;
 	}
-	/* Skip to runlist element containing @start_vcn. */
+	/* Skip to ntfs_runlist element containing @start_vcn. */
 	while (rl->length && start_vcn >= rl[1].vcn)
 		rl++;
 	if ((!rl->length && start_vcn > rl->vcn) || start_vcn < rl->vcn)
@@ -1509,7 +1509,7 @@
 		s64 delta;

 		/* We know rl->length != 0 already. */
-		if (rl->length < 0 || rl->lcn < LCN_HOLE)
+		if (rl->length < 0 || rl->lcn < NTFS_LCN_HOLE)
 			goto err_out;
 		delta = start_vcn - rl->vcn;
 		/* Write length. */
@@ -1544,12 +1544,12 @@
 		*dst = lcn_len << 4 | len_len;
 		/* Position at next mapping pairs array element. */
 		dst = dst_next;
-		/* Go to next runlist element. */
+		/* Go to next ntfs_runlist element. */
 		rl++;
 	}
 	/* Do the full runs. */
 	for (; rl->length; rl++) {
-		if (rl->length < 0 || rl->lcn < LCN_HOLE)
+		if (rl->length < 0 || rl->lcn < NTFS_LCN_HOLE)
 			goto err_out;
 		/* Write length. */
 		len_len = ntfs_write_significant_bytes(dst + 1, dst_max,
@@ -1600,7 +1600,7 @@
 	errno = EINVAL;
 	return -1;
 err_out:
-	if (rl->lcn == LCN_RL_NOT_MAPPED)
+	if (rl->lcn == NTFS_LCN_RL_NOT_MAPPED)
 		errno = EINVAL;
 	else
 		errno = EIO;
@@ -1608,21 +1608,21 @@
 }

 /**
- * ntfs_rl_truncate - truncate a runlist starting at a specified vcn
- * @arl:	address of runlist to truncate
+ * ntfs_rl_truncate - truncate a ntfs_runlist starting at a specified vcn
+ * @arl:	address of ntfs_runlist to truncate
  * @start_vcn:	first vcn which should be cut off
  *
- * Truncate the runlist *@arl starting at vcn @start_vcn as well as the memory
- * buffer holding the runlist.
+ * Truncate the ntfs_runlist *@arl starting at vcn @start_vcn as well as the memory
+ * buffer holding the ntfs_runlist.
  *
  * Return 0 on success and -1 on error with errno set to the error code.
  *
- * NOTE: @arl is the address of the runlist. We need the address so we can
- * modify the pointer to the runlist with the new, reallocated memory buffer.
+ * NOTE: @arl is the address of the ntfs_runlist. We need the address so we can
+ * modify the pointer to the ntfs_runlist with the new, reallocated memory buffer.
  */
-int ntfs_rl_truncate(runlist **arl, const VCN start_vcn)
+int ntfs_rl_truncate(ntfs_runlist **arl, const NTFS_VCN start_vcn)
 {
-	runlist *rl;
+	ntfs_runlist *rl;

 	if (!arl || !*arl) {
 		errno = EINVAL;
@@ -1634,7 +1634,7 @@

 	if (start_vcn < rl->vcn) {
 		errno = EINVAL;
-		ntfs_log_perror("Start_vcn lies outside front of runlist");
+		ntfs_log_perror("Start_vcn lies outside front of ntfs_runlist");
 		return -1;
 	}

@@ -1647,7 +1647,7 @@

 	if (!rl->length) {
 		errno = EIO;
-		ntfs_log_trace("Truncating already truncated runlist?\n");
+		ntfs_log_trace("Truncating already truncated ntfs_runlist?\n");
 		return -1;
 	}

@@ -1655,8 +1655,8 @@
 	rl->length = start_vcn - rl->vcn;

 	/*
-	 * If a run was partially truncated, make the following runlist
-	 * element a terminator instead of the truncated runlist
+	 * If a run was partially truncated, make the following ntfs_runlist
+	 * element a terminator instead of the truncated ntfs_runlist
 	 * element itself.
 	 */
 	if (rl->length) {
@@ -1664,23 +1664,23 @@
 		rl->vcn = start_vcn;
 		rl->length = 0;
 	}
-	rl->lcn = (LCN)LCN_ENOENT;
+	rl->lcn = (NTFS_LCN)NTFS_LCN_ENOENT;
 	return 0;
 }

 /**
- * ntfs_rl_sparse - check whether runlist have sparse regions or not.
- * @rl:		runlist to check
+ * ntfs_rl_sparse - check whether ntfs_runlist have sparse regions or not.
+ * @rl:		ntfs_runlist to check
  *
  * This function just skips not mapped regions assuming they are not sparse,
- * so you need to ensure that runlist is fully mapped if you want perform full
+ * so you need to ensure that ntfs_runlist is fully mapped if you want perform full
  * check.
  *
  * Return 1 if have, 0 if not, -1 on error with errno set to the error code.
  */
-int ntfs_rl_sparse(runlist *rl)
+int ntfs_rl_sparse(ntfs_runlist *rl)
 {
-	runlist *rlc;
+	ntfs_runlist *rlc;

 	if (!rl) {
 		ntfs_log_trace("Invalid argument passed.\n");
@@ -1690,10 +1690,10 @@

 	for (rlc = rl; rlc->length; rlc++) {
 		if (rlc->lcn < 0) {
-			if (rlc->lcn == LCN_RL_NOT_MAPPED)
+			if (rlc->lcn == NTFS_LCN_RL_NOT_MAPPED)
 				continue;
-			if (rlc->lcn != LCN_HOLE) {
-				ntfs_log_trace("Bad runlist.\n");
+			if (rlc->lcn != NTFS_LCN_HOLE) {
+				ntfs_log_trace("Bad ntfs_runlist.\n");
 				errno = EIO;
 				return -1;
 			}
@@ -1706,13 +1706,13 @@
 /**
  * ntfs_rl_get_compressed_size - calculate length of non sparse regions
  * @vol:	ntfs volume (need for cluster size)
- * @rl:		runlist to calculate for
+ * @rl:		ntfs_runlist to calculate for
  *
  * Return compressed size or -1 on error with errno set to the error code.
  */
-s64 ntfs_rl_get_compressed_size(ntfs_volume *vol, runlist *rl)
+s64 ntfs_rl_get_compressed_size(ntfs_volume *vol, ntfs_runlist *rl)
 {
-	runlist *rlc;
+	ntfs_runlist *rlc;
 	s64 ret = 0;

 	if (!rl) {
@@ -1723,8 +1723,8 @@

 	for (rlc = rl; rlc->length; rlc++) {
 		if (rlc->lcn < 0) {
-			if (rlc->lcn != LCN_HOLE) {
-				ntfs_log_trace("Received unmapped runlist.\n");
+			if (rlc->lcn != NTFS_LCN_HOLE) {
+				ntfs_log_trace("Received unmapped ntfs_runlist.\n");
 				errno = EINVAL;
 				return -1;
 			}
@@ -1747,14 +1747,14 @@
 }
 */
 /**
- * test_rl_dump_runlist - Runlist test: Display the contents of a runlist
+ * test_rl_dump_runlist - Runlist test: Display the contents of a ntfs_runlist
  * @rl:
  *
  * Description...
  *
  * Returns:
  */
-static void test_rl_dump_runlist(const runlist_element *rl)
+static void test_rl_dump_runlist(const ntfs_runlist_element *rl)
 {
 	int abbr = 0;	/* abbreviate long lists */
 	int len = 0;
@@ -1769,9 +1769,9 @@
 	if (abbr)
 		for (len = 0; rl[len].length; len++) ;

-	printf("     VCN      LCN      len\n");
+	printf("     NTFS_VCN      NTFS_LCN      len\n");
 	for (i = 0; ; i++, rl++) {
-		LCN lcn = rl->lcn;
+		NTFS_LCN lcn = rl->lcn;

 		if ((abbr) && (len > 20)) {
 			if (i == 4)
@@ -1780,10 +1780,10 @@
 				continue;
 		}

-		if (lcn < (LCN)0) {
+		if (lcn < (NTFS_LCN)0) {
 			int ind = -lcn - 1;

-			if (ind > -LCN_ENOENT - 1)
+			if (ind > -NTFS_LCN_ENOENT - 1)
 				ind = 3;
 			printf("%8lld %8s %8lld\n",
 				rl->vcn, lcn_str[ind], rl->length);
@@ -1807,9 +1807,9 @@
  *
  * Returns:
  */
-static runlist_element * test_rl_runlists_merge(runlist_element *drl, runlist_element *srl)
+static ntfs_runlist_element * test_rl_runlists_merge(ntfs_runlist_element *drl, ntfs_runlist_element *srl)
 {
-	runlist_element *res = NULL;
+	ntfs_runlist_element *res = NULL;

 	printf("dst:\n");
 	test_rl_dump_runlist(drl);
@@ -1825,7 +1825,7 @@
 }

 /**
- * test_rl_read_buffer - Runlist test: Read a file containing a runlist
+ * test_rl_read_buffer - Runlist test: Read a file containing a ntfs_runlist
  * @file:
  * @buf:
  * @bufsize:
@@ -1864,9 +1864,9 @@
  *
  * Returns:
  */
-static runlist_element * test_rl_pure_src(BOOL contig, BOOL multi, int vcn, int len)
+static ntfs_runlist_element * test_rl_pure_src(NTFS_BOOL contig, NTFS_BOOL multi, int vcn, int len)
 {
-	runlist_element *result;
+	ntfs_runlist_element *result;
 	int fudge;

 	if (contig)
@@ -1883,10 +1883,10 @@
 		MKRL(result+1, vcn + (1*len/4), fudge + vcn + 1000 + (1*len/4), len / 4)
 		MKRL(result+2, vcn + (2*len/4), fudge + vcn + 1000 + (2*len/4), len / 4)
 		MKRL(result+3, vcn + (3*len/4), fudge + vcn + 1000 + (3*len/4), len / 4)
-		MKRL(result+4, vcn + (4*len/4), LCN_RL_NOT_MAPPED,              0)
+		MKRL(result+4, vcn + (4*len/4), NTFS_LCN_RL_NOT_MAPPED,              0)
 	} else {
 		MKRL(result+0, vcn,       fudge + vcn + 1000, len)
-		MKRL(result+1, vcn + len, LCN_RL_NOT_MAPPED,  0)
+		MKRL(result+1, vcn + len, NTFS_LCN_RL_NOT_MAPPED,  0)
 	}
 	return result;
 }
@@ -1905,11 +1905,11 @@
  *
  * Returns:
  */
-static void test_rl_pure_test(int test, BOOL contig, BOOL multi, int vcn, int len, runlist_element *file, int size)
+static void test_rl_pure_test(int test, NTFS_BOOL contig, NTFS_BOOL multi, int vcn, int len, ntfs_runlist_element *file, int size)
 {
-	runlist_element *src;
-	runlist_element *dst;
-	runlist_element *res;
+	ntfs_runlist_element *src;
+	ntfs_runlist_element *dst;
+	ntfs_runlist_element *res;

 	src = test_rl_pure_src(contig, multi, vcn, len);
 	dst = malloc(4096);
@@ -1933,8 +1933,8 @@
  */
 static void test_rl_pure(char *contig, char *multi)
 {
-		/* VCN,  LCN, len */
-	static runlist_element file1[] = {
+		/* NTFS_VCN,  NTFS_LCN, len */
+	static ntfs_runlist_element file1[] = {
 		{    0,   -1, 100 },	/* HOLE */
 		{  100, 1100, 100 },	/* DATA */
 		{  200,   -1, 100 },	/* HOLE */
@@ -1942,19 +1942,19 @@
 		{  400,   -1, 100 },	/* HOLE */
 		{  500,   -3,   0 }	/* NOENT */
 	};
-	static runlist_element file2[] = {
+	static ntfs_runlist_element file2[] = {
 		{    0, 1000, 100 },	/* DATA */
 		{  100,   -1, 100 },	/* HOLE */
 		{  200,   -3,   0 }	/* NOENT */
 	};
-	static runlist_element file3[] = {
+	static ntfs_runlist_element file3[] = {
 		{    0, 1000, 100 },	/* DATA */
 		{  100,   -3,   0 }	/* NOENT */
 	};
-	static runlist_element file4[] = {
+	static ntfs_runlist_element file4[] = {
 		{    0,   -3,   0 }	/* NOENT */
 	};
-	static runlist_element file5[] = {
+	static ntfs_runlist_element file5[] = {
 		{    0,   -2, 100 },	/* NOTMAP */
 		{  100, 1100, 100 },	/* DATA */
 		{  200,   -2, 100 },	/* NOTMAP */
@@ -1962,12 +1962,12 @@
 		{  400,   -2, 100 },	/* NOTMAP */
 		{  500,   -3,   0 }	/* NOENT */
 	};
-	static runlist_element file6[] = {
+	static ntfs_runlist_element file6[] = {
 		{    0, 1000, 100 },	/* DATA */
 		{  100,   -2, 100 },	/* NOTMAP */
 		{  200,   -3,   0 }	/* NOENT */
 	};
-	BOOL c, m;
+	NTFS_BOOL c, m;

 	if (strcmp(contig, "contig") == 0)
 		c = TRUE;
@@ -2023,7 +2023,7 @@
 }

 /**
- * test_rl_zero - Runlist test: Merge a zero-length runlist
+ * test_rl_zero - Runlist test: Merge a zero-length ntfs_runlist
  *
  * Description...
  *
@@ -2031,15 +2031,15 @@
  */
 static void test_rl_zero(void)
 {
-	runlist_element *jim = NULL;
-	runlist_element *bob = NULL;
+	ntfs_runlist_element *jim = NULL;
+	ntfs_runlist_element *bob = NULL;

-	bob = calloc(3, sizeof(runlist_element));
+	bob = calloc(3, sizeof(ntfs_runlist_element));
 	if (!bob)
 		return;

 	MKRL(bob+0, 10, 99, 5)
-	MKRL(bob+1, 15, LCN_RL_NOT_MAPPED, 0)
+	MKRL(bob+1, 15, NTFS_LCN_RL_NOT_MAPPED, 0)

 	jim = test_rl_runlists_merge(jim, bob);
 	if (!jim)
@@ -2059,11 +2059,11 @@
  *
  * Returns:
  */
-static void test_rl_frag_combine(ntfs_volume *vol, ATTR_RECORD *attr1, ATTR_RECORD *attr2, ATTR_RECORD *attr3)
+static void test_rl_frag_combine(ntfs_volume *vol, NTFS_ATTR_RECORD *attr1, NTFS_ATTR_RECORD *attr2, NTFS_ATTR_RECORD *attr3)
 {
-	runlist_element *run1;
-	runlist_element *run2;
-	runlist_element *run3;
+	ntfs_runlist_element *run1;
+	ntfs_runlist_element *run2;
+	ntfs_runlist_element *run3;

 	run1 = ntfs_mapping_pairs_decompress(vol, attr1, NULL);
 	if (!run1)
@@ -2095,9 +2095,9 @@
 static void test_rl_frag(char *test)
 {
 	ntfs_volume vol;
-	ATTR_RECORD *attr1 = ntfs_malloc(1024);
-	ATTR_RECORD *attr2 = ntfs_malloc(1024);
-	ATTR_RECORD *attr3 = ntfs_malloc(1024);
+	NTFS_ATTR_RECORD *attr1 = ntfs_malloc(1024);
+	NTFS_ATTR_RECORD *attr2 = ntfs_malloc(1024);
+	NTFS_ATTR_RECORD *attr3 = ntfs_malloc(1024);

 	if (!attr1 || !attr2 || !attr3)
 		goto out;
@@ -2108,11 +2108,11 @@
 	vol.cluster_size_bits = 11;
 	vol.major_ver = 3;

-	if (!test_rl_read_buffer("runlist-data/attr1.bin", (u8*) attr1, 1024))
+	if (!test_rl_read_buffer("ntfs_runlist-data/attr1.bin", (u8*) attr1, 1024))
 		goto out;
-	if (!test_rl_read_buffer("runlist-data/attr2.bin", (u8*) attr2, 1024))
+	if (!test_rl_read_buffer("ntfs_runlist-data/attr2.bin", (u8*) attr2, 1024))
 		goto out;
-	if (!test_rl_read_buffer("runlist-data/attr3.bin", (u8*) attr3, 1024))
+	if (!test_rl_read_buffer("ntfs_runlist-data/attr3.bin", (u8*) attr3, 1024))
 		goto out;

 	if      (strcmp(test, "123") == 0)  test_rl_frag_combine(&vol, attr1, attr2, attr3);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/security.c ./libntfs/security.c
--- ../ntfsprogs-2.0.0/libntfs/security.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/security.c	2007-10-06 16:48:08.000000000 +0200
@@ -36,45 +36,45 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "layout.h"
-#include "security.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_security.h"

 /*
- * The zero GUID.
+ * The zero NTFS_GUID.
  */
-static const GUID __zero_guid = { { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } } };
-const GUID *const zero_guid = &__zero_guid;
+static const NTFS_GUID __zero_guid = { { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } } };
+const NTFS_GUID *const zero_guid = &__zero_guid;

 /**
- * ntfs_guid_is_zero - check if a GUID is zero
+ * ntfs_guid_is_zero - check if a NTFS_GUID is zero
  * @guid:	[IN] guid to check
  *
- * Return TRUE if @guid is a valid pointer to a GUID and it is the zero GUID
+ * Return TRUE if @guid is a valid pointer to a NTFS_GUID and it is the zero NTFS_GUID
  * and FALSE otherwise.
  */
-BOOL ntfs_guid_is_zero(const GUID *guid)
+NTFS_BOOL ntfs_guid_is_zero(const NTFS_GUID *guid)
 {
 	return (memcmp(guid, zero_guid, sizeof(*zero_guid)));
 }

 /**
- * ntfs_guid_to_mbs - convert a GUID to a multi byte string
+ * ntfs_guid_to_mbs - convert a NTFS_GUID to a multi byte string
  * @guid:	[IN]  guid to convert
- * @guid_str:	[OUT] string in which to return the GUID (optional)
+ * @guid_str:	[OUT] string in which to return the NTFS_GUID (optional)
  *
- * Convert the GUID pointed to by @guid to a multi byte string of the form
+ * Convert the NTFS_GUID pointed to by @guid to a multi byte string of the form
  * "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX".  Therefore, @guid_str (if not NULL)
  * needs to be able to store at least 37 bytes.
  *
- * If @guid_str is not NULL it will contain the converted GUID on return.  If
+ * If @guid_str is not NULL it will contain the converted NTFS_GUID on return.  If
  * it is NULL a string will be allocated and this will be returned.  The caller
  * is responsible for free()ing the string in that case.
  *
  * On success return the converted string and on failure return NULL with errno
  * set to the error code.
  */
-char *ntfs_guid_to_mbs(const GUID *guid, char *guid_str)
+char *ntfs_guid_to_mbs(const NTFS_GUID *guid, char *guid_str)
 {
 	char *_guid_str;
 	int res;
@@ -105,17 +105,17 @@
 }

 /**
- * ntfs_sid_to_mbs_size - determine maximum size for the string of a SID
- * @sid:	[IN]  SID for which to determine the maximum string size
+ * ntfs_sid_to_mbs_size - determine maximum size for the string of a NTFS_SID
+ * @sid:	[IN]  NTFS_SID for which to determine the maximum string size
  *
  * Determine the maximum multi byte string size in bytes which is needed to
- * store the standard textual representation of the SID pointed to by @sid.
+ * store the standard textual representation of the NTFS_SID pointed to by @sid.
  * See ntfs_sid_to_mbs(), below.
  *
  * On success return the maximum number of bytes needed to store the multi byte
  * string and on failure return -1 with errno set to the error code.
  */
-int ntfs_sid_to_mbs_size(const SID *sid)
+int ntfs_sid_to_mbs_size(const NTFS_SID *sid)
 {
 	int size, i;

@@ -126,10 +126,10 @@
 	/* Start with "S-". */
 	size = 2;
 	/*
-	 * Add the SID_REVISION.  Hopefully the compiler will optimize this
-	 * away as SID_REVISION is a constant.
+	 * Add the NTFS_SID_REVISION.  Hopefully the compiler will optimize this
+	 * away as NTFS_SID_REVISION is a constant.
 	 */
-	for (i = SID_REVISION; i > 0; i /= 10)
+	for (i = NTFS_SID_REVISION; i > 0; i /= 10)
 		size++;
 	/* Add the "-". */
 	size++;
@@ -153,22 +153,22 @@
 }

 /**
- * ntfs_sid_to_mbs - convert a SID to a multi byte string
- * @sid:		[IN]  SID to convert
- * @sid_str:		[OUT] string in which to return the SID (optional)
+ * ntfs_sid_to_mbs - convert a NTFS_SID to a multi byte string
+ * @sid:		[IN]  NTFS_SID to convert
+ * @sid_str:		[OUT] string in which to return the NTFS_SID (optional)
  * @sid_str_size:	[IN]  size in bytes of @sid_str
  *
- * Convert the SID pointed to by @sid to its standard textual representation.
+ * Convert the NTFS_SID pointed to by @sid to its standard textual representation.
  * @sid_str (if not NULL) needs to be able to store at least
  * ntfs_sid_to_mbs_size() bytes.  @sid_str_size is the size in bytes of
  * @sid_str if @sid_str is not NULL.
  *
- * The standard textual representation of the SID is of the form:
+ * The standard textual representation of the NTFS_SID is of the form:
  *	S-R-I-S-S...
  * Where:
  *    - The first "S" is the literal character 'S' identifying the following
- *	digits as a SID.
- *    - R is the revision level of the SID expressed as a sequence of digits
+ *	digits as a NTFS_SID.
+ *    - R is the revision level of the NTFS_SID expressed as a sequence of digits
  *	in decimal.
  *    - I is the 48-bit identifier_authority, expressed as digits in decimal,
  *	if I < 2^32, or hexadecimal prefixed by "0x", if I >= 2^32.
@@ -182,7 +182,7 @@
  * On success return the converted string and on failure return NULL with errno
  * set to the error code.
  */
-char *ntfs_sid_to_mbs(const SID *sid, char *sid_str, size_t sid_str_size)
+char *ntfs_sid_to_mbs(const NTFS_SID *sid, char *sid_str, size_t sid_str_size)
 {
 	u64 u;
 	char *s;
@@ -190,7 +190,7 @@

 	/*
 	 * No need to check @sid if !@sid_str since ntfs_sid_to_mbs_size() will
-	 * check @sid, too.  8 is the minimum SID string size.
+	 * check @sid, too.  8 is the minimum NTFS_SID string size.
 	 */
 	if (sid_str && (sid_str_size < 8 || !ntfs_sid_is_valid(sid))) {
 		errno = EINVAL;
@@ -251,16 +251,16 @@

 /**
  * ntfs_generate_guid - generatates a random current guid.
- * @guid:	[OUT]   pointer to a GUID struct to hold the generated guid.
+ * @guid:	[OUT]   pointer to a NTFS_GUID struct to hold the generated guid.
  *
  * perhaps not a very good random number generator though...
  */
-void ntfs_generate_guid(GUID *guid)
+void ntfs_generate_guid(NTFS_GUID *guid)
 {
 	unsigned int i;
 	u8 *p = (u8 *)guid;

-	for (i = 0; i < sizeof(GUID); i++) {
+	for (i = 0; i < sizeof(NTFS_GUID); i++) {
 		p[i] = (u8)(random() & 0xFF);
 		if (i == 7)
 			p[7] = (p[7] & 0x0F) | 0x40;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/unistr.c ./libntfs/unistr.c
--- ../ntfsprogs-2.0.0/libntfs/unistr.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/unistr.c	2007-10-06 16:48:07.000000000 +0200
@@ -40,12 +40,12 @@
 #include <errno.h>
 #endif

-#include "attrib.h"
-#include "endians.h"
-#include "types.h"
-#include "unistr.h"
-#include "debug.h"
-#include "logging.h"
+#include "ntfs_attrib.h"
+#include "ntfs_endians.h"
+#include "ntfs_types.h"
+#include "ntfs_unistr.h"
+#include "ntfs_debug.h"
+#include "ntfs_logging.h"

 /*
  * IMPORTANT
@@ -82,23 +82,23 @@
  * @s2:			name to compare to @s1
  * @s2_len:		length in Unicode characters of @s2
  * @ic:			ignore case bool
- * @upcase:		upcase table (only if @ic == IGNORE_CASE)
+ * @upcase:		upcase table (only if @ic == NTFS_IGNORE_CASE)
  * @upcase_size:	length in Unicode characters of @upcase (if present)
  *
  * Compare the names @s1 and @s2 and return TRUE (1) if the names are
- * identical, or FALSE (0) if they are not identical. If @ic is IGNORE_CASE,
+ * identical, or FALSE (0) if they are not identical. If @ic is NTFS_IGNORE_CASE,
  * the @upcase table is used to perform a case insensitive comparison.
  */
-BOOL ntfs_names_are_equal(const ntfschar *s1, size_t s1_len,
+NTFS_BOOL ntfs_names_are_equal(const ntfschar *s1, size_t s1_len,
 		const ntfschar *s2, size_t s2_len,
-		const IGNORE_CASE_BOOL ic,
+		const NTFS_IGNORE_CASE_BOOL ic,
 		const ntfschar *upcase, const u32 upcase_size)
 {
 	if (s1_len != s2_len)
 		return FALSE;
 	if (!s1_len)
 		return TRUE;
-	if (ic == CASE_SENSITIVE)
+	if (ic == NTFS_CASE_SENSITIVE)
 		return ntfs_ucsncmp(s1, s2, s1_len) ? FALSE: TRUE;
 	return ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size) ? FALSE:
 								       TRUE;
@@ -111,9 +111,9 @@
  * @name2:	second Unicode name to compare
  * @name2_len:	length of second Unicode name to compare
  * @err_val:	if @name1 contains an invalid character return this value
- * @ic:		either CASE_SENSITIVE or IGNORE_CASE
- * @upcase:	upcase table (ignored if @ic is CASE_SENSITIVE)
- * @upcase_len:	upcase table size (ignored if @ic is CASE_SENSITIVE)
+ * @ic:		either NTFS_CASE_SENSITIVE or NTFS_IGNORE_CASE
+ * @upcase:	upcase table (ignored if @ic is NTFS_CASE_SENSITIVE)
+ * @upcase_len:	upcase table size (ignored if @ic is NTFS_CASE_SENSITIVE)
  *
  * ntfs_names_collate() collates two Unicode names and returns:
  *
@@ -127,7 +127,7 @@
 int ntfs_names_collate(const ntfschar *name1, const u32 name1_len,
 		const ntfschar *name2, const u32 name2_len,
 		const int err_val __attribute__((unused)),
-		const IGNORE_CASE_BOOL ic, const ntfschar *upcase,
+		const NTFS_IGNORE_CASE_BOOL ic, const ntfschar *upcase,
 		const u32 upcase_len)
 {
 	u32 cnt;
@@ -341,7 +341,7 @@
  *
  * Returns:
  */
-void ntfs_file_value_upcase(FILE_NAME_ATTR *file_name_attr,
+void ntfs_file_value_upcase(NTFS_FILE_NAME_ATTR *file_name_attr,
 		const ntfschar *upcase, const u32 upcase_len)
 {
 	ntfs_name_upcase((ntfschar*)&file_name_attr->file_name,
@@ -361,9 +361,9 @@
  *
  * Returns:
  */
-int ntfs_file_values_compare(const FILE_NAME_ATTR *file_name_attr1,
-		const FILE_NAME_ATTR *file_name_attr2,
-		const int err_val, const IGNORE_CASE_BOOL ic,
+int ntfs_file_values_compare(const NTFS_FILE_NAME_ATTR *file_name_attr1,
+		const NTFS_FILE_NAME_ATTR *file_name_attr2,
+		const int err_val, const NTFS_IGNORE_CASE_BOOL ic,
 		const ntfschar *upcase, const u32 upcase_len)
 {
 	return ntfs_names_collate((ntfschar*)&file_name_attr1->file_name,
@@ -731,7 +731,7 @@
  * 2-byte Unicode string. The length of the converted string is less
  * or equal to the maximum length allowed by the NTFS format (255).
  *
- * If @s is NULL then return AT_UNNAMED.
+ * If @s is NULL then return NTFS_AT_UNNAMED.
  *
  * On success the function returns the Unicode string in an allocated
  * buffer and the caller is responsible to free it when it's not needed
@@ -753,7 +753,7 @@
 		return NULL;
 	}
 	if (!ucs || !*len) {
-		ucs  = AT_UNNAMED;
+		ucs  = NTFS_AT_UNNAMED;
 		*len = 0;
 	}
 	return ucs;
@@ -769,7 +769,7 @@
  */
 void ntfs_ucsfree(ntfschar *ucs)
 {
-	if (ucs && (ucs != AT_UNNAMED))
+	if (ucs && (ucs != NTFS_AT_UNNAMED))
 		free(ucs);
 }

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/unix_io.c ./libntfs/unix_io.c
--- ../ntfsprogs-2.0.0/libntfs/unix_io.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/unix_io.c	2007-10-06 16:48:09.000000000 +0200
@@ -54,11 +54,11 @@
 #include <linux/fd.h>
 #endif

-#include "types.h"
-#include "mst.h"
-#include "debug.h"
-#include "device.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_mst.h"
+#include "ntfs_debug.h"
+#include "ntfs_device.h"
+#include "ntfs_logging.h"

 #define DEV_FD(dev)	(*(int *)dev->d_private)

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/version.c ./libntfs/version.c
--- ../ntfsprogs-2.0.0/libntfs/version.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/version.c	2007-10-06 16:48:08.000000000 +0200
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif

-#include "version.h"
+#include "ntfs_version.h"

 #ifdef LTVERSION_LIBNTFS
 #define LIBNTFS_VERSION_STRING LTVERSION_LIBNTFS
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/volume.c ./libntfs/volume.c
--- ../ntfsprogs-2.0.0/libntfs/volume.c	2007-09-27 14:55:33.000000000 +0200
+++ ./libntfs/volume.c	2007-10-06 16:48:07.000000000 +0200
@@ -51,17 +51,17 @@
 #include <limits.h>
 #endif

-#include "volume.h"
-#include "attrib.h"
-#include "mft.h"
-#include "bootsect.h"
-#include "device.h"
-#include "debug.h"
-#include "inode.h"
-#include "runlist.h"
-#include "logfile.h"
-#include "dir.h"
-#include "logging.h"
+#include "ntfs_volume.h"
+#include "ntfs_attrib.h"
+#include "ntfs_mft.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_device.h"
+#include "ntfs_debug.h"
+#include "ntfs_inode.h"
+#include "ntfs_runlist.h"
+#include "ntfs_logfile.h"
+#include "ntfs_dir.h"
+#include "ntfs_logging.h"

 #ifndef PATH_MAX
 #define PATH_MAX 4096
@@ -82,7 +82,7 @@
 	vol = calloc(1, sizeof(ntfs_volume));
 	if (vol) {
 		for (i = 0; i < NTFS_INODE_CACHE_SIZE; i++)
-			INIT_LIST_HEAD(&vol->inode_cache[i]);
+			NTFS_INIT_LIST_HEAD(&vol->inode_cache[i]);
 	}
 	return vol;
 }
@@ -97,20 +97,20 @@
  */
 static void __ntfs_volume_release(ntfs_volume *v)
 {
-	struct list_head *pos, *tmp;
+	struct ntfs_list_head *pos, *tmp;
 	int i;

 	/* Sync and print error about not detached inodes. */
 	for (i = 0; i < NTFS_INODE_CACHE_SIZE; i++)
-		list_for_each_safe(pos, tmp, &v->inode_cache[i]) {
+		ntfs_list_for_each_safe(pos, tmp, &v->inode_cache[i]) {
 			ntfs_inode *ni =
-					list_entry(pos, ntfs_inode, list_entry);
+					ntfs_list_entry(pos, ntfs_inode, ntfs_list_entry);

 			switch (ni->mft_no) {
-				case FILE_Volume:
-				case FILE_Bitmap:
-				case FILE_MFT:
-				case FILE_MFTMirr:
+				case NTFS_FILE_Volume:
+				case NTFS_FILE_Bitmap:
+				case NTFS_FILE_MFT:
+				case NTFS_FILE_MFTMirr:
 					if (ni->nr_references == 1)
 						continue;
 					break;
@@ -126,7 +126,7 @@
 	 * not a forensic mount.
 	 */
 	if (!NVolReadOnly(v) && !NVolWasDirty(v) && !NVolForensicMount(v)) {
-		v->flags &= ~VOLUME_IS_DIRTY;
+		v->flags &= ~NTFS_VOLUME_IS_DIRTY;
 		(void)ntfs_volume_write_flags(v, v->flags);
 	}
 	if (v->lcnbmp_ni && NInoDirty(v->lcnbmp_ni))
@@ -177,17 +177,17 @@
  */
 static int ntfs_mft_load(ntfs_volume *vol)
 {
-	VCN next_vcn, last_vcn, highest_vcn;
+	NTFS_VCN next_vcn, last_vcn, highest_vcn;
 	s64 l;
-	MFT_RECORD *mb = NULL;
+	NTFS_MFT_RECORD *mb = NULL;
 	ntfs_attr_search_ctx *ctx = NULL;
-	ATTR_RECORD *a;
-	STANDARD_INFORMATION *std_info;
+	NTFS_ATTR_RECORD *a;
+	NTFS_STANDARD_INFORMATION *std_info;
 	int eo;

 	/* Manually setup an ntfs_inode. */
 	vol->mft_ni = ntfs_inode_allocate(vol);
-	mb = (MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
+	mb = (NTFS_MFT_RECORD*)ntfs_malloc(vol->mft_record_size);
 	if (!vol->mft_ni || !mb) {
 		ntfs_log_perror("Error allocating memory for $MFT");
 		goto error_exit;
@@ -224,7 +224,7 @@
 		goto io_error_exit;
 	}
 	/* Find the $ATTRIBUTE_LIST attribute in $MFT if present. */
-	if (ntfs_attr_lookup(AT_ATTRIBUTE_LIST, AT_UNNAMED, 0, 0, 0, NULL, 0,
+	if (ntfs_attr_lookup(NTFS_AT_ATTRIBUTE_LIST, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0,
 			ctx)) {
 		if (errno != ENOENT) {
 			ntfs_log_error("$MFT has corrupt attribute list.\n");
@@ -255,16 +255,16 @@
 		goto io_error_exit;
 	}
 mft_has_no_attr_list:
-	/* Receive attributes from STANDARD_INFORMATION. */
-	std_info = ntfs_attr_readall(vol->mft_ni, AT_STANDARD_INFORMATION,
-				     AT_UNNAMED, 0, NULL);
+	/* Receive attributes from NTFS_STANDARD_INFORMATION. */
+	std_info = ntfs_attr_readall(vol->mft_ni, NTFS_AT_STANDARD_INFORMATION,
+				     NTFS_AT_UNNAMED, 0, NULL);
 	vol->mft_ni->flags = std_info->file_attributes;
 	free(std_info);

 	/* We now have a fully setup ntfs inode for $MFT in vol->mft_ni. */

 	/* Get an ntfs attribute for $MFT/$DATA and set it up, too. */
-	vol->mft_na = ntfs_attr_open(vol->mft_ni, AT_DATA, AT_UNNAMED, 0);
+	vol->mft_na = ntfs_attr_open(vol->mft_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!vol->mft_na) {
 		ntfs_log_perror("Failed to open ntfs attribute");
 		goto error_exit;
@@ -274,9 +274,9 @@
 	last_vcn = vol->mft_na->allocated_size >> vol->cluster_size_bits;
 	highest_vcn = next_vcn = 0;
 	a = NULL;
-	while (!ntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, 0, next_vcn, NULL, 0,
+	while (!ntfs_attr_lookup(NTFS_AT_DATA, NTFS_AT_UNNAMED, 0, 0, next_vcn, NULL, 0,
 			ctx)) {
-		runlist_element *nrl;
+		ntfs_runlist_element *nrl;

 		a = ctx->attr;
 		/* $MFT must be non-resident. */
@@ -287,8 +287,8 @@
 			goto io_error_exit;
 		}
 		/* $MFT must be uncompressed and unencrypted. */
-		if (a->flags & ATTR_COMPRESSION_MASK ||
-				a->flags & ATTR_IS_ENCRYPTED) {
+		if (a->flags & NTFS_ATTR_COMPRESSION_MASK ||
+				a->flags & NTFS_ATTR_IS_ENCRYPTED) {
 			ntfs_log_error("$MFT must be uncompressed and "
 					"unencrypted but a compressed/encrypted"
 					" extent was found. $MFT is corrupt. "
@@ -297,7 +297,7 @@
 		}
 		/*
 		 * Decompress the mapping pairs array of this extent and merge
-		 * the result into the existing runlist. No need for locking
+		 * the result into the existing ntfs_runlist. No need for locking
 		 * as we have exclusive access to the inode at this time and we
 		 * are a mount in progress task, too.
 		 */
@@ -330,7 +330,7 @@
 		goto io_error_exit;
 	}
 	if (highest_vcn && highest_vcn != last_vcn - 1) {
-		ntfs_log_error("Failed to load the complete runlist for "
+		ntfs_log_error("Failed to load the complete ntfs_runlist for "
 				"$MFT/$DATA. Bug or corrupt $MFT. "
 				"Run chkdsk.\n highest_vcn = 0x%llx, "
 				"last_vcn - 1 = 0x%llx\n", (long long)
@@ -343,7 +343,7 @@
 	/*
 	 * The volume is now setup so we can use all read access functions.
 	 */
-	vol->mftbmp_na = ntfs_attr_open(vol->mft_ni, AT_BITMAP, AT_UNNAMED, 0);
+	vol->mftbmp_na = ntfs_attr_open(vol->mft_ni, NTFS_AT_BITMAP, NTFS_AT_UNNAMED, 0);
 	if (!vol->mftbmp_na) {
 		ntfs_log_perror("Failed to open $MFT/$BITMAP");
 		goto error_exit;
@@ -383,23 +383,23 @@
 {
 	int err;

-	vol->mftmirr_ni = ntfs_inode_open(vol, FILE_MFTMirr);
+	vol->mftmirr_ni = ntfs_inode_open(vol, NTFS_FILE_MFTMirr);
 	if (!vol->mftmirr_ni) {
 		ntfs_log_perror("Failed to open inode $MFTMirr");
 		return -1;
 	}
 	/* Get an ntfs attribute for $MFTMirr/$DATA, too. */
-	vol->mftmirr_na = ntfs_attr_open(vol->mftmirr_ni, AT_DATA,
-			AT_UNNAMED, 0);
+	vol->mftmirr_na = ntfs_attr_open(vol->mftmirr_ni, NTFS_AT_DATA,
+			NTFS_AT_UNNAMED, 0);
 	if (!vol->mftmirr_na) {
 		ntfs_log_perror("Failed to open $MFTMirr/$DATA");
 		goto error_exit;
 	}
 	if (ntfs_attr_map_runlist(vol->mftmirr_na, 0) < 0) {
-		ntfs_log_perror("Failed to map runlist of $MFTMirr/$DATA");
+		ntfs_log_perror("Failed to map ntfs_runlist of $MFTMirr/$DATA");
 		goto error_exit;
 	}
-	/* Check $MFTMirr runlist. */
+	/* Check $MFTMirr ntfs_runlist. */
 	if (vol->mftmirr_na->rl[0].lcn != vol->mftmirr_lcn ||
 			vol->mftmirr_na->rl[0].length < (vol->mftmirr_size *
 			vol->mft_record_size + vol->cluster_size - 1) /
@@ -438,7 +438,7 @@
 ntfs_volume *ntfs_volume_startup(struct ntfs_device *dev,
 		ntfs_mount_flags flags)
 {
-	LCN mft_zone_size, mft_lcn;
+	NTFS_LCN mft_zone_size, mft_lcn;
 	s64 br;
 	ntfs_volume *vol;
 	NTFS_BOOT_SECTOR *bs;
@@ -446,9 +446,9 @@
 #ifdef DEBUG
 	const char *OK = "OK\n";
 	const char *FAILED = "FAILED\n";
-	BOOL debug = 1;
+	NTFS_BOOL debug = 1;
 #else
-	BOOL debug = 0;
+	NTFS_BOOL debug = 0;
 #endif

 	if (!dev || !dev->d_ops || !dev->d_name) {
@@ -633,16 +633,16 @@
 {
 	ntfs_inode *ni;
 	ntfs_attr *na = NULL;
-	RESTART_PAGE_HEADER *rp = NULL;
+	NTFS_RESTART_PAGE_HEADER *rp = NULL;
 	int err = 0;

-	if ((ni = ntfs_inode_open(vol, FILE_LogFile)) == NULL) {
-		ntfs_log_debug("Failed to open inode FILE_LogFile.\n");
+	if ((ni = ntfs_inode_open(vol, NTFS_FILE_LogFile)) == NULL) {
+		ntfs_log_debug("Failed to open inode NTFS_FILE_LogFile.\n");
 		errno = EIO;
 		return -1;
 	}
-	if ((na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0)) == NULL) {
-		ntfs_log_debug("Failed to open $FILE_LogFile/$DATA\n");
+	if ((na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0)) == NULL) {
+		ntfs_log_debug("Failed to open $NTFS_FILE_LogFile/$DATA\n");
 		err = EIO;
 		goto exit;
 	}
@@ -681,7 +681,7 @@
 		return NULL;
 	}

-	ni_root = ntfs_inode_open(vol, FILE_root);
+	ni_root = ntfs_inode_open(vol, NTFS_FILE_root);
 	if (!ni_root) {
 		ntfs_log_debug("Couldn't open the root directory.\n");
 		return NULL;
@@ -699,7 +699,7 @@
 		goto out;
 	}

-	inode = MREF(inode);
+	inode = NTFS_MREF(inode);
 	ni_hibr = ntfs_inode_open(vol, inode);
 	if (!ni_hibr) {
 		ntfs_log_debug("Couldn't open inode %lld.\n", (long long)inode);
@@ -740,7 +740,7 @@
 	if (!buf)
 		goto out;

-	na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		ntfs_log_perror("Failed to open hiberfil.sys data attribute");
 		goto out;
@@ -894,8 +894,8 @@
 	ntfs_attr_search_ctx *ctx = NULL;
 	ntfs_inode *ni;
 	ntfs_attr *na;
-	ATTR_RECORD *a;
-	VOLUME_INFORMATION *vinf;
+	NTFS_ATTR_RECORD *a;
+	NTFS_VOLUME_INFORMATION *vinf;
 	ntfschar *vname;
 	int i, j, eo;
 	u32 u;
@@ -941,7 +941,7 @@
 	}
 	ntfs_log_debug("Comparing $MFTMirr to $MFT... ");
 	for (i = 0; i < vol->mftmirr_size; ++i) {
-		MFT_RECORD *mrec, *mrec2;
+		NTFS_MFT_RECORD *mrec, *mrec2;
 		const char *ESTR[12] = { "$MFT", "$MFTMirr", "$LogFile",
 			"$Volume", "$AttrDef", "root directory", "$Bitmap",
 			"$Boot", "$BadClus", "$Secure", "$UpCase", "$Extend" };
@@ -954,8 +954,8 @@
 		else
 			s = "mft record";

-		mrec = (MFT_RECORD*)(m + i * vol->mft_record_size);
-		if (mrec->flags & MFT_RECORD_IN_USE) {
+		mrec = (NTFS_MFT_RECORD*)(m + i * vol->mft_record_size);
+		if (mrec->flags & NTFS_MFT_RECORD_IN_USE) {
 			if (ntfs_is_baad_record(mrec->magic)) {
 				ntfs_log_debug("FAILED\n");
 				ntfs_log_debug("$MFT error: Incomplete multi "
@@ -970,8 +970,8 @@
 				goto io_error_exit;
 			}
 		}
-		mrec2 = (MFT_RECORD*)(m2 + i * vol->mft_record_size);
-		if (mrec2->flags & MFT_RECORD_IN_USE) {
+		mrec2 = (NTFS_MFT_RECORD*)(m2 + i * vol->mft_record_size);
+		if (mrec2->flags & NTFS_MFT_RECORD_IN_USE) {
 			if (ntfs_is_baad_record(mrec2->magic)) {
 				ntfs_log_debug("FAILED\n");
 				ntfs_log_debug("$MFTMirr error: Incomplete "
@@ -1001,14 +1001,14 @@

 	/* Now load the bitmap from $Bitmap. */
 	ntfs_log_debug("Loading $Bitmap... ");
-	vol->lcnbmp_ni = ntfs_inode_open(vol, FILE_Bitmap);
+	vol->lcnbmp_ni = ntfs_inode_open(vol, NTFS_FILE_Bitmap);
 	if (!vol->lcnbmp_ni) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open inode");
 		goto error_exit;
 	}
 	/* Get an ntfs attribute for $Bitmap/$DATA. */
-	vol->lcnbmp_na = ntfs_attr_open(vol->lcnbmp_ni, AT_DATA, AT_UNNAMED, 0);
+	vol->lcnbmp_na = ntfs_attr_open(vol->lcnbmp_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!vol->lcnbmp_na) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open ntfs attribute");
@@ -1019,14 +1019,14 @@

 	/* Now load the upcase table from $UpCase. */
 	ntfs_log_debug("Loading $UpCase... ");
-	ni = ntfs_inode_open(vol, FILE_UpCase);
+	ni = ntfs_inode_open(vol, NTFS_FILE_UpCase);
 	if (!ni) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open inode");
 		goto error_exit;
 	}
 	/* Get an ntfs attribute for $UpCase/$DATA. */
-	na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open ntfs attribute");
@@ -1075,24 +1075,24 @@
 	 * vol structure accordingly.
 	 */
 	ntfs_log_debug("Loading $Volume... ");
-	vol->vol_ni = ntfs_inode_open(vol, FILE_Volume);
+	vol->vol_ni = ntfs_inode_open(vol, NTFS_FILE_Volume);
 	if (!vol->vol_ni) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open inode");
 		goto error_exit;
 	}
-	/* Get a search context for the $Volume/$VOLUME_INFORMATION lookup. */
+	/* Get a search context for the $Volume/$NTFS_VOLUME_INFORMATION lookup. */
 	ctx = ntfs_attr_get_search_ctx(vol->vol_ni, NULL);
 	if (!ctx) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to allocate attribute search context");
 		goto error_exit;
 	}
-	/* Find the $VOLUME_INFORMATION attribute. */
-	if (ntfs_attr_lookup(AT_VOLUME_INFORMATION, AT_UNNAMED, 0, 0, 0, NULL,
+	/* Find the $NTFS_VOLUME_INFORMATION attribute. */
+	if (ntfs_attr_lookup(NTFS_AT_VOLUME_INFORMATION, NTFS_AT_UNNAMED, 0, 0, 0, NULL,
 			0, ctx)) {
 		ntfs_log_debug(FAILED);
-		ntfs_log_debug("$VOLUME_INFORMATION attribute not found in "
+		ntfs_log_debug("$NTFS_VOLUME_INFORMATION attribute not found in "
 				"$Volume?!?\n");
 		goto error_exit;
 	}
@@ -1100,20 +1100,20 @@
 	/* Has to be resident. */
 	if (a->non_resident) {
 		ntfs_log_debug(FAILED);
-		ntfs_log_debug("Error: Attribute $VOLUME_INFORMATION must be "
+		ntfs_log_debug("Error: Attribute $NTFS_VOLUME_INFORMATION must be "
 				"resident (and it isn't)!\n");
 		errno = EIO;
 		goto error_exit;
 	}
 	/* Get a pointer to the value of the attribute. */
-	vinf = (VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
+	vinf = (NTFS_VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
 	/* Sanity checks. */
 	if ((char*)vinf + le32_to_cpu(a->value_length) > (char*)ctx->mrec +
 			le32_to_cpu(ctx->mrec->bytes_in_use) ||
 			le16_to_cpu(a->value_offset) + le32_to_cpu(
 			a->value_length) > le32_to_cpu(a->length)) {
 		ntfs_log_debug(FAILED);
-		ntfs_log_debug("Error: Attribute $VOLUME_INFORMATION in "
+		ntfs_log_debug("Error: Attribute $NTFS_VOLUME_INFORMATION in "
 				"$Volume is corrupt!\n");
 		errno = EIO;
 		goto error_exit;
@@ -1122,22 +1122,22 @@
 	vol->major_ver = vinf->major_ver;
 	vol->minor_ver = vinf->minor_ver;
 	/*
-	 * Do not use le16_to_cpu() macro here as our VOLUME_FLAGS are defined
+	 * Do not use le16_to_cpu() macro here as our NTFS_VOLUME_FLAGS are defined
 	 * using cpu_to_le16() macro and hence are consistent.
 	 */
 	vol->flags = vinf->flags;
 	/* Record whether the volume was dirty or not. */
-	if (vol->flags & VOLUME_IS_DIRTY)
+	if (vol->flags & NTFS_VOLUME_IS_DIRTY)
 		NVolSetWasDirty(vol);
 	/*
-	 * Reinitialize the search context for the $Volume/$VOLUME_NAME lookup.
+	 * Reinitialize the search context for the $Volume/$NTFS_VOLUME_NAME lookup.
 	 */
 	ntfs_attr_reinit_search_ctx(ctx);
-	if (ntfs_attr_lookup(AT_VOLUME_NAME, AT_UNNAMED, 0, 0, 0, NULL, 0,
+	if (ntfs_attr_lookup(NTFS_AT_VOLUME_NAME, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0,
 			ctx)) {
 		if (errno != ENOENT) {
 			ntfs_log_debug(FAILED);
-			ntfs_log_debug("Error: Lookup of $VOLUME_NAME "
+			ntfs_log_debug("Error: Lookup of $NTFS_VOLUME_NAME "
 					"attribute in $Volume failed.  "
 					"This probably means something is "
 					"corrupt.  Run chkdsk.\n");
@@ -1159,7 +1159,7 @@
 		/* Has to be resident. */
 		if (a->non_resident) {
 			ntfs_log_debug(FAILED);
-			ntfs_log_debug("Error: Attribute $VOLUME_NAME must be "
+			ntfs_log_debug("Error: Attribute $NTFS_VOLUME_NAME must be "
 					"resident!\n");
 			errno = EIO;
 			goto error_exit;
@@ -1196,14 +1196,14 @@
 	ctx = NULL;
 	/* Now load the attribute definitions from $AttrDef. */
 	ntfs_log_debug("Loading $AttrDef... ");
-	ni = ntfs_inode_open(vol, FILE_AttrDef);
+	ni = ntfs_inode_open(vol, NTFS_FILE_AttrDef);
 	if (!ni) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open inode");
 		goto error_exit;
 	}
 	/* Get an ntfs attribute for $AttrDef/$DATA. */
-	na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		ntfs_log_debug(FAILED);
 		ntfs_log_perror("Failed to open ntfs attribute");
@@ -1218,7 +1218,7 @@
 		goto error_exit;
 	}
 	vol->attrdef_len = na->data_size;
-	vol->attrdef = (ATTR_DEF*)ntfs_malloc(na->data_size);
+	vol->attrdef = (NTFS_ATTR_DEF*)ntfs_malloc(na->data_size);
 	if (!vol->attrdef) {
 		ntfs_log_debug(FAILED);
 		goto error_exit;
@@ -1268,8 +1268,8 @@
 		if (!NVolForensicMount(vol)) {
 			if (ntfs_logfile_reset(vol) < 0)
 				goto error_exit;
-			if (!(vol->flags & VOLUME_IS_DIRTY)) {
-				vol->flags |= VOLUME_IS_DIRTY;
+			if (!(vol->flags & NTFS_VOLUME_IS_DIRTY)) {
+				vol->flags |= NTFS_VOLUME_IS_DIRTY;
 				if (ntfs_volume_write_flags(vol, vol->flags) <
 						0)
 					goto error_exit;
@@ -1369,7 +1369,7 @@
  * so it is safe to continue using @vol.
  */
 int ntfs_device_umount(ntfs_volume *vol,
-		const BOOL force __attribute__((unused)))
+		const NTFS_BOOL force __attribute__((unused)))
 {
 	if (!vol) {
 		errno = EINVAL;
@@ -1402,7 +1402,7 @@
  * so it is safe to continue using @vol.
  */
 int ntfs_umount(ntfs_volume *vol,
-		const BOOL force __attribute__((unused)))
+		const NTFS_BOOL force __attribute__((unused)))
 {
 	struct ntfs_device *dev;

@@ -1572,7 +1572,7 @@
  * Fill the value of the $LogFile data attribute, i.e. the contents of
  * the file, with 0xff's, thus marking the journal as empty.
  *
- * FIXME(?): We might need to zero the LSN field of every single mft
+ * FIXME(?): We might need to zero the NTFS_LSN field of every single mft
  * record as well. (But, first try without doing that and see what
  * happens, since chkdsk might pickup the pieces and do it for us...)
  *
@@ -1591,20 +1591,20 @@
 		return -1;
 	}

-	if ((ni = ntfs_inode_open(vol, FILE_LogFile)) == NULL) {
-		ntfs_log_perror("Failed to open inode FILE_LogFile.");
+	if ((ni = ntfs_inode_open(vol, NTFS_FILE_LogFile)) == NULL) {
+		ntfs_log_perror("Failed to open inode NTFS_FILE_LogFile.");
 		return -1;
 	}

-	if ((na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0)) == NULL) {
+	if ((na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0)) == NULL) {
 		eo = errno;
-		ntfs_log_perror("Failed to open $FILE_LogFile/$DATA");
+		ntfs_log_perror("Failed to open $NTFS_FILE_LogFile/$DATA");
 		goto error_exit;
 	}

 	if (ntfs_empty_logfile(na)) {
 		eo = errno;
-		ntfs_log_perror("Failed to empty $FILE_LogFile/$DATA");
+		ntfs_log_perror("Failed to empty $NTFS_FILE_LogFile/$DATA");
 		ntfs_attr_close(na);
 		goto error_exit;
 	}
@@ -1629,8 +1629,8 @@
  */
 int ntfs_volume_write_flags(ntfs_volume *vol, const le16 flags)
 {
-	ATTR_RECORD *a;
-	VOLUME_INFORMATION *c;
+	NTFS_ATTR_RECORD *a;
+	NTFS_VOLUME_INFORMATION *c;
 	ntfs_attr_search_ctx *ctx;
 	int ret = -1;	/* failure */

@@ -1644,34 +1644,34 @@
 		ntfs_log_perror("Failed to allocate attribute search context");
 		return -1;
 	}
-	if (ntfs_attr_lookup(AT_VOLUME_INFORMATION, AT_UNNAMED, 0, 0, 0, NULL,
+	if (ntfs_attr_lookup(NTFS_AT_VOLUME_INFORMATION, NTFS_AT_UNNAMED, 0, 0, 0, NULL,
 			0, ctx)) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION was not found "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION was not found "
 				"in $Volume!\n");
 		goto err_out;
 	}
 	a = ctx->attr;
 	/* Sanity check. */
 	if (a->non_resident) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION must be "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION must be "
 				"resident (and it isn't)!\n");
 		errno = EIO;
 		goto err_out;
 	}
 	/* Get a pointer to the value of the attribute. */
-	c = (VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
+	c = (NTFS_VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
 	/* Sanity checks. */
 	if ((char*)c + le32_to_cpu(a->value_length) > (char*)ctx->mrec +
 			le32_to_cpu(ctx->mrec->bytes_in_use) ||
 			le16_to_cpu(a->value_offset) +
 			le32_to_cpu(a->value_length) > le32_to_cpu(a->length)) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION in $Volume is "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION in $Volume is "
 				"corrupt!\n");
 		errno = EIO;
 		goto err_out;
 	}
 	/* Set the volume flags. */
-	vol->flags = c->flags = flags & VOLUME_FLAGS_MASK;
+	vol->flags = c->flags = flags & NTFS_VOLUME_FLAGS_MASK;
 	/* Write them to disk. */
 	ntfs_inode_mark_dirty(vol->vol_ni);
 	if (ntfs_inode_sync(vol->vol_ni)) {
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/libntfs/win32_io.c ./libntfs/win32_io.c
--- ../ntfsprogs-2.0.0/libntfs/win32_io.c	2007-09-26 20:28:34.000000000 +0200
+++ ./libntfs/win32_io.c	2007-10-06 16:48:08.000000000 +0200
@@ -48,9 +48,9 @@
 struct ntfs_volume;
 typedef struct ntfs_volume ntfs_volume;

-#include "debug.h"
-#include "types.h"
-#include "device.h"
+#include "ntfs_debug.h"
+#include "ntfs_types.h"
+#include "ntfs_device.h"

 #ifndef NTFS_BLOCK_SIZE
 #define NTFS_BLOCK_SIZE		512
@@ -63,9 +63,9 @@

 /* Windows 2k+ imports. */
 typedef HANDLE (WINAPI *LPFN_FINDFIRSTVOLUME)(LPTSTR, DWORD);
-typedef BOOL (WINAPI *LPFN_FINDNEXTVOLUME)(HANDLE, LPTSTR, DWORD);
-typedef BOOL (WINAPI *LPFN_FINDVOLUMECLOSE)(HANDLE);
-typedef BOOL (WINAPI *LPFN_SETFILEPOINTEREX)(HANDLE, LARGE_INTEGER,
+typedef NTFS_BOOL (WINAPI *LPFN_FINDNEXTVOLUME)(HANDLE, LPTSTR, DWORD);
+typedef NTFS_BOOL (WINAPI *LPFN_FINDVOLUMECLOSE)(HANDLE);
+typedef NTFS_BOOL (WINAPI *LPFN_SETFILEPOINTEREX)(HANDLE, LARGE_INTEGER,
 		PLARGE_INTEGER, DWORD);

 static LPFN_FINDFIRSTVOLUME fnFindFirstVolume = NULL;
@@ -148,7 +148,7 @@
  * We use this to emulate SetFilePointerEx() when it is not present.  This can
  * happen since SetFilePointerEx() only exists in Win2k+.
  */
-static BOOL WINAPI libntfs_SetFilePointerEx(HANDLE hFile,
+static NTFS_BOOL WINAPI libntfs_SetFilePointerEx(HANDLE hFile,
 		LARGE_INTEGER liDistanceToMove,
 		PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
 {
@@ -228,13 +228,13 @@

 	switch (flags & O_ACCMODE) {
 	case O_RDONLY:
-		win_mode = FILE_READ_DATA;
+		win_mode = NTFS_FILE_READ_DATA;
 		break;
 	case O_WRONLY:
-		win_mode = FILE_WRITE_DATA;
+		win_mode = NTFS_FILE_WRITE_DATA;
 		break;
 	case O_RDWR:
-		win_mode = FILE_READ_DATA | FILE_WRITE_DATA;
+		win_mode = NTFS_FILE_READ_DATA | NTFS_FILE_WRITE_DATA;
 		break;
 	default:
 		/* error */
@@ -258,7 +258,7 @@
  *	 -1 if not, and errno set.  In this case handle is trashed.
  */
 static int ntfs_device_win32_simple_open_file(const char *filename,
-		HANDLE *handle, int flags, BOOL locking)
+		HANDLE *handle, int flags, NTFS_BOOL locking)
 {
 	*handle = CreateFile(filename,
 			ntfs_device_unix_status_flags_to_win32(flags),
@@ -447,7 +447,7 @@
 static int ntfs_device_win32_getgeo(HANDLE handle, win32_fd *fd)
 {
 	DWORD i;
-	BOOL rvl;
+	NTFS_BOOL rvl;
 	BYTE b[sizeof(DISK_GEOMETRY) + sizeof(DISK_PARTITION_INFO) +
 			sizeof(DISK_DETECTION_INFO) + 512];

@@ -675,7 +675,7 @@
  * Returns: TRUE  if found, and sets the output parameters.
  *          FALSE if not and errno is set to the error code.
  */
-static BOOL ntfs_device_win32_find_partition(HANDLE handle, DWORD partition_id,
+static NTFS_BOOL ntfs_device_win32_find_partition(HANDLE handle, DWORD partition_id,
 		s64 *part_offset, s64 *part_length, int *hidden_sectors)
 {
 	DRIVE_LAYOUT_INFORMATION *drive_layout;
@@ -939,12 +939,12 @@
  *	- Does not use/set @fd->pos.
  */
 static s64 ntfs_device_win32_pio(win32_fd *fd, const s64 pos,
-		const s64 count, void *b, const BOOL write)
+		const s64 count, void *b, const NTFS_BOOL write)
 {
 	LARGE_INTEGER li;
 	HANDLE handle;
 	DWORD bt;
-	BOOL res;
+	NTFS_BOOL res;

 	ntfs_log_trace("pos = 0x%llx, count = 0x%llx, direction = %s.\n",
 			(long long)pos, (long long)count, write ? "write" :
@@ -1096,7 +1096,7 @@
 static int ntfs_device_win32_close(struct ntfs_device *dev)
 {
 	win32_fd *fd = (win32_fd *)dev->d_private;
-	BOOL rvl;
+	NTFS_BOOL rvl;

 	ntfs_log_trace("Closing device %p.\n", dev);
 	if (!NDevOpen(dev)) {
@@ -1136,7 +1136,7 @@
 static int ntfs_device_win32_sync(struct ntfs_device *dev)
 {
 	int err = 0;
-	BOOL to_clear = TRUE;
+	NTFS_BOOL to_clear = TRUE;

 	if (!NDevReadOnly(dev) && NDevDirty(dev)) {
 		win32_fd *fd = (win32_fd *)dev->d_private;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/NEWS ./NEWS
--- ../ntfsprogs-2.0.0/NEWS	2007-09-29 00:11:50.000000000 +0200
+++ ./NEWS	2007-10-06 16:48:10.000000000 +0200
@@ -12,5 +12,5 @@
 ntfsprogs and libntfs are now entirely endian safe and more over now we have
 checks that automatically reports endian errors.

-mkntfs now creates a DCE compliant GUID for the volume and does a few other
+mkntfs now creates a DCE compliant NTFS_GUID for the volume and does a few other
 things to be more compliant with Windows Vista.
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/cluster.c ./ntfsprogs/cluster.c
--- ../ntfsprogs-2.0.0/ntfsprogs/cluster.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/cluster.c	2007-10-06 16:48:06.000000000 +0200
@@ -35,19 +35,19 @@

 #include "cluster.h"
 #include "utils.h"
-#include "logging.h"
+#include "ntfs_logging.h"

 /**
  * cluster_find
  */
-int cluster_find(ntfs_volume *vol, LCN c_begin, LCN c_end, cluster_cb *cb, void *data)
+int cluster_find(ntfs_volume *vol, NTFS_LCN c_begin, NTFS_LCN c_end, cluster_cb *cb, void *data)
 {
 	int j;
 	int result = -1;
 	struct mft_search_ctx *m_ctx = NULL;
 	ntfs_attr_search_ctx  *a_ctx = NULL;
-	ATTR_RECORD *rec;
-	runlist *runs;
+	NTFS_ATTR_RECORD *rec;
+	ntfs_runlist *runs;

 	if (!vol || !cb)
 		return -1;
@@ -65,7 +65,7 @@

 		a_ctx = ntfs_attr_get_search_ctx(m_ctx->inode, NULL);

-		while ((rec = find_attribute(AT_UNUSED, a_ctx))) {
+		while ((rec = find_attribute(NTFS_AT_UNUSED, a_ctx))) {

 			if (!rec->non_resident) {
 				ntfs_log_verbose("0x%02x skipped - attr is resident\n", a_ctx->attr->type);
@@ -82,8 +82,8 @@

 			ntfs_log_verbose("\t\tVCN\tLCN\tLength\n");
 			for (j = 0; runs[j].length > 0; j++) {
-				LCN a_begin = runs[j].lcn;
-				LCN a_end   = a_begin + runs[j].length - 1;
+				NTFS_LCN a_begin = runs[j].lcn;
+				NTFS_LCN a_end   = a_begin + runs[j].length - 1;

 				if (a_begin < 0)
 					continue;	// sparse, discontiguous, etc
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/cluster.h ./ntfsprogs/cluster.h
--- ../ntfsprogs-2.0.0/ntfsprogs/cluster.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/cluster.h	2007-10-06 16:48:06.000000000 +0200
@@ -24,16 +24,16 @@
 #ifndef _CLUSTER_H_
 #define _CLUSTER_H_

-#include "types.h"
-#include "volume.h"
+#include "ntfs_types.h"
+#include "ntfs_volume.h"

 typedef struct {
 	int x;
 } ntfs_cluster;

-typedef int (cluster_cb)(ntfs_inode *ino, ATTR_RECORD *attr, runlist_element *run, void *data);
+typedef int (cluster_cb)(ntfs_inode *ino, NTFS_ATTR_RECORD *attr, ntfs_runlist_element *run, void *data);

-int cluster_find(ntfs_volume *vol, LCN c_begin, LCN c_end, cluster_cb *cb, void *data);
+int cluster_find(ntfs_volume *vol, NTFS_LCN c_begin, NTFS_LCN c_end, cluster_cb *cb, void *data);

 #endif /* _CLUSTER_H_ */

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/mkntfs.c ./ntfsprogs/mkntfs.c
--- ../ntfsprogs-2.0.0/ntfsprogs/mkntfs.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/mkntfs.c	2007-10-06 16:48:05.000000000 +0200
@@ -118,25 +118,25 @@
 #	endif
 #endif

-#include "security.h"
-#include "types.h"
-#include "attrib.h"
-#include "bitmap.h"
-#include "bootsect.h"
-#include "device.h"
-#include "dir.h"
-#include "mft.h"
-#include "mst.h"
-#include "runlist.h"
+#include "ntfs_security.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_device.h"
+#include "ntfs_dir.h"
+#include "ntfs_mft.h"
+#include "ntfs_mst.h"
+#include "ntfs_runlist.h"
 #include "utils.h"
-#include "ntfstime.h"
+#include "ntfs_time.h"
 #include "sd.h"
 #include "boot.h"
 #include "attrdef.h"
-#include "version.h"
-#include "logging.h"
-#include "support.h"
-#include "unistr.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"
+#include "ntfs_support.h"
+#include "ntfs_unistr.h"

 #ifdef NO_NTFS_DEVICE_DEFAULT_IO_OPS
 #error "No default device io operations!  Cannot build mkntfs.  \
@@ -157,13 +157,13 @@
 static u8		  *g_mft_bitmap		  = NULL;
 static int		   g_lcn_bitmap_byte_size = 0;
 static u8		  *g_lcn_bitmap		  = NULL;
-static runlist		  *g_rl_mft		  = NULL;
-static runlist		  *g_rl_mft_bmp		  = NULL;
-static runlist		  *g_rl_mftmirr		  = NULL;
-static runlist		  *g_rl_logfile		  = NULL;
-static runlist		  *g_rl_boot		  = NULL;
-static runlist		  *g_rl_bad		  = NULL;
-static INDEX_ALLOCATION  *g_index_block	  = NULL;
+static ntfs_runlist		  *g_rl_mft		  = NULL;
+static ntfs_runlist		  *g_rl_mft_bmp		  = NULL;
+static ntfs_runlist		  *g_rl_mftmirr		  = NULL;
+static ntfs_runlist		  *g_rl_logfile		  = NULL;
+static ntfs_runlist		  *g_rl_boot		  = NULL;
+static ntfs_runlist		  *g_rl_bad		  = NULL;
+static NTFS_INDEX_ALLOCATION  *g_index_block	  = NULL;
 static ntfs_volume	  *g_vol		  = NULL;
 static int		   g_mft_size		  = 0;
 static long long	   g_mft_lcn		  = 0;		/* lcn of $MFT, $DATA attribute */
@@ -179,16 +179,16 @@
  */
 static struct mkntfs_options {
 	char *dev_name;			/* Name of the device, or file, to use */
-	BOOL enable_compression;	/* -C, enables compression of all files on the volume by default. */
-	BOOL quick_format;		/* -f or -Q, fast format, don't zero the volume first. */
-	BOOL force;			/* -F, force fs creation. */
+	NTFS_BOOL enable_compression;	/* -C, enables compression of all files on the volume by default. */
+	NTFS_BOOL quick_format;		/* -f or -Q, fast format, don't zero the volume first. */
+	NTFS_BOOL force;			/* -F, force fs creation. */
 	long heads;			/* -H, number of heads on device */
-	BOOL disable_indexing;		/* -I, disables indexing of file contents on the volume by default. */
-	BOOL no_action;			/* -n, do not write to device, only display what would be done. */
+	NTFS_BOOL disable_indexing;		/* -I, disables indexing of file contents on the volume by default. */
+	NTFS_BOOL no_action;			/* -n, do not write to device, only display what would be done. */
 	long long part_start_sect;	/* -p, start sector of partition on parent device */
 	long sector_size;		/* -s, in bytes, power of 2, default is 512 bytes. */
 	long sectors_per_track;		/* -S, number of sectors per track on device */
-	BOOL use_epoch_time;		/* -T, fake the time to be 00:00:00 UTC, Jan 1, 1970. */
+	NTFS_BOOL use_epoch_time;		/* -T, fake the time to be 00:00:00 UTC, Jan 1, 1970. */
 	long mft_zone_multiplier;	/* -z, value from 1 to 4. Default is 1. */
 	long long num_sectors;		/* size of device in sectors */
 	long cluster_size;		/* -c, format with this cluster-size */
@@ -263,7 +263,7 @@
 /**
  * mkntfs_parse_long
  */
-static BOOL mkntfs_parse_long(const char *string, const char *name, long *num)
+static NTFS_BOOL mkntfs_parse_long(const char *string, const char *name, long *num)
 {
 	char *end = NULL;
 	long tmp;
@@ -289,7 +289,7 @@
 /**
  * mkntfs_parse_llong
  */
-static BOOL mkntfs_parse_llong(const char *string, const char *name,
+static NTFS_BOOL mkntfs_parse_llong(const char *string, const char *name,
 		long long *num)
 {
 	char *end = NULL;
@@ -337,7 +337,7 @@
 /**
  * mkntfs_parse_options
  */
-static BOOL mkntfs_parse_options(int argc, char *argv[], struct mkntfs_options *opts2)
+static NTFS_BOOL mkntfs_parse_options(int argc, char *argv[], struct mkntfs_options *opts2)
 {
 	static const char *sopt = "-c:CfFhH:IlL:np:qQs:S:TvVz:";
 	static const struct option lopt[] = {
@@ -520,7 +520,7 @@
 /**
  * append_to_bad_blocks
  */
-static BOOL append_to_bad_blocks(unsigned long long block)
+static NTFS_BOOL append_to_bad_blocks(unsigned long long block)
 {
 	long long *new_buf;

@@ -572,9 +572,9 @@
 }

 /**
- * ntfs_rlwrite - Write data to disk on clusters found in a runlist.
+ * ntfs_rlwrite - Write data to disk on clusters found in a ntfs_runlist.
  *
- * Write to disk the clusters contained in the runlist @rl taking the data
+ * Write to disk the clusters contained in the ntfs_runlist @rl taking the data
  * from @val.  Take @val_len bytes from @val and pad the rest with zeroes.
  *
  * If the @rl specifies a completely sparse file, @val is allowed to be NULL.
@@ -586,7 +586,7 @@
  * Return the number of bytes written (minus padding) or -1 on error. Errno
  * will be set to the error code.
  */
-static s64 ntfs_rlwrite(struct ntfs_device *dev, const runlist *rl,
+static s64 ntfs_rlwrite(struct ntfs_device *dev, const ntfs_runlist *rl,
 		const u8 *val, const s64 val_len, s64 *inited_size)
 {
 	s64 bytes_written, total, length, delta;
@@ -678,7 +678,7 @@
  *	-EINVAL		Can only occur if mkntfs was compiled with -DDEBUG. Means
  *			the input parameters were faulty.
  */
-static int make_room_for_attribute(MFT_RECORD *m, char *pos, const u32 size)
+static int make_room_for_attribute(NTFS_MFT_RECORD *m, char *pos, const u32 size)
 {
 	u32 biu;

@@ -718,14 +718,14 @@
 /**
  * deallocate_scattered_clusters
  */
-static void deallocate_scattered_clusters(const runlist *rl)
+static void deallocate_scattered_clusters(const ntfs_runlist *rl)
 {
-	LCN j;
+	NTFS_LCN j;
 	int i;

 	if (!rl)
 		return;
-	/* Iterate over all runs in the runlist @rl. */
+	/* Iterate over all runs in the ntfs_runlist @rl. */
 	for (i = 0; rl[i].length; i++) {
 		/* Skip sparse runs. */
 		if (rl[i].lcn == -1LL)
@@ -740,9 +740,9 @@
  * allocate_scattered_clusters
  * @clusters: Amount of clusters to allocate.
  *
- * Allocate @clusters and create a runlist of the allocated clusters.
+ * Allocate @clusters and create a ntfs_runlist of the allocated clusters.
  *
- * Return the allocated runlist. Caller has to free the runlist when finished
+ * Return the allocated ntfs_runlist. Caller has to free the ntfs_runlist when finished
  * with it.
  *
  * On error return NULL and errno is set to the error code.
@@ -750,11 +750,11 @@
  * TODO: We should be returning the size as well, but for mkntfs this is not
  * necessary.
  */
-static runlist * allocate_scattered_clusters(s64 clusters)
+static ntfs_runlist * allocate_scattered_clusters(s64 clusters)
 {
-	runlist *rl = NULL, *rlt;
-	VCN vcn = 0LL;
-	LCN lcn, end, prev_lcn = 0LL;
+	ntfs_runlist *rl = NULL, *rlt;
+	NTFS_VCN vcn = 0LL;
+	NTFS_LCN lcn, end, prev_lcn = 0LL;
 	int rlpos = 0;
 	int rlsize = 0;
 	s64 prev_run_len = 0LL;
@@ -772,7 +772,7 @@
 			 * Reallocate memory if necessary. Make sure we have
 			 * enough for the terminator entry as well.
 			 */
-			if ((rlpos + 2) * (int)sizeof(runlist) >= rlsize) {
+			if ((rlpos + 2) * (int)sizeof(ntfs_runlist) >= rlsize) {
 				rlsize += 4096; /* PAGE_SIZE */
 				rlt = realloc(rl, rlsize);
 				if (!rlt)
@@ -817,7 +817,7 @@
 		rl[rlpos].length = 0LL;
 		/* Deallocate all allocated clusters. */
 		deallocate_scattered_clusters(rl);
-		/* Free the runlist. */
+		/* Free the ntfs_runlist. */
 		free(rl);
 	}
 	return NULL;
@@ -828,7 +828,7 @@
  * @type:	attribute type to find
  * @name:	attribute name to find (optional, i.e. NULL means don't care)
  * @name_len:	attribute name length (only needed if @name present)
- * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)
+ * @ic:		NTFS_IGNORE_CASE or NTFS_CASE_SENSITIVE (ignored if @name not present)
  * @val:	attribute value to find (optional, resident attributes only)
  * @val_len:	attribute value length
  * @ctx:	search context with mft record and attribute to search from
@@ -851,26 +851,26 @@
  * If @ctx->is_first is TRUE, the search begins with @ctx->attr itself. If it
  * is FALSE, the search begins after @ctx->attr.
  *
- * If @type is AT_UNUSED, return the first found attribute, i.e. one can
- * enumerate all attributes by setting @type to AT_UNUSED and then calling
+ * If @type is NTFS_AT_UNUSED, return the first found attribute, i.e. one can
+ * enumerate all attributes by setting @type to NTFS_AT_UNUSED and then calling
  * ntfs_attr_find() repeatedly until it returns -1 with errno set to ENOENT to
  * indicate that there are no more entries. During the enumeration, each
  * successful call of ntfs_attr_find() will return the next attribute in the
  * mft record @ctx->mrec.
  *
- * If @type is AT_END, seek to the end and return -1 with errno set to ENOENT.
- * AT_END is not a valid attribute, its length is zero for example, thus it is
+ * If @type is NTFS_AT_END, seek to the end and return -1 with errno set to ENOENT.
+ * NTFS_AT_END is not a valid attribute, its length is zero for example, thus it is
  * safer to return error instead of success in this case. This also allows us
  * to interoperate cleanly with ntfs_external_attr_find().
  *
- * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present
- * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,
+ * If @name is NTFS_AT_UNNAMED search for an unnamed attribute. If @name is present
+ * but not NTFS_AT_UNNAMED search for a named attribute matching @name. Otherwise,
  * match both named and unnamed attributes.
  *
- * If @ic is IGNORE_CASE, the @name comparison is not case sensitive and
+ * If @ic is NTFS_IGNORE_CASE, the @name comparison is not case sensitive and
  * @ctx->ntfs_ino must be set to the ntfs inode to which the mft record
  * @ctx->mrec belongs. This is so we can get at the ntfs volume and hence at
- * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case
+ * the upcase table. If @ic is NTFS_CASE_SENSITIVE, the comparison is case
  * sensitive. When @name is present, @name_len is the @name length in Unicode
  * characters.
  *
@@ -893,11 +893,11 @@
  * Warning: Never use @val when looking for attribute types which can be
  *	    non-resident as this most likely will result in a crash!
  */
-static int mkntfs_attr_find(const ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
+static int mkntfs_attr_find(const NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
 		const u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	ntfschar *upcase = g_vol->upcase;
 	u32 upcase_len = g_vol->upcase_len;

@@ -909,33 +909,33 @@
 		a = ctx->attr;
 		ctx->is_first = FALSE;
 	} else {
-		a = (ATTR_RECORD*)((char*)ctx->attr +
+		a = (NTFS_ATTR_RECORD*)((char*)ctx->attr +
 				le32_to_cpu(ctx->attr->length));
 	}
-	for (;;	a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a->length))) {
+	for (;;	a = (NTFS_ATTR_RECORD*)((char*)a + le32_to_cpu(a->length))) {
 		if (p2n(a) < p2n(ctx->mrec) || (char*)a > (char*)ctx->mrec +
 				le32_to_cpu(ctx->mrec->bytes_allocated))
 			break;
 		ctx->attr = a;
-		if (((type != AT_UNUSED) && (le32_to_cpu(a->type) >
+		if (((type != NTFS_AT_UNUSED) && (le32_to_cpu(a->type) >
 				le32_to_cpu(type))) ||
-				(a->type == AT_END)) {
+				(a->type == NTFS_AT_END)) {
 			errno = ENOENT;
 			return -1;
 		}
 		if (!a->length)
 			break;
 		/* If this is an enumeration return this attribute. */
-		if (type == AT_UNUSED)
+		if (type == NTFS_AT_UNUSED)
 			return 0;
 		if (a->type != type)
 			continue;
 		/*
-		 * If @name is AT_UNNAMED we want an unnamed attribute.
+		 * If @name is NTFS_AT_UNNAMED we want an unnamed attribute.
 		 * If @name is present, compare the two names.
 		 * Otherwise, match any attribute.
 		 */
-		if (name == AT_UNNAMED) {
+		if (name == NTFS_AT_UNNAMED) {
 			/* The search failed if the found attribute is named. */
 			if (a->name_length) {
 				errno = ENOENT;
@@ -949,7 +949,7 @@
 			rc = ntfs_names_collate(name, name_len,
 					(ntfschar*)((char*)a +
 					le16_to_cpu(a->name_offset)),
-					a->name_length, 1, IGNORE_CASE,
+					a->name_length, 1, NTFS_IGNORE_CASE,
 					upcase, upcase_len);
 			/*
 			 * If @name collates before a->name, there is no
@@ -965,7 +965,7 @@
 			rc = ntfs_names_collate(name, name_len,
 					(ntfschar*)((char*)a +
 					le16_to_cpu(a->name_offset)),
-					a->name_length, 1, CASE_SENSITIVE,
+					a->name_length, 1, NTFS_CASE_SENSITIVE,
 					upcase, upcase_len);
 			if (rc == -1) {
 				errno = ENOENT;
@@ -1017,7 +1017,7 @@
  * @type:	attribute type to find
  * @name:	attribute name to find (optional, i.e. NULL means don't care)
  * @name_len:	attribute name length (only needed if @name present)
- * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)
+ * @ic:		NTFS_IGNORE_CASE or NTFS_CASE_SENSITIVE (ignored if @name not present)
  * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)
  * @val:	attribute value to find (optional, resident attributes only)
  * @val_len:	attribute value length
@@ -1030,22 +1030,22 @@
  * This function transparently handles attribute lists and @ctx is used to
  * continue searches where they were left off at.
  *
- * If @type is AT_UNUSED, return the first found attribute, i.e. one can
- * enumerate all attributes by setting @type to AT_UNUSED and then calling
+ * If @type is NTFS_AT_UNUSED, return the first found attribute, i.e. one can
+ * enumerate all attributes by setting @type to NTFS_AT_UNUSED and then calling
  * ntfs_attr_lookup() repeatedly until it returns -1 with errno set to ENOENT
  * to indicate that there are no more entries. During the enumeration, each
  * successful call of ntfs_attr_lookup() will return the next attribute, with
  * the current attribute being described by the search context @ctx.
  *
- * If @type is AT_END, seek to the end of the base mft record ignoring the
- * attribute list completely and return -1 with errno set to ENOENT.  AT_END is
+ * If @type is NTFS_AT_END, seek to the end of the base mft record ignoring the
+ * attribute list completely and return -1 with errno set to ENOENT.  NTFS_AT_END is
  * not a valid attribute, its length is zero for example, thus it is safer to
  * return error instead of success in this case.  It should never be needed to
  * do this, but we implement the functionality because it allows for simpler
  * code inside ntfs_external_attr_find().
  *
- * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present
- * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,
+ * If @name is NTFS_AT_UNNAMED search for an unnamed attribute. If @name is present
+ * but not NTFS_AT_UNNAMED search for a named attribute matching @name. Otherwise,
  * match both named and unnamed attributes.
  *
  * After finishing with the attribute/mft record you need to call
@@ -1069,7 +1069,7 @@
  * @ctx->al_entry points to the position within @ctx->base_ntfs_ino->attr_list
  * at which the new attribute's attribute list entry should be inserted.  The
  * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.
- * The only exception to this is when @type is AT_END, in which case
+ * The only exception to this is when @type is NTFS_AT_END, in which case
  * @ctx->al_entry is set to NULL also (see above).
  *
  * The following error codes are defined:
@@ -1078,9 +1078,9 @@
  *	EIO	I/O error or corrupt data structures found.
  *	ENOMEM	Not enough memory to allocate necessary buffers.
  */
-static int mkntfs_attr_lookup(const ATTR_TYPES type, const ntfschar *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const VCN lowest_vcn __attribute__((unused)), const u8 *val,
+static int mkntfs_attr_lookup(const NTFS_ATTR_TYPES type, const ntfschar *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_VCN lowest_vcn __attribute__((unused)), const u8 *val,
 		const u32 val_len, ntfs_attr_search_ctx *ctx)
 {
 	ntfs_inode *base_ni;
@@ -1093,7 +1093,7 @@
 		base_ni = ctx->base_ntfs_ino;
 	else
 		base_ni = ctx->ntfs_ino;
-	if (!base_ni || !NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)
+	if (!base_ni || !NInoAttrList(base_ni) || type == NTFS_AT_ATTRIBUTE_LIST)
 		return mkntfs_attr_find(type, name, name_len, ic, val, val_len,
 				ctx);
 	errno = EOPNOTSUPP;
@@ -1104,22 +1104,22 @@
  * insert_positioned_attr_in_mft_record
  *
  * Create a non-resident attribute with a predefined on disk location
- * specified by the runlist @rl. The clusters specified by @rl are assumed to
+ * specified by the ntfs_runlist @rl. The clusters specified by @rl are assumed to
  * be allocated already.
  *
  * Return 0 on success and -errno on error.
  */
-static int insert_positioned_attr_in_mft_record(MFT_RECORD *m,
-		const ATTR_TYPES type, const char *name, u32 name_len,
-		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,
-		const runlist *rl, const u8 *val, const s64 val_len)
+static int insert_positioned_attr_in_mft_record(NTFS_MFT_RECORD *m,
+		const NTFS_ATTR_TYPES type, const char *name, u32 name_len,
+		const NTFS_IGNORE_CASE_BOOL ic, const NTFS_ATTR_FLAGS flags,
+		const ntfs_runlist *rl, const u8 *val, const s64 val_len)
 {
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	u16 hdr_size;
 	int asize, mpa_size, err, i;
 	s64 bw = 0, inited_size;
-	VCN highest_vcn;
+	NTFS_VCN highest_vcn;
 	ntfschar *uname = NULL;
 	int uname_len = 0;
 	/*
@@ -1139,7 +1139,7 @@
 		err = -ENOMEM;
 		goto err_out;
 	}
-	if (ic == IGNORE_CASE) {
+	if (ic == NTFS_IGNORE_CASE) {
 		ntfs_log_error("FIXME: Hit unimplemented code path #1.\n");
 		err = -EOPNOTSUPP;
 		goto err_out;
@@ -1154,19 +1154,19 @@
 		goto err_out;
 	}
 	a = ctx->attr;
-	if (flags & ATTR_COMPRESSION_MASK) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
 		ntfs_log_error("Compressed attributes not supported yet.\n");
 		/* FIXME: Compress attribute into a temporary buffer, set */
 		/* val accordingly and save the compressed size. */
 		err = -EOPNOTSUPP;
 		goto err_out;
 	}
-	if (flags & (ATTR_IS_ENCRYPTED | ATTR_IS_SPARSE)) {
+	if (flags & (NTFS_ATTR_IS_ENCRYPTED | NTFS_ATTR_IS_SPARSE)) {
 		ntfs_log_error("Encrypted/sparse attributes not supported.\n");
 		err = -EOPNOTSUPP;
 		goto err_out;
 	}
-	if (flags & ATTR_COMPRESSION_MASK) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
 		hdr_size = 72;
 		/* FIXME: This compression stuff is all wrong. Never mind for */
 		/* now. (AIA) */
@@ -1205,14 +1205,14 @@
 		 * FIXME: Make space! (AIA)
 		 * can we make it non-resident? if yes, do that.
 		 *	does it fit now? yes -> do it.
-		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?
+		 * m's $DATA or $BITMAP+$NTFS_INDEX_ALLOCATION resident?
 		 * yes -> make non-resident
 		 *	does it fit now? yes -> do it.
 		 * make all attributes non-resident
 		 *	does it fit now? yes -> do it.
 		 * m is a base record? yes -> allocate extension record
 		 *	does the new attribute fit in there? yes -> do it.
-		 * split up runlist into extents and place each in an extension
+		 * split up ntfs_runlist into extents and place each in an extension
 		 * record.
 		 * FIXME: the check for needing extension records should be
 		 * earlier on as it is very quick: asize > m->bytes_allocated?
@@ -1245,12 +1245,12 @@
 	a->data_size = cpu_to_sle64(val_len);
 	if (name_len)
 		memcpy((char*)a + hdr_size, uname, name_len << 1);
-	if (flags & ATTR_COMPRESSION_MASK) {
-		if (flags & ATTR_COMPRESSION_MASK & ~ATTR_IS_COMPRESSED) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
+		if (flags & NTFS_ATTR_COMPRESSION_MASK & ~NTFS_ATTR_IS_COMPRESSED) {
 			ntfs_log_error("Unknown compression format. Reverting "
 					"to standard compression.\n");
-			a->flags &= ~ATTR_COMPRESSION_MASK;
-			a->flags |= ATTR_IS_COMPRESSED;
+			a->flags &= ~NTFS_ATTR_COMPRESSION_MASK;
+			a->flags |= NTFS_ATTR_IS_COMPRESSED;
 		}
 		a->compression_unit = 4;
 		inited_size = val_len;
@@ -1292,16 +1292,16 @@
  *
  * Return 0 on success and -errno on error.
  */
-static int insert_non_resident_attr_in_mft_record(MFT_RECORD *m,
-		const ATTR_TYPES type, const char *name, u32 name_len,
-		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,
+static int insert_non_resident_attr_in_mft_record(NTFS_MFT_RECORD *m,
+		const NTFS_ATTR_TYPES type, const char *name, u32 name_len,
+		const NTFS_IGNORE_CASE_BOOL ic, const NTFS_ATTR_FLAGS flags,
 		const u8 *val, const s64 val_len)
 {
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	u16 hdr_size;
 	int asize, mpa_size, err, i;
-	runlist *rl = NULL;
+	ntfs_runlist *rl = NULL;
 	s64 bw = 0;
 	ntfschar *uname = NULL;
 	int uname_len = 0;
@@ -1322,7 +1322,7 @@
 		err = -ENOMEM;
 		goto err_out;
 	}
-	if (ic == IGNORE_CASE) {
+	if (ic == NTFS_IGNORE_CASE) {
 		ntfs_log_error("FIXME: Hit unimplemented code path #2.\n");
 		err = -EOPNOTSUPP;
 		goto err_out;
@@ -1337,14 +1337,14 @@
 		goto err_out;
 	}
 	a = ctx->attr;
-	if (flags & ATTR_COMPRESSION_MASK) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
 		ntfs_log_error("Compressed attributes not supported yet.\n");
 		/* FIXME: Compress attribute into a temporary buffer, set */
 		/* val accordingly and save the compressed size. */
 		err = -EOPNOTSUPP;
 		goto err_out;
 	}
-	if (flags & (ATTR_IS_ENCRYPTED | ATTR_IS_SPARSE)) {
+	if (flags & (NTFS_ATTR_IS_ENCRYPTED | NTFS_ATTR_IS_SPARSE)) {
 		ntfs_log_error("Encrypted/sparse attributes not supported.\n");
 		err = -EOPNOTSUPP;
 		goto err_out;
@@ -1360,7 +1360,7 @@
 	} else {
 		rl = NULL;
 	}
-	if (flags & ATTR_COMPRESSION_MASK) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
 		hdr_size = 72;
 		/* FIXME: This compression stuff is all wrong. Never mind for */
 		/* now. (AIA) */
@@ -1390,14 +1390,14 @@
 		 * FIXME: Make space! (AIA)
 		 * can we make it non-resident? if yes, do that.
 		 *	does it fit now? yes -> do it.
-		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?
+		 * m's $DATA or $BITMAP+$NTFS_INDEX_ALLOCATION resident?
 		 * yes -> make non-resident
 		 *	does it fit now? yes -> do it.
 		 * make all attributes non-resident
 		 *	does it fit now? yes -> do it.
 		 * m is a base record? yes -> allocate extension record
 		 *	does the new attribute fit in there? yes -> do it.
-		 * split up runlist into extents and place each in an extension
+		 * split up ntfs_runlist into extents and place each in an extension
 		 * record.
 		 * FIXME: the check for needing extension records should be
 		 * earlier on as it is very quick: asize > m->bytes_allocated?
@@ -1434,12 +1434,12 @@
 	a->initialized_size = cpu_to_sle64(val_len);
 	if (name_len)
 		memcpy((char*)a + hdr_size, uname, name_len << 1);
-	if (flags & ATTR_COMPRESSION_MASK) {
-		if (flags & ATTR_COMPRESSION_MASK & ~ATTR_IS_COMPRESSED) {
+	if (flags & NTFS_ATTR_COMPRESSION_MASK) {
+		if (flags & NTFS_ATTR_COMPRESSION_MASK & ~NTFS_ATTR_IS_COMPRESSED) {
 			ntfs_log_error("Unknown compression format. Reverting "
 					"to standard compression.\n");
-			a->flags &= ~ATTR_COMPRESSION_MASK;
-			a->flags |= ATTR_IS_COMPRESSED;
+			a->flags &= ~NTFS_ATTR_COMPRESSION_MASK;
+			a->flags |= NTFS_ATTR_IS_COMPRESSED;
 		}
 		a->compression_unit = 4;
 		/* FIXME: Set the compressed size. */
@@ -1480,14 +1480,14 @@
  *
  * Return 0 on success and -errno on error.
  */
-static int insert_resident_attr_in_mft_record(MFT_RECORD *m,
-		const ATTR_TYPES type, const char *name, u32 name_len,
-		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,
-		const RESIDENT_ATTR_FLAGS res_flags,
+static int insert_resident_attr_in_mft_record(NTFS_MFT_RECORD *m,
+		const NTFS_ATTR_TYPES type, const char *name, u32 name_len,
+		const NTFS_IGNORE_CASE_BOOL ic, const NTFS_ATTR_FLAGS flags,
+		const NTFS_RESIDENT_ATTR_FLAGS res_flags,
 		const u8 *val, const u32 val_len)
 {
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	int asize, err;
 	ntfschar *uname = NULL;
 	int uname_len = 0;
@@ -1508,7 +1508,7 @@
 		err = -ENOMEM;
 		goto err_out;
 	}
-	if (ic == IGNORE_CASE) {
+	if (ic == NTFS_IGNORE_CASE) {
 		ntfs_log_error("FIXME: Hit unimplemented code path #3.\n");
 		err = -EOPNOTSUPP;
 		goto err_out;
@@ -1532,14 +1532,14 @@
 		 * FIXME: Make space! (AIA)
 		 * can we make it non-resident? if yes, do that.
 		 *	does it fit now? yes -> do it.
-		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?
+		 * m's $DATA or $BITMAP+$NTFS_INDEX_ALLOCATION resident?
 		 * yes -> make non-resident
 		 *	does it fit now? yes -> do it.
 		 * make all attributes non-resident
 		 *	does it fit now? yes -> do it.
 		 * m is a base record? yes -> allocate extension record
 		 *	does the new attribute fit in there? yes -> do it.
-		 * split up runlist into extents and place each in an extension
+		 * split up ntfs_runlist into extents and place each in an extension
 		 * record.
 		 * FIXME: the check for needing extension records should be
 		 * earlier on as it is very quick: asize > m->bytes_allocated?
@@ -1559,7 +1559,7 @@
 	a->length = cpu_to_le32(asize);
 	a->non_resident = 0;
 	a->name_length = name_len;
-	if (type == AT_OBJECT_ID)
+	if (type == NTFS_AT_OBJECT_ID)
 		a->name_offset = const_cpu_to_le16(0);
 	else
 		a->name_offset = const_cpu_to_le16(24);
@@ -1588,10 +1588,10 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_std_info(MFT_RECORD *m, const FILE_ATTR_FLAGS flags,
+static int add_attr_std_info(NTFS_MFT_RECORD *m, const NTFS_FILE_ATTR_FLAGS flags,
 		le32 security_id)
 {
-	STANDARD_INFORMATION si;
+	NTFS_STANDARD_INFORMATION si;
 	int err, sd_size;

 	sd_size = 48;
@@ -1613,7 +1613,7 @@
 	/* FIXME: $UsnJrnl support... Not needed on fresh w2k3-volume */
 	si.usn = cpu_to_le64(0ULL);
 	/* NTFS 1.2: size of si = 48, NTFS 3.[01]: size of si = 72 */
-	err = insert_resident_attr_in_mft_record(m, AT_STANDARD_INFORMATION,
+	err = insert_resident_attr_in_mft_record(m, NTFS_AT_STANDARD_INFORMATION,
 			NULL, 0, 0, 0, 0, (u8*)&si, sd_size);
 	if (err < 0)
 		ntfs_log_perror("add_attr_std_info failed");
@@ -1625,15 +1625,15 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_file_name(MFT_RECORD *m, const leMFT_REF parent_dir,
+static int add_attr_file_name(NTFS_MFT_RECORD *m, const NTFS_leMFT_REF parent_dir,
 		const s64 allocated_size, const s64 data_size,
-		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
+		const NTFS_FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
 		const u32 reparse_point_tag, const char *file_name,
-		const FILE_NAME_TYPE_FLAGS file_name_type)
+		const NTFS_FILE_NAME_TYPE_FLAGS file_name_type)
 {
 	ntfs_attr_search_ctx *ctx;
-	STANDARD_INFORMATION *si;
-	FILE_NAME_ATTR *fn;
+	NTFS_STANDARD_INFORMATION *si;
+	NTFS_FILE_NAME_ATTR *fn;
 	int i, fn_size;
 	ntfschar *uname;

@@ -1643,7 +1643,7 @@
 		ntfs_log_error("Failed to get attribute search context.\n");
 		return -ENOMEM;
 	}
-	if (mkntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED, 0, 0, 0,
+	if (mkntfs_attr_lookup(NTFS_AT_STANDARD_INFORMATION, NTFS_AT_UNNAMED, 0, 0, 0,
 				NULL, 0, ctx)) {
 		int eo = errno;
 		ntfs_log_error("BUG: Standard information attribute not "
@@ -1651,10 +1651,10 @@
 		ntfs_attr_put_search_ctx(ctx);
 		return -eo;
 	}
-	si = (STANDARD_INFORMATION*)((char*)ctx->attr +
+	si = (NTFS_STANDARD_INFORMATION*)((char*)ctx->attr +
 			le16_to_cpu(ctx->attr->value_offset));
 	i = (strlen(file_name) + 1) * sizeof(ntfschar);
-	fn_size = sizeof(FILE_NAME_ATTR) + i;
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i;
 	fn = ntfs_malloc(fn_size);
 	if (!fn) {
 		ntfs_attr_put_search_ctx(ctx);
@@ -1695,9 +1695,9 @@
 	}
 	/* No terminating null in file names. */
 	fn->file_name_length = i;
-	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);
-	i = insert_resident_attr_in_mft_record(m, AT_FILE_NAME, NULL, 0, 0,
-			0, RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i * sizeof(ntfschar);
+	i = insert_resident_attr_in_mft_record(m, NTFS_AT_FILE_NAME, NULL, 0, 0,
+			0, NTFS_RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
 	free(fn);
 	if (i < 0)
 		ntfs_log_error("add_attr_file_name failed: %s\n", strerror(-i));
@@ -1709,21 +1709,21 @@
 /**
  * add_attr_object_id -
  *
- * Note we insert only a basic object id which only has the GUID and none of
+ * Note we insert only a basic object id which only has the NTFS_GUID and none of
  * the extended fields.  This is because we currently only use this function
  * when creating the object id for the volume.
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_object_id(MFT_RECORD *m, const GUID *object_id)
+static int add_attr_object_id(NTFS_MFT_RECORD *m, const NTFS_GUID *object_id)
 {
-	OBJECT_ID_ATTR oi;
+	NTFS_OBJECT_ID_ATTR oi;
 	int err;

-	oi = (OBJECT_ID_ATTR) {
+	oi = (NTFS_OBJECT_ID_ATTR) {
 		.object_id = *object_id,
 	};
-	err = insert_resident_attr_in_mft_record(m, AT_OBJECT_ID, NULL,
+	err = insert_resident_attr_in_mft_record(m, NTFS_AT_OBJECT_ID, NULL,
 			0, 0, 0, 0, (u8*)&oi, sizeof(oi.object_id));
 	if (err < 0)
 		ntfs_log_error("add_attr_vol_info failed: %s\n", strerror(-err));
@@ -1740,7 +1740,7 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_sd(MFT_RECORD *m, const u8 *sd, const s64 sd_len)
+static int add_attr_sd(NTFS_MFT_RECORD *m, const u8 *sd, const s64 sd_len)
 {
 	int err;

@@ -1748,11 +1748,11 @@
 	if (le32_to_cpu(m->bytes_in_use) + 24 + sd_len >
 						le32_to_cpu(m->bytes_allocated))
 		err = insert_non_resident_attr_in_mft_record(m,
-				AT_SECURITY_DESCRIPTOR, NULL, 0, 0, 0, sd,
+				NTFS_AT_SECURITY_DESCRIPTOR, NULL, 0, 0, 0, sd,
 				sd_len);
 	else
 		err = insert_resident_attr_in_mft_record(m,
-				AT_SECURITY_DESCRIPTOR, NULL, 0, 0, 0, 0, sd,
+				NTFS_AT_SECURITY_DESCRIPTOR, NULL, 0, 0, 0, 0, sd,
 				sd_len);
 	if (err < 0)
 		ntfs_log_error("add_attr_sd failed: %s\n", strerror(-err));
@@ -1764,8 +1764,8 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_data(MFT_RECORD *m, const char *name, const u32 name_len,
-		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,
+static int add_attr_data(NTFS_MFT_RECORD *m, const char *name, const u32 name_len,
+		const NTFS_IGNORE_CASE_BOOL ic, const NTFS_ATTR_FLAGS flags,
 		const u8 *val, const s64 val_len)
 {
 	int err;
@@ -1784,10 +1784,10 @@
 	if (le32_to_cpu(m->bytes_in_use) + 24 + val_len >
 			min(le32_to_cpu(m->bytes_allocated),
 			le32_to_cpu(m->bytes_allocated) - 512))
-		err = insert_non_resident_attr_in_mft_record(m, AT_DATA, name,
+		err = insert_non_resident_attr_in_mft_record(m, NTFS_AT_DATA, name,
 				name_len, ic, flags, val, val_len);
 	else
-		err = insert_resident_attr_in_mft_record(m, AT_DATA, name,
+		err = insert_resident_attr_in_mft_record(m, NTFS_AT_DATA, name,
 				name_len, ic, flags, 0, val, val_len);

 	if (err < 0)
@@ -1799,19 +1799,19 @@
  * add_attr_data_positioned
  *
  * Create a non-resident data attribute with a predefined on disk location
- * specified by the runlist @rl. The clusters specified by @rl are assumed to
+ * specified by the ntfs_runlist @rl. The clusters specified by @rl are assumed to
  * be allocated already.
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_data_positioned(MFT_RECORD *m, const char *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const ATTR_FLAGS flags, const runlist *rl,
+static int add_attr_data_positioned(NTFS_MFT_RECORD *m, const char *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_ATTR_FLAGS flags, const ntfs_runlist *rl,
 		const u8 *val, const s64 val_len)
 {
 	int err;

-	err = insert_positioned_attr_in_mft_record(m, AT_DATA, name, name_len,
+	err = insert_positioned_attr_in_mft_record(m, NTFS_AT_DATA, name, name_len,
 			ic, flags, rl, val, val_len);
 	if (err < 0)
 		ntfs_log_error("add_attr_data_positioned failed: %s\n",
@@ -1830,7 +1830,7 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_vol_name(MFT_RECORD *m, const char *vol_name,
+static int add_attr_vol_name(NTFS_MFT_RECORD *m, const char *vol_name,
 		const int vol_name_len __attribute__((unused)))
 {
 	ntfschar *uname = NULL;
@@ -1846,7 +1846,7 @@
 			return -ENAMETOOLONG;
 		}
 	}
-	i = insert_resident_attr_in_mft_record(m, AT_VOLUME_NAME, NULL, 0, 0,
+	i = insert_resident_attr_in_mft_record(m, NTFS_AT_VOLUME_NAME, NULL, 0, 0,
 			0, 0, (u8*)uname, uname_len*sizeof(ntfschar));
 	free(uname);
 	if (i < 0)
@@ -1859,17 +1859,17 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_vol_info(MFT_RECORD *m, const VOLUME_FLAGS flags,
+static int add_attr_vol_info(NTFS_MFT_RECORD *m, const NTFS_VOLUME_FLAGS flags,
 		const u8 major_ver, const u8 minor_ver)
 {
-	VOLUME_INFORMATION vi;
+	NTFS_VOLUME_INFORMATION vi;
 	int err;

 	memset(&vi, 0, sizeof(vi));
 	vi.major_ver = major_ver;
 	vi.minor_ver = minor_ver;
-	vi.flags = flags & VOLUME_FLAGS_MASK;
-	err = insert_resident_attr_in_mft_record(m, AT_VOLUME_INFORMATION, NULL,
+	vi.flags = flags & NTFS_VOLUME_FLAGS_MASK;
+	err = insert_resident_attr_in_mft_record(m, NTFS_AT_VOLUME_INFORMATION, NULL,
 			0, 0, 0, 0, (u8*)&vi, sizeof(vi));
 	if (err < 0)
 		ntfs_log_error("add_attr_vol_info failed: %s\n", strerror(-err));
@@ -1881,26 +1881,26 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_index_root(MFT_RECORD *m, const char *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const ATTR_TYPES indexed_attr_type,
-		const COLLATION_RULES collation_rule,
+static int add_attr_index_root(NTFS_MFT_RECORD *m, const char *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const NTFS_ATTR_TYPES indexed_attr_type,
+		const NTFS_COLLATION_RULES collation_rule,
 		const u32 index_block_size)
 {
-	INDEX_ROOT *r;
-	INDEX_ENTRY_HEADER *e;
+	NTFS_INDEX_ROOT *r;
+	NTFS_INDEX_ENTRY_HEADER *e;
 	int err, val_len;

-	val_len = sizeof(INDEX_ROOT) + sizeof(INDEX_ENTRY_HEADER);
+	val_len = sizeof(NTFS_INDEX_ROOT) + sizeof(NTFS_INDEX_ENTRY_HEADER);
 	r = ntfs_malloc(val_len);
 	if (!r)
 		return -errno;
-	r->type = (indexed_attr_type == AT_FILE_NAME) ? AT_FILE_NAME : 0;
-	if (indexed_attr_type == AT_FILE_NAME &&
-			collation_rule != COLLATION_FILE_NAME) {
+	r->type = (indexed_attr_type == NTFS_AT_FILE_NAME) ? NTFS_AT_FILE_NAME : 0;
+	if (indexed_attr_type == NTFS_AT_FILE_NAME &&
+			collation_rule != NTFS_COLLATION_FILE_NAME) {
 		free(r);
 		ntfs_log_error("add_attr_index_root: indexed attribute is $FILE_NAME "
-			"but collation rule is not COLLATION_FILE_NAME.\n");
+			"but collation rule is not NTFS_COLLATION_FILE_NAME.\n");
 		return -EINVAL;
 	}
 	r->collation_rule = collation_rule;
@@ -1931,13 +1931,13 @@
 				opts.sector_size;
 	}
 	memset(&r->reserved, 0, sizeof(r->reserved));
-	r->index.entries_offset = const_cpu_to_le32(sizeof(INDEX_HEADER));
-	r->index.index_length = const_cpu_to_le32(sizeof(INDEX_HEADER) +
-			sizeof(INDEX_ENTRY_HEADER));
+	r->index.entries_offset = const_cpu_to_le32(sizeof(NTFS_INDEX_HEADER));
+	r->index.index_length = const_cpu_to_le32(sizeof(NTFS_INDEX_HEADER) +
+			sizeof(NTFS_INDEX_ENTRY_HEADER));
 	r->index.allocated_size = r->index.index_length;
-	r->index.flags = SMALL_INDEX;
+	r->index.flags = NTFS_SMALL_INDEX;
 	memset(&r->index.reserved, 0, sizeof(r->index.reserved));
-	e = (INDEX_ENTRY_HEADER*)((u8*)&r->index +
+	e = (NTFS_INDEX_ENTRY_HEADER*)((u8*)&r->index +
 			le32_to_cpu(r->index.entries_offset));
 	/*
 	 * No matter whether this is a file index or a view as this is a
@@ -1945,11 +1945,11 @@
 	 * at all. Thus, we just need the union to be all zero.
 	 */
 	e->indexed_file = const_cpu_to_le64(0LL);
-	e->length = const_cpu_to_le16(sizeof(INDEX_ENTRY_HEADER));
+	e->length = const_cpu_to_le16(sizeof(NTFS_INDEX_ENTRY_HEADER));
 	e->key_length = const_cpu_to_le16(0);
-	e->flags = INDEX_ENTRY_END;
+	e->flags = NTFS_INDEX_ENTRY_END;
 	e->reserved = const_cpu_to_le16(0);
-	err = insert_resident_attr_in_mft_record(m, AT_INDEX_ROOT, name,
+	err = insert_resident_attr_in_mft_record(m, NTFS_AT_INDEX_ROOT, name,
 				name_len, ic, 0, 0, (u8*)r, val_len);
 	free(r);
 	if (err < 0)
@@ -1962,13 +1962,13 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_index_alloc(MFT_RECORD *m, const char *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
+static int add_attr_index_alloc(NTFS_MFT_RECORD *m, const char *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
 		const u8 *index_alloc_val, const u32 index_alloc_val_len)
 {
 	int err;

-	err = insert_non_resident_attr_in_mft_record(m, AT_INDEX_ALLOCATION,
+	err = insert_non_resident_attr_in_mft_record(m, NTFS_AT_INDEX_ALLOCATION,
 			name, name_len, ic, 0, index_alloc_val,
 			index_alloc_val_len);
 	if (err < 0)
@@ -1981,8 +1981,8 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_bitmap(MFT_RECORD *m, const char *name, const u32 name_len,
-		const IGNORE_CASE_BOOL ic, const u8 *bitmap,
+static int add_attr_bitmap(NTFS_MFT_RECORD *m, const char *name, const u32 name_len,
+		const NTFS_IGNORE_CASE_BOOL ic, const u8 *bitmap,
 		const u32 bitmap_len)
 {
 	int err;
@@ -1990,10 +1990,10 @@
 	/* Does it fit? NO: create non-resident. YES: create resident. */
 	if (le32_to_cpu(m->bytes_in_use) + 24 + bitmap_len >
 						le32_to_cpu(m->bytes_allocated))
-		err = insert_non_resident_attr_in_mft_record(m, AT_BITMAP, name,
+		err = insert_non_resident_attr_in_mft_record(m, NTFS_AT_BITMAP, name,
 				name_len, ic, 0, bitmap, bitmap_len);
 	else
-		err = insert_resident_attr_in_mft_record(m, AT_BITMAP, name,
+		err = insert_resident_attr_in_mft_record(m, NTFS_AT_BITMAP, name,
 				name_len, ic, 0, 0, bitmap, bitmap_len);

 	if (err < 0)
@@ -2005,18 +2005,18 @@
  * add_attr_bitmap_positioned
  *
  * Create a non-resident bitmap attribute with a predefined on disk location
- * specified by the runlist @rl. The clusters specified by @rl are assumed to
+ * specified by the ntfs_runlist @rl. The clusters specified by @rl are assumed to
  * be allocated already.
  *
  * Return 0 on success or -errno on error.
  */
-static int add_attr_bitmap_positioned(MFT_RECORD *m, const char *name,
-		const u32 name_len, const IGNORE_CASE_BOOL ic,
-		const runlist *rl, const u8 *bitmap, const u32 bitmap_len)
+static int add_attr_bitmap_positioned(NTFS_MFT_RECORD *m, const char *name,
+		const u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		const ntfs_runlist *rl, const u8 *bitmap, const u32 bitmap_len)
 {
 	int err;

-	err = insert_positioned_attr_in_mft_record(m, AT_BITMAP, name, name_len,
+	err = insert_positioned_attr_in_mft_record(m, NTFS_AT_BITMAP, name, name_len,
 			ic, 0, rl, bitmap, bitmap_len);
 	if (err < 0)
 		ntfs_log_error("add_attr_bitmap_positioned failed: %s\n",
@@ -2034,15 +2034,15 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int upgrade_to_large_index(MFT_RECORD *m, const char *name,
-		u32 name_len, const IGNORE_CASE_BOOL ic,
-		INDEX_ALLOCATION **idx)
+static int upgrade_to_large_index(NTFS_MFT_RECORD *m, const char *name,
+		u32 name_len, const NTFS_IGNORE_CASE_BOOL ic,
+		NTFS_INDEX_ALLOCATION **idx)
 {
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
-	INDEX_ROOT *r;
-	INDEX_ENTRY *re;
-	INDEX_ALLOCATION *ia_val = NULL;
+	NTFS_ATTR_RECORD *a;
+	NTFS_INDEX_ROOT *r;
+	NTFS_INDEX_ENTRY *re;
+	NTFS_INDEX_ALLOCATION *ia_val = NULL;
 	ntfschar *uname = NULL;
 	int uname_len = 0;
 	u8 bmp[8];
@@ -2060,13 +2060,13 @@
 		ntfs_ucsfree(uname);
 		return -ENOMEM;
 	}
-	if (ic == IGNORE_CASE) {
+	if (ic == NTFS_IGNORE_CASE) {
 		ntfs_log_error("FIXME: Hit unimplemented code path #4.\n");
 		err = -EOPNOTSUPP;
 		ntfs_ucsfree(uname);
 		goto err_out;
 	}
-	err = mkntfs_attr_lookup(AT_INDEX_ROOT, uname, uname_len, ic, 0, NULL, 0,
+	err = mkntfs_attr_lookup(NTFS_AT_INDEX_ROOT, uname, uname_len, ic, 0, NULL, 0,
 			ctx);
 	ntfs_ucsfree(uname);
 	if (err) {
@@ -2078,10 +2078,10 @@
 		err = -EINVAL;
 		goto err_out;
 	}
-	r = (INDEX_ROOT*)((char*)a + le16_to_cpu(a->value_offset));
+	r = (NTFS_INDEX_ROOT*)((char*)a + le16_to_cpu(a->value_offset));
 	re_end = (char*)r + le32_to_cpu(a->value_length);
 	re_start = (char*)&r->index + le32_to_cpu(r->index.entries_offset);
-	re = (INDEX_ENTRY*)re_start;
+	re = (NTFS_INDEX_ENTRY*)re_start;
 	index_block_size = le32_to_cpu(r->index_block_size);
 	memset(bmp, 0, sizeof(bmp));
 	ntfs_bit_set(bmp, 0ULL, 1);
@@ -2096,7 +2096,7 @@
 	}
 	/* Setup header. */
 	ia_val->magic = magic_INDX;
-	ia_val->usa_ofs = cpu_to_le16(sizeof(INDEX_ALLOCATION));
+	ia_val->usa_ofs = cpu_to_le16(sizeof(NTFS_INDEX_ALLOCATION));
 	if (index_block_size >= NTFS_BLOCK_SIZE) {
 		ia_val->usa_count = cpu_to_le16(index_block_size /
 				NTFS_BLOCK_SIZE + 1);
@@ -2114,16 +2114,16 @@
 			cpu_to_le16(1);
 	ia_val->lsn = 0;
 	ia_val->index_block_vcn = 0;
-	ia_val->index.flags = LEAF_NODE;
+	ia_val->index.flags = NTFS_LEAF_NODE;
 	/* Align to 8-byte boundary. */
-	ia_val->index.entries_offset = cpu_to_le32((sizeof(INDEX_HEADER) +
+	ia_val->index.entries_offset = cpu_to_le32((sizeof(NTFS_INDEX_HEADER) +
 			le16_to_cpu(ia_val->usa_count) * 2 + 7) & ~7);
 	ia_val->index.allocated_size = cpu_to_le32(index_block_size -
-			(sizeof(INDEX_ALLOCATION) - sizeof(INDEX_HEADER)));
+			(sizeof(NTFS_INDEX_ALLOCATION) - sizeof(NTFS_INDEX_HEADER)));
 	/* Find the last entry in the index root and save it in re. */
-	while ((char*)re < re_end && !(re->flags & INDEX_ENTRY_END)) {
+	while ((char*)re < re_end && !(re->flags & NTFS_INDEX_ENTRY_END)) {
 		/* Next entry in index root. */
-		re = (INDEX_ENTRY*)((char*)re + le16_to_cpu(re->length));
+		re = (NTFS_INDEX_ENTRY*)((char*)re + le16_to_cpu(re->length));
 	}
 	/* Copy all the entries including the termination entry. */
 	i = (char*)re - re_start + le16_to_cpu(re->length);
@@ -2135,27 +2135,27 @@
 	/* Move the termination entry forward to the beginning if necessary. */
 	if ((char*)re > re_start) {
 		memmove(re_start, (char*)re, le16_to_cpu(re->length));
-		re = (INDEX_ENTRY*)re_start;
+		re = (NTFS_INDEX_ENTRY*)re_start;
 	}
-	/* Now fixup empty index root with pointer to index allocation VCN 0. */
-	r->index.flags = LARGE_INDEX;
-	re->flags |= INDEX_ENTRY_NODE;
-	if (le16_to_cpu(re->length) < sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN))
-		re->length = cpu_to_le16(le16_to_cpu(re->length) + sizeof(VCN));
+	/* Now fixup empty index root with pointer to index allocation NTFS_VCN 0. */
+	r->index.flags = NTFS_LARGE_INDEX;
+	re->flags |= NTFS_INDEX_ENTRY_NODE;
+	if (le16_to_cpu(re->length) < sizeof(NTFS_INDEX_ENTRY_HEADER) + sizeof(NTFS_VCN))
+		re->length = cpu_to_le16(le16_to_cpu(re->length) + sizeof(NTFS_VCN));
 	r->index.index_length = cpu_to_le32(le32_to_cpu(r->index.entries_offset)
 			+ le16_to_cpu(re->length));
 	r->index.allocated_size = r->index.index_length;
 	/* Resize index root attribute. */
-	if (ntfs_resident_attr_value_resize(m, a, sizeof(INDEX_ROOT) -
-			sizeof(INDEX_HEADER) +
+	if (ntfs_resident_attr_value_resize(m, a, sizeof(NTFS_INDEX_ROOT) -
+			sizeof(NTFS_INDEX_HEADER) +
 			le32_to_cpu(r->index.allocated_size))) {
 		/* TODO: Remove the added bitmap! */
 		/* Revert index root from index allocation. */
 		err = -errno;
 		goto err_out;
 	}
-	/* Set VCN pointer to 0LL. */
-	*(leVCN*)((char*)re + le16_to_cpu(re->length) - sizeof(VCN)) = 0;
+	/* Set NTFS_VCN pointer to 0LL. */
+	*(NTFS_leVCN*)((char*)re + le16_to_cpu(re->length) - sizeof(NTFS_VCN)) = 0;
 	err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)ia_val, index_block_size);
 	if (err) {
 		err = -errno;
@@ -2187,8 +2187,8 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int make_room_for_index_entry_in_index_block(INDEX_BLOCK *idx,
-		INDEX_ENTRY *pos, u32 size)
+static int make_room_for_index_entry_in_index_block(NTFS_INDEX_BLOCK *idx,
+		NTFS_INDEX_ENTRY *pos, u32 size)
 {
 	u32 biu;

@@ -2207,17 +2207,17 @@
 	if (!idx || !pos)
 		return -EINVAL;
 	if ((char*)pos < (char*)idx || (char*)pos + size < (char*)idx ||
-			(char*)pos > (char*)idx + sizeof(INDEX_BLOCK) -
-				sizeof(INDEX_HEADER) +
+			(char*)pos > (char*)idx + sizeof(NTFS_INDEX_BLOCK) -
+				sizeof(NTFS_INDEX_HEADER) +
 				le32_to_cpu(idx->index.allocated_size) ||
-			(char*)pos + size > (char*)idx + sizeof(INDEX_BLOCK) -
-				sizeof(INDEX_HEADER) +
+			(char*)pos + size > (char*)idx + sizeof(NTFS_INDEX_BLOCK) -
+				sizeof(NTFS_INDEX_HEADER) +
 				le32_to_cpu(idx->index.allocated_size))
 		return -EINVAL;
-	/* The - sizeof(INDEX_ENTRY_HEADER) is for the index terminator. */
+	/* The - sizeof(NTFS_INDEX_ENTRY_HEADER) is for the index terminator. */
 	if ((char*)pos - (char*)&idx->index >
 			(int)le32_to_cpu(idx->index.index_length)
-			- (int)sizeof(INDEX_ENTRY_HEADER))
+			- (int)sizeof(NTFS_INDEX_ENTRY_HEADER))
 		return -EINVAL;
 #endif
 	biu = le32_to_cpu(idx->index.index_length);
@@ -2235,16 +2235,16 @@
 /**
  * ntfs_index_keys_compare
  *
- * not all types of COLLATION_RULES supported yet...
+ * not all types of NTFS_COLLATION_RULES supported yet...
  * added as needed.. (remove this comment when all are added)
  */
 static int ntfs_index_keys_compare(u8 *key1, u8 *key2, int key1_length,
-		int key2_length, COLLATION_RULES collation_rule)
+		int key2_length, NTFS_COLLATION_RULES collation_rule)
 {
 	u32 u1, u2;
 	int i;

-	if (collation_rule == COLLATION_NTOFS_ULONG) {
+	if (collation_rule == NTFS_COLLATION_NTOFS_ULONG) {
 		/* i.e. $SII or $QUOTA-$Q */
 		u1 = le32_to_cpup(key1);
 		u2 = le32_to_cpup(key2);
@@ -2255,7 +2255,7 @@
 		/* u1 == u2 */
 		return 0;
 	}
-	if (collation_rule == COLLATION_NTOFS_ULONGS) {
+	if (collation_rule == NTFS_COLLATION_NTOFS_ULONGS) {
 		/* i.e $OBJID-$O */
 		i = 0;
 		while (i < min(key1_length, key2_length)) {
@@ -2274,24 +2274,24 @@
 			return 1;
 		return 0;
 	}
-	if (collation_rule == COLLATION_NTOFS_SECURITY_HASH) {
+	if (collation_rule == NTFS_COLLATION_NTOFS_SECURITY_HASH) {
 		/* i.e. $SDH */
-		u1 = le32_to_cpu(((SDH_INDEX_KEY*)key1)->hash);
-		u2 = le32_to_cpu(((SDH_INDEX_KEY*)key2)->hash);
+		u1 = le32_to_cpu(((NTFS_SDH_INDEX_KEY*)key1)->hash);
+		u2 = le32_to_cpu(((NTFS_SDH_INDEX_KEY*)key2)->hash);
 		if (u1 < u2)
 			return -1;
 		if (u1 > u2)
 			return 1;
 		/* u1 == u2 */
-		u1 = le32_to_cpu(((SDH_INDEX_KEY*)key1)->security_id);
-		u2 = le32_to_cpu(((SDH_INDEX_KEY*)key2)->security_id);
+		u1 = le32_to_cpu(((NTFS_SDH_INDEX_KEY*)key1)->security_id);
+		u2 = le32_to_cpu(((NTFS_SDH_INDEX_KEY*)key2)->security_id);
 		if (u1 < u2)
 			return -1;
 		if (u1 > u2)
 			return 1;
 		return 0;
 	}
-	if (collation_rule == COLLATION_NTOFS_SID) {
+	if (collation_rule == NTFS_COLLATION_NTOFS_SID) {
 		/* i.e. $QUOTA-O */
 		i = memcmp(key1, key2, min(key1_length, key2_length));
 		if (!i) {
@@ -2313,21 +2313,21 @@
  * i.e. insert an index_entry in some named index_root
  * simplified search method, works for mkntfs
  */
-static int insert_index_entry_in_res_dir_index(INDEX_ENTRY *idx, u32 idx_size,
-		MFT_RECORD *m, ntfschar *name, u32 name_size, ATTR_TYPES type)
+static int insert_index_entry_in_res_dir_index(NTFS_INDEX_ENTRY *idx, u32 idx_size,
+		NTFS_MFT_RECORD *m, ntfschar *name, u32 name_size, NTFS_ATTR_TYPES type)
 {
 	ntfs_attr_search_ctx *ctx;
-	INDEX_HEADER *idx_header;
-	INDEX_ENTRY *idx_entry, *idx_end;
-	ATTR_RECORD *a;
-	COLLATION_RULES collation_rule;
+	NTFS_INDEX_HEADER *idx_header;
+	NTFS_INDEX_ENTRY *idx_entry, *idx_end;
+	NTFS_ATTR_RECORD *a;
+	NTFS_COLLATION_RULES collation_rule;
 	int err, i;

 	err = 0;
 	/* does it fit ?*/
 	if (g_vol->mft_record_size > idx_size + le32_to_cpu(m->bytes_allocated))
 		return -ENOSPC;
-	/* find the INDEX_ROOT attribute:*/
+	/* find the NTFS_INDEX_ROOT attribute:*/
 	ctx = ntfs_attr_get_search_ctx(NULL, m);
 	if (!ctx) {
 		ntfs_log_error("Failed to allocate attribute search "
@@ -2335,31 +2335,31 @@
 		err = -ENOMEM;
 		goto err_out;
 	}
-	if (mkntfs_attr_lookup(AT_INDEX_ROOT, name, name_size, 0, 0, NULL, 0,
+	if (mkntfs_attr_lookup(NTFS_AT_INDEX_ROOT, name, name_size, 0, 0, NULL, 0,
 			ctx)) {
 		err = -EEXIST;
 		goto err_out;
 	}
 	/* found attribute */
-	a = (ATTR_RECORD*)ctx->attr;
-	collation_rule = ((INDEX_ROOT*)((u8*)a +
+	a = (NTFS_ATTR_RECORD*)ctx->attr;
+	collation_rule = ((NTFS_INDEX_ROOT*)((u8*)a +
 			le16_to_cpu(a->value_offset)))->collation_rule;
-	idx_header = (INDEX_HEADER*)((u8*)a + le16_to_cpu(a->value_offset)
+	idx_header = (NTFS_INDEX_HEADER*)((u8*)a + le16_to_cpu(a->value_offset)
 			+ 0x10);
-	idx_entry = (INDEX_ENTRY*)((u8*)idx_header +
+	idx_entry = (NTFS_INDEX_ENTRY*)((u8*)idx_header +
 			le32_to_cpu(idx_header->entries_offset));
-	idx_end = (INDEX_ENTRY*)((u8*)idx_entry +
+	idx_end = (NTFS_INDEX_ENTRY*)((u8*)idx_entry +
 			le32_to_cpu(idx_header->index_length));
 	/*
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	if (type == AT_FILE_NAME) {
+	if (type == NTFS_AT_FILE_NAME) {
 		while (((u8*)idx_entry < (u8*)idx_end) &&
-				!(idx_entry->flags & INDEX_ENTRY_END)) {
+				!(idx_entry->flags & NTFS_INDEX_ENTRY_END)) {
 			i = ntfs_file_values_compare(&idx->key.file_name,
 					&idx_entry->key.file_name, 1,
-					IGNORE_CASE, g_vol->upcase,
+					NTFS_IGNORE_CASE, g_vol->upcase,
 					g_vol->upcase_len);
 			/*
 			 * If @file_name collates before ie->key.file_name,
@@ -2371,25 +2371,25 @@
 			if (i)
 				goto do_next;
 			if (idx->key.file_name.file_name_type !=
-					FILE_NAME_POSIX ||
+					NTFS_FILE_NAME_POSIX ||
 					idx_entry->key.file_name.file_name_type
-					!= FILE_NAME_POSIX)
+					!= NTFS_FILE_NAME_POSIX)
 				return -EEXIST;
 			i = ntfs_file_values_compare(&idx->key.file_name,
 					&idx_entry->key.file_name, 1,
-					CASE_SENSITIVE, g_vol->upcase,
+					NTFS_CASE_SENSITIVE, g_vol->upcase,
 					g_vol->upcase_len);
 			if (!i)
 				return -EEXIST;
 			if (i == -1)
 				break;
 do_next:
-			idx_entry = (INDEX_ENTRY*)((u8*)idx_entry +
+			idx_entry = (NTFS_INDEX_ENTRY*)((u8*)idx_entry +
 					le16_to_cpu(idx_entry->length));
 		}
-	} else if (type == AT_UNUSED) {  /* case view */
+	} else if (type == NTFS_AT_UNUSED) {  /* case view */
 		while (((u8*)idx_entry < (u8*)idx_end) &&
-				!(idx_entry->flags & INDEX_ENTRY_END)) {
+				!(idx_entry->flags & NTFS_INDEX_ENTRY_END)) {
 			i = ntfs_index_keys_compare((u8*)idx + 0x10,
 					(u8*)idx_entry + 0x10,
 					le16_to_cpu(idx->key_length),
@@ -2399,7 +2399,7 @@
 				return -EEXIST;
 			if (i == -1)
 				break;
-			idx_entry = (INDEX_ENTRY*)((u8*)idx_entry +
+			idx_entry = (NTFS_INDEX_ENTRY*)((u8*)idx_entry +
 					le16_to_cpu(idx_entry->length));
 		}
 	} else
@@ -2427,23 +2427,23 @@
  *
  * initializes $Secure's $SDH and $SII indexes from $SDS datastream
  */
-static int initialize_secure(char *sds, u32 sds_size, MFT_RECORD *m)
+static int initialize_secure(char *sds, u32 sds_size, NTFS_MFT_RECORD *m)
 {
 	int err, sdh_size, sii_size;
-	SECURITY_DESCRIPTOR_HEADER *sds_header;
-	INDEX_ENTRY *idx_entry_sdh, *idx_entry_sii;
-	SDH_INDEX_DATA *sdh_data;
-	SII_INDEX_DATA *sii_data;
-
-	sds_header = (SECURITY_DESCRIPTOR_HEADER*)sds;
-	sdh_size  = sizeof(INDEX_ENTRY_HEADER);
-	sdh_size += sizeof(SDH_INDEX_KEY) + sizeof(SDH_INDEX_DATA);
-	sii_size  = sizeof(INDEX_ENTRY_HEADER);
-	sii_size += sizeof(SII_INDEX_KEY) + sizeof(SII_INDEX_DATA);
-	idx_entry_sdh = ntfs_calloc(sizeof(INDEX_ENTRY));
+	NTFS_SECURITY_DESCRIPTOR_HEADER *sds_header;
+	NTFS_INDEX_ENTRY *idx_entry_sdh, *idx_entry_sii;
+	NTFS_SDH_INDEX_DATA *sdh_data;
+	NTFS_SII_INDEX_DATA *sii_data;
+
+	sds_header = (NTFS_SECURITY_DESCRIPTOR_HEADER*)sds;
+	sdh_size  = sizeof(NTFS_INDEX_ENTRY_HEADER);
+	sdh_size += sizeof(NTFS_SDH_INDEX_KEY) + sizeof(NTFS_SDH_INDEX_DATA);
+	sii_size  = sizeof(NTFS_INDEX_ENTRY_HEADER);
+	sii_size += sizeof(NTFS_SII_INDEX_KEY) + sizeof(NTFS_SII_INDEX_DATA);
+	idx_entry_sdh = ntfs_calloc(sizeof(NTFS_INDEX_ENTRY));
 	if (!idx_entry_sdh)
 		return -errno;
-	idx_entry_sii = ntfs_calloc(sizeof(INDEX_ENTRY));
+	idx_entry_sii = ntfs_calloc(sizeof(NTFS_INDEX_ENTRY));
 	if (!idx_entry_sii) {
 		free(idx_entry_sdh);
 		return -errno;
@@ -2463,7 +2463,7 @@
 		idx_entry_sdh->reserved = const_cpu_to_le16(0x00);
 		idx_entry_sdh->key.sdh.hash = sds_header->hash;
 		idx_entry_sdh->key.sdh.security_id = sds_header->security_id;
-		sdh_data = (SDH_INDEX_DATA*)((u8*)idx_entry_sdh +
+		sdh_data = (NTFS_SDH_INDEX_DATA*)((u8*)idx_entry_sdh +
 				le16_to_cpu(idx_entry_sdh->data_offset));
 		sdh_data->hash = sds_header->hash;
 		sdh_data->security_id = sds_header->security_id;
@@ -2480,19 +2480,19 @@
 		idx_entry_sii->flags = const_cpu_to_le16(0x00);
 		idx_entry_sii->reserved = const_cpu_to_le16(0x00);
 		idx_entry_sii->key.sii.security_id = sds_header->security_id;
-		sii_data = (SII_INDEX_DATA*)((u8*)idx_entry_sii +
+		sii_data = (NTFS_SII_INDEX_DATA*)((u8*)idx_entry_sii +
 				le16_to_cpu(idx_entry_sii->data_offset));
 		sii_data->hash = sds_header->hash;
 		sii_data->security_id = sds_header->security_id;
 		sii_data->offset = sds_header->offset;
 		sii_data->length = sds_header->length;
 		if ((err = insert_index_entry_in_res_dir_index(idx_entry_sdh,
-				sdh_size, m, NTFS_INDEX_SDH, 4, AT_UNUSED)))
+				sdh_size, m, NTFS_INDEX_SDH, 4, NTFS_AT_UNUSED)))
 			break;
 		if ((err = insert_index_entry_in_res_dir_index(idx_entry_sii,
-				sii_size, m, NTFS_INDEX_SII, 4, AT_UNUSED)))
+				sii_size, m, NTFS_INDEX_SII, 4, NTFS_AT_UNUSED)))
 			break;
-		sds_header = (SECURITY_DESCRIPTOR_HEADER*)((u8*)sds_header +
+		sds_header = (NTFS_SECURITY_DESCRIPTOR_HEADER*)((u8*)sds_header +
 				((le32_to_cpu(sds_header->length) + 15) & ~15));
 	}
 	free(idx_entry_sdh);
@@ -2505,12 +2505,12 @@
  *
  * initialize $Quota with the default quota index-entries.
  */
-static int initialize_quota(MFT_RECORD *m)
+static int initialize_quota(NTFS_MFT_RECORD *m)
 {
 	int o_size, q1_size, q2_size, err, i;
-	INDEX_ENTRY *idx_entry_o, *idx_entry_q1, *idx_entry_q2;
-	QUOTA_O_INDEX_DATA *idx_entry_o_data;
-	QUOTA_CONTROL_ENTRY *idx_entry_q1_data, *idx_entry_q2_data;
+	NTFS_INDEX_ENTRY *idx_entry_o, *idx_entry_q1, *idx_entry_q2;
+	NTFS_QUOTA_O_INDEX_DATA *idx_entry_o_data;
+	NTFS_QUOTA_CONTROL_ENTRY *idx_entry_q1_data, *idx_entry_q2_data;

 	err = 0;
 	/* q index entry num 1 */
@@ -2526,17 +2526,17 @@
 	idx_entry_q1->flags = const_cpu_to_le16(0x00);
 	idx_entry_q1->reserved = const_cpu_to_le16(0x00);
 	idx_entry_q1->key.owner_id = const_cpu_to_le32(0x01);
-	idx_entry_q1_data = (QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q1
+	idx_entry_q1_data = (NTFS_QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q1
 			+ le16_to_cpu(idx_entry_q1->data_offset));
 	idx_entry_q1_data->version = const_cpu_to_le32(0x02);
-	idx_entry_q1_data->flags = QUOTA_FLAG_DEFAULT_LIMITS;
+	idx_entry_q1_data->flags = NTFS_QUOTA_FLAG_DEFAULT_LIMITS;
 	idx_entry_q1_data->bytes_used = const_cpu_to_le64(0x00);
 	idx_entry_q1_data->change_time = utc2ntfs(mkntfs_time());
 	idx_entry_q1_data->threshold = cpu_to_sle64(-1);
 	idx_entry_q1_data->limit = cpu_to_sle64(-1);
 	idx_entry_q1_data->exceeded_time = 0;
 	err = insert_index_entry_in_res_dir_index(idx_entry_q1, q1_size, m,
-			NTFS_INDEX_Q, 2, AT_UNUSED);
+			NTFS_INDEX_Q, 2, NTFS_AT_UNUSED);
 	free(idx_entry_q1);
 	if (err)
 		return err;
@@ -2552,11 +2552,11 @@
 	idx_entry_q2->key_length = const_cpu_to_le16(0x04);
 	idx_entry_q2->flags = const_cpu_to_le16(0x00);
 	idx_entry_q2->reserved = const_cpu_to_le16(0x00);
-	idx_entry_q2->key.owner_id = QUOTA_FIRST_USER_ID;
-	idx_entry_q2_data = (QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q2
+	idx_entry_q2->key.owner_id = NTFS_QUOTA_FIRST_USER_ID;
+	idx_entry_q2_data = (NTFS_QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q2
 			+ le16_to_cpu(idx_entry_q2->data_offset));
 	idx_entry_q2_data->version = const_cpu_to_le32(0x02);
-	idx_entry_q2_data->flags = QUOTA_FLAG_DEFAULT_LIMITS;
+	idx_entry_q2_data->flags = NTFS_QUOTA_FLAG_DEFAULT_LIMITS;
 	idx_entry_q2_data->bytes_used = const_cpu_to_le64(0x00);
 	idx_entry_q2_data->change_time = utc2ntfs(mkntfs_time());;
 	idx_entry_q2_data->threshold = cpu_to_sle64(-1);
@@ -2568,11 +2568,11 @@
 		idx_entry_q2_data->sid.identifier_authority.value[i] = 0;
 	idx_entry_q2_data->sid.identifier_authority.value[5] = 0x05;
 	idx_entry_q2_data->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	idx_entry_q2_data->sid.sub_authority[1] =
-			const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+			const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
 	err = insert_index_entry_in_res_dir_index(idx_entry_q2, q2_size, m,
-			NTFS_INDEX_Q, 2, AT_UNUSED);
+			NTFS_INDEX_Q, 2, NTFS_AT_UNUSED);
 	free(idx_entry_q2);
 	if (err)
 		return err;
@@ -2593,16 +2593,16 @@
 		idx_entry_o->key.sid.identifier_authority.value[i] = 0;
 	idx_entry_o->key.sid.identifier_authority.value[5] = 0x05;
 	idx_entry_o->key.sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	idx_entry_o->key.sid.sub_authority[1] =
-			const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
-	idx_entry_o_data = (QUOTA_O_INDEX_DATA*)((char*)idx_entry_o
+			const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
+	idx_entry_o_data = (NTFS_QUOTA_O_INDEX_DATA*)((char*)idx_entry_o
 			+ le16_to_cpu(idx_entry_o->data_offset));
-	idx_entry_o_data->owner_id  = QUOTA_FIRST_USER_ID;
+	idx_entry_o_data->owner_id  = NTFS_QUOTA_FIRST_USER_ID;
 	/* 20 00 00 00 padding after here on ntfs 3.1. 3.0 is unchecked. */
 	idx_entry_o_data->unknown = const_cpu_to_le32(32);
 	err = insert_index_entry_in_res_dir_index(idx_entry_o, o_size, m,
-			NTFS_INDEX_O, 2, AT_UNUSED);
+			NTFS_INDEX_O, 2, NTFS_AT_UNUSED);
 	free(idx_entry_o);

 	return err;
@@ -2611,17 +2611,17 @@
 /**
  * insert_file_link_in_dir_index
  *
- * Insert the fully completed FILE_NAME_ATTR @file_name which is inside
+ * Insert the fully completed NTFS_FILE_NAME_ATTR @file_name which is inside
  * the file with mft reference @file_ref into the index (allocation) block
  * @idx (which belongs to @file_ref's parent directory).
  *
  * Return 0 on success or -errno on error.
  */
-static int insert_file_link_in_dir_index(INDEX_BLOCK *idx, leMFT_REF file_ref,
-		FILE_NAME_ATTR *file_name, u32 file_name_size)
+static int insert_file_link_in_dir_index(NTFS_INDEX_BLOCK *idx, NTFS_leMFT_REF file_ref,
+		NTFS_FILE_NAME_ATTR *file_name, u32 file_name_size)
 {
 	int err, i;
-	INDEX_ENTRY *ie;
+	NTFS_INDEX_ENTRY *ie;
 	char *index_end;

 	/*
@@ -2632,13 +2632,13 @@
 	 */

 	index_end = (char*)&idx->index + le32_to_cpu(idx->index.index_length);
-	ie = (INDEX_ENTRY*)((char*)&idx->index +
+	ie = (NTFS_INDEX_ENTRY*)((char*)&idx->index +
 			le32_to_cpu(idx->index.entries_offset));
 	/*
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	while ((char*)ie < index_end && !(ie->flags & INDEX_ENTRY_END)) {
+	while ((char*)ie < index_end && !(ie->flags & NTFS_INDEX_ENTRY_END)) {
 #if 0
 #ifdef DEBUG
 		ntfs_log_debug("file_name_attr1->file_name_length = %i\n",
@@ -2671,8 +2671,8 @@
 #endif
 #endif
 		i = ntfs_file_values_compare(file_name,
-				(FILE_NAME_ATTR*)&ie->key.file_name, 1,
-				IGNORE_CASE, g_vol->upcase, g_vol->upcase_len);
+				(NTFS_FILE_NAME_ATTR*)&ie->key.file_name, 1,
+				NTFS_IGNORE_CASE, g_vol->upcase, g_vol->upcase_len);
 		/*
 		 * If @file_name collates before ie->key.file_name, there is no
 		 * matching index entry.
@@ -2691,12 +2691,12 @@
 		 * fine for mkntfs where we don't use POSIX namespace at all
 		 * and hence this following code is luxury. (AIA)
 		 */
-		if (file_name->file_name_type != FILE_NAME_POSIX ||
-		    ie->key.file_name.file_name_type != FILE_NAME_POSIX)
+		if (file_name->file_name_type != NTFS_FILE_NAME_POSIX ||
+		    ie->key.file_name.file_name_type != NTFS_FILE_NAME_POSIX)
 			return -EEXIST;
 		i = ntfs_file_values_compare(file_name,
-				(FILE_NAME_ATTR*)&ie->key.file_name, 1,
-				CASE_SENSITIVE, g_vol->upcase,
+				(NTFS_FILE_NAME_ATTR*)&ie->key.file_name, 1,
+				NTFS_CASE_SENSITIVE, g_vol->upcase,
 				g_vol->upcase_len);
 		if (i == -1)
 			break;
@@ -2712,9 +2712,9 @@
 			break;
 		}
 #endif
-		ie = (INDEX_ENTRY*)((char*)ie + le16_to_cpu(ie->length));
+		ie = (NTFS_INDEX_ENTRY*)((char*)ie + le16_to_cpu(ie->length));
 	};
-	i = (sizeof(INDEX_ENTRY_HEADER) + file_name_size + 7) & ~7;
+	i = (sizeof(NTFS_INDEX_ENTRY_HEADER) + file_name_size + 7) & ~7;
 	err = make_room_for_index_entry_in_index_block(idx, ie, i);
 	if (err) {
 		ntfs_log_error("make_room_for_index_entry_in_index_block "
@@ -2744,21 +2744,21 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int create_hardlink_res(MFT_RECORD *m_parent, const leMFT_REF ref_parent,
-		MFT_RECORD *m_file, const leMFT_REF ref_file,
+static int create_hardlink_res(NTFS_MFT_RECORD *m_parent, const NTFS_leMFT_REF ref_parent,
+		NTFS_MFT_RECORD *m_file, const NTFS_leMFT_REF ref_file,
 		const s64 allocated_size, const s64 data_size,
-		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
+		const NTFS_FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
 		const u32 reparse_point_tag, const char *file_name,
-		const FILE_NAME_TYPE_FLAGS file_name_type)
+		const NTFS_FILE_NAME_TYPE_FLAGS file_name_type)
 {
-	FILE_NAME_ATTR *fn;
+	NTFS_FILE_NAME_ATTR *fn;
 	int i, fn_size, idx_size;
-	INDEX_ENTRY *idx_entry_new;
+	NTFS_INDEX_ENTRY *idx_entry_new;
 	ntfschar *uname;

 	/* Create the file_name attribute. */
 	i = (strlen(file_name) + 1) * sizeof(ntfschar);
-	fn_size = sizeof(FILE_NAME_ATTR) + i;
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i;
 	fn = ntfs_malloc(fn_size);
 	if (!fn)
 		return -errno;
@@ -2799,7 +2799,7 @@
 	}
 	/* No terminating null in file names. */
 	fn->file_name_length = i;
-	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i * sizeof(ntfschar);
 	/* Increment the link count of @m_file. */
 	i = le16_to_cpu(m_file->link_count);
 	if (i == 0xffff) {
@@ -2809,8 +2809,8 @@
 	}
 	m_file->link_count = cpu_to_le16(i + 1);
 	/* Add the file_name to @m_file. */
-	i = insert_resident_attr_in_mft_record(m_file, AT_FILE_NAME, NULL, 0, 0,
-			0, RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
+	i = insert_resident_attr_in_mft_record(m_file, NTFS_AT_FILE_NAME, NULL, 0, 0,
+			0, NTFS_RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
 	if (i < 0) {
 		ntfs_log_error("create_hardlink failed adding file name "
 				"attribute: %s\n", strerror(-i));
@@ -2830,7 +2830,7 @@
 	idx_entry_new->key_length = cpu_to_le16(fn_size);
 	memcpy((u8*)idx_entry_new + 0x10, (u8*)fn, fn_size);
 	i = insert_index_entry_in_res_dir_index(idx_entry_new, idx_size + 0x10,
-			m_parent, NTFS_INDEX_I30, 4, AT_FILE_NAME);
+			m_parent, NTFS_INDEX_I30, 4, NTFS_AT_FILE_NAME);
 	if (i < 0) {
 		ntfs_log_error("create_hardlink failed inserting index entry: "
 				"%s\n", strerror(-i));
@@ -2860,20 +2860,20 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int create_hardlink(INDEX_BLOCK *idx, const leMFT_REF ref_parent,
-		MFT_RECORD *m_file, const leMFT_REF ref_file,
+static int create_hardlink(NTFS_INDEX_BLOCK *idx, const NTFS_leMFT_REF ref_parent,
+		NTFS_MFT_RECORD *m_file, const NTFS_leMFT_REF ref_file,
 		const s64 allocated_size, const s64 data_size,
-		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
+		const NTFS_FILE_ATTR_FLAGS flags, const u16 packed_ea_size,
 		const u32 reparse_point_tag, const char *file_name,
-		const FILE_NAME_TYPE_FLAGS file_name_type)
+		const NTFS_FILE_NAME_TYPE_FLAGS file_name_type)
 {
-	FILE_NAME_ATTR *fn;
+	NTFS_FILE_NAME_ATTR *fn;
 	int i, fn_size;
 	ntfschar *uname;

 	/* Create the file_name attribute. */
 	i = (strlen(file_name) + 1) * sizeof(ntfschar);
-	fn_size = sizeof(FILE_NAME_ATTR) + i;
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i;
 	fn = ntfs_malloc(fn_size);
 	if (!fn)
 		return -errno;
@@ -2911,7 +2911,7 @@
 	}
 	/* No terminating null in file names. */
 	fn->file_name_length = i;
-	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);
+	fn_size = sizeof(NTFS_FILE_NAME_ATTR) + i * sizeof(ntfschar);
 	/* Increment the link count of @m_file. */
 	i = le16_to_cpu(m_file->link_count);
 	if (i == 0xffff) {
@@ -2921,8 +2921,8 @@
 	}
 	m_file->link_count = cpu_to_le16(i + 1);
 	/* Add the file_name to @m_file. */
-	i = insert_resident_attr_in_mft_record(m_file, AT_FILE_NAME, NULL, 0, 0,
-			0, RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
+	i = insert_resident_attr_in_mft_record(m_file, NTFS_AT_FILE_NAME, NULL, 0, 0,
+			0, NTFS_RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);
 	if (i < 0) {
 		ntfs_log_error("create_hardlink failed adding file name attribute: "
 				"%s\n", strerror(-i));
@@ -2959,34 +2959,34 @@
  *
  * Return 0 on success or -errno on error.
  */
-static int index_obj_id_insert(MFT_RECORD *m, const GUID *guid,
-		const leMFT_REF ref)
+static int index_obj_id_insert(NTFS_MFT_RECORD *m, const NTFS_GUID *guid,
+		const NTFS_leMFT_REF ref)
 {
-	INDEX_ENTRY *idx_entry_new;
+	NTFS_INDEX_ENTRY *idx_entry_new;
 	int data_ofs, idx_size, err;
-	OBJ_ID_INDEX_DATA *oi;
+	NTFS_OBJ_ID_INDEX_DATA *oi;

 	/*
 	 * Insert the index entry for the object id in the index.
 	 *
 	 * First determine the size of the index entry to be inserted.  This
 	 * consists of the index entry header, followed by the index key, i.e.
-	 * the GUID, followed by the index data, i.e. OBJ_ID_INDEX_DATA.
+	 * the NTFS_GUID, followed by the index data, i.e. NTFS_OBJ_ID_INDEX_DATA.
 	 */
-	data_ofs = (sizeof(INDEX_ENTRY_HEADER) + sizeof(GUID) + 7) & ~7;
-	idx_size = (data_ofs + sizeof(OBJ_ID_INDEX_DATA) + 7) & ~7;
+	data_ofs = (sizeof(NTFS_INDEX_ENTRY_HEADER) + sizeof(NTFS_GUID) + 7) & ~7;
+	idx_size = (data_ofs + sizeof(NTFS_OBJ_ID_INDEX_DATA) + 7) & ~7;
 	idx_entry_new = ntfs_calloc(idx_size);
 	if (!idx_entry_new)
 		return -errno;
 	idx_entry_new->data_offset = cpu_to_le16(data_ofs);
-	idx_entry_new->data_length = cpu_to_le16(sizeof(OBJ_ID_INDEX_DATA));
+	idx_entry_new->data_length = cpu_to_le16(sizeof(NTFS_OBJ_ID_INDEX_DATA));
 	idx_entry_new->length = cpu_to_le16(idx_size);
-	idx_entry_new->key_length = cpu_to_le16(sizeof(GUID));
+	idx_entry_new->key_length = cpu_to_le16(sizeof(NTFS_GUID));
 	idx_entry_new->key.object_id = *guid;
-	oi = (OBJ_ID_INDEX_DATA*)((u8*)idx_entry_new + data_ofs);
+	oi = (NTFS_OBJ_ID_INDEX_DATA*)((u8*)idx_entry_new + data_ofs);
 	oi->mft_reference = ref;
 	err = insert_index_entry_in_res_dir_index(idx_entry_new, idx_size, m,
-			NTFS_INDEX_O, 2, AT_UNUSED);
+			NTFS_INDEX_O, 2, NTFS_AT_UNUSED);
 	free(idx_entry_new);
 	if (err < 0) {
 		ntfs_log_error("index_obj_id_insert failed inserting index "
@@ -3035,9 +3035,9 @@
 /**
  * mkntfs_open_partition -
  */
-static BOOL mkntfs_open_partition(ntfs_volume *vol)
+static NTFS_BOOL mkntfs_open_partition(ntfs_volume *vol)
 {
-	BOOL result = FALSE;
+	NTFS_BOOL result = FALSE;
 	int i;
 	struct stat sbuf;
 	unsigned long mnt_flags;
@@ -3152,12 +3152,12 @@
 /**
  * mkntfs_override_vol_params -
  */
-static BOOL mkntfs_override_vol_params(ntfs_volume *vol)
+static NTFS_BOOL mkntfs_override_vol_params(ntfs_volume *vol)
 {
 	s64 volume_size;
 	long page_size;
 	int i;
-	BOOL winboot = TRUE;
+	NTFS_BOOL winboot = TRUE;

 	/* If user didn't specify the sector size, determine it now. */
 	if (opts.sector_size < 0) {
@@ -3440,7 +3440,7 @@
 /**
  * mkntfs_initialize_bitmaps -
  */
-static BOOL mkntfs_initialize_bitmaps(void)
+static NTFS_BOOL mkntfs_initialize_bitmaps(void)
 {
 	u64 i;
 	int mft_bitmap_size;
@@ -3482,8 +3482,8 @@
 	g_mft_bitmap = ntfs_calloc(g_mft_bitmap_byte_size);
 	if (!g_mft_bitmap)
 		return FALSE;
-	/* Create runlist for mft bitmap. */
-	g_rl_mft_bmp = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for mft bitmap. */
+	g_rl_mft_bmp = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_mft_bmp)
 		return FALSE;

@@ -3507,7 +3507,7 @@
 /**
  * mkntfs_initialize_rl_mft -
  */
-static BOOL mkntfs_initialize_rl_mft(void)
+static NTFS_BOOL mkntfs_initialize_rl_mft(void)
 {
 	int i, j;

@@ -3547,8 +3547,8 @@
 	 * of the device.
 	 */
 	g_mft_zone_end += g_mft_lcn;
-	/* Create runlist for mft. */
-	g_rl_mft = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for mft. */
+	g_rl_mft = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_mft)
 		return FALSE;

@@ -3568,8 +3568,8 @@
 			/ g_vol->cluster_size;
 	ntfs_log_debug("$MFTMirr logical cluster number = 0x%llx\n",
 			g_mftmirr_lcn);
-	/* Create runlist for mft mirror. */
-	g_rl_mftmirr = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for mft mirror. */
+	g_rl_mftmirr = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_mftmirr)
 		return FALSE;

@@ -3599,13 +3599,13 @@
 /**
  * mkntfs_initialize_rl_logfile -
  */
-static BOOL mkntfs_initialize_rl_logfile(void)
+static NTFS_BOOL mkntfs_initialize_rl_logfile(void)
 {
 	int i, j;
 	u64 volume_size;

-	/* Create runlist for log file. */
-	g_rl_logfile = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for log file. */
+	g_rl_logfile = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_logfile)
 		return FALSE;

@@ -3679,11 +3679,11 @@
 /**
  * mkntfs_initialize_rl_boot -
  */
-static BOOL mkntfs_initialize_rl_boot(void)
+static NTFS_BOOL mkntfs_initialize_rl_boot(void)
 {
 	int i, j;
-	/* Create runlist for $Boot. */
-	g_rl_boot = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for $Boot. */
+	g_rl_boot = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_boot)
 		return FALSE;

@@ -3707,10 +3707,10 @@
 /**
  * mkntfs_initialize_rl_bad -
  */
-static BOOL mkntfs_initialize_rl_bad(void)
+static NTFS_BOOL mkntfs_initialize_rl_bad(void)
 {
-	/* Create runlist for $BadClus, $DATA named stream $Bad. */
-	g_rl_bad = ntfs_malloc(2 * sizeof(runlist));
+	/* Create ntfs_runlist for $BadClus, $DATA named stream $Bad. */
+	g_rl_bad = ntfs_malloc(2 * sizeof(ntfs_runlist));
 	if (!g_rl_bad)
 		return FALSE;

@@ -3718,7 +3718,7 @@
 	g_rl_bad[0].lcn = -1LL;
 	/*
 	 * $BadClus named stream $Bad contains the whole volume as a single
-	 * sparse runlist entry.
+	 * sparse ntfs_runlist entry.
 	 */
 	g_rl_bad[1].vcn = g_vol->nr_clusters;
 	g_rl_bad[0].length = g_vol->nr_clusters;
@@ -3732,7 +3732,7 @@
 /**
  * mkntfs_fill_device_with_zeroes -
  */
-static BOOL mkntfs_fill_device_with_zeroes(void)
+static NTFS_BOOL mkntfs_fill_device_with_zeroes(void)
 {
 	/*
 	 * If not quick format, fill the device with 0s.
@@ -3808,14 +3808,14 @@
  * (ERSO) made a function out of this, but the reason for doing that
  * disappeared during coding....
  */
-static BOOL mkntfs_sync_index_record(INDEX_ALLOCATION* idx, MFT_RECORD* m,
+static NTFS_BOOL mkntfs_sync_index_record(NTFS_INDEX_ALLOCATION* idx, NTFS_MFT_RECORD* m,
 		ntfschar* name, u32 name_len)
 {
 	int i, err;
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	long long lw;
-	runlist	*rl_index = NULL;
+	ntfs_runlist	*rl_index = NULL;

 	i = 5 * sizeof(ntfschar);
 	ctx = ntfs_attr_get_search_ctx(NULL, m);
@@ -3823,29 +3823,29 @@
 		ntfs_log_perror("Failed to allocate attribute search context");
 		return FALSE;
 	}
-	/* FIXME: This should be IGNORE_CASE! */
-	if (mkntfs_attr_lookup(AT_INDEX_ALLOCATION, name, name_len, 0, 0,
+	/* FIXME: This should be NTFS_IGNORE_CASE! */
+	if (mkntfs_attr_lookup(NTFS_AT_INDEX_ALLOCATION, name, name_len, 0, 0,
 			NULL, 0, ctx)) {
 		ntfs_attr_put_search_ctx(ctx);
-		ntfs_log_error("BUG: $INDEX_ALLOCATION attribute not found.\n");
+		ntfs_log_error("BUG: $NTFS_INDEX_ALLOCATION attribute not found.\n");
 		return FALSE;
 	}
 	a = ctx->attr;
 	rl_index = ntfs_mapping_pairs_decompress(g_vol, a, NULL);
 	if (!rl_index) {
 		ntfs_attr_put_search_ctx(ctx);
-		ntfs_log_error("Failed to decompress runlist of $INDEX_ALLOCATION "
+		ntfs_log_error("Failed to decompress ntfs_runlist of $NTFS_INDEX_ALLOCATION "
 				"attribute.\n");
 		return FALSE;
 	}
 	if (sle64_to_cpu(a->initialized_size) < i) {
 		ntfs_attr_put_search_ctx(ctx);
 		free(rl_index);
-		ntfs_log_error("BUG: $INDEX_ALLOCATION attribute too short.\n");
+		ntfs_log_error("BUG: $NTFS_INDEX_ALLOCATION attribute too short.\n");
 		return FALSE;
 	}
 	ntfs_attr_put_search_ctx(ctx);
-	i = sizeof(INDEX_BLOCK) - sizeof(INDEX_HEADER) +
+	i = sizeof(NTFS_INDEX_BLOCK) - sizeof(NTFS_INDEX_HEADER) +
 			le32_to_cpu(idx->index.allocated_size);
 	err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)idx, i);
 	if (err) {
@@ -3857,7 +3857,7 @@
 	lw = ntfs_rlwrite(g_vol->dev, rl_index, (u8*)idx, i, NULL);
 	free(rl_index);
 	if (lw != i) {
-		ntfs_log_error("Error writing $INDEX_ALLOCATION.\n");
+		ntfs_log_error("Error writing $NTFS_INDEX_ALLOCATION.\n");
 		return FALSE;
 	}
 	/* No more changes to @idx below here so no need for fixup: */
@@ -3868,8 +3868,8 @@
 /**
  * create_file_volume -
  */
-static BOOL create_file_volume(MFT_RECORD *m, leMFT_REF root_ref,
-		VOLUME_FLAGS fl, const GUID *volume_guid
+static NTFS_BOOL create_file_volume(NTFS_MFT_RECORD *m, NTFS_leMFT_REF root_ref,
+		NTFS_VOLUME_FLAGS fl, const NTFS_GUID *volume_guid
 #ifndef ENABLE_UUID
 		__attribute__((unused))
 #endif
@@ -3879,13 +3879,13 @@
 	u8 *sd;

 	ntfs_log_verbose("Creating $Volume (mft record 3)\n");
-	m = (MFT_RECORD*)(g_buf + 3 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 3 * g_vol->mft_record_size);
 	err = create_hardlink(g_index_block, root_ref, m,
-			MK_LE_MREF(FILE_Volume, FILE_Volume), 0LL, 0LL,
-			FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-			"$Volume", FILE_NAME_WIN32_AND_DOS);
+			NTFS_MK_LE_MREF(NTFS_FILE_Volume, NTFS_FILE_Volume), 0LL, 0LL,
+			NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+			"$Volume", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (!err) {
-		init_system_file_sd(FILE_Volume, &sd, &i);
+		init_system_file_sd(NTFS_FILE_Volume, &sd, &i);
 		err = add_attr_sd(m, sd, i);
 	}
 	if (!err)
@@ -3894,7 +3894,7 @@
 		err = add_attr_vol_name(m, g_vol->vol_name, g_vol->vol_name ?
 				strlen(g_vol->vol_name) : 0);
 	if (!err) {
-		if (fl & VOLUME_IS_DIRTY)
+		if (fl & NTFS_VOLUME_IS_DIRTY)
 			ntfs_log_quiet("Setting the volume dirty so check "
 					"disk runs on next reboot into "
 					"Windows.\n");
@@ -3967,18 +3967,18 @@
 /**
  * mkntfs_create_root_structures -
  */
-static BOOL mkntfs_create_root_structures(void)
+static NTFS_BOOL mkntfs_create_root_structures(void)
 {
 	NTFS_BOOT_SECTOR *bs;
-	MFT_RECORD *m;
-	leMFT_REF root_ref;
-	leMFT_REF extend_ref;
+	NTFS_MFT_RECORD *m;
+	NTFS_leMFT_REF root_ref;
+	NTFS_leMFT_REF extend_ref;
 	int i;
 	int j;
 	int err;
 	u8 *sd;
-	FILE_ATTR_FLAGS extend_flags;
-	VOLUME_FLAGS volume_flags = 0;
+	NTFS_FILE_ATTR_FLAGS extend_flags;
+	NTFS_VOLUME_FLAGS volume_flags = 0;
 	int nr_sysfiles;
 	u8 *buf_log = NULL;
 	int buf_sds_first_size;
@@ -3996,7 +3996,7 @@
 	 * of that file (only for $MFT is the sequence number 1 rather than 0).
 	 */
 	for (i = 0; i < nr_sysfiles; i++) {
-		if (ntfs_mft_record_layout(g_vol, 0, m = (MFT_RECORD *)(g_buf +
+		if (ntfs_mft_record_layout(g_vol, 0, m = (NTFS_MFT_RECORD *)(g_buf +
 				i * g_vol->mft_record_size))) {
 			ntfs_log_error("Failed to layout system mft records."
 					"\n");
@@ -4014,7 +4014,7 @@
 	if (nr_sysfiles * (s32)g_vol->mft_record_size < g_mft_size) {
 		for (i = nr_sysfiles;
 		      i * (s32)g_vol->mft_record_size < g_mft_size; i++) {
-			m = (MFT_RECORD *)(g_buf + i * g_vol->mft_record_size);
+			m = (NTFS_MFT_RECORD *)(g_buf + i * g_vol->mft_record_size);
 			if (ntfs_mft_record_layout(g_vol, 0, m)) {
 				ntfs_log_error("Failed to layout mft record."
 						"\n");
@@ -4031,19 +4031,19 @@
 	for (i = 0; i < nr_sysfiles; i++) {
 		le32 file_attrs;

-		m = (MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
+		m = (NTFS_MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
 		if (i < 16 || i > 23) {
 			m->mft_record_number = cpu_to_le32(i);
-			m->flags |= MFT_RECORD_IN_USE;
+			m->flags |= NTFS_MFT_RECORD_IN_USE;
 			ntfs_bit_set(g_mft_bitmap, 0LL + i, 1);
 		}
-		file_attrs = FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM;
-		if (i == FILE_root) {
-			file_attrs |= FILE_ATTR_ARCHIVE;
+		file_attrs = NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM;
+		if (i == NTFS_FILE_root) {
+			file_attrs |= NTFS_FILE_ATTR_ARCHIVE;
 			if (opts.disable_indexing)
-				file_attrs |= FILE_ATTR_NOT_CONTENT_INDEXED;
+				file_attrs |= NTFS_FILE_ATTR_NOT_CONTENT_INDEXED;
 			if (opts.enable_compression)
-				file_attrs |= FILE_ATTR_COMPRESSED;
+				file_attrs |= NTFS_FILE_ATTR_COMPRESSED;
 		}
 		/* setting specific security_id flag and */
 		/* file permissions for ntfs 3.x */
@@ -4052,15 +4052,15 @@
 			add_attr_std_info(m, file_attrs,
 				cpu_to_le32(0x0100));
 		} else if (i == 9) {
-			file_attrs |= FILE_ATTR_VIEW_INDEX_PRESENT;
+			file_attrs |= NTFS_FILE_ATTR_VIEW_INDEX_PRESENT;
 			add_attr_std_info(m, file_attrs,
 				cpu_to_le32(0x0101));
 		} else if (i == 11) {
 			add_attr_std_info(m, file_attrs,
 				cpu_to_le32(0x0101));
 		} else if (i == 24 || i == 25 || i == 26) {
-			file_attrs |= FILE_ATTR_ARCHIVE;
-			file_attrs |= FILE_ATTR_VIEW_INDEX_PRESENT;
+			file_attrs |= NTFS_FILE_ATTR_ARCHIVE;
+			file_attrs |= NTFS_FILE_ATTR_VIEW_INDEX_PRESENT;
 			add_attr_std_info(m, file_attrs,
 				cpu_to_le32(0x0101));
 		} else {
@@ -4069,30 +4069,30 @@
 		}
 	}
 	/* The root directory mft reference. */
-	root_ref = MK_LE_MREF(FILE_root, FILE_root);
-	extend_ref = MK_LE_MREF(11,11);
+	root_ref = NTFS_MK_LE_MREF(NTFS_FILE_root, NTFS_FILE_root);
+	extend_ref = NTFS_MK_LE_MREF(11,11);
 	ntfs_log_verbose("Creating root directory (mft record 5)\n");
-	m = (MFT_RECORD*)(g_buf + 5 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_DIRECTORY;
+	m = (NTFS_MFT_RECORD*)(g_buf + 5 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_DIRECTORY;
 	m->link_count = cpu_to_le16(le16_to_cpu(m->link_count) + 1);
 	err = add_attr_file_name(m, root_ref, 0LL, 0LL,
-			FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |
-			FILE_ATTR_I30_INDEX_PRESENT, 0, 0, ".",
-			FILE_NAME_WIN32_AND_DOS);
+			NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM |
+			NTFS_FILE_ATTR_I30_INDEX_PRESENT, 0, 0, ".",
+			NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (!err) {
 		init_root_sd(&sd, &i);
 		err = add_attr_sd(m, sd, i);
 	}
-	/* FIXME: This should be IGNORE_CASE */
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$I30", 4, 0, AT_FILE_NAME,
-				COLLATION_FILE_NAME, g_vol->indx_record_size);
-	/* FIXME: This should be IGNORE_CASE */
+		err = add_attr_index_root(m, "$I30", 4, 0, NTFS_AT_FILE_NAME,
+				NTFS_COLLATION_FILE_NAME, g_vol->indx_record_size);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
 		err = upgrade_to_large_index(m, "$I30", 4, 0, &g_index_block);
 	if (!err) {
 		ntfs_attr_search_ctx *ctx;
-		ATTR_RECORD *a;
+		NTFS_ATTR_RECORD *a;
 		ctx = ntfs_attr_get_search_ctx(NULL, m);
 		if (!ctx) {
 			ntfs_log_perror("Failed to allocate attribute search "
@@ -4100,7 +4100,7 @@
 			return FALSE;
 		}
 		/* There is exactly one file name so this is ok. */
-		if (mkntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, 0, 0, NULL,
+		if (mkntfs_attr_lookup(NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, 0, 0, NULL,
 				0, ctx)) {
 			ntfs_attr_put_search_ctx(ctx);
 			ntfs_log_error("BUG: $FILE_NAME attribute not found."
@@ -4109,7 +4109,7 @@
 		}
 		a = ctx->attr;
 		err = insert_file_link_in_dir_index(g_index_block, root_ref,
-				(FILE_NAME_ATTR*)((char*)a +
+				(NTFS_FILE_NAME_ATTR*)((char*)a +
 				le16_to_cpu(a->value_offset)),
 				le32_to_cpu(a->value_length));
 		ntfs_attr_put_search_ctx(ctx);
@@ -4121,15 +4121,15 @@
 	}
 	/* Add all other attributes, on a per-file basis for clarity. */
 	ntfs_log_verbose("Creating $MFT (mft record 0)\n");
-	m = (MFT_RECORD*)g_buf;
+	m = (NTFS_MFT_RECORD*)g_buf;
 	err = add_attr_data_positioned(m, NULL, 0, 0, 0, g_rl_mft, g_buf,
 			g_mft_size);
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_MFT, 1), g_mft_size,
-				g_mft_size, FILE_ATTR_HIDDEN |
-				FILE_ATTR_SYSTEM, 0, 0, "$MFT",
-				FILE_NAME_WIN32_AND_DOS);
+				NTFS_MK_LE_MREF(NTFS_FILE_MFT, 1), g_mft_size,
+				g_mft_size, NTFS_FILE_ATTR_HIDDEN |
+				NTFS_FILE_ATTR_SYSTEM, 0, 0, "$MFT",
+				NTFS_FILE_NAME_WIN32_AND_DOS);
 	/* mft_bitmap is not modified in mkntfs; no need to sync it later. */
 	if (!err)
 		err = add_attr_bitmap_positioned(m, NULL, 0, 0, g_rl_mft_bmp,
@@ -4139,23 +4139,23 @@
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $MFTMirr (mft record 1)\n");
-	m = (MFT_RECORD*)(g_buf + 1 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 1 * g_vol->mft_record_size);
 	err = add_attr_data_positioned(m, NULL, 0, 0, 0, g_rl_mftmirr, g_buf,
 			g_rl_mftmirr[0].length * g_vol->cluster_size);
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_MFTMirr, FILE_MFTMirr),
+				NTFS_MK_LE_MREF(NTFS_FILE_MFTMirr, NTFS_FILE_MFTMirr),
 				g_rl_mftmirr[0].length * g_vol->cluster_size,
 				g_rl_mftmirr[0].length * g_vol->cluster_size,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$MFTMirr", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$MFTMirr", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $MFTMirr: %s\n",
 				strerror(-err));
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $LogFile (mft record 2)\n");
-	m = (MFT_RECORD*)(g_buf + 2 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 2 * g_vol->mft_record_size);
 	buf_log = ntfs_malloc(g_logfile_size);
 	if (!buf_log)
 		return FALSE;
@@ -4166,28 +4166,28 @@
 	buf_log = NULL;
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_LogFile, FILE_LogFile),
+				NTFS_MK_LE_MREF(NTFS_FILE_LogFile, NTFS_FILE_LogFile),
 				g_logfile_size, g_logfile_size,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$LogFile", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$LogFile", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $LogFile: %s\n",
 				strerror(-err));
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $AttrDef (mft record 4)\n");
-	m = (MFT_RECORD*)(g_buf + 4 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 4 * g_vol->mft_record_size);
 	err = add_attr_data(m, NULL, 0, 0, 0, (u8*)g_vol->attrdef,
 			g_vol->attrdef_len);
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_AttrDef, FILE_AttrDef),
+				NTFS_MK_LE_MREF(NTFS_FILE_AttrDef, NTFS_FILE_AttrDef),
 				(g_vol->attrdef_len + g_vol->cluster_size - 1) &
 				~(g_vol->cluster_size - 1), g_vol->attrdef_len,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$AttrDef", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$AttrDef", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (!err) {
-		init_system_file_sd(FILE_AttrDef, &sd, &i);
+		init_system_file_sd(NTFS_FILE_AttrDef, &sd, &i);
 		err = add_attr_sd(m, sd, i);
 	}
 	if (err < 0) {
@@ -4196,29 +4196,29 @@
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $Bitmap (mft record 6)\n");
-	m = (MFT_RECORD*)(g_buf + 6 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 6 * g_vol->mft_record_size);
 	/* the data attribute of $Bitmap must be non-resident or otherwise */
 	/* windows 2003 will regard the volume as corrupt (ERSO) */
 	if (!err)
 		err = insert_non_resident_attr_in_mft_record(m,
-			AT_DATA,  NULL, 0, 0, 0,
+			NTFS_AT_DATA,  NULL, 0, 0, 0,
 			g_lcn_bitmap, g_lcn_bitmap_byte_size);


 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_Bitmap, FILE_Bitmap),
+				NTFS_MK_LE_MREF(NTFS_FILE_Bitmap, NTFS_FILE_Bitmap),
 				(g_lcn_bitmap_byte_size + g_vol->cluster_size -
 				1) & ~(g_vol->cluster_size - 1),
 				g_lcn_bitmap_byte_size,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$Bitmap", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$Bitmap", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $Bitmap: %s\n", strerror(-err));
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $Boot (mft record 7)\n");
-	m = (MFT_RECORD*)(g_buf + 7 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 7 * g_vol->mft_record_size);
 	bs = ntfs_calloc(8192);
 	if (!bs)
 		return FALSE;
@@ -4299,13 +4299,13 @@
 			8192);
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_Boot, FILE_Boot),
+				NTFS_MK_LE_MREF(NTFS_FILE_Boot, NTFS_FILE_Boot),
 				(8192 + g_vol->cluster_size - 1) &
 				~(g_vol->cluster_size - 1), 8192,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$Boot", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$Boot", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (!err) {
-		init_system_file_sd(FILE_Boot, &sd, &i);
+		init_system_file_sd(NTFS_FILE_Boot, &sd, &i);
 		err = add_attr_sd(m, sd, i);
 	}
 	if (err < 0) {
@@ -4319,17 +4319,17 @@
 		 * odd and we failed to set the device block size to the sector
 		 * size, hence we schedule chkdsk to create it.
 		 */
-		volume_flags |= VOLUME_IS_DIRTY;
+		volume_flags |= NTFS_VOLUME_IS_DIRTY;
 	}
 	free(bs);
 #ifdef ENABLE_UUID
 	/*
 	 * We cheat a little here and if the user has requested all times to be
-	 * set to zero then we set the GUID to zero as well.  This options is
+	 * set to zero then we set the NTFS_GUID to zero as well.  This options is
 	 * only used for development purposes so that should be fine.
 	 */
 	if (!opts.use_epoch_time) {
-		/* Generate a GUID for the volume. */
+		/* Generate a NTFS_GUID for the volume. */
 		uuid_generate((void*)&g_vol->guid);
 	} else
 		memset(&g_vol->guid, 0, sizeof(g_vol->guid));
@@ -4337,8 +4337,8 @@
 	if (!create_file_volume(m, root_ref, volume_flags, &g_vol->guid))
 		return FALSE;
 	ntfs_log_verbose("Creating $BadClus (mft record 8)\n");
-	m = (MFT_RECORD*)(g_buf + 8 * g_vol->mft_record_size);
-	/* FIXME: This should be IGNORE_CASE */
+	m = (NTFS_MFT_RECORD*)(g_buf + 8 * g_vol->mft_record_size);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	/* Create a sparse named stream of size equal to the volume size. */
 	err = add_attr_data_positioned(m, "$Bad", 4, 0, 0, g_rl_bad, NULL,
 			g_vol->nr_clusters * g_vol->cluster_size);
@@ -4347,9 +4347,9 @@
 	}
 	if (!err) {
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_BadClus, FILE_BadClus),
-				0LL, 0LL, FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM,
-				0, 0, "$BadClus", FILE_NAME_WIN32_AND_DOS);
+				NTFS_MK_LE_MREF(NTFS_FILE_BadClus, NTFS_FILE_BadClus),
+				0LL, 0LL, NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM,
+				0, 0, "$BadClus", NTFS_FILE_NAME_WIN32_AND_DOS);
 	}
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $BadClus: %s\n",
@@ -4358,14 +4358,14 @@
 	}
 	/* create $Secure (NTFS 3.0+) */
 	ntfs_log_verbose("Creating $Secure (mft record 9)\n");
-	m = (MFT_RECORD*)(g_buf + 9 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_VIEW_INDEX;
+	m = (NTFS_MFT_RECORD*)(g_buf + 9 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_VIEW_INDEX;
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(9, 9), 0LL, 0LL,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |
-				FILE_ATTR_VIEW_INDEX_PRESENT, 0, 0,
-				"$Secure", FILE_NAME_WIN32_AND_DOS);
+				NTFS_MK_LE_MREF(9, 9), 0LL, 0LL,
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM |
+				NTFS_FILE_ATTR_VIEW_INDEX_PRESENT, 0, 0,
+				"$Secure", NTFS_FILE_NAME_WIN32_AND_DOS);
 	buf_sds = NULL;
 	buf_sds_first_size = 0;
 	if (!err) {
@@ -4381,15 +4381,15 @@
 		err = add_attr_data(m, "$SDS", 4, 0, 0, (u8*)buf_sds,
 				buf_sds_size);
 	}
-	/* FIXME: This should be IGNORE_CASE */
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$SDH", 4, 0, AT_UNUSED,
-			COLLATION_NTOFS_SECURITY_HASH,
+		err = add_attr_index_root(m, "$SDH", 4, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_SECURITY_HASH,
 			g_vol->indx_record_size);
-	/* FIXME: This should be IGNORE_CASE */
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$SII", 4, 0, AT_UNUSED,
-			COLLATION_NTOFS_ULONG, g_vol->indx_record_size);
+		err = add_attr_index_root(m, "$SII", 4, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_ULONG, g_vol->indx_record_size);
 	if (!err)
 		err = initialize_secure(buf_sds, buf_sds_first_size, m);
 	free(buf_sds);
@@ -4399,18 +4399,18 @@
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $UpCase (mft record 0xa)\n");
-	m = (MFT_RECORD*)(g_buf + 0xa * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 0xa * g_vol->mft_record_size);
 	err = add_attr_data(m, NULL, 0, 0, 0, (u8*)g_vol->upcase,
 			g_vol->upcase_len << 1);
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(FILE_UpCase, FILE_UpCase),
+				NTFS_MK_LE_MREF(NTFS_FILE_UpCase, NTFS_FILE_UpCase),
 				((g_vol->upcase_len << 1) +
 				g_vol->cluster_size - 1) &
 				~(g_vol->cluster_size - 1),
 				g_vol->upcase_len << 1,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,
-				"$UpCase", FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM, 0, 0,
+				"$UpCase", NTFS_FILE_NAME_WIN32_AND_DOS);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $UpCase: %s\n", strerror(-err));
 		return FALSE;
@@ -4420,18 +4420,18 @@
 	 * $Extend index must be resident.  Otherwise, w2k3 will regard the
 	 * volume as corrupt. (ERSO)
 	 */
-	m = (MFT_RECORD*)(g_buf + 11 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_DIRECTORY;
+	m = (NTFS_MFT_RECORD*)(g_buf + 11 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_DIRECTORY;
 	if (!err)
 		err = create_hardlink(g_index_block, root_ref, m,
-				MK_LE_MREF(11, 11), 0LL, 0LL,
-				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |
-				FILE_ATTR_I30_INDEX_PRESENT, 0, 0,
-				"$Extend", FILE_NAME_WIN32_AND_DOS);
-	/* FIXME: This should be IGNORE_CASE */
+				NTFS_MK_LE_MREF(11, 11), 0LL, 0LL,
+				NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM |
+				NTFS_FILE_ATTR_I30_INDEX_PRESENT, 0, 0,
+				"$Extend", NTFS_FILE_NAME_WIN32_AND_DOS);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$I30", 4, 0, AT_FILE_NAME,
-			COLLATION_FILE_NAME, g_vol->indx_record_size);
+		err = add_attr_index_root(m, "$I30", 4, 0, NTFS_AT_FILE_NAME,
+			NTFS_COLLATION_FILE_NAME, g_vol->indx_record_size);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $Extend: %s\n",
 			strerror(-err));
@@ -4440,7 +4440,7 @@
 	/* NTFS reserved system files (mft records 0xc-0xf) */
 	for (i = 0xc; i < 0x10; i++) {
 		ntfs_log_verbose("Creating system file (mft record 0x%x)\n", i);
-		m = (MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
+		m = (NTFS_MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
 		err = add_attr_data(m, NULL, 0, 0, 0, NULL, 0);
 		if (!err) {
 			init_system_file_sd(i, &sd, &j);
@@ -4454,25 +4454,25 @@
 	}
 	/* create systemfiles for ntfs volumes (3.1) */
 	/* starting with file 24 (ignoring file 16-23) */
-	extend_flags = FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |
-		FILE_ATTR_ARCHIVE | FILE_ATTR_VIEW_INDEX_PRESENT;
+	extend_flags = NTFS_FILE_ATTR_HIDDEN | NTFS_FILE_ATTR_SYSTEM |
+		NTFS_FILE_ATTR_ARCHIVE | NTFS_FILE_ATTR_VIEW_INDEX_PRESENT;
 	ntfs_log_verbose("Creating $Quota (mft record 24)\n");
-	m = (MFT_RECORD*)(g_buf + 24 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_4;
-	m->flags |= MFT_RECORD_IS_VIEW_INDEX;
+	m = (NTFS_MFT_RECORD*)(g_buf + 24 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_4;
+	m->flags |= NTFS_MFT_RECORD_IS_VIEW_INDEX;
 	if (!err)
-		err = create_hardlink_res((MFT_RECORD*)(g_buf +
+		err = create_hardlink_res((NTFS_MFT_RECORD*)(g_buf +
 			11 * g_vol->mft_record_size), extend_ref, m,
-			MK_LE_MREF(24, 1), 0LL, 0LL, extend_flags,
-			0, 0, "$Quota", FILE_NAME_WIN32_AND_DOS);
-	/* FIXME: This should be IGNORE_CASE */
+			NTFS_MK_LE_MREF(24, 1), 0LL, 0LL, extend_flags,
+			0, 0, "$Quota", NTFS_FILE_NAME_WIN32_AND_DOS);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$Q", 2, 0, AT_UNUSED,
-			COLLATION_NTOFS_ULONG, g_vol->indx_record_size);
-	/* FIXME: This should be IGNORE_CASE */
+		err = add_attr_index_root(m, "$Q", 2, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_ULONG, g_vol->indx_record_size);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$O", 2, 0, AT_UNUSED,
-			COLLATION_NTOFS_SID, g_vol->indx_record_size);
+		err = add_attr_index_root(m, "$O", 2, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_SID, g_vol->indx_record_size);
 	if (!err)
 		err = initialize_quota(m);
 	if (err < 0) {
@@ -4480,25 +4480,25 @@
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $ObjId (mft record 25)\n");
-	m = (MFT_RECORD*)(g_buf + 25 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_4;
-	m->flags |= MFT_RECORD_IS_VIEW_INDEX;
+	m = (NTFS_MFT_RECORD*)(g_buf + 25 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_4;
+	m->flags |= NTFS_MFT_RECORD_IS_VIEW_INDEX;
 	if (!err)
-		err = create_hardlink_res((MFT_RECORD*)(g_buf +
+		err = create_hardlink_res((NTFS_MFT_RECORD*)(g_buf +
 				11 * g_vol->mft_record_size), extend_ref,
-				m, MK_LE_MREF(25, 1), 0LL, 0LL,
+				m, NTFS_MK_LE_MREF(25, 1), 0LL, 0LL,
 				extend_flags, 0, 0, "$ObjId",
-				FILE_NAME_WIN32_AND_DOS);
+				NTFS_FILE_NAME_WIN32_AND_DOS);

-	/* FIXME: This should be IGNORE_CASE */
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$O", 2, 0, AT_UNUSED,
-			COLLATION_NTOFS_ULONGS,
+		err = add_attr_index_root(m, "$O", 2, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_ULONGS,
 			g_vol->indx_record_size);
 #ifdef ENABLE_UUID
 	if (!err)
 		err = index_obj_id_insert(m, &g_vol->guid,
-				MK_LE_MREF(FILE_Volume, FILE_Volume));
+				NTFS_MK_LE_MREF(NTFS_FILE_Volume, NTFS_FILE_Volume));
 #endif
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $ObjId: %s\n",
@@ -4506,19 +4506,19 @@
 		return FALSE;
 	}
 	ntfs_log_verbose("Creating $Reparse (mft record 26)\n");
-	m = (MFT_RECORD*)(g_buf + 26 * g_vol->mft_record_size);
-	m->flags |= MFT_RECORD_IS_4;
-	m->flags |= MFT_RECORD_IS_VIEW_INDEX;
+	m = (NTFS_MFT_RECORD*)(g_buf + 26 * g_vol->mft_record_size);
+	m->flags |= NTFS_MFT_RECORD_IS_4;
+	m->flags |= NTFS_MFT_RECORD_IS_VIEW_INDEX;
 	if (!err)
-		err = create_hardlink_res((MFT_RECORD*)(g_buf +
+		err = create_hardlink_res((NTFS_MFT_RECORD*)(g_buf +
 				11 * g_vol->mft_record_size),
-				extend_ref, m, MK_LE_MREF(26, 1),
+				extend_ref, m, NTFS_MK_LE_MREF(26, 1),
 				0LL, 0LL, extend_flags, 0, 0,
-				"$Reparse", FILE_NAME_WIN32_AND_DOS);
-	/* FIXME: This should be IGNORE_CASE */
+				"$Reparse", NTFS_FILE_NAME_WIN32_AND_DOS);
+	/* FIXME: This should be NTFS_IGNORE_CASE */
 	if (!err)
-		err = add_attr_index_root(m, "$R", 2, 0, AT_UNUSED,
-			COLLATION_NTOFS_ULONGS, g_vol->indx_record_size);
+		err = add_attr_index_root(m, "$R", 2, 0, NTFS_AT_UNUSED,
+			NTFS_COLLATION_NTOFS_ULONGS, g_vol->indx_record_size);
 	if (err < 0) {
 		ntfs_log_error("Couldn't create $Reparse: %s\n",
 			strerror(-err));
@@ -4535,8 +4535,8 @@
 	int result = 1;
 	ntfs_attr_search_ctx *ctx = NULL;
 	long long lw, pos;
-	ATTR_RECORD *a;
-	MFT_RECORD *m;
+	NTFS_ATTR_RECORD *a;
+	NTFS_MFT_RECORD *m;
 	int i, err;

 	if (!opts2) {
@@ -4604,7 +4604,7 @@
 	g_buf = ntfs_calloc(g_mft_size);
 	if (!g_buf)
 		goto done;
-	/* Create runlist for $BadClus, $DATA named stream $Bad. */
+	/* Create ntfs_runlist for $BadClus, $DATA named stream $Bad. */
 	if (!mkntfs_initialize_rl_bad())
 		goto done;
 	/* If not quick format, fill the device with 0s. */
@@ -4629,12 +4629,12 @@
 	 *   possible and update during each subsequent c&w of each system file.
 	 */
 	ntfs_log_verbose("Syncing root directory index record.\n");
-	if (!mkntfs_sync_index_record(g_index_block, (MFT_RECORD*)(g_buf + 5 *
+	if (!mkntfs_sync_index_record(g_index_block, (NTFS_MFT_RECORD*)(g_buf + 5 *
 			g_vol->mft_record_size), NTFS_INDEX_I30, 4))
 		goto done;

 	ntfs_log_verbose("Syncing $Bitmap.\n");
-	m = (MFT_RECORD*)(g_buf + 6 * g_vol->mft_record_size);
+	m = (NTFS_MFT_RECORD*)(g_buf + 6 * g_vol->mft_record_size);

 	ctx = ntfs_attr_get_search_ctx(NULL, m);
 	if (!ctx) {
@@ -4642,14 +4642,14 @@
 		goto done;
 	}

-	if (mkntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
+	if (mkntfs_attr_lookup(NTFS_AT_DATA, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {
 		ntfs_log_error("BUG: $DATA attribute not found.\n");
 		goto done;
 	}

 	a = ctx->attr;
 	if (a->non_resident) {
-		runlist *rl = ntfs_mapping_pairs_decompress(g_vol, a, NULL);
+		ntfs_runlist *rl = ntfs_mapping_pairs_decompress(g_vol, a, NULL);
 		if (!rl) {
 			ntfs_log_error("ntfs_mapping_pairs_decompress() failed\n");
 			goto done;
@@ -4687,7 +4687,7 @@
 	pos = g_mftmirr_lcn * g_vol->cluster_size;
 	lw = 1;
 	for (i = 0; i < g_rl_mftmirr[0].length * g_vol->cluster_size / g_vol->mft_record_size; i++) {
-		m = (MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
+		m = (NTFS_MFT_RECORD*)(g_buf + i * g_vol->mft_record_size);
 		/*
 		 * Decrement the usn by one, so it becomes the same as the one
 		 * in $MFT once it is mst protected. - This is as we need the
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.8.in ./ntfsprogs/ntfscat.8.in
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.8.in	2007-09-26 20:31:55.000000000 +0200
+++ ./ntfsprogs/ntfscat.8.in	2007-10-06 16:48:05.000000000 +0200
@@ -39,22 +39,22 @@
 lB lB lB
 l l l.
 Hex	Decimal	Name
-0x10	16	"$STANDARD_INFORMATION"
+0x10	16	"$NTFS_STANDARD_INFORMATION"
 0x20	32	"$ATTRIBUTE_LIST"
 0x30	48	"$FILE_NAME"
 0x40	64	"$OBJECT_ID"
-0x50	80	"$SECURITY_DESCRIPTOR"
-0x60	96	"$VOLUME_NAME"
-0x70	112	"$VOLUME_INFORMATION"
+0x50	80	"$NTFS_SECURITY_DESCRIPTOR"
+0x60	96	"$NTFS_VOLUME_NAME"
+0x70	112	"$NTFS_VOLUME_INFORMATION"
 0x80	128	"$DATA"
-0x90	144	"$INDEX_ROOT"
-0xA0	160	"$INDEX_ALLOCATION"
+0x90	144	"$NTFS_INDEX_ROOT"
+0xA0	160	"$NTFS_INDEX_ALLOCATION"
 0xB0	176	"$BITMAP"
-0xC0	192	"$REPARSE_POINT"
-0xD0	208	"$EA_INFORMATION"
+0xC0	192	"$NTFS_REPARSE_POINT"
+0xD0	208	"$NTFS_EA_INFORMATION"
 0xE0	224	"$EA"
-0xF0	240	"$PROPERTY_SET"
-0x100	256	"$LOGGED_UTILITY_STREAM"
+0xF0	240	"$NTFS_PROPERTY_SET"
+0x100	256	"$NTFS_LOGGED_UTILITY_STREAM"
 .TE
 .sp
 .sp
@@ -99,11 +99,11 @@
 .B ntfscat /dev/hda1 /winnt/system32/drivers/etc/hosts
 .sp
 .RE
-Display the contents of the $INDEX_ROOT attribute of the root directory (inode
+Display the contents of the $NTFS_INDEX_ROOT attribute of the root directory (inode
 5).
 .RS
 .sp
-.B ntfscat /dev/hda1 \-a INDEX_ROOT \-i 5 | hexdump \-C
+.B ntfscat /dev/hda1 \-a NTFS_INDEX_ROOT \-i 5 | hexdump \-C
 .sp
 .RE
 .SH BUGS
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.c ./ntfsprogs/ntfscat.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfscat.c	2007-10-06 16:48:05.000000000 +0200
@@ -39,14 +39,14 @@
 #include <string.h>
 #endif

-#include "types.h"
-#include "attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
 #include "utils.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
 #include "ntfscat.h"
-#include "version.h"
+#include "ntfs_version.h"

 static const char *EXEC_NAME = "ntfscat";
 static struct options opts;
@@ -106,25 +106,25 @@
  * Return:  1  Success, a valid attribute name or number
  *	    0  Error, not an attribute name or number
  */
-static int parse_attribute(const char *value, ATTR_TYPES *attr)
+static int parse_attribute(const char *value, NTFS_ATTR_TYPES *attr)
 {
 	static const char *attr_name[] = {
-		"$STANDARD_INFORMATION",
+		"$NTFS_STANDARD_INFORMATION",
 		"$ATTRIBUTE_LIST",
 		"$FILE_NAME",
 		"$OBJECT_ID",
-		"$SECURITY_DESCRIPTOR",
-		"$VOLUME_NAME",
-		"$VOLUME_INFORMATION",
+		"$NTFS_SECURITY_DESCRIPTOR",
+		"$NTFS_VOLUME_NAME",
+		"$NTFS_VOLUME_INFORMATION",
 		"$DATA",
-		"$INDEX_ROOT",
-		"$INDEX_ALLOCATION",
+		"$NTFS_INDEX_ROOT",
+		"$NTFS_INDEX_ALLOCATION",
 		"$BITMAP",
-		"$REPARSE_POINT",
-		"$EA_INFORMATION",
+		"$NTFS_REPARSE_POINT",
+		"$NTFS_EA_INFORMATION",
 		"$EA",
-		"$PROPERTY_SET",
-		"$LOGGED_UTILITY_STREAM",
+		"$NTFS_PROPERTY_SET",
+		"$NTFS_LOGGED_UTILITY_STREAM",
 		NULL
 	};

@@ -134,14 +134,14 @@
 	for (i = 0; attr_name[i]; i++) {
 		if ((strcmp(value, attr_name[i]) == 0) ||
 		    (strcmp(value, attr_name[i] + 1) == 0)) {
-			*attr = (ATTR_TYPES)cpu_to_le32((i + 1) * 16);
+			*attr = (NTFS_ATTR_TYPES)cpu_to_le32((i + 1) * 16);
 			return 1;
 		}
 	}

 	num = strtol(value, NULL, 0);
 	if ((num > 0) && (num < 257)) {
-		*attr = (ATTR_TYPES)cpu_to_le32(num);
+		*attr = (NTFS_ATTR_TYPES)cpu_to_le32(num);
 		return 1;
 	}

@@ -178,7 +178,7 @@
 	int ver  = 0;
 	int help = 0;
 	int levels = 0;
-	ATTR_TYPES attr = AT_UNUSED;
+	NTFS_ATTR_TYPES attr = NTFS_AT_UNUSED;

 	opterr = 0; /* We'll handle the errors, thank you. */

@@ -307,28 +307,28 @@
  * index_get_size - Find the INDX block size from the index root
  * @inode:  Inode of the directory to be checked
  *
- * Find the size of a directory's INDX block from the INDEX_ROOT attribute.
+ * Find the size of a directory's INDX block from the NTFS_INDEX_ROOT attribute.
  *
  * Return:  n  Success, the INDX blocks are n bytes in size
  *	    0  Error, not a directory
  */
 static int index_get_size(ntfs_inode *inode)
 {
-	ATTR_RECORD *attr90;
-	INDEX_ROOT *iroot;
+	NTFS_ATTR_RECORD *attr90;
+	NTFS_INDEX_ROOT *iroot;

-	attr90 = find_first_attribute(AT_INDEX_ROOT, inode->mrec);
+	attr90 = find_first_attribute(NTFS_AT_INDEX_ROOT, inode->mrec);
 	if (!attr90)
 		return 0;	// not a directory

-	iroot = (INDEX_ROOT*)((u8*)attr90 + le16_to_cpu(attr90->value_offset));
+	iroot = (NTFS_INDEX_ROOT*)((u8*)attr90 + le16_to_cpu(attr90->value_offset));
 	return le32_to_cpu(iroot->index_block_size);
 }

 /**
  * cat
  */
-static int cat(ntfs_volume *vol, ntfs_inode *inode, ATTR_TYPES type,
+static int cat(ntfs_volume *vol, ntfs_inode *inode, NTFS_ATTR_TYPES type,
 		ntfschar *name, int namelen)
 {
 	const int bufsize = 4096;
@@ -350,9 +350,9 @@
 		return 1;
 	}

-	if ((inode->mft_no < 2) && (attr->type == AT_DATA))
+	if ((inode->mft_no < 2) && (attr->type == NTFS_AT_DATA))
 		block_size = vol->mft_record_size;
-	else if (attr->type == AT_INDEX_ALLOCATION)
+	else if (attr->type == NTFS_AT_INDEX_ALLOCATION)
 		block_size = index_get_size(inode);
 	else
 		block_size = 0;
@@ -400,7 +400,7 @@
 {
 	ntfs_volume *vol;
 	ntfs_inode *inode;
-	ATTR_TYPES attr;
+	NTFS_ATTR_TYPES attr;
 	int result = 1;

 	ntfs_log_set_handler(ntfs_log_handler_stderr);
@@ -427,7 +427,7 @@
 		return 1;
 	}

-	attr = AT_DATA;
+	attr = NTFS_AT_DATA;
 	if (opts.attr != cpu_to_le32(-1))
 		attr = opts.attr;

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.h ./ntfsprogs/ntfscat.h
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscat.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfscat.h	2007-10-06 16:48:05.000000000 +0200
@@ -25,20 +25,20 @@
 #ifndef _NTFSCAT_H_
 #define _NTFSCAT_H_

-#include "types.h"
-#include "layout.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"

 struct options {
 	char		*device;	/* Device/File to work with */
 	char		*file;		/* File to display */
 	s64		 inode;		/* Inode to work with */
-	ATTR_TYPES	 attr;		/* Attribute type to display */
+	NTFS_ATTR_TYPES	 attr;		/* Attribute type to display */
 	ntfschar	*attr_name;	/* Attribute name to display */
 	int		 attr_name_len;	/* Attribute name length */
 	int		 force;		/* Override common sense */
 	int		 quiet;		/* Less output */
 	int		 verbose;	/* Extra output */
-	BOOL		 raw;		/* Raw data output */
+	NTFS_BOOL		 raw;		/* Raw data output */
 };

 #endif /* _NTFSCAT_H_ */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsck.c ./ntfsprogs/ntfsck.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsck.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsck.c	2007-10-06 16:48:06.000000000 +0200
@@ -37,12 +37,12 @@
 #include <fcntl.h>
 #endif

-#include "layout.h"
+#include "ntfs_layout.h"
 #include "cluster.h"
-#include "bitmap.h"
+#include "ntfs_bitmap.h"
 #include "utils.h"
-#include "endians.h"
-#include "bootsect.h"
+#include "ntfs_endians.h"
+#include "ntfs_bootsect.h"

 #define RETURN_FS_ERRORS_CORRECTED (1)
 #define RETURN_SYSTEM_NEEDS_REBOOT (2)
@@ -80,7 +80,7 @@
  *	--rebuild-sb	: try to find $MFT start and rebuild the boot sector.
  *	--rebuild-tree	: scan for items and rebuild the indices that point to them (0x30, $SDS, etc.)
  *	--clean-reserved: zero rezerved fields. (use with care!)
- *	--adjust-size -z: insert a sparse hole if the data_size is larger than the size marked in the runlist.
+ *	--adjust-size -z: insert a sparse hole if the data_size is larger than the size marked in the ntfs_runlist.
  *	--logfile file	: report corruptions (unlike other errors) to a file instead of stderr.
  *	--nolog		: don't report corruptions at all.
  *	--quiet -q	: no progress bar.
@@ -125,7 +125,7 @@
  */
 static ntfs_volume vol;

-static runlist_element *mft_rl, *mft_bitmap_rl;
+static ntfs_runlist_element *mft_rl, *mft_bitmap_rl;

 #define check_failed(FORMAT, ARGS...) \
 	do { \
@@ -188,7 +188,7 @@
  * todo: may we use ntfs_boot_sector_is_ntfs() instead?
  *	It already does the checks but will not be able to fix anything.
  */
-static BOOL verify_boot_sector(struct ntfs_device *dev)
+static NTFS_BOOL verify_boot_sector(struct ntfs_device *dev)
 {
 	u8 buf[512];
 	NTFS_BOOT_SECTOR *ntfs_boot = (NTFS_BOOT_SECTOR *)&buf;
@@ -229,7 +229,7 @@
 }

 /**
- * Load the runlist of the <attr_type> attribute.
+ * Load the ntfs_runlist of the <attr_type> attribute.
  *
  * Return NULL if an error.
  * The caller is responsible on freeing the allocated memory if the result is not NULL.
@@ -244,12 +244,12 @@
  *
  * Assumes dev is open.
  */
-static runlist *load_runlist(struct ntfs_device *dev, s64 offset_to_file_record, u32 attr_type, u32 size_of_file_record)
+static ntfs_runlist *load_runlist(struct ntfs_device *dev, s64 offset_to_file_record, u32 attr_type, u32 size_of_file_record)
 {
 	u8 *buf;
 	u16 attrs_offset;
 	u32 length;
-	ATTR_RECORD *attr_rec;
+	NTFS_ATTR_RECORD *attr_rec;

 	if (size_of_file_record<22) // offset to attrs_offset
 		return NULL;
@@ -263,25 +263,25 @@
 		return NULL;
 	}

-	attrs_offset = le16_to_cpu(((MFT_RECORD*)buf)->attrs_offset);
+	attrs_offset = le16_to_cpu(((NTFS_MFT_RECORD*)buf)->attrs_offset);
 	// first attribute must be after the header.
 	if (attrs_offset<42) {
 		check_failed("First attribute must be after the header (%u).\n", (int)attrs_offset);
 	}
-	attr_rec = (ATTR_RECORD *)(buf + attrs_offset);
+	attr_rec = (NTFS_ATTR_RECORD *)(buf + attrs_offset);
 	//printf("uv1.\n");

 	while ((u8*)attr_rec<=buf+size_of_file_record-4) {

 		//printf("Attr type: 0x%x.\n", attr_rec->type);
 		// Check attribute record. (Only what is in the buffer)
-		if (attr_rec->type==AT_END) {
+		if (attr_rec->type==NTFS_AT_END) {
 			check_failed("Attribute 0x%x not found in file record at offset %lld (0x%llx).\n", (int)le32_to_cpu(attr_rec->type), offset_to_file_record, offset_to_file_record);
 			return NULL;
 		}
 		if ((u8*)attr_rec>buf+size_of_file_record-8) {
-			// not AT_END yet no room for the length field.
-			check_failed("Attribute 0x%x is not AT_END, yet no "
+			// not NTFS_AT_END yet no room for the length field.
+			check_failed("Attribute 0x%x is not NTFS_AT_END, yet no "
 					"room for the length field.\n",
 					(int)le32_to_cpu(attr_rec->type));
 			return NULL;
@@ -307,7 +307,7 @@
 			return ntfs_mapping_pairs_decompress(&vol, attr_rec, NULL);
 		}

-		attr_rec = (ATTR_RECORD*)((u8*)attr_rec+length);
+		attr_rec = (NTFS_ATTR_RECORD*)((u8*)attr_rec+length);
 	}
 	// If we got here, there was an overflow.
 	check_failed("file record corrupted at offset %lld (0x%llx).\n", offset_to_file_record, offset_to_file_record);
@@ -315,17 +315,17 @@
 }

 /**
- * Return: >=0 last VCN
- *	   LCN_EINVAL error.
+ * Return: >=0 last NTFS_VCN
+ *	   NTFS_LCN_EINVAL error.
  */
-static VCN get_last_vcn(runlist *rl)
+static NTFS_VCN get_last_vcn(ntfs_runlist *rl)
 {
-	VCN res;
+	NTFS_VCN res;

 	if (!rl)
-		return LCN_EINVAL;
+		return NTFS_LCN_EINVAL;

-	res = LCN_EINVAL;
+	res = NTFS_LCN_EINVAL;
 	while (rl->length) {
 		ntfs_log_verbose("vcn: %lld, length: %lld.\n", rl->vcn,
 				rl->length);
@@ -349,11 +349,11 @@
  */
 static int mft_bitmap_load(struct ntfs_device *dev)
 {
-	VCN vcn;
+	NTFS_VCN vcn;
 	u32 mft_bitmap_length;

 	vcn = get_last_vcn(mft_bitmap_rl);
-	if (vcn<=LCN_EINVAL) {
+	if (vcn<=NTFS_LCN_EINVAL) {
 		mft_bitmap_buf = NULL;
 		/* This case should not happen, not even with on-disk errors */
 		goto error;
@@ -405,7 +405,7 @@
  *
  * Assumes mft_rec is current_mft_record.
  */
-static ATTR_REC *check_attr_record(ATTR_REC *attr_rec, MFT_RECORD *mft_rec,
+static NTFS_ATTR_REC *check_attr_record(NTFS_ATTR_REC *attr_rec, NTFS_MFT_RECORD *mft_rec,
 			u16 buflen)
 {
 	u16 name_offset;
@@ -548,7 +548,7 @@
 	}
 	return 0;
 check_attr_record_next_attr:
-	return (ATTR_REC *)(((u8 *)attr_rec) + length);
+	return (NTFS_ATTR_REC *)(((u8 *)attr_rec) + length);
 }

 /**
@@ -561,12 +561,12 @@
  *	0	Everything's cool.
  *	else	Consider this record as damaged.
  */
-static BOOL check_file_record(u8 *buffer, u16 buflen)
+static NTFS_BOOL check_file_record(u8 *buffer, u16 buflen)
 {
 	u16 usa_count, usa_ofs, attrs_offset, usa;
 	u32 bytes_in_use, bytes_allocated, i;
-	MFT_RECORD *mft_rec = (MFT_RECORD *)buffer;
-	ATTR_REC *attr_rec;
+	NTFS_MFT_RECORD *mft_rec = (NTFS_MFT_RECORD *)buffer;
+	NTFS_ATTR_REC *attr_rec;

 	// check record magic
 	assert_u32_equal(mft_rec->magic, magic_FILE, "FILE record magic");
@@ -610,17 +610,17 @@
 		*fixup = saved_val; // remove it.
 	}

-	attr_rec = (ATTR_REC *)(buffer + attrs_offset);
+	attr_rec = (NTFS_ATTR_REC *)(buffer + attrs_offset);
 	while ((u8*)attr_rec<=buffer+buflen-4) {

 		// Check attribute record. (Only what is in the buffer)
-		if (attr_rec->type==AT_END) {
+		if (attr_rec->type==NTFS_AT_END) {
 			// Done.
 			return 0;
 		}
 		if ((u8*)attr_rec>buffer+buflen-8) {
-			// not AT_END yet no room for the length field.
-			check_failed("Attribute 0x%x is not AT_END, yet no "
+			// not NTFS_AT_END yet no room for the length field.
+			check_failed("Attribute 0x%x is not NTFS_AT_END, yet no "
 					"room for the length field.\n",
 					(int)le32_to_cpu(attr_rec->type));
 			return 1;
@@ -697,7 +697,7 @@

 /**
  * This function serves as bootstraping for the more comprehensive checks.
- * It will load the MFT runlist and MFT/Bitmap runlist.
+ * It will load the MFT ntfs_runlist and MFT/Bitmap ntfs_runlist.
  * It should not depend on other checks or we may have a circular dependancy.
  * Also, this loadng must be forgiving, unlike the comprehensive checks.
  */
@@ -709,31 +709,31 @@

 	ntfs_log_trace("Entering verify_mft_preliminary().\n");
 	// todo: get size_of_file_record from boot sector
-	// Load the first segment of the $MFT/DATA runlist.
+	// Load the first segment of the $MFT/DATA ntfs_runlist.
 	mft_offset = vol.mft_lcn * vol.cluster_size;
 	mftmirr_offset = vol.mftmirr_lcn * vol.cluster_size;
-	mft_rl = load_runlist(dev, mft_offset, AT_DATA, 1024);
+	mft_rl = load_runlist(dev, mft_offset, NTFS_AT_DATA, 1024);
 	if (!mft_rl) {
-		check_failed("Loading $MFT runlist failed. Trying $MFTMirr.\n");
-		mft_rl = load_runlist(dev, mftmirr_offset, AT_DATA, 1024);
+		check_failed("Loading $MFT ntfs_runlist failed. Trying $MFTMirr.\n");
+		mft_rl = load_runlist(dev, mftmirr_offset, NTFS_AT_DATA, 1024);
 	}
 	if (!mft_rl) {
-		check_failed("Loading $MFTMirr runlist failed too. Aborting.\n");
+		check_failed("Loading $MFTMirr ntfs_runlist failed too. Aborting.\n");
 		return RETURN_FS_ERRORS_LEFT_UNCORRECTED | RETURN_OPERATIONAL_ERROR;
 	}
 	// TODO: else { recover $MFT } // Use $MFTMirr to recover $MFT.
-	// todo: support loading the next runlist extents when ATTRIBUTE_LIST is used on $MFT.
-	// If attribute list: Gradually load mft runlist. (parse runlist from first file record, check all referenced file records, continue with the next file record). If no attribute list, just load it.
+	// todo: support loading the next ntfs_runlist extents when ATTRIBUTE_LIST is used on $MFT.
+	// If attribute list: Gradually load mft ntfs_runlist. (parse ntfs_runlist from first file record, check all referenced file records, continue with the next file record). If no attribute list, just load it.

-	// Load the runlist of $MFT/Bitmap.
+	// Load the ntfs_runlist of $MFT/Bitmap.
 	// todo: what about ATTRIBUTE_LIST? Can we reuse code?
-	mft_bitmap_rl = load_runlist(dev, mft_offset, AT_BITMAP, 1024);
+	mft_bitmap_rl = load_runlist(dev, mft_offset, NTFS_AT_BITMAP, 1024);
 	if (!mft_bitmap_rl) {
-		check_failed("Loading $MFT/Bitmap runlist failed. Trying $MFTMirr.\n");
-		mft_bitmap_rl = load_runlist(dev, mftmirr_offset, AT_BITMAP, 1024);
+		check_failed("Loading $MFT/Bitmap ntfs_runlist failed. Trying $MFTMirr.\n");
+		mft_bitmap_rl = load_runlist(dev, mftmirr_offset, NTFS_AT_BITMAP, 1024);
 	}
 	if (!mft_bitmap_rl) {
-		check_failed("Loading $MFTMirr/Bitmap runlist failed too. Aborting.\n");
+		check_failed("Loading $MFTMirr/Bitmap ntfs_runlist failed too. Aborting.\n");
 		return RETURN_FS_ERRORS_LEFT_UNCORRECTED;
 		// todo: rebuild the bitmap by using the "in_use" file record flag or by filling it with 1's.
 	}
@@ -774,12 +774,12 @@
 {
 	u16 flags;

-	if (!(vol->flags | VOLUME_IS_DIRTY))
+	if (!(vol->flags | NTFS_VOLUME_IS_DIRTY))
 		return 0;

 	ntfs_log_verbose("Resetting dirty flag.\n");

-	flags = vol->flags & ~VOLUME_IS_DIRTY;
+	flags = vol->flags & ~NTFS_VOLUME_IS_DIRTY;

 	if (ntfs_volume_write_flags(vol, flags)) {
 		ntfs_log_error("Error setting volume flags.\n");
@@ -841,7 +841,7 @@

 	replay_log(vol);

-	if (vol->flags & VOLUME_IS_DIRTY)
+	if (vol->flags & NTFS_VOLUME_IS_DIRTY)
 		ntfs_log_warning("Volume is dirty.\n");

 	check_volume(vol);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsclone.c ./ntfsprogs/ntfsclone.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsclone.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsclone.c	2007-10-06 16:48:06.000000000 +0200
@@ -61,24 +61,24 @@
  */
 #define NTFS_DO_NOT_CHECK_ENDIANS

-#include "debug.h"
-#include "types.h"
-#include "support.h"
-#include "endians.h"
-#include "bootsect.h"
-#include "device.h"
-#include "attrib.h"
-#include "mst.h"
-#include "volume.h"
-#include "mft.h"
-#include "bitmap.h"
-#include "inode.h"
-#include "index.h"
-#include "dir.h"
-#include "runlist.h"
-#include "ntfstime.h"
+#include "ntfs_debug.h"
+#include "ntfs_types.h"
+#include "ntfs_support.h"
+#include "ntfs_endians.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_device.h"
+#include "ntfs_attrib.h"
+#include "ntfs_mst.h"
+#include "ntfs_volume.h"
+#include "ntfs_mft.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_inode.h"
+#include "ntfs_index.h"
+#include "ntfs_dir.h"
+#include "ntfs_runlist.h"
+#include "ntfs_time.h"
 #include "utils.h"
-#include "version.h"
+#include "ntfs_version.h"

 #if defined(linux) && defined(_IO) && !defined(BLKGETSIZE)
 #define BLKGETSIZE	_IO(0x12,96)  /* Get device size in 512-byte blocks. */
@@ -159,7 +159,7 @@
 static unsigned int wiped_resident_data   = 0;
 static unsigned int wiped_timestamp_data  = 0;

-static BOOL image_is_host_endian = FALSE;
+static NTFS_BOOL image_is_host_endian = FALSE;

 #define IMAGE_MAGIC "\0ntfsclone-image"
 #define IMAGE_MAGIC_SIZE 16
@@ -472,22 +472,22 @@
 	fflush(msg_out);
 }

-static s64 is_critical_metadata(ntfs_walk_clusters_ctx *image, runlist *rl)
+static s64 is_critical_metadata(ntfs_walk_clusters_ctx *image, ntfs_runlist *rl)
 {
 	s64 inode = image->ni->mft_no;

 	if (inode <= LAST_METADATA_INODE) {

 		/* Don't save bad sectors (both $Bad and unnamed are ignored */
-		if (inode == FILE_BadClus && image->ctx->attr->type == AT_DATA)
+		if (inode == NTFS_FILE_BadClus && image->ctx->attr->type == NTFS_AT_DATA)
 			return 0;

-		if (inode != FILE_LogFile)
+		if (inode != NTFS_FILE_LogFile)
 			return rl->length;

-		if (image->ctx->attr->type == AT_DATA) {
+		if (image->ctx->attr->type == NTFS_AT_DATA) {

-			/* Save at least the first 16 KiB of FILE_LogFile */
+			/* Save at least the first 16 KiB of NTFS_FILE_LogFile */
 			s64 s = (s64)16384 - rl->vcn * vol->cluster_size;
 			if (s > 0) {
 				s = rounded_up_division(s, vol->cluster_size);
@@ -499,7 +499,7 @@
 		}
 	}

-	if (image->ctx->attr->type != AT_DATA)
+	if (image->ctx->attr->type != NTFS_AT_DATA)
 		return rl->length;

 	return 0;
@@ -630,7 +630,7 @@
 	}
 }

-static void dump_clusters(ntfs_walk_clusters_ctx *image, runlist *rl)
+static void dump_clusters(ntfs_walk_clusters_ctx *image, ntfs_runlist *rl)
 {
 	s64 i, len; /* number of clusters to copy */

@@ -750,12 +750,12 @@
 	}
 }

-static void wipe_index_entry_timestams(INDEX_ENTRY *e)
+static void wipe_index_entry_timestams(NTFS_INDEX_ENTRY *e)
 {
 	s64 timestamp = utc2ntfs(0);

 	/* FIXME: can fall into infinite loop if corrupted */
-	while (!(e->flags & INDEX_ENTRY_END)) {
+	while (!(e->flags & NTFS_INDEX_ENTRY_END)) {

 		e->key.file_name.creation_time = timestamp;
 		e->key.file_name.last_data_change_time = timestamp;
@@ -764,15 +764,15 @@

 		wiped_timestamp_data += 32;

-		e = (INDEX_ENTRY *)((u8 *)e + le16_to_cpu(e->length));
+		e = (NTFS_INDEX_ENTRY *)((u8 *)e + le16_to_cpu(e->length));
 	}
 }

-static void wipe_index_allocation_timestamps(ntfs_inode *ni, ATTR_RECORD *attr)
+static void wipe_index_allocation_timestamps(ntfs_inode *ni, NTFS_ATTR_RECORD *attr)
 {
-	INDEX_ALLOCATION *indexa, *tmp_indexa;
-	INDEX_ENTRY *entry;
-	INDEX_ROOT *indexr;
+	NTFS_INDEX_ALLOCATION *indexa, *tmp_indexa;
+	NTFS_INDEX_ENTRY *entry;
+	NTFS_INDEX_ROOT *indexr;
 	u8 *bitmap, *byte;
 	int bit;
 	ntfs_attr *na;
@@ -781,26 +781,26 @@

 	indexr = ntfs_index_root_get(ni, attr);
 	if (!indexr) {
-		perr_printf("Failed to read $INDEX_ROOT attribute of inode "
+		perr_printf("Failed to read $NTFS_INDEX_ROOT attribute of inode "
 			    "%lld", ni->mft_no);
 		return;
 	}

-	if (indexr->type != AT_FILE_NAME)
+	if (indexr->type != NTFS_AT_FILE_NAME)
 		goto out_indexr;

 	name = (ntfschar *)((u8 *)attr + le16_to_cpu(attr->name_offset));
 	name_len = attr->name_length;

-	byte = bitmap = ntfs_attr_readall(ni, AT_BITMAP, name, name_len, NULL);
+	byte = bitmap = ntfs_attr_readall(ni, NTFS_AT_BITMAP, name, name_len, NULL);
 	if (!byte) {
 		perr_printf("Failed to read $BITMAP attribute");
 		goto out_indexr;
 	}

-	na = ntfs_attr_open(ni, AT_INDEX_ALLOCATION, name, name_len);
+	na = ntfs_attr_open(ni, NTFS_AT_INDEX_ALLOCATION, name, name_len);
 	if (!na) {
-		perr_printf("Failed to open $INDEX_ALLOCATION attribute");
+		perr_printf("Failed to open $NTFS_INDEX_ALLOCATION attribute");
 		goto out_bitmap;
 	}

@@ -812,7 +812,7 @@
 		goto out_na;

 	if (ntfs_attr_pread(na, 0, na->data_size, indexa) != na->data_size) {
-		perr_printf("Failed to read $INDEX_ALLOCATION attribute");
+		perr_printf("Failed to read $NTFS_INDEX_ALLOCATION attribute");
 		goto out_indexa;
 	}

@@ -825,12 +825,12 @@
 				perr_printf("Damaged INDX record");
 				goto out_indexa;
 			}
-			entry = (INDEX_ENTRY *)((u8 *)tmp_indexa + le32_to_cpu(
+			entry = (NTFS_INDEX_ENTRY *)((u8 *)tmp_indexa + le32_to_cpu(
 				tmp_indexa->index.entries_offset) + 0x18);

 			wipe_index_entry_timestams(entry);

-			if (ntfs_mft_usn_dec((MFT_RECORD *)tmp_indexa))
+			if (ntfs_mft_usn_dec((NTFS_MFT_RECORD *)tmp_indexa))
 				perr_exit("ntfs_mft_usn_dec");

 			if (ntfs_mst_pre_write_fixup((NTFS_RECORD *)tmp_indexa,
@@ -840,7 +840,7 @@
 				goto out_indexa;
 			}
 		}
-		tmp_indexa = (INDEX_ALLOCATION *)((u8 *)tmp_indexa +
+		tmp_indexa = (NTFS_INDEX_ALLOCATION *)((u8 *)tmp_indexa +
 				le32_to_cpu(indexr->index_block_size));
 		bit++;
 		if (bit > 7) {
@@ -861,18 +861,18 @@
 	free(indexr);
 }

-static void wipe_index_root_timestamps(ATTR_RECORD *attr, s64 timestamp)
+static void wipe_index_root_timestamps(NTFS_ATTR_RECORD *attr, s64 timestamp)
 {
-	INDEX_ENTRY *entry;
-	INDEX_ROOT *iroot;
+	NTFS_INDEX_ENTRY *entry;
+	NTFS_INDEX_ROOT *iroot;

-	iroot = (INDEX_ROOT *)((u8 *)attr + le16_to_cpu(attr->value_offset));
-	entry = (INDEX_ENTRY *)((u8 *)iroot +
+	iroot = (NTFS_INDEX_ROOT *)((u8 *)attr + le16_to_cpu(attr->value_offset));
+	entry = (NTFS_INDEX_ENTRY *)((u8 *)iroot +
 			le32_to_cpu(iroot->index.entries_offset) + 0x10);

-	while (!(entry->flags & INDEX_ENTRY_END)) {
+	while (!(entry->flags & NTFS_INDEX_ENTRY_END)) {

-		if (iroot->type == AT_FILE_NAME) {
+		if (iroot->type == NTFS_AT_FILE_NAME) {

 			entry->key.file_name.creation_time = timestamp;
 			entry->key.file_name.last_access_time = timestamp;
@@ -887,9 +887,9 @@
 					    le16_to_cpu(attr->name_offset)),
 				attr->name_length, 0, NULL, 0)) {

-			QUOTA_CONTROL_ENTRY *quota_q;
+			NTFS_QUOTA_CONTROL_ENTRY *quota_q;

-			quota_q = (QUOTA_CONTROL_ENTRY *)((u8 *)entry +
+			quota_q = (NTFS_QUOTA_CONTROL_ENTRY *)((u8 *)entry +
 					le16_to_cpu(entry->data_offset));
 			/*
 			 *  FIXME: no guarantee it's indeed /$Extend/$Quota:$Q.
@@ -902,7 +902,7 @@
 			}
 		}

-		entry = (INDEX_ENTRY*)((u8*)entry + le16_to_cpu(entry->length));
+		entry = (NTFS_INDEX_ENTRY*)((u8*)entry + le16_to_cpu(entry->length));
 	}
 }

@@ -922,22 +922,22 @@

 static void wipe_timestamps(ntfs_walk_clusters_ctx *image)
 {
-	ATTR_RECORD *a = image->ctx->attr;
+	NTFS_ATTR_RECORD *a = image->ctx->attr;
 	s64 timestamp = utc2ntfs(0);

-	if (a->type == AT_FILE_NAME)
-		WIPE_TIMESTAMPS(FILE_NAME_ATTR, a, timestamp);
+	if (a->type == NTFS_AT_FILE_NAME)
+		WIPE_TIMESTAMPS(NTFS_FILE_NAME_ATTR, a, timestamp);

-	else if (a->type == AT_STANDARD_INFORMATION)
-		WIPE_TIMESTAMPS(STANDARD_INFORMATION, a, timestamp);
+	else if (a->type == NTFS_AT_STANDARD_INFORMATION)
+		WIPE_TIMESTAMPS(NTFS_STANDARD_INFORMATION, a, timestamp);

-	else if (a->type == AT_INDEX_ROOT)
+	else if (a->type == NTFS_AT_INDEX_ROOT)
 		wipe_index_root_timestamps(a, timestamp);
 }

 static void wipe_resident_data(ntfs_walk_clusters_ctx *image)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	u32 i;
 	int n = 0;
 	u8 *p;
@@ -948,7 +948,7 @@
 	if (image->ni->mft_no <= LAST_METADATA_INODE)
 		return;

-	if (a->type != AT_DATA)
+	if (a->type != NTFS_AT_DATA)
 		return;

 	for (i = 0; i < le32_to_cpu(a->value_length); i++) {
@@ -961,7 +961,7 @@
 	wiped_resident_data += n;
 }

-static void clone_logfile_parts(ntfs_walk_clusters_ctx *image, runlist *rl)
+static void clone_logfile_parts(ntfs_walk_clusters_ctx *image, ntfs_runlist *rl)
 {
 	s64 offset = 0, lcn, vcn;

@@ -985,8 +985,8 @@
 static void walk_runs(struct ntfs_walk_cluster *walk)
 {
 	int i, j;
-	runlist *rl;
-	ATTR_RECORD *a;
+	ntfs_runlist *rl;
+	NTFS_ATTR_RECORD *a;
 	ntfs_attr_search_ctx *ctx;

 	ctx = walk->image->ctx;
@@ -1000,7 +1000,7 @@
 		return;
 	}

-	if (wipe && walk->image->ctx->attr->type == AT_INDEX_ALLOCATION)
+	if (wipe && walk->image->ctx->attr->type == NTFS_AT_INDEX_ALLOCATION)
 		wipe_index_allocation_timestamps(walk->image->ni, a);

 	if (!(rl = ntfs_mapping_pairs_decompress(vol, a, NULL)))
@@ -1010,12 +1010,12 @@
 		s64 lcn = rl[i].lcn;
 		s64 lcn_length = rl[i].length;

-		if (lcn == LCN_HOLE || lcn == LCN_RL_NOT_MAPPED)
+		if (lcn == NTFS_LCN_HOLE || lcn == NTFS_LCN_RL_NOT_MAPPED)
 			continue;

 		/* FIXME: ntfs_mapping_pairs_decompress should return error */
 		if (lcn < 0 || lcn_length < 0)
-			err_exit("Corrupt runlist in inode %lld attr %x LCN "
+			err_exit("Corrupt ntfs_runlist in inode %lld attr %x NTFS_LCN "
 				 "%llx length %llx\n", ctx->ntfs_ino->mft_no,
 				 (unsigned int)le32_to_cpu(a->type), lcn,
 				 lcn_length);
@@ -1034,8 +1034,8 @@
 		walk->image->inuse += lcn_length;
 	}
 	if (!wipe && !opt.std_out && opt.metadata &&
-	    walk->image->ni->mft_no == FILE_LogFile &&
-	    walk->image->ctx->attr->type == AT_DATA)
+	    walk->image->ni->mft_no == NTFS_FILE_LogFile &&
+	    walk->image->ctx->attr->type == NTFS_AT_DATA)
 		clone_logfile_parts(walk->image, rl);

 	free(rl);
@@ -1050,7 +1050,7 @@
 		perr_exit("ntfs_get_attr_search_ctx");

 	while (!ntfs_attrs_walk(ctx)) {
-		if (ctx->attr->type == AT_END)
+		if (ctx->attr->type == NTFS_AT_END)
 			break;

 		walk->image->ctx = ctx;
@@ -1146,7 +1146,7 @@
 static void wipe_unused_mft_data(ntfs_inode *ni)
 {
 	int unused;
-	MFT_RECORD *m = ni->mrec;
+	NTFS_MFT_RECORD *m = ni->mrec;

 	/* FIXME: broken MFTMirr update was fixed in libntfs, check if OK now */
 	if (ni->mft_no <= LAST_METADATA_INODE)
@@ -1160,14 +1160,14 @@
 static void wipe_unused_mft(ntfs_inode *ni)
 {
 	int unused;
-	MFT_RECORD *m = ni->mrec;
+	NTFS_MFT_RECORD *m = ni->mrec;

 	/* FIXME: broken MFTMirr update was fixed in libntfs, check if OK now */
 	if (ni->mft_no <= LAST_METADATA_INODE)
 		return;

-	unused = le32_to_cpu(m->bytes_in_use) - sizeof(MFT_RECORD);
-	wiped_unused_mft += wipe_data((char *)m, sizeof(MFT_RECORD), unused);
+	unused = le32_to_cpu(m->bytes_in_use) - sizeof(NTFS_MFT_RECORD);
+	wiped_unused_mft += wipe_data((char *)m, sizeof(NTFS_MFT_RECORD), unused);
 }

 static void mft_record_write_with_same_usn(ntfs_volume *volume, ntfs_inode *ni)
@@ -1210,7 +1210,7 @@
 	for (; inode <= last_mft_rec; inode++) {

 		int err, deleted_inode;
-		MFT_REF mref = (MFT_REF)inode;
+		NTFS_MFT_REF mref = (NTFS_MFT_REF)inode;

 		progress_update(&progress, inode);

@@ -1228,11 +1228,11 @@
 			continue;
 		}

-		deleted_inode = !(ni->mrec->flags & MFT_RECORD_IN_USE);
+		deleted_inode = !(ni->mrec->flags & NTFS_MFT_RECORD_IN_USE);

 		if (deleted_inode) {

-			ni->mft_no = MREF(mref);
+			ni->mft_no = NTFS_MREF(mref);
 			if (wipe) {
 				wipe_unused_mft(ni);
 				wipe_unused_mft_data(ni);
@@ -1671,7 +1671,7 @@
 		goto error_out;
 	}

-	if (ntfs_attr_lookup(AT_DATA, ustr, len, 0, 0, NULL, 0, ctx)) {
+	if (ntfs_attr_lookup(NTFS_AT_DATA, ustr, len, 0, 0, NULL, 0, ctx)) {
 		perr_printf("ntfs_attr_lookup");
 		goto error_out;
 	}
@@ -1686,10 +1686,10 @@
 {
 	ntfs_inode *ni;
 	ntfs_attr_search_ctx *ctx = NULL;
-	runlist *rl, *rl_bad;
+	ntfs_runlist *rl, *rl_bad;
 	s64 nr_bad_clusters = 0;

-	if (!(ni = ntfs_inode_open(vol, FILE_BadClus)))
+	if (!(ni = ntfs_inode_open(vol, NTFS_FILE_BadClus)))
 		perr_exit("ntfs_open_inode");

 	if ((ctx = lookup_data_attr(ni, "$Bad")) == NULL)
@@ -1701,7 +1701,7 @@
 	for (rl = rl_bad; rl->length; rl++) {
 		s64 lcn = rl->lcn;

-		if (lcn == LCN_HOLE || lcn < 0)
+		if (lcn == NTFS_LCN_HOLE || lcn < 0)
 			continue;

 		for (; lcn < rl->lcn + rl->length; lcn++, nr_bad_clusters++) {
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscluster.c ./ntfsprogs/ntfscluster.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscluster.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfscluster.c	2007-10-06 16:48:05.000000000 +0200
@@ -42,15 +42,15 @@
 #endif

 #include "ntfscluster.h"
-#include "types.h"
-#include "attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
 #include "utils.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
 #include "cluster.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfscluster";
 static struct options opts;
@@ -283,8 +283,8 @@

 	struct mft_search_ctx *m_ctx;
 	ntfs_attr_search_ctx *a_ctx;
-	runlist_element *rl;
-	ATTR_RECORD *rec;
+	ntfs_runlist_element *rl;
+	NTFS_ATTR_RECORD *rec;
 	int z;
 	int inuse = 0;

@@ -299,7 +299,7 @@

 		a_ctx = ntfs_attr_get_search_ctx(m_ctx->inode, NULL);

-		while ((rec = find_attribute(AT_UNUSED, a_ctx))) {
+		while ((rec = find_attribute(NTFS_AT_UNUSED, a_ctx))) {

 			if (!rec->non_resident)
 				continue;
@@ -387,9 +387,9 @@
 {
 	char buffer[1024];
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *rec;
+	NTFS_ATTR_RECORD *rec;
 	int i;
-	runlist *runs;
+	ntfs_runlist *runs;

 	utils_inode_get_name(ino, buffer, sizeof(buffer));

@@ -397,13 +397,13 @@

 	ctx = ntfs_attr_get_search_ctx(ino, NULL);

-	while ((rec = find_attribute(AT_UNUSED, ctx))) {
+	while ((rec = find_attribute(NTFS_AT_UNUSED, ctx))) {
 		ntfs_log_info("    0x%02x - ", rec->type);
 		if (rec->non_resident) {
 			ntfs_log_info("non-resident\n");
 			runs = ntfs_mapping_pairs_decompress(vol, rec, NULL);
 			if (runs) {
-				ntfs_log_info("             VCN     LCN     Length\n");
+				ntfs_log_info("             NTFS_VCN     NTFS_LCN     Length\n");
 				for (i = 0; runs[i].length > 0; i++) {
 					ntfs_log_info("        %8lld %8lld %8lld\n",
 							(long long)runs[i].vcn,
@@ -425,8 +425,8 @@
 /**
  * print_match
  */
-static int print_match(ntfs_inode *ino, ATTR_RECORD *attr,
-	runlist_element *run, void *data __attribute__((unused)))
+static int print_match(ntfs_inode *ino, NTFS_ATTR_RECORD *attr,
+	ntfs_runlist_element *run, void *data __attribute__((unused)))
 {
 	char *buffer;

@@ -452,7 +452,7 @@
 /**
  * find_last
  */
-static int find_last(ntfs_inode *ino, ATTR_RECORD *attr, runlist_element *run,
+static int find_last(ntfs_inode *ino, NTFS_ATTR_RECORD *attr, ntfs_runlist_element *run,
 	void *data)
 {
 	struct match *m;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscluster.h ./ntfsprogs/ntfscluster.h
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscluster.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfscluster.h	2007-10-06 16:48:06.000000000 +0200
@@ -24,8 +24,8 @@
 #ifndef _NTFSCLUSTER_H_
 #define _NTFSCLUSTER_H_

-#include "types.h"
-#include "layout.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"

 enum action {
 	act_none,
@@ -52,8 +52,8 @@

 struct match {
 	u64		 inum;		/* Inode number */
-	LCN		 lcn;		/* Last cluster in use */
-	ATTR_TYPES	 type;		/* Attribute type */
+	NTFS_LCN		 lcn;		/* Last cluster in use */
+	NTFS_ATTR_TYPES	 type;		/* Attribute type */
 	ntfschar	*name;		/* Attribute name */
 	int		 name_len;	/* Length of attribute name */
 };
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscmp.c ./ntfsprogs/ntfscmp.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscmp.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfscmp.c	2007-10-06 16:48:06.000000000 +0200
@@ -34,9 +34,9 @@
 #include <getopt.h>

 #include "utils.h"
-#include "mst.h"
-#include "version.h"
-#include "support.h"
+#include "ntfs_mst.h"
+#include "ntfs_version.h"
+#include "ntfs_support.h"

 static const char *EXEC_NAME = "ntfscmp";

@@ -348,7 +348,7 @@
 	return "OK";
 }

-static int inode_open(ntfs_volume *vol, MFT_REF mref, ntfs_inode **ni)
+static int inode_open(ntfs_volume *vol, NTFS_MFT_REF mref, ntfs_inode **ni)
 {
 	*ni = ntfs_inode_open(vol, mref);
 	if (*ni == NULL) {
@@ -390,7 +390,7 @@
 	print_inode(inumber(ni));
 }

-static void print_attribute_type(ATTR_TYPES atype)
+static void print_attribute_type(NTFS_ATTR_TYPES atype)
 {
 	printf("attribute 0x%x", atype);
 }
@@ -414,14 +414,14 @@
 }

 static char *get_attr_name(u64 mft_no,
-			   ATTR_TYPES atype,
+			   NTFS_ATTR_TYPES atype,
 			   const ntfschar *uname,
 			   const int uname_len)
 {
 	char *name = NULL;
 	int name_len;

-	if (atype == AT_END)
+	if (atype == NTFS_AT_END)
 		return NULL;

 	name_len = ntfs_ucstombs(uname, uname_len, &name, 0);
@@ -447,12 +447,12 @@
 static char *get_attr_name_ctx(ntfs_attr_search_ctx *ctx)
 {
 	u64 mft_no = inumber(ctx->ntfs_ino);
-	ATTR_TYPES atype = ctx->attr->type;
+	NTFS_ATTR_TYPES atype = ctx->attr->type;

 	return get_attr_name(mft_no, atype, GET_ATTR_NAME(ctx->attr));
 }

-static void print_attribute(ATTR_TYPES atype, char *name)
+static void print_attribute(NTFS_ATTR_TYPES atype, char *name)
 {
 	print_attribute_type(atype);
 	print_attribute_name(name);
@@ -498,8 +498,8 @@
 }

 struct cmp_ia {
-	INDEX_ALLOCATION *ia;
-	INDEX_ALLOCATION *tmp_ia;
+	NTFS_INDEX_ALLOCATION *ia;
+	NTFS_INDEX_ALLOCATION *tmp_ia;
 	u8 *bitmap;
 	u8 *byte;
 	s64 bm_size;
@@ -507,7 +507,7 @@

 static int setup_cmp_ia(ntfs_attr *na, struct cmp_ia *cia)
 {
-	cia->bitmap = ntfs_attr_readall(na->ni, AT_BITMAP, na->name,
+	cia->bitmap = ntfs_attr_readall(na->ni, NTFS_AT_BITMAP, na->name,
 					na->name_len, &cia->bm_size);
 	if (!cia->bitmap) {
 		perr_println("Failed to readall BITMAP");
@@ -520,7 +520,7 @@
 		goto free_bm;

 	if (ntfs_attr_pread(na, 0, na->data_size, cia->ia) != na->data_size) {
-		perr_println("Failed to pread INDEX_ALLOCATION");
+		perr_println("Failed to pread NTFS_INDEX_ALLOCATION");
 		goto free_ia;
 	}

@@ -578,8 +578,8 @@
 				goto out;
 		}

-		cia1.tmp_ia = (INDEX_ALLOCATION *)((u8 *)cia1.tmp_ia + ib_size);
-		cia2.tmp_ia = (INDEX_ALLOCATION *)((u8 *)cia2.tmp_ia + ib_size);
+		cia1.tmp_ia = (NTFS_INDEX_ALLOCATION *)((u8 *)cia1.tmp_ia + ib_size);
+		cia2.tmp_ia = (NTFS_INDEX_ALLOCATION *)((u8 *)cia2.tmp_ia + ib_size);

 		bit++;
 		if (bit > 7) {
@@ -645,9 +645,9 @@
 	exit(1);
 }

-static int cmp_attribute_header(ATTR_RECORD *a1, ATTR_RECORD *a2)
+static int cmp_attribute_header(NTFS_ATTR_RECORD *a1, NTFS_ATTR_RECORD *a2)
 {
-	u32 header_size = offsetof(ATTR_RECORD, resident_end);
+	u32 header_size = offsetof(NTFS_ATTR_RECORD, resident_end);

 	if (a1->non_resident != a2->non_resident)
 		return 1;
@@ -665,8 +665,8 @@
 static void cmp_attribute(ntfs_attr_search_ctx *ctx1,
 			  ntfs_attr_search_ctx *ctx2)
 {
-	ATTR_RECORD *a1 = ctx1->attr;
-	ATTR_RECORD *a2 = ctx2->attr;
+	NTFS_ATTR_RECORD *a1 = ctx1->attr;
+	NTFS_ATTR_RECORD *a2 = ctx2->attr;
 	ntfs_attr *na1, *na2;

 	if (cmp_attribute_header(a1, a2)) {
@@ -700,7 +700,7 @@
 		return;
 	}

-	if (na1->type == AT_INDEX_ALLOCATION)
+	if (na1->type == NTFS_AT_INDEX_ALLOCATION)
 		cmp_index_allocation(na1, na2);
 	else
 		cmp_attribute_data(na1, na2);
@@ -710,7 +710,7 @@
 	ntfs_attr_close(na2);
 }

-static void vprint_attribute(ATTR_TYPES atype, char  *name)
+static void vprint_attribute(NTFS_ATTR_TYPES atype, char  *name)
 {
 	if (!opt.verbose)
 		return;
@@ -722,8 +722,8 @@
 }

 static void print_attributes(ntfs_inode *ni,
-			     ATTR_TYPES atype1,
-			     ATTR_TYPES atype2,
+			     NTFS_ATTR_TYPES atype1,
+			     NTFS_ATTR_TYPES atype2,
 			     char  *name1,
 			     char  *name2)
 {
@@ -753,7 +753,7 @@
 }

 static int new_attribute(ntfs_attr_search_ctx *ctx,
-			 ATTR_TYPES prev_atype,
+			 NTFS_ATTR_TYPES prev_atype,
 			 char *prev_name)
 {
 	if (!prev_atype && !prev_name)
@@ -778,8 +778,8 @@
 	return 0;
 }

-static void set_prev(char **prev_name, ATTR_TYPES *prev_atype,
-		     char *name, ATTR_TYPES atype)
+static void set_prev(char **prev_name, NTFS_ATTR_TYPES *prev_atype,
+		     char *name, NTFS_ATTR_TYPES atype)
 {
 	free_name(prev_name);
 	if (name) {
@@ -791,7 +791,7 @@
 	*prev_atype = atype;
 }

-static void set_cmp_attr(ntfs_attr_search_ctx *ctx, ATTR_TYPES *atype, char **name)
+static void set_cmp_attr(ntfs_attr_search_ctx *ctx, NTFS_ATTR_TYPES *atype, char **name)
 {
 	*atype = ctx->attr->type;

@@ -799,7 +799,7 @@
 	*name = get_attr_name_ctx(ctx);
 }

-static int next_attr(ntfs_attr_search_ctx *ctx, ATTR_TYPES *atype, char **name,
+static int next_attr(ntfs_attr_search_ctx *ctx, NTFS_ATTR_TYPES *atype, char **name,
 		     int *err)
 {
 	int ret;
@@ -807,7 +807,7 @@
 	ret = ntfs_attrs_walk(ctx);
 	*err = errno;
 	if (ret) {
-		*atype = AT_END;
+		*atype = NTFS_AT_END;
 		free_name(name);
 	} else
 		set_cmp_attr(ctx, atype, name);
@@ -821,7 +821,7 @@
 	int old_ret1, ret1 = 0, ret2 = 0;
 	int errno1 = 0, errno2 = 0;
 	char  *prev_name = NULL, *name1 = NULL, *name2 = NULL;
-	ATTR_TYPES old_atype1, prev_atype = 0, atype1, atype2;
+	NTFS_ATTR_TYPES old_atype1, prev_atype = 0, atype1, atype2;
 	ntfs_attr_search_ctx *ctx1, *ctx2;

 	if (!(ctx1 = attr_get_search_ctx(ni1)))
@@ -914,8 +914,8 @@

 	for (inode = 0; inode < nr_mft_records; inode++) {

-		ret1 = inode_open(vol1, (MFT_REF)inode, &ni1);
-		ret2 = inode_open(vol2, (MFT_REF)inode, &ni2);
+		ret1 = inode_open(vol1, (NTFS_MFT_REF)inode, &ni1);
+		ret2 = inode_open(vol2, (NTFS_MFT_REF)inode, &ni2);

 		if (ret1 != ret2) {
 			print_inode(inode);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfscp.c ./ntfsprogs/ntfscp.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfscp.c	2007-09-24 20:48:43.000000000 +0200
+++ ./ntfsprogs/ntfscp.c	2007-10-06 16:48:06.000000000 +0200
@@ -48,14 +48,14 @@
 #include <libgen.h>
 #endif

-#include "types.h"
-#include "attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
 #include "utils.h"
-#include "volume.h"
-#include "dir.h"
-#include "debug.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_volume.h"
+#include "ntfs_dir.h"
+#include "ntfs_debug.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 struct options {
 	char		*device;	/* Device/File to work with */
@@ -66,7 +66,7 @@
 	int		 quiet;		/* Less output */
 	int		 verbose;	/* Extra output */
 	int		 noaction;	/* Do not write to disk */
-	ATTR_TYPES	 attribute;	/* Write to this attribute. */
+	NTFS_ATTR_TYPES	 attribute;	/* Write to this attribute. */
 	int		 inode;		/* Treat dest_file as inode number. */
 };

@@ -152,7 +152,7 @@
 	opts.dest_file = NULL;
 	opts.attr_name = NULL;
 	opts.inode = 0;
-	opts.attribute = AT_DATA;
+	opts.attribute = NTFS_AT_DATA;

 	opterr = 0; /* We'll handle the errors, thank you. */

@@ -172,7 +172,7 @@
 			}
 			break;
 		case 'a':
-			if (opts.attribute != AT_DATA) {
+			if (opts.attribute != NTFS_AT_DATA) {
 				ntfs_log_error("You can specify only one "
 						"attribute.\n");
 				err++;
@@ -184,7 +184,7 @@
 				ntfs_log_error("Couldn't parse attribute.\n");
 				err++;
 			} else
-				opts.attribute = (ATTR_TYPES)cpu_to_le32(attr);
+				opts.attribute = (NTFS_ATTR_TYPES)cpu_to_le32(attr);
 			break;
 		case 'i':
 			opts.inode++;
@@ -411,10 +411,10 @@
 		} else {
 			ntfs_log_verbose("Target path does not contain '/'. "
 					"Using root directory as parent.\n");
-			dir_ni = ntfs_inode_open(vol, FILE_root);
+			dir_ni = ntfs_inode_open(vol, NTFS_FILE_root);
 		}
 		if (dir_ni) {
-			if (!(dir_ni->mrec->flags & MFT_RECORD_IS_DIRECTORY)) {
+			if (!(dir_ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY)) {
 				/* Remove the last '/' for estetic reasons. */
 				dirname_last_whack[0] = 0;
 				ntfs_log_error("The file '%s' already exists "
@@ -445,7 +445,7 @@
 		free(parent_dirname);
 	}
 	/* The destination is a directory. */
-	if ((out->mrec->flags & MFT_RECORD_IS_DIRECTORY) && !opts.inode) {
+	if ((out->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY) && !opts.inode) {
 		char *filename;
 		char *overwrite_filename;
 		int overwrite_filename_len;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsdecrypt.c ./ntfsprogs/ntfsdecrypt.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsdecrypt.c	2007-09-27 15:40:43.000000000 +0200
+++ ./ntfsprogs/ntfsdecrypt.c	2007-10-06 16:48:06.000000000 +0200
@@ -56,14 +56,14 @@
 #include <gcrypt.h>
 #include <gnutls/pkcs12.h>

-#include "types.h"
-#include "attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
 #include "utils.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
-#include "layout.h"
-#include "version.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
+#include "ntfs_layout.h"
+#include "ntfs_version.h"

 typedef gcry_sexp_t ntfs_rsa_private_key;

@@ -126,7 +126,7 @@
 	char *device;		/* Device/File to work with */
 	char *file;		/* File to display */
 	s64 inode;		/* Inode to work with */
-	ATTR_TYPES attr;	/* Attribute type to display */
+	NTFS_ATTR_TYPES attr;	/* Attribute type to display */
 	int force;		/* Override common sense */
 	int quiet;		/* Less output */
 	int verbose;		/* Extra output */
@@ -478,7 +478,7 @@
 	char purpose_oid[100];
 	size_t purpose_oid_size = sizeof(purpose_oid);
 	size_t tp_size = thumbprint_size;
-	BOOL have_thumbprint = FALSE;
+	NTFS_BOOL have_thumbprint = FALSE;

 	*df_type = DF_TYPE_UNKNOWN;
 	/* Create a pkcs12 structure. */
@@ -950,7 +950,7 @@
 /**
  * ntfs_desx_key_expand_test
  */
-static BOOL ntfs_desx_key_expand_test(void)
+static NTFS_BOOL ntfs_desx_key_expand_test(void)
 {
 	const u8 known_desx_on_disk_key[16] = {
 		0xa1, 0xf9, 0xe0, 0xb2, 0x53, 0x23, 0x9e, 0x8f,
@@ -971,7 +971,7 @@
 		u32 u32[2];
 	} test_des_key;
 	gcry_error_t err;
-	BOOL res;
+	NTFS_BOOL res;

 	err = ntfs_desx_key_expand(known_desx_on_disk_key, test_des_key.u32,
 			&test_out_whitening, &test_in_whitening);
@@ -991,7 +991,7 @@
 /**
  * ntfs_des_test
  */
-static BOOL ntfs_des_test(void)
+static NTFS_BOOL ntfs_des_test(void)
 {
 	const u8 known_des_key[8] = {
 		0x27, 0xd1, 0x93, 0x09, 0xcb, 0x78, 0x93, 0x1f
@@ -1045,7 +1045,7 @@
 /**
  * ntfs_desx_key_expand_test
  */
-static inline BOOL ntfs_desx_key_expand_test(void)
+static inline NTFS_BOOL ntfs_desx_key_expand_test(void)
 {
 	return TRUE;
 }
@@ -1053,7 +1053,7 @@
 /**
  * ntfs_des_test
  */
-static inline BOOL ntfs_des_test(void)
+static inline NTFS_BOOL ntfs_des_test(void)
 {
 	return TRUE;
 }
@@ -1179,13 +1179,13 @@
 /**
  * ntfs_df_array_fek_get
  */
-static ntfs_fek *ntfs_df_array_fek_get(EFS_DF_ARRAY_HEADER *df_array,
+static ntfs_fek *ntfs_df_array_fek_get(NTFS_EFS_DF_ARRAY_HEADER *df_array,
 		ntfs_rsa_private_key rsa_key, char *thumbprint,
 		int thumbprint_size)
 {
-	EFS_DF_HEADER *df_header;
-	EFS_DF_CREDENTIAL_HEADER *df_cred;
-	EFS_DF_CERT_THUMBPRINT_HEADER *df_cert;
+	NTFS_EFS_DF_HEADER *df_header;
+	NTFS_EFS_DF_CREDENTIAL_HEADER *df_cred;
+	NTFS_EFS_DF_CERT_THUMBPRINT_HEADER *df_cert;
 	u8 *fek_buf;
 	ntfs_fek *fek;
 	u32 df_count, fek_size;
@@ -1194,17 +1194,17 @@
 	df_count = le32_to_cpu(df_array->df_count);
 	if (!df_count)
 		ntfs_log_error("There are no elements in the DF array.\n");
-	df_header = (EFS_DF_HEADER*)(df_array + 1);
-	for (i = 0; i < df_count; i++, df_header = (EFS_DF_HEADER*)(
+	df_header = (NTFS_EFS_DF_HEADER*)(df_array + 1);
+	for (i = 0; i < df_count; i++, df_header = (NTFS_EFS_DF_HEADER*)(
 			(u8*)df_header + le32_to_cpu(df_header->df_length))) {
-		df_cred = (EFS_DF_CREDENTIAL_HEADER*)((u8*)df_header +
+		df_cred = (NTFS_EFS_DF_CREDENTIAL_HEADER*)((u8*)df_header +
 				le32_to_cpu(df_header->cred_header_offset));
 		if (df_cred->type != NTFS_CRED_TYPE_CERT_THUMBPRINT) {
 			ntfs_log_debug("Credential type is not certificate "
 					"thumbprint, skipping DF entry.\n");
 			continue;
 		}
-		df_cert = (EFS_DF_CERT_THUMBPRINT_HEADER*)((u8*)df_cred +
+		df_cert = (NTFS_EFS_DF_CERT_THUMBPRINT_HEADER*)((u8*)df_cred +
 				le32_to_cpu(
 				df_cred->cert_thumbprint_header_offset));
 		if (le32_to_cpu(df_cert->thumbprint_size) != thumbprint_size) {
@@ -1251,12 +1251,12 @@
 		ntfs_rsa_private_key rsa_key, char *thumbprint,
 		int thumbprint_size, NTFS_DF_TYPES df_type)
 {
-	EFS_ATTR_HEADER *efs;
-	EFS_DF_ARRAY_HEADER *df_array = NULL;
+	NTFS_EFS_ATTR_HEADER *efs;
+	NTFS_EFS_DF_ARRAY_HEADER *df_array = NULL;
 	ntfs_fek *fek = NULL;

 	/* Obtain the $EFS contents. */
-	efs = ntfs_attr_readall(inode, AT_LOGGED_UTILITY_STREAM, EFS, 4, NULL);
+	efs = ntfs_attr_readall(inode, NTFS_AT_LOGGED_UTILITY_STREAM, EFS, 4, NULL);
 	if (!efs) {
 		ntfs_log_perror("Failed to read $EFS attribute");
 		return NULL;
@@ -1267,14 +1267,14 @@
 	 */
 	if (df_type == DF_TYPE_DDF) {
 		if (efs->offset_to_ddf_array)
-			df_array = (EFS_DF_ARRAY_HEADER*)((u8*)efs +
+			df_array = (NTFS_EFS_DF_ARRAY_HEADER*)((u8*)efs +
 					le32_to_cpu(efs->offset_to_ddf_array));
 		else
 			ntfs_log_error("There are no entries in the DDF "
 					"array.\n");
 	} else if (df_type == DF_TYPE_DRF) {
 		if (efs->offset_to_drf_array)
-			df_array = (EFS_DF_ARRAY_HEADER*)((u8*)efs +
+			df_array = (NTFS_EFS_DF_ARRAY_HEADER*)((u8*)efs +
 					le32_to_cpu(efs->offset_to_drf_array));
 		else
 			ntfs_log_error("There are no entries in the DRF "
@@ -1341,7 +1341,7 @@
 	buffer = malloc(bufsize);
 	if (!buffer)
 		return 1;
-	attr = ntfs_attr_open(inode, AT_DATA, NULL, 0);
+	attr = ntfs_attr_open(inode, NTFS_AT_DATA, NULL, 0);
 	if (!attr) {
 		ntfs_log_error("Cannot cat a directory.\n");
 		free(buffer);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsdump_logfile.c ./ntfsprogs/ntfsdump_logfile.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsdump_logfile.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsdump_logfile.c	2007-10-06 16:48:05.000000000 +0200
@@ -60,20 +60,20 @@
 #include <fcntl.h>
 #endif

-#include "types.h"
-#include "endians.h"
-#include "volume.h"
-#include "inode.h"
-#include "attrib.h"
-#include "layout.h"
-#include "logfile.h"
-#include "mst.h"
+#include "ntfs_types.h"
+#include "ntfs_endians.h"
+#include "ntfs_volume.h"
+#include "ntfs_inode.h"
+#include "ntfs_attrib.h"
+#include "ntfs_layout.h"
+#include "ntfs_logfile.h"
+#include "ntfs_mst.h"
 #include "utils.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 typedef struct {
-	BOOL is_volume;
+	NTFS_BOOL is_volume;
 	const char *filename;
 	s64 data_size;
 	union {
@@ -98,7 +98,7 @@
 			ntfs_attr_close(logfile->na);
 		if (logfile->ni && ntfs_inode_close(logfile->ni))
 			ntfs_log_perror("Warning: Failed to close $LogFile "
-					"(inode %i)", FILE_LogFile);
+					"(inode %i)", NTFS_FILE_LogFile);
 		if (ntfs_umount(logfile->vol, 0))
 			ntfs_log_perror("Warning: Failed to umount %s",
 				logfile->filename);
@@ -130,7 +130,7 @@
 		ntfs_attr_close(na);
 	if (ni && ntfs_inode_close(ni))
 		ntfs_log_perror("Warning: Failed to close $LogFile (inode %i)",
-			FILE_LogFile);
+			NTFS_FILE_LogFile);
 	if (ntfs_umount(vol, 0))
 		ntfs_log_perror("Warning: Failed to umount");

@@ -189,7 +189,7 @@
 /**
  * logfile_open
  */
-static int logfile_open(BOOL is_volume, const char *filename,
+static int logfile_open(NTFS_BOOL is_volume, const char *filename,
 		logfile_file *logfile)
 {
 	if (is_volume) {
@@ -207,17 +207,17 @@
 		if (ntfs_version_is_supported(vol))
 			device_err_exit(vol, NULL, NULL,
 					"Unsupported NTFS version.\n");
-		ni = ntfs_inode_open(vol, FILE_LogFile);
+		ni = ntfs_inode_open(vol, NTFS_FILE_LogFile);
 		if (!ni)
 			device_err_exit(vol, NULL, NULL, "Failed to "
 					"open $LogFile (inode %i): %s\n",
-					FILE_LogFile, strerror(errno));
-		na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+					NTFS_FILE_LogFile, strerror(errno));
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 		if (!na)
 			device_err_exit(vol, ni, NULL, "Failed to open "
 					"$LogFile/$DATA (attribute 0x%x):"
 					" %s\n", (unsigned int)
-					le32_to_cpu(AT_DATA), strerror(errno));
+					le32_to_cpu(NTFS_AT_DATA), strerror(errno));
 		if (!na->data_size)
 			device_err_exit(vol, ni, na, "$LogFile has zero "
 					"length.  Run chkdsk /f to correct "
@@ -279,7 +279,7 @@
 /**
  * restart_header_sanity()
  */
-static void restart_header_sanity(RESTART_PAGE_HEADER *rstr, u8 *buf)
+static void restart_header_sanity(NTFS_RESTART_PAGE_HEADER *rstr, u8 *buf)
 {
 	unsigned int usa_end_ofs, page_size;

@@ -287,7 +287,7 @@
 	if (!ntfs_is_chkd_record(rstr->magic) &&
 			sle64_to_cpu(rstr->chkdsk_lsn))
 		log_err_exit(buf, "$LogFile is corrupt:  Restart page header "
-				"magic is not CHKD but a chkdsk LSN is "
+				"magic is not CHKD but a chkdsk NTFS_LSN is "
 				"specified.  Cannot handle this yet.\n");
 	/* Both system and log page size must be >= 512 and a power of 2. */
 	page_size = le32_to_cpu(rstr->log_page_size);
@@ -316,7 +316,7 @@
 		log_err_exit(buf, "Restart page header in $LogFile is "
 				"corrupt:  Update sequence array size is "
 				"wrong.  Cannot handle this yet.\n");
-	if (le16_to_cpu(rstr->usa_ofs) < sizeof(RESTART_PAGE_HEADER))
+	if (le16_to_cpu(rstr->usa_ofs) < sizeof(NTFS_RESTART_PAGE_HEADER))
 		log_err_exit(buf, "Restart page header in $LogFile is "
 				"corrupt:  Update sequence array overlaps "
 				"restart page header.  Cannot handle this "
@@ -342,7 +342,7 @@
 /**
  * dump_restart_areas_header
  */
-static void dump_restart_areas_header(RESTART_PAGE_HEADER *rstr)
+static void dump_restart_areas_header(NTFS_RESTART_PAGE_HEADER *rstr)
 {
 	ntfs_log_info("\nRestart page header:\n");
 	ntfs_log_info("magic = %s\n", ntfs_is_rstr_record(rstr->magic) ? "RSTR" :
@@ -368,13 +368,13 @@
 /**
  * dump_restart_areas_area
  */
-static void dump_restart_areas_area(RESTART_PAGE_HEADER *rstr)
+static void dump_restart_areas_area(NTFS_RESTART_PAGE_HEADER *rstr)
 {
-	LOG_CLIENT_RECORD *lcr;
-	RESTART_AREA *ra;
+	NTFS_LOG_CLIENT_RECORD *lcr;
+	NTFS_RESTART_AREA *ra;
 	int client;

-	ra = (RESTART_AREA*)((u8*)rstr +
+	ra = (NTFS_RESTART_AREA*)((u8*)rstr +
 			le16_to_cpu(rstr->restart_area_offset));
 	ntfs_log_info("current_lsn = %lli (0x%llx)\n",
 			(long long)sle64_to_cpu(ra->current_lsn),
@@ -412,7 +412,7 @@
 	ntfs_log_info("restart_log_open_count = %u (0x%x)\n",
 			(unsigned)le32_to_cpu(ra->restart_log_open_count),
 			(unsigned)le32_to_cpu(ra->restart_log_open_count));
-	lcr = (LOG_CLIENT_RECORD*)((u8*)ra +
+	lcr = (NTFS_LOG_CLIENT_RECORD*)((u8*)ra +
 			le16_to_cpu(ra->client_array_offset));
 	for (client = 0; client < le16_to_cpu(ra->log_clients); client++) {
 		char *client_name;
@@ -460,7 +460,7 @@
 /**
  * dump_restart_areas()
  */
-static void *dump_restart_areas(RESTART_PAGE_HEADER *rstr, u8 *buf,
+static void *dump_restart_areas(NTFS_RESTART_PAGE_HEADER *rstr, u8 *buf,
 		unsigned int page_size)
 {
 	int pass = 1;
@@ -482,17 +482,17 @@
 				sle16_to_cpu(rstr->major_ver),
 				sle16_to_cpu(rstr->minor_ver));
 	else /* if (pass == 2) */ {
-		RESTART_AREA *ra;
+		NTFS_RESTART_AREA *ra;

 		/*
 		 * rstr is now the second restart page so we declare rstr1
 		 * as the first restart page as this one has been verified in
 		 * the first pass so we can use all its members safely.
 		 */
-		RESTART_PAGE_HEADER *rstr1 = (RESTART_PAGE_HEADER*)buf;
+		NTFS_RESTART_PAGE_HEADER *rstr1 = (NTFS_RESTART_PAGE_HEADER*)buf;

 		/* Exclude the usa from the comparison. */
-		ra = (RESTART_AREA*)((u8*)rstr1 +
+		ra = (NTFS_RESTART_AREA*)((u8*)rstr1 +
 				le16_to_cpu(rstr1->restart_area_offset));
 		if (!memcmp(rstr1, rstr, le16_to_cpu(rstr1->usa_ofs)) &&
 				!memcmp((u8*)rstr1 + le16_to_cpu(
@@ -524,7 +524,7 @@

 skip_rstr_pass:
 	if (pass == 1) {
-		rstr = (RESTART_PAGE_HEADER*)((u8*)rstr + page_size);
+		rstr = (NTFS_RESTART_PAGE_HEADER*)((u8*)rstr + page_size);
 		++pass;
 		goto rstr_pass_loc;
 	}
@@ -535,7 +535,7 @@
 /**
  * dump_log_records()
  */
-static void dump_log_record(LOG_RECORD *lr)
+static void dump_log_record(NTFS_LOG_RECORD *lr)
 {
 	unsigned int i;
 	ntfs_log_info("this lsn = 0x%llx\n",
@@ -560,11 +560,11 @@
 	else {
 		int _b = 0;

-		if (lr->flags & LOG_RECORD_MULTI_PAGE) {
-			ntfs_log_info(" LOG_RECORD_MULTI_PAGE");
+		if (lr->flags & NTFS_LOG_RECORD_MULTI_PAGE) {
+			ntfs_log_info(" NTFS_LOG_RECORD_MULTI_PAGE");
 			_b = 1;
 		}
-		if (lr->flags & ~LOG_RECORD_MULTI_PAGE) {
+		if (lr->flags & ~NTFS_LOG_RECORD_MULTI_PAGE) {
 			if (_b)
 				ntfs_log_info(" |");
 			ntfs_log_info(" Unknown flags");
@@ -593,16 +593,16 @@
 /**
  * dump_log_records()
  */
-static void dump_log_records(RECORD_PAGE_HEADER *rcrd, u8 *buf,
+static void dump_log_records(NTFS_RECORD_PAGE_HEADER *rcrd, u8 *buf,
 		int buf_size, unsigned int page_size)
 {
-	LOG_RECORD *lr;
+	NTFS_LOG_RECORD *lr;
 	int pass = 0;
 	int client;

 	/* Reuse pass for log area. */
 rcrd_pass_loc:
-	rcrd = (RECORD_PAGE_HEADER*)((u8*)rcrd + page_size);
+	rcrd = (NTFS_RECORD_PAGE_HEADER*)((u8*)rcrd + page_size);
 	if ((u8*)rcrd + page_size > buf + buf_size)
 		return;
 	ntfs_log_info("\nLog record page number %i", pass);
@@ -637,13 +637,13 @@
 	 * Where does the 0x40 come from? Is it just usa_offset +
 	 * usa_client * 2 + 7 & ~7 or is it derived from somewhere?
 	 */
-	lr = (LOG_RECORD*)((u8*)rcrd + 0x40);
+	lr = (NTFS_LOG_RECORD*)((u8*)rcrd + 0x40);
 	client = 0;
 	do {
 		ntfs_log_info("\nLog record %i:\n", client);
 		dump_log_record(lr);
 		client++;
-		lr = (LOG_RECORD*)((u8*)lr + 0x70);
+		lr = (NTFS_LOG_RECORD*)((u8*)lr + 0x70);
 	} while (((u8*)lr + 0x70 <= (u8*)rcrd +
 			le64_to_cpu(rcrd->header.packed.next_record_offset)));

@@ -656,8 +656,8 @@
  */
 int main(int argc, char **argv)
 {
-	RESTART_PAGE_HEADER *rstr;
-	RECORD_PAGE_HEADER *rcrd;
+	NTFS_RESTART_PAGE_HEADER *rstr;
+	NTFS_RECORD_PAGE_HEADER *rcrd;
 	unsigned int page_size;
 	int buf_size, br, err;
 	logfile_file logfile;
@@ -720,7 +720,7 @@
 	 * never seen such a large $LogFile.  Usually it is only a few MiB in
 	 * size.
 	 */
-	rstr = (RESTART_PAGE_HEADER*)buf;
+	rstr = (NTFS_RESTART_PAGE_HEADER*)buf;

 	/* Check for presence of restart area signature. */
 	if (!ntfs_is_rstr_record(rstr->magic) &&
@@ -761,7 +761,7 @@
 	/*
 	 * Dump the restart headers & areas.
 	 */
-	rcrd = (RECORD_PAGE_HEADER*)dump_restart_areas(rstr, buf, page_size);
+	rcrd = (NTFS_RECORD_PAGE_HEADER*)dump_restart_areas(rstr, buf, page_size);
 	ntfs_log_info("\n\nFinished with restart pages.  "
 		"Beginning with log pages.\n");

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsfix.c ./ntfsprogs/ntfsfix.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsfix.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsfix.c	2007-10-06 16:48:06.000000000 +0200
@@ -65,14 +65,14 @@
 #include <getopt.h>
 #endif

-#include "types.h"
-#include "attrib.h"
-#include "mft.h"
-#include "device.h"
-#include "logfile.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_mft.h"
+#include "ntfs_device.h"
+#include "ntfs_logfile.h"
 #include "utils.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 #ifdef NO_NTFS_DEVICE_DEFAULT_IO_OPS
 #	error "No default device io operations!  Cannot build ntfsfix.  \
@@ -172,9 +172,9 @@
  */
 static int OLD_ntfs_volume_set_flags(ntfs_volume *vol, const le16 flags)
 {
-	MFT_RECORD *m = NULL;
-	ATTR_RECORD *a;
-	VOLUME_INFORMATION *c;
+	NTFS_MFT_RECORD *m = NULL;
+	NTFS_ATTR_RECORD *a;
+	NTFS_VOLUME_INFORMATION *c;
 	ntfs_attr_search_ctx *ctx;
 	int ret = -1;   /* failure */

@@ -182,12 +182,12 @@
 		errno = EINVAL;
 		return -1;
 	}
-	if (ntfs_file_record_read(vol, FILE_Volume, &m, NULL)) {
+	if (ntfs_file_record_read(vol, NTFS_FILE_Volume, &m, NULL)) {
 		ntfs_log_perror("Failed to read $Volume");
 		return -1;
 	}
 	/* Sanity check */
-	if (!(m->flags & MFT_RECORD_IN_USE)) {
+	if (!(m->flags & NTFS_MFT_RECORD_IN_USE)) {
 		ntfs_log_error("$Volume has been deleted. Cannot handle this "
 				"yet. Run chkdsk to fix this.\n");
 		errno = EIO;
@@ -200,35 +200,35 @@
 				"context.\n");
 		goto err_exit;
 	}
-	if (ntfs_attr_lookup(AT_VOLUME_INFORMATION, AT_UNNAMED, 0, 0, 0, NULL,
+	if (ntfs_attr_lookup(NTFS_AT_VOLUME_INFORMATION, NTFS_AT_UNNAMED, 0, 0, 0, NULL,
 			0, ctx)) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION was not found in "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION was not found in "
 				"$Volume!\n");
 		goto err_out;
 	}
 	a = ctx->attr;
 	/* Sanity check. */
 	if (a->non_resident) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION must be resident "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION must be resident "
 				"(and it isn't)!\n");
 		errno = EIO;
 		goto err_out;
 	}
 	/* Get a pointer to the value of the attribute. */
-	c = (VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
+	c = (NTFS_VOLUME_INFORMATION*)(le16_to_cpu(a->value_offset) + (char*)a);
 	/* Sanity checks. */
 	if ((char*)c + le32_to_cpu(a->value_length) >
 			(char*)m + le32_to_cpu(m->bytes_in_use) ||
 			le16_to_cpu(a->value_offset) +
 			le32_to_cpu(a->value_length) > le32_to_cpu(a->length)) {
-		ntfs_log_error("Attribute $VOLUME_INFORMATION in $Volume is "
+		ntfs_log_error("Attribute $NTFS_VOLUME_INFORMATION in $Volume is "
 				"corrupt!\n");
 		errno = EIO;
 		goto err_out;
 	}
 	/* Set the volume flags. */
 	vol->flags = c->flags = flags;
-	if (ntfs_mft_record_write(vol, FILE_Volume, m)) {
+	if (ntfs_mft_record_write(vol, NTFS_FILE_Volume, m)) {
 		ntfs_log_perror("Error writing $Volume");
 		goto err_out;
 	}
@@ -254,7 +254,7 @@
 	 * Set chkdsk flag, i.e. mark the partition dirty so chkdsk will run
 	 * and fix it for us.
 	 */
-	flags = vol->flags | VOLUME_IS_DIRTY;
+	flags = vol->flags | NTFS_VOLUME_IS_DIRTY;
 	if (OLD_ntfs_volume_set_flags(vol, flags)) {
 		ntfs_log_info(FAILED);
 		ntfs_log_error("Error setting volume flags.\n");
@@ -291,7 +291,7 @@
 	s64 l, br;
 	unsigned char *m, *m2;
 	int i, ret = -1; /* failure */
-	BOOL done;
+	NTFS_BOOL done;

 	ntfs_log_info("\nProcessing $MFT and $MFTMirr...\n");

@@ -347,12 +347,12 @@
 	ntfs_log_info("Comparing $MFTMirr to $MFT... ");
 	done = FALSE;
 	for (i = 0; i < vol->mftmirr_size; ++i) {
-		MFT_RECORD *mrec, *mrec2;
+		NTFS_MFT_RECORD *mrec, *mrec2;
 		const char *ESTR[12] = { "$MFT", "$MFTMirr", "$LogFile",
 			"$Volume", "$AttrDef", "root directory", "$Bitmap",
 			"$Boot", "$BadClus", "$Secure", "$UpCase", "$Extend" };
 		const char *s;
-		BOOL use_mirr;
+		NTFS_BOOL use_mirr;

 		if (i < 12)
 			s = ESTR[i];
@@ -362,8 +362,8 @@
 			s = "mft record";

 		use_mirr = FALSE;
-		mrec = (MFT_RECORD*)(m + i * vol->mft_record_size);
-		if (mrec->flags & MFT_RECORD_IN_USE) {
+		mrec = (NTFS_MFT_RECORD*)(m + i * vol->mft_record_size);
+		if (mrec->flags & NTFS_MFT_RECORD_IN_USE) {
 			if (ntfs_is_baad_record(mrec->magic)) {
 				ntfs_log_info(FAILED);
 				ntfs_log_error("$MFT error: Incomplete multi "
@@ -380,8 +380,8 @@
 				goto error_exit;
 			}
 		}
-		mrec2 = (MFT_RECORD*)(m2 + i * vol->mft_record_size);
-		if (mrec2->flags & MFT_RECORD_IN_USE) {
+		mrec2 = (NTFS_MFT_RECORD*)(m2 + i * vol->mft_record_size);
+		if (mrec2->flags & NTFS_MFT_RECORD_IN_USE) {
 			if (ntfs_is_baad_record(mrec2->magic)) {
 				ntfs_log_info(FAILED);
 				ntfs_log_error("$MFTMirr error: Incomplete "
@@ -396,7 +396,7 @@
 				goto error_exit;
 			}
 			/* $MFT is corrupt but $MFTMirr is ok, use $MFTMirr. */
-			if (!(mrec->flags & MFT_RECORD_IN_USE) &&
+			if (!(mrec->flags & NTFS_MFT_RECORD_IN_USE) &&
 					!ntfs_is_mft_record(mrec->magic))
 				use_mirr = TRUE;
 		}
@@ -478,7 +478,7 @@
 	ntfs_volume *vol;
 	unsigned long mnt_flags;
 	int ret = 1; /* failure */
-	BOOL force = FALSE;
+	NTFS_BOOL force = FALSE;

 	ntfs_log_set_handler(ntfs_log_handler_outerr);

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsinfo.c ./ntfsprogs/ntfsinfo.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsinfo.c	2007-09-29 00:11:50.000000000 +0200
+++ ./ntfsprogs/ntfsinfo.c	2007-10-06 16:48:06.000000000 +0200
@@ -41,8 +41,8 @@
  *	way to output some of these attributes.
  *
  *	Still need to do:
- *	    $REPARSE_POINT/$SYMBOLIC_LINK
- *	    $LOGGED_UTILITY_STREAM
+ *	    $NTFS_REPARSE_POINT/$SYMBOLIC_LINK
+ *	    $NTFS_LOGGED_UTILITY_STREAM
  */

 #include "config.h"
@@ -66,19 +66,19 @@
 #include <errno.h>
 #endif

-#include "types.h"
-#include "mft.h"
-#include "attrib.h"
-#include "layout.h"
-#include "inode.h"
-#include "index.h"
+#include "ntfs_types.h"
+#include "ntfs_mft.h"
+#include "ntfs_attrib.h"
+#include "ntfs_layout.h"
+#include "ntfs_inode.h"
+#include "ntfs_index.h"
 #include "utils.h"
-#include "security.h"
-#include "mst.h"
-#include "dir.h"
-#include "ntfstime.h"
-#include "version.h"
-#include "support.h"
+#include "ntfs_security.h"
+#include "ntfs_mst.h"
+#include "ntfs_dir.h"
+#include "ntfs_time.h"
+#include "ntfs_version.h"
+#include "ntfs_support.h"

 static const char *EXEC_NAME = "ntfsinfo";

@@ -349,7 +349,7 @@
  *        null if cannot convert to multi-byte string. errno would contain the
  *             error id. no memory allocated in that case
  */
-static char *ntfs_attr_get_name_mbs(ATTR_RECORD *attr)
+static char *ntfs_attr_get_name_mbs(NTFS_ATTR_RECORD *attr)
 {
 	ntfschar *ucs_attr_name;
 	char *mbs_attr_name = NULL;
@@ -395,7 +395,7 @@
 			(long long)vol->data1_zone_pos);
 	printf("\tCurrent Position in Second Data Zone: %lld\n",
 			(long long)vol->data2_zone_pos);
-	printf("\tLCN of Data Attribute for FILE_MFT: %lld\n",
+	printf("\tLCN of Data Attribute for NTFS_FILE_MFT: %lld\n",
 			(long long)vol->mft_lcn);
 	printf("\tFILE_MFTMirr Size: %d\n", vol->mftmirr_size);
 	printf("\tLCN of Data Attribute for File_MFTMirr: %lld\n",
@@ -403,19 +403,19 @@
 	printf("\tSize of Attribute Definition Table: %d\n",
 			(int)vol->attrdef_len);

-	printf("FILE_Bitmap Information \n");
+	printf("NTFS_FILE_Bitmap Information \n");
 	printf("\tFILE_Bitmap MFT Record Number: %llu\n",
 			(unsigned long long)vol->lcnbmp_ni->mft_no);
-	printf("\tState of FILE_Bitmap Inode: %lu\n", vol->lcnbmp_ni->state);
+	printf("\tState of NTFS_FILE_Bitmap Inode: %lu\n", vol->lcnbmp_ni->state);
 	printf("\tLength of Attribute List: %u\n",
 			(unsigned int)vol->lcnbmp_ni->attr_list_size);
 	printf("\tAttribute List: %s\n", vol->lcnbmp_ni->attr_list);
 	printf("\tNumber of Attached Extent Inodes: %d\n",
 			(int)vol->lcnbmp_ni->nr_extents);
 	/* FIXME: need to add code for the union if nr_extens != 0, but
-	   i dont know if it will ever != 0 with FILE_Bitmap */
+	   i dont know if it will ever != 0 with NTFS_FILE_Bitmap */

-	printf("FILE_Bitmap Data Attribute Information\n");
+	printf("NTFS_FILE_Bitmap Data Attribute Information\n");
 	printf("\tDecompressed Runlist: not done yet\n");
 	printf("\tBase Inode: %llu\n",
 			(unsigned long long)vol->lcnbmp_na->ni->mft_no);
@@ -443,80 +443,80 @@
 }

 /**
- * ntfs_dump_flags - Dump flags for STANDARD_INFORMATION and FILE_NAME.
+ * ntfs_dump_flags - Dump flags for NTFS_STANDARD_INFORMATION and FILE_NAME.
  * @type:	dump flags for this attribute type
  * @flags:	flags for dumping
  */
-static void ntfs_dump_flags(const char *indent, ATTR_TYPES type, le32 flags)
+static void ntfs_dump_flags(const char *indent, NTFS_ATTR_TYPES type, le32 flags)
 {
 	printf("%sFile attributes:\t", indent);
-	if (flags & FILE_ATTR_READONLY) {
+	if (flags & NTFS_FILE_ATTR_READONLY) {
 		printf(" READONLY");
-		flags &= ~FILE_ATTR_READONLY;
+		flags &= ~NTFS_FILE_ATTR_READONLY;
 	}
-	if (flags & FILE_ATTR_HIDDEN) {
+	if (flags & NTFS_FILE_ATTR_HIDDEN) {
 		printf(" HIDDEN");
-		flags &= ~FILE_ATTR_HIDDEN;
+		flags &= ~NTFS_FILE_ATTR_HIDDEN;
 	}
-	if (flags & FILE_ATTR_SYSTEM) {
+	if (flags & NTFS_FILE_ATTR_SYSTEM) {
 		printf(" SYSTEM");
-		flags &= ~FILE_ATTR_SYSTEM;
+		flags &= ~NTFS_FILE_ATTR_SYSTEM;
 	}
-	if (flags & FILE_ATTR_DIRECTORY) {
+	if (flags & NTFS_FILE_ATTR_DIRECTORY) {
 		printf(" DIRECTORY");
-		flags &= ~FILE_ATTR_DIRECTORY;
+		flags &= ~NTFS_FILE_ATTR_DIRECTORY;
 	}
-	if (flags & FILE_ATTR_ARCHIVE) {
+	if (flags & NTFS_FILE_ATTR_ARCHIVE) {
 		printf(" ARCHIVE");
-		flags &= ~FILE_ATTR_ARCHIVE;
+		flags &= ~NTFS_FILE_ATTR_ARCHIVE;
 	}
-	if (flags & FILE_ATTR_DEVICE) {
+	if (flags & NTFS_FILE_ATTR_DEVICE) {
 		printf(" DEVICE");
-		flags &= ~FILE_ATTR_DEVICE;
+		flags &= ~NTFS_FILE_ATTR_DEVICE;
 	}
-	if (flags & FILE_ATTR_NORMAL) {
+	if (flags & NTFS_FILE_ATTR_NORMAL) {
 		printf(" NORMAL");
-		flags &= ~FILE_ATTR_NORMAL;
+		flags &= ~NTFS_FILE_ATTR_NORMAL;
 	}
-	if (flags & FILE_ATTR_TEMPORARY) {
+	if (flags & NTFS_FILE_ATTR_TEMPORARY) {
 		printf(" TEMPORARY");
-		flags &= ~FILE_ATTR_TEMPORARY;
+		flags &= ~NTFS_FILE_ATTR_TEMPORARY;
 	}
-	if (flags & FILE_ATTR_SPARSE_FILE) {
+	if (flags & NTFS_FILE_ATTR_SPARSE_FILE) {
 		printf(" SPARSE_FILE");
-		flags &= ~FILE_ATTR_SPARSE_FILE;
+		flags &= ~NTFS_FILE_ATTR_SPARSE_FILE;
 	}
-	if (flags & FILE_ATTR_REPARSE_POINT) {
-		printf(" REPARSE_POINT");
-		flags &= ~FILE_ATTR_REPARSE_POINT;
+	if (flags & NTFS_FILE_ATTR_REPARSE_POINT) {
+		printf(" NTFS_REPARSE_POINT");
+		flags &= ~NTFS_FILE_ATTR_REPARSE_POINT;
 	}
-	if (flags & FILE_ATTR_COMPRESSED) {
+	if (flags & NTFS_FILE_ATTR_COMPRESSED) {
 		printf(" COMPRESSED");
-		flags &= ~FILE_ATTR_COMPRESSED;
+		flags &= ~NTFS_FILE_ATTR_COMPRESSED;
 	}
-	if (flags & FILE_ATTR_OFFLINE) {
+	if (flags & NTFS_FILE_ATTR_OFFLINE) {
 		printf(" OFFLINE");
-		flags &= ~FILE_ATTR_OFFLINE;
+		flags &= ~NTFS_FILE_ATTR_OFFLINE;
 	}
-	if (flags & FILE_ATTR_NOT_CONTENT_INDEXED) {
+	if (flags & NTFS_FILE_ATTR_NOT_CONTENT_INDEXED) {
 		printf(" NOT_CONTENT_INDEXED");
-		flags &= ~FILE_ATTR_NOT_CONTENT_INDEXED;
+		flags &= ~NTFS_FILE_ATTR_NOT_CONTENT_INDEXED;
 	}
-	if (flags & FILE_ATTR_ENCRYPTED) {
+	if (flags & NTFS_FILE_ATTR_ENCRYPTED) {
 		printf(" ENCRYPTED");
-		flags &= ~FILE_ATTR_ENCRYPTED;
+		flags &= ~NTFS_FILE_ATTR_ENCRYPTED;
 	}
-	/* We know that FILE_ATTR_I30_INDEX_PRESENT only exists on $FILE_NAME,
+	/* We know that NTFS_FILE_ATTR_I30_INDEX_PRESENT only exists on $FILE_NAME,
 	   and in case we are wrong, let it appear as UNKNOWN */
-	if (type == AT_FILE_NAME) {
-		if (flags & FILE_ATTR_I30_INDEX_PRESENT) {
+	if (type == NTFS_AT_FILE_NAME) {
+		if (flags & NTFS_FILE_ATTR_I30_INDEX_PRESENT) {
 			printf(" I30_INDEX");
-			flags &= ~FILE_ATTR_I30_INDEX_PRESENT;
+			flags &= ~NTFS_FILE_ATTR_I30_INDEX_PRESENT;
 		}
 	}
-	if (flags & FILE_ATTR_VIEW_INDEX_PRESENT) {
+	if (flags & NTFS_FILE_ATTR_VIEW_INDEX_PRESENT) {
 		printf(" VIEW_INDEX");
-		flags &= ~FILE_ATTR_VIEW_INDEX_PRESENT;
+		flags &= ~NTFS_FILE_ATTR_VIEW_INDEX_PRESENT;
 	}
 	if (flags)
 		printf(" UNKNOWN: 0x%08x", (unsigned int)le32_to_cpu(flags));
@@ -533,16 +533,16 @@

 	/* name space */
 	switch (file_name_type) {
-	case FILE_NAME_POSIX:
+	case NTFS_FILE_NAME_POSIX:
 		mbs_file_type = "POSIX";
 		break;
-	case FILE_NAME_WIN32:
+	case NTFS_FILE_NAME_WIN32:
 		mbs_file_type = "Win32";
 		break;
-	case FILE_NAME_DOS:
+	case NTFS_FILE_NAME_DOS:
 		mbs_file_type = "DOS";
 		break;
-	case FILE_NAME_WIN32_AND_DOS:
+	case NTFS_FILE_NAME_WIN32_AND_DOS:
 		mbs_file_type = "Win32 & DOS";
 		break;
 	default:
@@ -555,12 +555,12 @@
 /**
  * ntfs_dump_standard_information
  */
-static void ntfs_dump_attr_standard_information(ATTR_RECORD *attr)
+static void ntfs_dump_attr_standard_information(NTFS_ATTR_RECORD *attr)
 {
-	STANDARD_INFORMATION *standard_attr = NULL;
+	NTFS_STANDARD_INFORMATION *standard_attr = NULL;
 	u32 value_length;

-	standard_attr = (STANDARD_INFORMATION*)((char *)attr +
+	standard_attr = (NTFS_STANDARD_INFORMATION*)((char *)attr +
 		le16_to_cpu(attr->value_offset));

 	/* time conversion stuff */
@@ -610,7 +610,7 @@
 				(unsigned long long)
 				le64_to_cpu(standard_attr->usn));
 	} else {
-		printf("\tSize of STANDARD_INFORMATION is %u (0x%x).  It "
+		printf("\tSize of NTFS_STANDARD_INFORMATION is %u (0x%x).  It "
 				"should be either 72 or 48, something is "
 				"wrong...\n", (unsigned int)value_length,
 				(unsigned)value_length);
@@ -629,9 +629,9 @@
 /**
  * ntfs_dump_attr_list()
  */
-static void ntfs_dump_attr_list(ATTR_RECORD *attr, ntfs_volume *vol)
+static void ntfs_dump_attr_list(NTFS_ATTR_RECORD *attr, ntfs_volume *vol)
 {
-	ATTR_LIST_ENTRY *entry;
+	NTFS_ATTR_LIST_ENTRY *entry;
 	u8 *value;
 	s64 l;

@@ -654,8 +654,8 @@
 		return;
 	}
 	printf("\tDumping attribute list:");
-	entry = (ATTR_LIST_ENTRY *) value;
-	for (;(u8 *)entry < (u8 *) value + l; entry = (ATTR_LIST_ENTRY *)
+	entry = (NTFS_ATTR_LIST_ENTRY *) value;
+	for (;(u8 *)entry < (u8 *) value + l; entry = (NTFS_ATTR_LIST_ENTRY *)
 				((u8 *) entry + le16_to_cpu(entry->length))) {
 		printf("\n");
 		printf("\t\tAttribute type:\t0x%x\n",
@@ -669,15 +669,15 @@
 		printf("\t\tName offset:\t%u (0x%x)\n",
 				(unsigned)entry->name_offset,
 				(unsigned)entry->name_offset);
-		printf("\t\tStarting VCN:\t%lld (0x%llx)\n",
+		printf("\t\tStarting NTFS_VCN:\t%lld (0x%llx)\n",
 				(long long)sle64_to_cpu(entry->lowest_vcn),
 				(unsigned long long)
 				sle64_to_cpu(entry->lowest_vcn));
 		printf("\t\tMFT reference:\t%lld (0x%llx)\n",
 				(unsigned long long)
-				MREF_LE(entry->mft_reference),
+				NTFS_MREF_LE(entry->mft_reference),
 				(unsigned long long)
-				MREF_LE(entry->mft_reference));
+				NTFS_MREF_LE(entry->mft_reference));
 		printf("\t\tInstance:\t%u (0x%x)\n",
 				(unsigned)le16_to_cpu(entry->instance),
 				(unsigned)le16_to_cpu(entry->instance));
@@ -710,11 +710,11 @@
  * ntfs_dump_filename()
  */
 static void ntfs_dump_filename(const char *indent,
-		FILE_NAME_ATTR *file_name_attr)
+		NTFS_FILE_NAME_ATTR *file_name_attr)
 {
 	printf("%sParent directory:\t %lld (0x%llx)\n", indent,
-			(long long)MREF_LE(file_name_attr->parent_directory),
-			(long long)MREF_LE(file_name_attr->parent_directory));
+			(long long)NTFS_MREF_LE(file_name_attr->parent_directory),
+			(long long)NTFS_MREF_LE(file_name_attr->parent_directory));
 	/* time stuff */
 	if (!opts.notime) {
 		char *ntfs_time_str;
@@ -747,8 +747,8 @@
 	printf("%sFilename Length:\t %d (0x%x)\n", indent,
 			(unsigned)file_name_attr->file_name_length,
 			(unsigned)file_name_attr->file_name_length);
-	ntfs_dump_flags(indent, AT_FILE_NAME, file_name_attr->file_attributes);
-	if (file_name_attr->file_attributes & FILE_ATTR_REPARSE_POINT &&
+	ntfs_dump_flags(indent, NTFS_AT_FILE_NAME, file_name_attr->file_attributes);
+	if (file_name_attr->file_attributes & NTFS_FILE_ATTR_REPARSE_POINT &&
 			file_name_attr->reparse_point_tag)
 		printf("%sReparse point tag:\t 0x%x\n", indent, (unsigned)
 				le32_to_cpu(file_name_attr->reparse_point_tag));
@@ -790,9 +790,9 @@
 /**
  * ntfs_dump_attr_file_name()
  */
-static void ntfs_dump_attr_file_name(ATTR_RECORD *attr)
+static void ntfs_dump_attr_file_name(NTFS_ATTR_RECORD *attr)
 {
-	ntfs_dump_filename("\t", (FILE_NAME_ATTR*)((u8*)attr +
+	ntfs_dump_filename("\t", (NTFS_FILE_NAME_ATTR*)((u8*)attr +
 			le16_to_cpu(attr->value_offset)));
 }

@@ -801,11 +801,11 @@
  *
  * dump the $OBJECT_ID attribute - not present on all systems
  */
-static void ntfs_dump_attr_object_id(ATTR_RECORD *attr,ntfs_volume *vol)
+static void ntfs_dump_attr_object_id(NTFS_ATTR_RECORD *attr,ntfs_volume *vol)
 {
-	OBJECT_ID_ATTR *obj_id_attr = NULL;
+	NTFS_OBJECT_ID_ATTR *obj_id_attr = NULL;

-	obj_id_attr = (OBJECT_ID_ATTR *)((u8*)attr +
+	obj_id_attr = (NTFS_OBJECT_ID_ATTR *)((u8*)attr +
 			le16_to_cpu(attr->value_offset));

 	if (vol->major_ver >= 3.0) {
@@ -819,7 +819,7 @@
 		printf("\tObject ID:\t\t %s\n", printable_GUID);

 		/* Dump Birth Volume ID. */
-		if ((value_length > sizeof(GUID)) && !ntfs_guid_is_zero(
+		if ((value_length > sizeof(NTFS_GUID)) && !ntfs_guid_is_zero(
 				&obj_id_attr->birth_volume_id)) {
 			ntfs_guid_to_mbs(&obj_id_attr->birth_volume_id,
 					printable_GUID);
@@ -828,7 +828,7 @@
 			printf("\tBirth Volume ID:\t missing\n");

 		/* Dumping Birth Object ID */
-		if ((value_length > sizeof(GUID)) && !ntfs_guid_is_zero(
+		if ((value_length > sizeof(NTFS_GUID)) && !ntfs_guid_is_zero(
 				&obj_id_attr->birth_object_id)) {
 			ntfs_guid_to_mbs(&obj_id_attr->birth_object_id,
 					printable_GUID);
@@ -837,7 +837,7 @@
 			printf("\tBirth Object ID:\t missing\n");

 		/* Dumping Domain_id - reserved for now */
-		if ((value_length > sizeof(GUID)) && !ntfs_guid_is_zero(
+		if ((value_length > sizeof(NTFS_GUID)) && !ntfs_guid_is_zero(
 				&obj_id_attr->domain_id)) {
 			ntfs_guid_to_mbs(&obj_id_attr->domain_id,
 					printable_GUID);
@@ -855,11 +855,11 @@
  *
  * given an acl, print it in a beautiful & lovely way.
  */
-static void ntfs_dump_acl(const char *prefix, ACL *acl)
+static void ntfs_dump_acl(const char *prefix, NTFS_ACL *acl)
 {
 	unsigned int i;
 	u16 ace_count;
-	ACCESS_ALLOWED_ACE *ace;
+	NTFS_ACCESS_ALLOWED_ACE *ace;

 	printf("%sRevision\t %u\n", prefix, acl->revision);

@@ -870,7 +870,7 @@
 	ace_count = le16_to_cpu(acl->ace_count);

 	/* initialize 'ace' to the first ace (if any) */
-	ace = (ACCESS_ALLOWED_ACE *)((char *)acl + 8);
+	ace = (NTFS_ACCESS_ALLOWED_ACE *)((char *)acl + 8);

 	/* iterate through ACE's */
 	for (i = 1; i <= ace_count; i++) {
@@ -879,13 +879,13 @@

 		/* set ace_type. */
 		switch (ace->type) {
-		case ACCESS_ALLOWED_ACE_TYPE:
+		case NTFS_ACCESS_ALLOWED_ACE_TYPE:
 			ace_type = "allow";
 			break;
-		case ACCESS_DENIED_ACE_TYPE:
+		case NTFS_ACCESS_DENIED_ACE_TYPE:
 			ace_type = "deny";
 			break;
-		case SYSTEM_AUDIT_ACE_TYPE:
+		case NTFS_SYSTEM_AUDIT_ACE_TYPE:
 			ace_type = "audit";
 			break;
 		default:
@@ -896,19 +896,19 @@
 		printf("%sACE:\t\t type:%s  flags:0x%x  access:0x%x\n", prefix,
 			ace_type, (unsigned int)ace->flags,
 			(unsigned int)le32_to_cpu(ace->mask));
-		/* get a SID string */
+		/* get a NTFS_SID string */
 		sid = ntfs_sid_to_mbs(&ace->sid, NULL, 0);
-		printf("%s\t\t SID: %s\n", prefix, sid);
+		printf("%s\t\t NTFS_SID: %s\n", prefix, sid);
 		free(sid);

 		/* proceed to next ACE */
-		ace = (ACCESS_ALLOWED_ACE *)(((char *)ace) +
+		ace = (NTFS_ACCESS_ALLOWED_ACE *)(((char *)ace) +
 				le16_to_cpu(ace->size));
 	}
 }


-static void ntfs_dump_security_descriptor(SECURITY_DESCRIPTOR_ATTR *sec_desc,
+static void ntfs_dump_security_descriptor(NTFS_SECURITY_DESCRIPTOR_ATTR *sec_desc,
 					  const char *indent)
 {
 	char *sid;
@@ -919,11 +919,11 @@
 	printf("%s\tControl:\t\t 0x%04x\n", indent,
 			le16_to_cpu(sec_desc->control));

-	if (~sec_desc->control & SE_SELF_RELATIVE) {
-		SECURITY_DESCRIPTOR *sd = (SECURITY_DESCRIPTOR *)sec_desc;
+	if (~sec_desc->control & NTFS_SE_SELF_RELATIVE) {
+		NTFS_SECURITY_DESCRIPTOR *sd = (NTFS_SECURITY_DESCRIPTOR *)sec_desc;

-		printf("%s\tOwner SID pointer:\t %p\n", indent, sd->owner);
-		printf("%s\tGroup SID pointer:\t %p\n", indent, sd->group);
+		printf("%s\tOwner NTFS_SID pointer:\t %p\n", indent, sd->owner);
+		printf("%s\tGroup NTFS_SID pointer:\t %p\n", indent, sd->group);
 		printf("%s\tSACL pointer:\t\t %p\n", indent, sd->sacl);
 		printf("%s\tDACL pointer:\t\t %p\n", indent, sd->dacl);

@@ -931,42 +931,42 @@
 	}

 	if (sec_desc->owner) {
-		sid = ntfs_sid_to_mbs((SID *)((char *)sec_desc +
+		sid = ntfs_sid_to_mbs((NTFS_SID *)((char *)sec_desc +
 			le32_to_cpu(sec_desc->owner)), NULL, 0);
-		printf("%s\tOwner SID:\t\t %s\n", indent, sid);
+		printf("%s\tOwner NTFS_SID:\t\t %s\n", indent, sid);
 		free(sid);
 	} else
-		printf("%s\tOwner SID:\t\t missing\n", indent);
+		printf("%s\tOwner NTFS_SID:\t\t missing\n", indent);

 	if (sec_desc->group) {
-		sid = ntfs_sid_to_mbs((SID *)((char *)sec_desc +
+		sid = ntfs_sid_to_mbs((NTFS_SID *)((char *)sec_desc +
 			le32_to_cpu(sec_desc->group)), NULL, 0);
-		printf("%s\tGroup SID:\t\t %s\n", indent, sid);
+		printf("%s\tGroup NTFS_SID:\t\t %s\n", indent, sid);
 		free(sid);
 	} else
-		printf("%s\tGroup SID:\t\t missing\n", indent);
+		printf("%s\tGroup NTFS_SID:\t\t missing\n", indent);

-	printf("%s\tSystem ACL:\t\t ", indent);
-	if (sec_desc->control & SE_SACL_PRESENT) {
-		if (sec_desc->control & SE_SACL_DEFAULTED) {
+	printf("%s\tSystem NTFS_ACL:\t\t ", indent);
+	if (sec_desc->control & NTFS_SE_SACL_PRESENT) {
+		if (sec_desc->control & NTFS_SE_SACL_DEFAULTED) {
 			printf("defaulted");
 		}
 		printf("\n");
 		ntfs_dump_acl(indent ? "\t\t\t" : "\t\t",
-			      (ACL *)((char *)sec_desc +
+			      (NTFS_ACL *)((char *)sec_desc +
 				      le32_to_cpu(sec_desc->sacl)));
 	} else {
 		printf("missing\n");
 	}

-	printf("%s\tDiscretionary ACL:\t ", indent);
-	if (sec_desc->control & SE_DACL_PRESENT) {
-		if (sec_desc->control & SE_SACL_DEFAULTED) {
+	printf("%s\tDiscretionary NTFS_ACL:\t ", indent);
+	if (sec_desc->control & NTFS_SE_DACL_PRESENT) {
+		if (sec_desc->control & NTFS_SE_SACL_DEFAULTED) {
 			printf("defaulted");
 		}
 		printf("\n");
 		ntfs_dump_acl(indent ? "\t\t\t" : "\t\t",
-			      (ACL *)((char *)sec_desc +
+			      (NTFS_ACL *)((char *)sec_desc +
 				      le32_to_cpu(sec_desc->dacl)));
 	} else {
 		printf("missing\n");
@@ -978,13 +978,13 @@
  *
  * dump the security information about the file
  */
-static void ntfs_dump_attr_security_descriptor(ATTR_RECORD *attr, ntfs_volume *vol)
+static void ntfs_dump_attr_security_descriptor(NTFS_ATTR_RECORD *attr, ntfs_volume *vol)
 {
-	SECURITY_DESCRIPTOR_ATTR *sec_desc_attr;
+	NTFS_SECURITY_DESCRIPTOR_ATTR *sec_desc_attr;

 	if (attr->non_resident) {
 		/* FIXME: We don't handle fragmented mapping pairs case. */
-		runlist *rl = ntfs_mapping_pairs_decompress(vol, attr, NULL);
+		ntfs_runlist *rl = ntfs_mapping_pairs_decompress(vol, attr, NULL);
 		if (rl) {
 			s64 data_size, bytes_read;

@@ -1006,11 +1006,11 @@
 			free(rl);
 		} else {
 			ntfs_log_error("ntfsinfo error: could not "
-						"decompress runlist\n");
+						"decompress ntfs_runlist\n");
 			return;
 		}
 	} else {
-		sec_desc_attr = (SECURITY_DESCRIPTOR_ATTR *)((u8*)attr +
+		sec_desc_attr = (NTFS_SECURITY_DESCRIPTOR_ATTR *)((u8*)attr +
 				le16_to_cpu(attr->value_offset));
 	}

@@ -1025,7 +1025,7 @@
  *
  * dump the name of the volume the inode belongs to
  */
-static void ntfs_dump_attr_volume_name(ATTR_RECORD *attr)
+static void ntfs_dump_attr_volume_name(NTFS_ATTR_RECORD *attr)
 {
 	ntfschar *ucs_vol_name = NULL;

@@ -1057,50 +1057,50 @@
  * dump the information for the volume the inode belongs to
  *
  */
-static void ntfs_dump_attr_volume_information(ATTR_RECORD *attr)
+static void ntfs_dump_attr_volume_information(NTFS_ATTR_RECORD *attr)
 {
-	VOLUME_INFORMATION *vol_information = NULL;
+	NTFS_VOLUME_INFORMATION *vol_information = NULL;

-	vol_information = (VOLUME_INFORMATION*)((char *)attr+
+	vol_information = (NTFS_VOLUME_INFORMATION*)((char *)attr+
 		le16_to_cpu(attr->value_offset));

 	printf("\tVolume Version:\t\t %d.%d\n", vol_information->major_ver,
 		vol_information->minor_ver);
 	printf("\tVolume Flags:\t\t ");
-	if (vol_information->flags & VOLUME_IS_DIRTY)
+	if (vol_information->flags & NTFS_VOLUME_IS_DIRTY)
 		printf("DIRTY ");
-	if (vol_information->flags & VOLUME_RESIZE_LOG_FILE)
+	if (vol_information->flags & NTFS_VOLUME_RESIZE_LOG_FILE)
 		printf("RESIZE_LOG ");
-	if (vol_information->flags & VOLUME_UPGRADE_ON_MOUNT)
+	if (vol_information->flags & NTFS_VOLUME_UPGRADE_ON_MOUNT)
 		printf("UPG_ON_MOUNT ");
-	if (vol_information->flags & VOLUME_MOUNTED_ON_NT4)
+	if (vol_information->flags & NTFS_VOLUME_MOUNTED_ON_NT4)
 		printf("MOUNTED_NT4 ");
-	if (vol_information->flags & VOLUME_DELETE_USN_UNDERWAY)
+	if (vol_information->flags & NTFS_VOLUME_DELETE_USN_UNDERWAY)
 		printf("DEL_USN ");
-	if (vol_information->flags & VOLUME_REPAIR_OBJECT_ID)
+	if (vol_information->flags & NTFS_VOLUME_REPAIR_OBJECT_ID)
 		printf("REPAIR_OBJID ");
-	if (vol_information->flags & VOLUME_CHKDSK_UNDERWAY)
+	if (vol_information->flags & NTFS_VOLUME_CHKDSK_UNDERWAY)
 		printf("CHKDSK_UNDERWAY ");
-	if (vol_information->flags & VOLUME_MODIFIED_BY_CHKDSK)
+	if (vol_information->flags & NTFS_VOLUME_MODIFIED_BY_CHKDSK)
 		printf("MOD_BY_CHKDSK ");
-	if (vol_information->flags & VOLUME_FLAGS_MASK) {
+	if (vol_information->flags & NTFS_VOLUME_FLAGS_MASK) {
 		printf("(0x%04x)\n",
 				(unsigned)le16_to_cpu(vol_information->flags));
 	} else
 		printf("none set (0x0000)\n");
-	if (vol_information->flags & (~VOLUME_FLAGS_MASK))
+	if (vol_information->flags & (~NTFS_VOLUME_FLAGS_MASK))
 		printf("\t\t\t\t Unknown Flags: 0x%04x\n",
 				le16_to_cpu(vol_information->flags &
-					(~VOLUME_FLAGS_MASK)));
+					(~NTFS_VOLUME_FLAGS_MASK)));
 }

 static ntfschar NTFS_DATA_SDS[5] = { const_cpu_to_le16('$'),
 	const_cpu_to_le16('S'), const_cpu_to_le16('D'),
 	const_cpu_to_le16('S'), const_cpu_to_le16('\0') };

-static void ntfs_dump_sds_entry(SECURITY_DESCRIPTOR_HEADER *sds)
+static void ntfs_dump_sds_entry(NTFS_SECURITY_DESCRIPTOR_HEADER *sds)
 {
-	SECURITY_DESCRIPTOR_RELATIVE *sd;
+	NTFS_SECURITY_DESCRIPTOR_RELATIVE *sd;

 	ntfs_log_verbose("\n");
 	ntfs_log_verbose("\t\tHash:\t\t\t 0x%08x\n",
@@ -1115,15 +1115,15 @@
 			(unsigned)le32_to_cpu(sds->length),
 			(unsigned)le32_to_cpu(sds->length));

-	sd = (SECURITY_DESCRIPTOR_RELATIVE *)((char *)sds +
-		sizeof(SECURITY_DESCRIPTOR_HEADER));
+	sd = (NTFS_SECURITY_DESCRIPTOR_RELATIVE *)((char *)sds +
+		sizeof(NTFS_SECURITY_DESCRIPTOR_HEADER));

 	ntfs_dump_security_descriptor(sd, "\t");
 }

-static void ntfs_dump_sds(ATTR_RECORD *attr, ntfs_inode *ni)
+static void ntfs_dump_sds(NTFS_ATTR_RECORD *attr, ntfs_inode *ni)
 {
-	SECURITY_DESCRIPTOR_HEADER *sds, *sd;
+	NTFS_SECURITY_DESCRIPTOR_HEADER *sds, *sd;
 	ntfschar *name;
 	int name_len;
 	s64 data_size;
@@ -1132,7 +1132,7 @@
 	inode = ni->mft_no;
 	if (ni->nr_extents < 0)
 		inode = ni->base_ni->mft_no;
-	if (FILE_Secure != inode)
+	if (NTFS_FILE_Secure != inode)
 		return;

 	name_len = attr->name_length;
@@ -1144,7 +1144,7 @@
 				  name, name_len, 0, NULL, 0))
 		return;

-	sd = sds = ntfs_attr_readall(ni, AT_DATA, name, name_len, &data_size);
+	sd = sds = ntfs_attr_readall(ni, NTFS_AT_DATA, name, name_len, &data_size);
 	if (!sd) {
 		ntfs_log_perror("Failed to read $SDS attribute");
 		return;
@@ -1159,7 +1159,7 @@
 	       le64_to_cpu(sd->offset) +
 			le32_to_cpu(sd->length) < (u64)data_size) {
 		ntfs_dump_sds_entry(sd);
-		sd = (SECURITY_DESCRIPTOR_HEADER *)((char*)sd +
+		sd = (NTFS_SECURITY_DESCRIPTOR_HEADER *)((char*)sd +
 				((le32_to_cpu(sd->length) + 15) & ~15));
 	}
 	free(sds);
@@ -1168,44 +1168,44 @@
 static const char *get_attribute_type_name(le32 type)
 {
 	switch (type) {
-	case AT_UNUSED:			return "$UNUSED";
-	case AT_STANDARD_INFORMATION:   return "$STANDARD_INFORMATION";
-	case AT_ATTRIBUTE_LIST:         return "$ATTRIBUTE_LIST";
-	case AT_FILE_NAME:              return "$FILE_NAME";
-	case AT_OBJECT_ID:              return "$OBJECT_ID";
-	case AT_SECURITY_DESCRIPTOR:    return "$SECURITY_DESCRIPTOR";
-	case AT_VOLUME_NAME:            return "$VOLUME_NAME";
-	case AT_VOLUME_INFORMATION:     return "$VOLUME_INFORMATION";
-	case AT_DATA:                   return "$DATA";
-	case AT_INDEX_ROOT:             return "$INDEX_ROOT";
-	case AT_INDEX_ALLOCATION:       return "$INDEX_ALLOCATION";
-	case AT_BITMAP:                 return "$BITMAP";
-	case AT_REPARSE_POINT:          return "$REPARSE_POINT";
-	case AT_EA_INFORMATION:         return "$EA_INFORMATION";
-	case AT_EA:                     return "$EA";
-	case AT_PROPERTY_SET:           return "$PROPERTY_SET";
-	case AT_LOGGED_UTILITY_STREAM:  return "$LOGGED_UTILITY_STREAM";
-	case AT_END:                    return "$END";
+	case NTFS_AT_UNUSED:			return "$UNUSED";
+	case NTFS_AT_STANDARD_INFORMATION:   return "$NTFS_STANDARD_INFORMATION";
+	case NTFS_AT_ATTRIBUTE_LIST:         return "$ATTRIBUTE_LIST";
+	case NTFS_AT_FILE_NAME:              return "$FILE_NAME";
+	case NTFS_AT_OBJECT_ID:              return "$OBJECT_ID";
+	case NTFS_AT_SECURITY_DESCRIPTOR:    return "$NTFS_SECURITY_DESCRIPTOR";
+	case NTFS_AT_VOLUME_NAME:            return "$NTFS_VOLUME_NAME";
+	case NTFS_AT_VOLUME_INFORMATION:     return "$NTFS_VOLUME_INFORMATION";
+	case NTFS_AT_DATA:                   return "$DATA";
+	case NTFS_AT_INDEX_ROOT:             return "$NTFS_INDEX_ROOT";
+	case NTFS_AT_INDEX_ALLOCATION:       return "$NTFS_INDEX_ALLOCATION";
+	case NTFS_AT_BITMAP:                 return "$BITMAP";
+	case NTFS_AT_REPARSE_POINT:          return "$NTFS_REPARSE_POINT";
+	case NTFS_AT_EA_INFORMATION:         return "$NTFS_EA_INFORMATION";
+	case NTFS_AT_EA:                     return "$EA";
+	case NTFS_AT_PROPERTY_SET:           return "$NTFS_PROPERTY_SET";
+	case NTFS_AT_LOGGED_UTILITY_STREAM:  return "$NTFS_LOGGED_UTILITY_STREAM";
+	case NTFS_AT_END:                    return "$END";
 	}

 	return "$UNKNOWN";
 }

-static const char * ntfs_dump_lcn(LCN lcn)
+static const char * ntfs_dump_lcn(NTFS_LCN lcn)
 {
 	switch (lcn) {
-		case LCN_HOLE:
+		case NTFS_LCN_HOLE:
 			return "<HOLE>\t";
-		case LCN_RL_NOT_MAPPED:
+		case NTFS_LCN_RL_NOT_MAPPED:
 			return "<RL_NOT_MAPPED>";
-		case LCN_ENOENT:
+		case NTFS_LCN_ENOENT:
 			return "<ENOENT>\t";
-		case LCN_EINVAL:
+		case NTFS_LCN_EINVAL:
 			return "<EINVAL>\t";
-		case LCN_EIO:
+		case NTFS_LCN_EIO:
 			return "<EIO>\t";
 		default:
-			ntfs_log_error("Invalid LCN value %llx passed to "
+			ntfs_log_error("Invalid NTFS_LCN value %llx passed to "
 					"ntfs_dump_lcn().\n", lcn);
 			return "???\t";
 	}
@@ -1214,7 +1214,7 @@
 static void ntfs_dump_attribute_header(ntfs_attr_search_ctx *ctx,
 		ntfs_volume *vol)
 {
-	ATTR_RECORD *a = ctx->attr;
+	NTFS_ATTR_RECORD *a = ctx->attr;

 	printf("Dumping attribute %s (0x%x) from mft record %lld (0x%llx)\n",
 			get_attribute_type_name(a->type),
@@ -1268,10 +1268,10 @@
 	}

 	/* Non-resident attribute */
-	ntfs_log_verbose("\tLowest VCN\t\t %lld (0x%llx)\n",
+	ntfs_log_verbose("\tLowest NTFS_VCN\t\t %lld (0x%llx)\n",
 			(long long)sle64_to_cpu(a->lowest_vcn),
 			(unsigned long long)sle64_to_cpu(a->lowest_vcn));
-	ntfs_log_verbose("\tHighest VCN:\t\t %lld (0x%llx)\n",
+	ntfs_log_verbose("\tHighest NTFS_VCN:\t\t %lld (0x%llx)\n",
 			(long long)sle64_to_cpu(a->highest_vcn),
 			(unsigned long long)sle64_to_cpu(a->highest_vcn));
 	ntfs_log_verbose("\tMapping pairs offset:\t %u (0x%x)\n",
@@ -1294,8 +1294,8 @@
 				(long long)sle64_to_cpu(a->initialized_size),
 				(unsigned long long)
 				sle64_to_cpu(a->initialized_size));
-		if (a->compression_unit || a->flags & ATTR_IS_COMPRESSED ||
-				a->flags & ATTR_IS_SPARSE)
+		if (a->compression_unit || a->flags & NTFS_ATTR_IS_COMPRESSED ||
+				a->flags & NTFS_ATTR_IS_SPARSE)
 			printf("\tCompressed size:\t %llu (0x%llx)\n",
 					(signed long long)
 					sle64_to_cpu(a->compressed_size),
@@ -1304,11 +1304,11 @@
 	}

 	if (opts.verbose) {
-		runlist *rl;
+		ntfs_runlist *rl;

 		rl = ntfs_mapping_pairs_decompress(vol, a, NULL);
 		if (rl) {
-			runlist *rlc = rl;
+			ntfs_runlist *rlc = rl;

 			// TODO: Switch this to properly aligned hex...
 			printf("\tRunlist:\tVCN\t\tLCN\t\tLength\n");
@@ -1326,7 +1326,7 @@
 			}
 			free(rl);
 		} else
-			ntfs_log_error("Error: couldn't decompress runlist\n");
+			ntfs_log_error("Error: couldn't decompress ntfs_runlist\n");
 	}
 }

@@ -1335,7 +1335,7 @@
  *
  * dump some info about the data attribute if it's metadata
  */
-static void ntfs_dump_attr_data(ATTR_RECORD *attr, ntfs_inode *ni)
+static void ntfs_dump_attr_data(NTFS_ATTR_RECORD *attr, ntfs_inode *ni)
 {
 	if (opts.verbose)
 		ntfs_dump_sds(attr, ni);
@@ -1352,7 +1352,7 @@
 	INDEX_ATTR_QUOTA_Q,
 } INDEX_ATTR_TYPE;

-static void ntfs_dump_index_key(INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
+static void ntfs_dump_index_key(NTFS_INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
 {
 	char *sid;
 	char printable_GUID[37];
@@ -1376,7 +1376,7 @@
 		break;
 	case INDEX_ATTR_OBJID_O:
 		ntfs_guid_to_mbs(&entry->key.object_id, printable_GUID);
-		ntfs_log_verbose("\t\tKey GUID:\t\t %s\n", printable_GUID);
+		ntfs_log_verbose("\t\tKey NTFS_GUID:\t\t %s\n", printable_GUID);
 		break;
 	case INDEX_ATTR_REPARSE_R:
 		ntfs_log_verbose("\t\tKey reparse tag:\t 0x%08x\n", (unsigned)
@@ -1389,7 +1389,7 @@
 		break;
 	case INDEX_ATTR_QUOTA_O:
 		sid = ntfs_sid_to_mbs(&entry->key.sid, NULL, 0);
-		ntfs_log_verbose("\t\tKey SID:\t\t %s\n", sid);
+		ntfs_log_verbose("\t\tKey NTFS_SID:\t\t %s\n", sid);
 		free(sid);
 		break;
 	case INDEX_ATTR_QUOTA_Q:
@@ -1405,13 +1405,13 @@
 }

 typedef union {
-	SII_INDEX_DATA sii;		/* $SII index data in $Secure */
-	SDH_INDEX_DATA sdh;		/* $SDH index data in $Secure */
-	QUOTA_O_INDEX_DATA quota_o;	/* $O index data in $Quota    */
-	QUOTA_CONTROL_ENTRY quota_q;	/* $Q index data in $Quota    */
+	NTFS_SII_INDEX_DATA sii;		/* $SII index data in $Secure */
+	NTFS_SDH_INDEX_DATA sdh;		/* $SDH index data in $Secure */
+	NTFS_QUOTA_O_INDEX_DATA quota_o;	/* $O index data in $Quota    */
+	NTFS_QUOTA_CONTROL_ENTRY quota_q;	/* $Q index data in $Quota    */
 } __attribute__((__packed__)) INDEX_ENTRY_DATA;

-static void ntfs_dump_index_data(INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
+static void ntfs_dump_index_data(NTFS_INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
 {
 	INDEX_ENTRY_DATA *data;

@@ -1452,27 +1452,27 @@
 				(unsigned)le32_to_cpu(data->sdh.reserved_II));
 		break;
 	case INDEX_ATTR_OBJID_O: {
-		OBJ_ID_INDEX_DATA *object_id_data;
+		NTFS_OBJ_ID_INDEX_DATA *object_id_data;
 		char printable_GUID[37];

-		object_id_data = (OBJ_ID_INDEX_DATA*)((u8*)entry +
+		object_id_data = (NTFS_OBJ_ID_INDEX_DATA*)((u8*)entry +
 				le16_to_cpu(entry->data_offset));
 		ntfs_log_verbose("\t\tMFT Number:\t\t 0x%llx\n",
 				(unsigned long long)
-				MREF_LE(object_id_data->mft_reference));
+				NTFS_MREF_LE(object_id_data->mft_reference));
 		ntfs_log_verbose("\t\tMFT Sequence Number:\t 0x%x\n",
 				(unsigned)
-				MSEQNO_LE(object_id_data->mft_reference));
+				NTFS_MSEQNO_LE(object_id_data->mft_reference));
 		ntfs_guid_to_mbs(&object_id_data->birth_volume_id,
 				printable_GUID);
-		ntfs_log_verbose("\t\tBirth volume id GUID:\t %s\n",
+		ntfs_log_verbose("\t\tBirth volume id NTFS_GUID:\t %s\n",
 				printable_GUID);
 		ntfs_guid_to_mbs(&object_id_data->birth_object_id,
 				printable_GUID);
-		ntfs_log_verbose("\t\tBirth object id GUID:\t %s\n",
+		ntfs_log_verbose("\t\tBirth object id NTFS_GUID:\t %s\n",
 				printable_GUID);
 		ntfs_guid_to_mbs(&object_id_data->domain_id, printable_GUID);
-		ntfs_log_verbose("\t\tDomain id GUID:\t\t %s\n",
+		ntfs_log_verbose("\t\tDomain id NTFS_GUID:\t\t %s\n",
 				printable_GUID);
 		}
 		break;
@@ -1518,7 +1518,7 @@
 		if (le16_to_cpu(entry->data_length) > 48) {
 			char *sid;
 			sid = ntfs_sid_to_mbs(&data->quota_q.sid, NULL, 0);
-			ntfs_log_verbose("\t\tOwner SID:\t\t %s\n", sid);
+			ntfs_log_verbose("\t\tOwner NTFS_SID:\t\t %s\n", sid);
 			free(sid);
 		}
 		break;
@@ -1534,14 +1534,14 @@
  *
  * dump sequence of index_entries and return number of entries dumped.
  */
-static int ntfs_dump_index_entries(INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
+static int ntfs_dump_index_entries(NTFS_INDEX_ENTRY *entry, INDEX_ATTR_TYPE type)
 {
 	int numb_entries = 1;
 	while (1) {
 		if (!opts.verbose) {
-			if (entry->flags & INDEX_ENTRY_END)
+			if (entry->flags & NTFS_INDEX_ENTRY_END)
 				break;
-			entry = (INDEX_ENTRY *)((u8 *)entry +
+			entry = (NTFS_INDEX_ENTRY *)((u8 *)entry +
 						le16_to_cpu(entry->length));
 			numb_entries++;
 			continue;
@@ -1555,20 +1555,20 @@
 		ntfs_log_verbose("\t\tIndex entry flags:\t 0x%02x\n",
 				(unsigned)le16_to_cpu(entry->flags));

-		if (entry->flags & INDEX_ENTRY_NODE)
-			ntfs_log_verbose("\t\tSubnode VCN:\t\t %lld (0x%llx)\n",
+		if (entry->flags & NTFS_INDEX_ENTRY_NODE)
+			ntfs_log_verbose("\t\tSubnode NTFS_VCN:\t\t %lld (0x%llx)\n",
 					 ntfs_ie_get_vcn(entry),
 					 ntfs_ie_get_vcn(entry));
-		if (entry->flags & INDEX_ENTRY_END)
+		if (entry->flags & NTFS_INDEX_ENTRY_END)
 			break;

 		switch (type) {
 		case INDEX_ATTR_DIRECTORY_I30:
 			ntfs_log_verbose("\t\tFILE record number:\t %llu "
 					"(0x%llx)\n", (unsigned long long)
-					MREF_LE(entry->indexed_file),
+					NTFS_MREF_LE(entry->indexed_file),
 					(unsigned long long)
-					MREF_LE(entry->indexed_file));
+					NTFS_MREF_LE(entry->indexed_file));
 			ntfs_dump_filename("\t\t", &entry->key.file_name);
 			break;
 		default:
@@ -1593,7 +1593,7 @@
 					"block.\n");
 			break;
 		}
-		entry = (INDEX_ENTRY*)((u8*)entry + le16_to_cpu(entry->length));
+		entry = (NTFS_INDEX_ENTRY*)((u8*)entry + le16_to_cpu(entry->length));
 		numb_entries++;
 		ntfs_log_verbose("\n");
 	}
@@ -1606,8 +1606,8 @@
 		(ntfschar*)((char*)(attr) + le16_to_cpu((attr)->name_offset)), \
 		(attr)->name_length, 0, NULL, 0)

-static INDEX_ATTR_TYPE get_index_attr_type(ntfs_inode *ni, ATTR_RECORD *attr,
-					   INDEX_ROOT *index_root)
+static INDEX_ATTR_TYPE get_index_attr_type(ntfs_inode *ni, NTFS_ATTR_RECORD *attr,
+					   NTFS_INDEX_ROOT *index_root)
 {
 	char file_name[64];

@@ -1615,7 +1615,7 @@
 		return INDEX_ATTR_UNKNOWN;

 	if (index_root->type) {
-		if (index_root->type == AT_FILE_NAME)
+		if (index_root->type == NTFS_AT_FILE_NAME)
 			return INDEX_ATTR_DIRECTORY_I30;
 		else
 			/* weird, this should be illegal */
@@ -1670,7 +1670,7 @@
 	printf("\n");
 }

-static void ntfs_dump_index_header(const char *indent, INDEX_HEADER *idx)
+static void ntfs_dump_index_header(const char *indent, NTFS_INDEX_HEADER *idx)
 {
 	printf("%sEntries Offset:\t\t %u (0x%x)\n", indent,
 			(unsigned)le32_to_cpu(idx->entries_offset),
@@ -1691,13 +1691,13 @@
  *
  * dump the index_root attribute
  */
-static void ntfs_dump_attr_index_root(ATTR_RECORD *attr, ntfs_inode *ni)
+static void ntfs_dump_attr_index_root(NTFS_ATTR_RECORD *attr, ntfs_inode *ni)
 {
 	INDEX_ATTR_TYPE type;
-	INDEX_ROOT *index_root = NULL;
-	INDEX_ENTRY *entry;
+	NTFS_INDEX_ROOT *index_root = NULL;
+	NTFS_INDEX_ENTRY *entry;

-	index_root = (INDEX_ROOT*)((u8*)attr + le16_to_cpu(attr->value_offset));
+	index_root = (NTFS_INDEX_ROOT*)((u8*)attr + le16_to_cpu(attr->value_offset));

 	/* attr_type dumping */
 	type = get_index_attr_type(ni, attr, index_root);
@@ -1708,9 +1708,9 @@
 	printf("\tCollation Rule:\t\t %u (0x%x)\n",
 			(unsigned)le32_to_cpu(index_root->collation_rule),
 			(unsigned)le32_to_cpu(index_root->collation_rule));
-/*	COLLATION_BINARY, COLLATION_FILE_NAME, COLLATION_UNICODE_STRING,
-	COLLATION_NTOFS_ULONG, COLLATION_NTOFS_SID,
-	COLLATION_NTOFS_SECURITY_HASH, COLLATION_NTOFS_ULONGS */
+/*	NTFS_COLLATION_BINARY, NTFS_COLLATION_FILE_NAME, NTFS_COLLATION_UNICODE_STRING,
+	NTFS_COLLATION_NTOFS_ULONG, NTFS_COLLATION_NTOFS_SID,
+	NTFS_COLLATION_NTOFS_SECURITY_HASH, NTFS_COLLATION_NTOFS_ULONGS */

 	printf("\tIndex Block Size:\t %u (0x%x)\n",
 			(unsigned)le32_to_cpu(index_root->index_block_size),
@@ -1721,14 +1721,14 @@

 	ntfs_dump_index_header("\t", &index_root->index);

-	entry = (INDEX_ENTRY*)((u8*)index_root +
+	entry = (NTFS_INDEX_ENTRY*)((u8*)index_root +
 			le32_to_cpu(index_root->index.entries_offset) + 0x10);
 	ntfs_log_verbose("\tDumping index root:\n");
 	printf("\tIndex entries total:\t %d\n",
 			ntfs_dump_index_entries(entry, type));
 }

-static void ntfs_dump_usa_lsn(const char *indent, MFT_RECORD *mrec)
+static void ntfs_dump_usa_lsn(const char *indent, NTFS_MFT_RECORD *mrec)
 {
 	printf("%sUpd. Seq. Array Off.:\t %u (0x%x)\n", indent,
 			(unsigned)le16_to_cpu(mrec->usa_ofs),
@@ -1746,10 +1746,10 @@
 }


-static s32 ntfs_dump_index_block(INDEX_BLOCK *ib, INDEX_ATTR_TYPE type,
+static s32 ntfs_dump_index_block(NTFS_INDEX_BLOCK *ib, INDEX_ATTR_TYPE type,
 		u32 ib_size)
 {
-	INDEX_ENTRY *entry;
+	NTFS_INDEX_ENTRY *entry;

 	if (ntfs_mst_post_read_fixup((NTFS_RECORD*)ib, ib_size)) {
 		ntfs_log_perror("Damaged INDX record");
@@ -1757,13 +1757,13 @@
 	}
 	ntfs_log_verbose("\tDumping index block:\n");
 	if (opts.verbose)
-		ntfs_dump_usa_lsn("\t\t", (MFT_RECORD*)ib);
+		ntfs_dump_usa_lsn("\t\t", (NTFS_MFT_RECORD*)ib);

-	ntfs_log_verbose("\t\tNode VCN:\t\t %lld (0x%llx)\n",
+	ntfs_log_verbose("\t\tNode NTFS_VCN:\t\t %lld (0x%llx)\n",
 			(unsigned long long)sle64_to_cpu(ib->index_block_vcn),
 			(unsigned long long)sle64_to_cpu(ib->index_block_vcn));

-	entry = (INDEX_ENTRY*)((u8*)ib +
+	entry = (NTFS_INDEX_ENTRY*)((u8*)ib +
 				le32_to_cpu(ib->index.entries_offset) + 0x18);

 	if (opts.verbose) {
@@ -1779,10 +1779,10 @@
  *
  * dump context of the index_allocation attribute
  */
-static void ntfs_dump_attr_index_allocation(ATTR_RECORD *attr, ntfs_inode *ni)
+static void ntfs_dump_attr_index_allocation(NTFS_ATTR_RECORD *attr, ntfs_inode *ni)
 {
-	INDEX_ALLOCATION *allocation, *tmp_alloc;
-	INDEX_ROOT *ir;
+	NTFS_INDEX_ALLOCATION *allocation, *tmp_alloc;
+	NTFS_INDEX_ROOT *ir;
 	INDEX_ATTR_TYPE type;
 	int total_entries = 0;
 	int total_indx_blocks = 0;
@@ -1794,7 +1794,7 @@

 	ir = ntfs_index_root_get(ni, attr);
 	if (!ir) {
-		ntfs_log_perror("Failed to read $INDEX_ROOT attribute");
+		ntfs_log_perror("Failed to read $NTFS_INDEX_ROOT attribute");
 		return;
 	}

@@ -1803,16 +1803,16 @@
 	name = (ntfschar *)((u8 *)attr + le16_to_cpu(attr->name_offset));
 	name_len = attr->name_length;

-	byte = bitmap = ntfs_attr_readall(ni, AT_BITMAP, name, name_len, NULL);
+	byte = bitmap = ntfs_attr_readall(ni, NTFS_AT_BITMAP, name, name_len, NULL);
 	if (!byte) {
 		ntfs_log_perror("Failed to read $BITMAP attribute");
 		goto out_index_root;
 	}

-	tmp_alloc = allocation = ntfs_attr_readall(ni, AT_INDEX_ALLOCATION,
+	tmp_alloc = allocation = ntfs_attr_readall(ni, NTFS_AT_INDEX_ALLOCATION,
 						   name, name_len, &data_size);
 	if (!tmp_alloc) {
-		ntfs_log_perror("Failed to read $INDEX_ALLOCATION attribute");
+		ntfs_log_perror("Failed to read $NTFS_INDEX_ALLOCATION attribute");
 		goto out_bitmap;
 	}

@@ -1831,7 +1831,7 @@
 						entries);
 			}
 		}
-		tmp_alloc = (INDEX_ALLOCATION *)((u8 *)tmp_alloc +
+		tmp_alloc = (NTFS_INDEX_ALLOCATION *)((u8 *)tmp_alloc +
 						le32_to_cpu(
 						ir->index_block_size));
 		bit++;
@@ -1856,7 +1856,7 @@
  *
  * dump the bitmap attribute
  */
-static void ntfs_dump_attr_bitmap(ATTR_RECORD *attr __attribute__((unused)))
+static void ntfs_dump_attr_bitmap(NTFS_ATTR_RECORD *attr __attribute__((unused)))
 {
 	/* TODO */
 }
@@ -1866,7 +1866,7 @@
  *
  * of ntfs 3.x dumps the reparse_point attribute
  */
-static void ntfs_dump_attr_reparse_point(ATTR_RECORD *attr __attribute__((unused)))
+static void ntfs_dump_attr_reparse_point(NTFS_ATTR_RECORD *attr __attribute__((unused)))
 {
 	/* TODO */
 }
@@ -1876,11 +1876,11 @@
  *
  * dump the ea_information attribute
  */
-static void ntfs_dump_attr_ea_information(ATTR_RECORD *attr)
+static void ntfs_dump_attr_ea_information(NTFS_ATTR_RECORD *attr)
 {
-	EA_INFORMATION *ea_info;
+	NTFS_EA_INFORMATION *ea_info;

-	ea_info = (EA_INFORMATION*)((u8*)attr +
+	ea_info = (NTFS_EA_INFORMATION*)((u8*)attr +
 			le16_to_cpu(attr->value_offset));
 	printf("\tPacked EA length:\t %u (0x%x)\n",
 			(unsigned)le16_to_cpu(ea_info->ea_length),
@@ -1898,14 +1898,14 @@
  *
  * dump the ea attribute
  */
-static void ntfs_dump_attr_ea(ATTR_RECORD *attr, ntfs_volume *vol)
+static void ntfs_dump_attr_ea(NTFS_ATTR_RECORD *attr, ntfs_volume *vol)
 {
-	EA_ATTR *ea;
+	NTFS_EA_ATTR *ea;
 	u8 *buf = NULL;
 	s64 data_size;

 	if (attr->non_resident) {
-		runlist *rl;
+		ntfs_runlist *rl;

 		data_size = sle64_to_cpu(attr->data_size);
 		if (!opts.verbose)
@@ -1928,7 +1928,7 @@
 				return;
 			}
 			free(rl);
-			ea = (EA_ATTR*)buf;
+			ea = (NTFS_EA_ATTR*)buf;
 		} else {
 			ntfs_log_perror("ntfs_mapping_pairs_decompress failed");
 			return;
@@ -1937,13 +1937,13 @@
 		data_size = le32_to_cpu(attr->value_length);
 		if (!opts.verbose)
 			return;
-		ea = (EA_ATTR*)((u8*)attr + le16_to_cpu(attr->value_offset));
+		ea = (NTFS_EA_ATTR*)((u8*)attr + le16_to_cpu(attr->value_offset));
 	}
 	while (1) {
 		printf("\n\tEA flags:\t\t ");
 		if (ea->flags) {
-			if (ea->flags == NEED_EA)
-				printf("NEED_EA\n");
+			if (ea->flags == NTFS_NEED_EA)
+				printf("NTFS_NEED_EA\n");
 			else
 				printf("Unknown (0x%02x)\n",
 						(unsigned)ea->flags);
@@ -1965,7 +1965,7 @@
 		else
 			printf("'%s'\n", ea->value + ea->name_length + 1);
 		if (ea->next_entry_offset)
-			ea = (EA_ATTR*)((u8*)ea +
+			ea = (NTFS_EA_ATTR*)((u8*)ea +
 					le32_to_cpu(ea->next_entry_offset));
 		else
 			break;
@@ -1980,7 +1980,7 @@
  *
  * dump the property_set attribute
  */
-static void ntfs_dump_attr_property_set(ATTR_RECORD *attr __attribute__((unused)))
+static void ntfs_dump_attr_property_set(NTFS_ATTR_RECORD *attr __attribute__((unused)))
 {
 	/* TODO */
 }
@@ -1992,7 +1992,7 @@
  *
  * dump the property_set attribute
  */
-static void ntfs_dump_attr_logged_utility_stream(ATTR_RECORD *attr,
+static void ntfs_dump_attr_logged_utility_stream(NTFS_ATTR_RECORD *attr,
 		ntfs_inode *ni)
 {
 	char *buf;
@@ -2000,7 +2000,7 @@

 	if (!opts.verbose)
 		return;
-	buf = ntfs_attr_readall(ni, AT_LOGGED_UTILITY_STREAM,
+	buf = ntfs_attr_readall(ni, NTFS_AT_LOGGED_UTILITY_STREAM,
 			ntfs_attr_get_name(attr), attr->name_length, &size);
 	if (buf)
 		ntfs_hex_dump(buf, size);
@@ -2050,7 +2050,7 @@
 /**
  * ntfs_dump_attr_unknown
  */
-static void ntfs_dump_attr_unknown(ATTR_RECORD *attr)
+static void ntfs_dump_attr_unknown(NTFS_ATTR_RECORD *attr)
 {
 	printf("=====  Please report this unknown attribute type to %s =====\n",
 	       NTFS_DEV_LIST);
@@ -2069,7 +2069,7 @@
  */
 static void ntfs_dump_inode_general_info(ntfs_inode *inode)
 {
-	MFT_RECORD *mrec = inode->mrec;
+	NTFS_MFT_RECORD *mrec = inode->mrec;
 	le16 inode_flags  = mrec->flags;

 	printf("Dumping Inode %llu (0x%llx)\n",
@@ -2089,22 +2089,22 @@

 	printf("MFT Record Flags:\t ");
 	if (inode_flags) {
-		if (MFT_RECORD_IN_USE & inode_flags) {
+		if (NTFS_MFT_RECORD_IN_USE & inode_flags) {
 			printf("IN_USE ");
-			inode_flags &= ~MFT_RECORD_IN_USE;
+			inode_flags &= ~NTFS_MFT_RECORD_IN_USE;
 		}
-		if (MFT_RECORD_IS_DIRECTORY & inode_flags) {
+		if (NTFS_MFT_RECORD_IS_DIRECTORY & inode_flags) {
 			printf("DIRECTORY ");
-			inode_flags &= ~MFT_RECORD_IS_DIRECTORY;
+			inode_flags &= ~NTFS_MFT_RECORD_IS_DIRECTORY;
 		}
 		/* The meaning of IS_4 is illusive but not its existence. */
-		if (MFT_RECORD_IS_4 & inode_flags) {
+		if (NTFS_MFT_RECORD_IS_4 & inode_flags) {
 			printf("IS_4 ");
-			inode_flags &= ~MFT_RECORD_IS_4;
+			inode_flags &= ~NTFS_MFT_RECORD_IS_4;
 		}
-		if (MFT_RECORD_IS_VIEW_INDEX & inode_flags) {
+		if (NTFS_MFT_RECORD_IS_VIEW_INDEX & inode_flags) {
 			printf("VIEW_INDEX ");
-			inode_flags &= ~MFT_RECORD_IS_VIEW_INDEX;
+			inode_flags &= ~NTFS_MFT_RECORD_IS_VIEW_INDEX;
 		}
 		if (inode_flags)
 			printf("UNKNOWN: 0x%04x", (unsigned)le16_to_cpu(
@@ -2124,9 +2124,9 @@
 	if (mrec->base_mft_record) {
 		printf("Base MFT Record:\t %llu (0x%llx)\n",
 				(unsigned long long)
-				MREF_LE(mrec->base_mft_record),
+				NTFS_MREF_LE(mrec->base_mft_record),
 				(unsigned long long)
-				MREF_LE(mrec->base_mft_record));
+				NTFS_MREF_LE(mrec->base_mft_record));
 	}
 	printf("Next Attribute Instance: %u (0x%x)\n",
 			(unsigned)le16_to_cpu(mrec->next_attr_instance),
@@ -2149,8 +2149,8 @@
 	/* then start enumerating attributes
 	   see ntfs_attr_lookup documentation for detailed explanation */
 	ctx = ntfs_attr_get_search_ctx(inode, NULL);
-	while (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
-		if (ctx->attr->type == AT_END || ctx->attr->type == AT_UNUSED) {
+	while (!ntfs_attr_lookup(NTFS_AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {
+		if (ctx->attr->type == NTFS_AT_END || ctx->attr->type == NTFS_AT_UNUSED) {
 			printf("Weird: %s attribute type was found, please "
 					"report this.\n",
 					get_attribute_type_name(
@@ -2161,53 +2161,53 @@
 		ntfs_dump_attribute_header(ctx, inode->vol);

 		switch (ctx->attr->type) {
-		case AT_STANDARD_INFORMATION:
+		case NTFS_AT_STANDARD_INFORMATION:
 			ntfs_dump_attr_standard_information(ctx->attr);
 			break;
-		case AT_ATTRIBUTE_LIST:
+		case NTFS_AT_ATTRIBUTE_LIST:
 			ntfs_dump_attr_list(ctx->attr, inode->vol);
 			break;
-		case AT_FILE_NAME:
+		case NTFS_AT_FILE_NAME:
 			ntfs_dump_attr_file_name(ctx->attr);
 			break;
-		case AT_OBJECT_ID:
+		case NTFS_AT_OBJECT_ID:
 			ntfs_dump_attr_object_id(ctx->attr, inode->vol);
 			break;
-		case AT_SECURITY_DESCRIPTOR:
+		case NTFS_AT_SECURITY_DESCRIPTOR:
 			ntfs_dump_attr_security_descriptor(ctx->attr,
 					inode->vol);
 			break;
-		case AT_VOLUME_NAME:
+		case NTFS_AT_VOLUME_NAME:
 			ntfs_dump_attr_volume_name(ctx->attr);
 			break;
-		case AT_VOLUME_INFORMATION:
+		case NTFS_AT_VOLUME_INFORMATION:
 			ntfs_dump_attr_volume_information(ctx->attr);
 			break;
-		case AT_DATA:
+		case NTFS_AT_DATA:
 			ntfs_dump_attr_data(ctx->attr, inode);
 			break;
-		case AT_INDEX_ROOT:
+		case NTFS_AT_INDEX_ROOT:
 			ntfs_dump_attr_index_root(ctx->attr, inode);
 			break;
-		case AT_INDEX_ALLOCATION:
+		case NTFS_AT_INDEX_ALLOCATION:
 			ntfs_dump_attr_index_allocation(ctx->attr, inode);
 			break;
-		case AT_BITMAP:
+		case NTFS_AT_BITMAP:
 			ntfs_dump_attr_bitmap(ctx->attr);
 			break;
-		case AT_REPARSE_POINT:
+		case NTFS_AT_REPARSE_POINT:
 			ntfs_dump_attr_reparse_point(ctx->attr);
 			break;
-		case AT_EA_INFORMATION:
+		case NTFS_AT_EA_INFORMATION:
 			ntfs_dump_attr_ea_information(ctx->attr);
 			break;
-		case AT_EA:
+		case NTFS_AT_EA:
 			ntfs_dump_attr_ea(ctx->attr, inode->vol);
 			break;
-		case AT_PROPERTY_SET:
+		case NTFS_AT_PROPERTY_SET:
 			ntfs_dump_attr_property_set(ctx->attr);
 			break;
-		case AT_LOGGED_UTILITY_STREAM:
+		case NTFS_AT_LOGGED_UTILITY_STREAM:
 			ntfs_dump_attr_logged_utility_stream(ctx->attr, inode);
 			break;
 		default:
@@ -2272,7 +2272,7 @@
 			inode = ntfs_pathname_to_inode(vol, NULL,
 					opts.filename);
 		} else {
-			inode = ntfs_inode_open(vol, MK_MREF(opts.inode, 0));
+			inode = ntfs_inode_open(vol, NTFS_MK_MREF(opts.inode, 0));
 		}

 		/* dump the inode information */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfslabel.c ./ntfsprogs/ntfslabel.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfslabel.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfslabel.c	2007-10-06 16:48:05.000000000 +0200
@@ -44,11 +44,11 @@
 #include <getopt.h>
 #endif

-#include "debug.h"
-#include "mft.h"
+#include "ntfs_debug.h"
+#include "ntfs_mft.h"
 #include "utils.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfslabel";

@@ -237,7 +237,7 @@
  * Return 0 on success and -1 with errno = ENOSPC if not enough space in the
  * mft record.
  */
-static int resize_resident_attribute_value(MFT_RECORD *m, ATTR_RECORD *a,
+static int resize_resident_attribute_value(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a,
 		const u32 new_vsize)
 {
 	int new_alen, new_muse;
@@ -272,11 +272,11 @@
  *
  * Change the label on the device @dev to @label.
  */
-static int change_label(ntfs_volume *vol, unsigned long mnt_flags, char *label, BOOL force)
+static int change_label(ntfs_volume *vol, unsigned long mnt_flags, char *label, NTFS_BOOL force)
 {
 	ntfs_attr_search_ctx *ctx;
 	ntfschar *new_label = NULL;
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	int label_len;
 	int result = 0;

@@ -299,10 +299,10 @@
 		ntfs_log_perror("Failed to get attribute search context");
 		goto err_out;
 	}
-	if (ntfs_attr_lookup(AT_VOLUME_NAME, AT_UNNAMED, 0, 0, 0, NULL, 0,
+	if (ntfs_attr_lookup(NTFS_AT_VOLUME_NAME, NTFS_AT_UNNAMED, 0, 0, 0, NULL, 0,
 			ctx)) {
 		if (errno != ENOENT) {
-			ntfs_log_perror("Lookup of $VOLUME_NAME attribute failed");
+			ntfs_log_perror("Lookup of $NTFS_VOLUME_NAME attribute failed");
 			goto err_out;
 		}
 		/* The volume name attribute does not exist.  Need to add it. */
@@ -310,7 +310,7 @@
 	} else {
 		a = ctx->attr;
 		if (a->non_resident) {
-			ntfs_log_error("Error: Attribute $VOLUME_NAME must be "
+			ntfs_log_error("Error: Attribute $NTFS_VOLUME_NAME must be "
 					"resident.\n");
 			goto err_out;
 		}
@@ -345,7 +345,7 @@
 		a = ctx->attr;
 		memmove((u8*)a + asize, a, biu - ((u8*)a - (u8*)ctx->mrec));
 		ctx->mrec->bytes_in_use = cpu_to_le32(biu + asize);
-		a->type = AT_VOLUME_NAME;
+		a->type = NTFS_AT_VOLUME_NAME;
 		a->length = cpu_to_le32(asize);
 		a->non_resident = 0;
 		a->name_length = 0;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsls.c ./ntfsprogs/ntfsls.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsls.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsls.c	2007-10-06 16:48:06.000000000 +0200
@@ -42,17 +42,17 @@
 #include <string.h>
 #endif

-#include "types.h"
-#include "mft.h"
-#include "attrib.h"
-#include "layout.h"
-#include "inode.h"
+#include "ntfs_types.h"
+#include "ntfs_mft.h"
+#include "ntfs_attrib.h"
+#include "ntfs_layout.h"
+#include "ntfs_inode.h"
 #include "utils.h"
-#include "dir.h"
-#include "list.h"
-#include "ntfstime.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_dir.h"
+#include "ntfs_list.h"
+#include "ntfs_time.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfsls";

@@ -61,7 +61,7 @@
  * @depth:     the level of this dir relative to opts.path
  */
 struct dir {
-	struct list_head list;
+	struct ntfs_list_head list;
 	ntfs_inode *ni;
 	char name[MAX_PATH];
 	int depth;
@@ -76,7 +76,7 @@
  * character array name in struct dir.
  */
 struct path_component {
-	struct list_head list;
+	struct ntfs_list_head list;
 	const char *name;
 };

@@ -98,7 +98,7 @@
  * dir_list_insert_pos keeps track of where to insert a sub-dir
  * into the list.
  */
-static struct list_head *dir_list_insert_pos = NULL;
+static struct ntfs_list_head *dir_list_insert_pos = NULL;

 /* The global depth relative to opts.path.
  * ie: opts.path has depth 0, a sub-dir of opts.path has depth 1
@@ -126,7 +126,7 @@

 static int list_dir_entry(ntfsls_dirent * dirent, const ntfschar * name,
 			  const int name_len, const int name_type,
-			  const s64 pos, const MFT_REF mref,
+			  const s64 pos, const NTFS_MFT_REF mref,
 			  const unsigned dt_type);

 /**
@@ -339,19 +339,19 @@

 /**
  * free_dirs - walk the list of dir's and free each of them
- * @dir_list:    the list_head of any entry in the list
+ * @dir_list:    the ntfs_list_head of any entry in the list
  *
  * Iterate over @dir_list, calling free_dir on each entry
  */
-static void free_dirs(struct list_head *dir_list)
+static void free_dirs(struct ntfs_list_head *dir_list)
 {
 	struct dir *tofree = NULL;
-	struct list_head *walker = NULL;
+	struct ntfs_list_head *walker = NULL;

 	if (dir_list) {
-		list_for_each(walker, dir_list) {
+		ntfs_list_for_each(walker, dir_list) {
 			free_dir(tofree);
-			tofree = list_entry(walker, struct dir, list);
+			tofree = ntfs_list_entry(walker, struct dir, list);
 		}

 		free_dir(tofree);
@@ -376,14 +376,14 @@
 {
 	/* list of dirs to "ls" recursively */
 	static struct dir dirs = {
-		.list = LIST_HEAD_INIT(dirs.list),
+		.list = NTFS_LIST_HEAD_INIT(dirs.list),
 		.ni = NULL,
 		.name = {0},
 		.depth = 0
 	};

 	static struct path_component paths = {
-		.list = LIST_HEAD_INIT(paths.list),
+		.list = NTFS_LIST_HEAD_INIT(paths.list),
 		.name = NULL
 	};

@@ -393,15 +393,15 @@
 	struct dir *tofree = NULL;
 	struct path_component comp;
 	struct path_component *tempcomp = NULL;
-	struct list_head *dir_walker = NULL;
-	struct list_head *comp_walker = NULL;
+	struct ntfs_list_head *dir_walker = NULL;
+	struct ntfs_list_head *comp_walker = NULL;
 	s64 pos2 = 0;
 	int ni_depth = depth;
 	int result = 0;

-	if (list_empty(&dirs.list)) {
+	if (ntfs_list_empty(&dirs.list)) {
 		base_comp.name = opts.path;
-		list_add(&base_comp.list, &paths.list);
+		ntfs_list_add(&base_comp.list, &paths.list);
 		dir_list_insert_pos = &dirs.list;
 		printf("%s:\n", opts.path);
 	}
@@ -411,16 +411,16 @@
 	result = ntfs_readdir(ni, pos, dirent, (ntfs_filldir_t) list_dir_entry);

 	if (result == 0) {
-		list_add_tail(&comp.list, &paths.list);
+		ntfs_list_add_tail(&comp.list, &paths.list);

 		/* for each of ni's sub-dirs: list in this iteration, then
 		   free at the top of the next iteration or outside of loop */
-		list_for_each(dir_walker, &dirs.list) {
+		ntfs_list_for_each(dir_walker, &dirs.list) {
 			if (tofree) {
 				free_dir(tofree);
 				tofree = NULL;
 			}
-			subdir = list_entry(dir_walker, struct dir, list);
+			subdir = ntfs_list_entry(dir_walker, struct dir, list);

 			/* subdir is not a subdir of ni */
 			if (subdir->depth != ni_depth + 1)
@@ -445,9 +445,9 @@
 			comp.name = subdir->name;

 			/* print relative path header */
-			list_for_each(comp_walker, &paths.list) {
+			ntfs_list_for_each(comp_walker, &paths.list) {
 				tempcomp =
-				    list_entry(comp_walker,
+				    ntfs_list_entry(comp_walker,
 					       struct path_component, list);
 				printf("%s", tempcomp->name);
 				if (tempcomp != &comp
@@ -464,10 +464,10 @@
 				break;

 			tofree = subdir;
-			list_del(dir_walker);
+			ntfs_list_del(dir_walker);
 		}

-		list_del(&comp.list);
+		ntfs_list_del(&comp.list);
 	}

 	if (tofree)
@@ -491,7 +491,7 @@
 static int list_dir_entry(ntfsls_dirent * dirent, const ntfschar * name,
 			  const int name_len, const int name_type,
 			  const s64 pos __attribute__((unused)),
-			  const MFT_REF mref, const unsigned dt_type)
+			  const NTFS_MFT_REF mref, const unsigned dt_type)
 {
 	char *filename = NULL;
 	int result = 0;
@@ -508,14 +508,14 @@
 	}

 	result = 0;					// These are successful
-	if ((MREF(mref) < FILE_first_user) && (!opts.system))
+	if ((NTFS_MREF(mref) < NTFS_FILE_first_user) && (!opts.system))
 		goto free;
-	if (name_type == FILE_NAME_POSIX && !opts.all)
+	if (name_type == NTFS_FILE_NAME_POSIX && !opts.all)
 		goto free;
-	if (((name_type & FILE_NAME_WIN32_AND_DOS) == FILE_NAME_WIN32) &&
+	if (((name_type & NTFS_FILE_NAME_WIN32_AND_DOS) == NTFS_FILE_NAME_WIN32) &&
 			opts.dos)
 		goto free;
-	if (((name_type & FILE_NAME_WIN32_AND_DOS) == FILE_NAME_DOS) &&
+	if (((name_type & NTFS_FILE_NAME_WIN32_AND_DOS) == NTFS_FILE_NAME_DOS) &&
 			!opts.dos)
 		goto free;
 	if (dt_type == NTFS_DT_DIR && opts.classify)
@@ -542,15 +542,15 @@
 		if (!opts.inode)
 			printf("%s\n", filename);
 		else
-			printf("%7llu %s\n", (unsigned long long)MREF(mref),
+			printf("%7llu %s\n", (unsigned long long)NTFS_MREF(mref),
 					filename);
 		result = 0;
 	} else {
 		s64 filesize = 0;
 		ntfs_inode *ni;
 		ntfs_attr_search_ctx *ctx = NULL;
-		FILE_NAME_ATTR *file_name_attr;
-		ATTR_RECORD *attr;
+		NTFS_FILE_NAME_ATTR *file_name_attr;
+		NTFS_ATTR_RECORD *attr;
 		time_t ntfs_time;
 		char t_buf[26];

@@ -564,12 +564,12 @@
 		if (!ctx)
 			goto release;

-		if (ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, 0, 0, NULL,
+		if (ntfs_attr_lookup(NTFS_AT_FILE_NAME, NTFS_AT_UNNAMED, 0, 0, 0, NULL,
 				0, ctx))
 			goto release;
 		attr = ctx->attr;

-		file_name_attr = (FILE_NAME_ATTR *)((char *)attr +
+		file_name_attr = (NTFS_FILE_NAME_ATTR *)((char *)attr +
 				le16_to_cpu(attr->value_offset));
 		if (!file_name_attr)
 			goto release;
@@ -580,7 +580,7 @@
 		t_buf[21] = '\0';

 		if (dt_type != NTFS_DT_DIR) {
-			if (!ntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, 0, 0,
+			if (!ntfs_attr_lookup(NTFS_AT_DATA, NTFS_AT_UNNAMED, 0, 0, 0,
 					NULL, 0, ctx))
 				filesize = ntfs_get_attribute_value_length(
 						ctx->attr);
@@ -588,7 +588,7 @@

 		if (opts.inode)
 			printf("%7llu    %8lld %s %s\n",
-					(unsigned long long)MREF(mref),
+					(unsigned long long)NTFS_MREF(mref),
 					(long long)filesize, t_buf + 4,
 					filename);
 		else
@@ -611,7 +611,7 @@

 	if (dir) {
 		if (result == 0) {
-			list_add(&dir->list, dir_list_insert_pos);
+			ntfs_list_add(&dir->list, dir_list_insert_pos);
 			dir_list_insert_pos = &dir->list;
 		} else {
 			free(dir);
@@ -672,7 +672,7 @@
 	pos = 0;
 	memset(&dirent, 0, sizeof(dirent));
 	dirent.vol = vol;
-	if (ni->mrec->flags & MFT_RECORD_IS_DIRECTORY) {
+	if (ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY) {
 		if (opts.recursive)
 			readdir_recursive(ni, &pos, &dirent);
 		else
@@ -680,8 +680,8 @@
 				     (ntfs_filldir_t) list_dir_entry);
 		// FIXME: error checking... (AIA)
 	} else {
-		ATTR_RECORD *rec;
-		FILE_NAME_ATTR *attr;
+		NTFS_ATTR_RECORD *rec;
+		NTFS_FILE_NAME_ATTR *attr;
 		ntfs_attr_search_ctx *ctx;
 		int space = 4;
 		ntfschar *name = NULL;
@@ -691,9 +691,9 @@
 		if (!ctx)
 			return -1;

-		while ((rec = find_attribute(AT_FILE_NAME, ctx))) {
+		while ((rec = find_attribute(NTFS_AT_FILE_NAME, ctx))) {
 			/* We know this will always be resident. */
-			attr = (FILE_NAME_ATTR *) ((char *) rec + le16_to_cpu(rec->value_offset));
+			attr = (NTFS_FILE_NAME_ATTR *) ((char *) rec + le16_to_cpu(rec->value_offset));

 			if (attr->file_name_type < space) {
 				name     = attr->file_name;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsmftalloc.c ./ntfsprogs/ntfsmftalloc.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsmftalloc.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsmftalloc.c	2007-10-06 16:48:06.000000000 +0200
@@ -56,20 +56,20 @@
 #	define LLONG_MAX 9223372036854775807LL
 #endif

-#include "types.h"
-#include "attrib.h"
-#include "inode.h"
-#include "layout.h"
-#include "volume.h"
-#include "mft.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_layout.h"
+#include "ntfs_volume.h"
+#include "ntfs_mft.h"
 #include "utils.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfsmftalloc";

 /* Need these global so ntfsmftalloc_exit can access them. */
-static BOOL success = FALSE;
+static NTFS_BOOL success = FALSE;

 static char *dev_name;

@@ -216,11 +216,11 @@
 /**
  * dump_mft_record
  */
-static void dump_mft_record(MFT_RECORD *m)
+static void dump_mft_record(NTFS_MFT_RECORD *m)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	unsigned int u;
-	MFT_REF r;
+	NTFS_MFT_REF r;

 	ntfs_log_info("-- Beginning dump of mft record. --\n");
 	u = le32_to_cpu(m->magic);
@@ -237,12 +237,12 @@
 	u = le16_to_cpu(m->attrs_offset);
 	ntfs_log_info("First attribute offset = %u (0x%x)\n", u, u);
 	ntfs_log_info("Flags = %u: ", le16_to_cpu(m->flags));
-	if (m->flags & MFT_RECORD_IN_USE)
-		ntfs_log_info("MFT_RECORD_IN_USE");
+	if (m->flags & NTFS_MFT_RECORD_IN_USE)
+		ntfs_log_info("NTFS_MFT_RECORD_IN_USE");
 	else
 		ntfs_log_info("MFT_RECORD_NOT_IN_USE");
-	if (m->flags & MFT_RECORD_IS_DIRECTORY)
-		ntfs_log_info(" | MFT_RECORD_IS_DIRECTORY");
+	if (m->flags & NTFS_MFT_RECORD_IS_DIRECTORY)
+		ntfs_log_info(" | NTFS_MFT_RECORD_IS_DIRECTORY");
 	ntfs_log_info("\n");
 	u = le32_to_cpu(m->bytes_in_use);
 	ntfs_log_info("Bytes in use = %u (0x%x)\n", u, u);
@@ -251,15 +251,15 @@
 	r = le64_to_cpu(m->base_mft_record);
 	ntfs_log_info("Base mft record reference:\n\tMft record number = %llu\n\t"
 			"Sequence number = %u\n",
-			(unsigned long long)MREF(r), MSEQNO(r));
+			(unsigned long long)NTFS_MREF(r), NTFS_MSEQNO(r));
 	ntfs_log_info("Next attribute instance = %u\n",
 			le16_to_cpu(m->next_attr_instance));
-	a = (ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
+	a = (NTFS_ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
 	ntfs_log_info("-- Beginning dump of attributes within mft record. --\n");
 	while ((char*)a < (char*)m + le32_to_cpu(m->bytes_in_use)) {
-		if (a->type == AT_END)
+		if (a->type == NTFS_AT_END)
 			break;
-		a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
+		a = (NTFS_ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
 	};
 	ntfs_log_info("-- End of attributes. --\n");
 }
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsmount.c ./ntfsprogs/ntfsmount.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsmount.c	2007-09-27 15:27:54.000000000 +0200
+++ ./ntfsprogs/ntfsmount.c	2007-10-06 16:48:05.000000000 +0200
@@ -65,17 +65,17 @@
 #include <sys/xattr.h>
 #endif

-#include "attrib.h"
-#include "inode.h"
-#include "volume.h"
-#include "dir.h"
-#include "unistr.h"
-#include "layout.h"
-#include "index.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_volume.h"
+#include "ntfs_dir.h"
+#include "ntfs_unistr.h"
+#include "ntfs_layout.h"
+#include "ntfs_index.h"
 #include "utils.h"
-#include "version.h"
-#include "ntfstime.h"
-#include "support.h"
+#include "ntfs_version.h"
+#include "ntfs_time.h"
+#include "ntfs_support.h"

 #ifndef PATH_MAX
 #define PATH_MAX 4096
@@ -105,18 +105,18 @@
 	unsigned int fmask;
 	unsigned int dmask;
 	ntfs_fuse_streams_interface streams;
-	BOOL ro;
-	BOOL silent;
-	BOOL force;
-	BOOL debug;
-	BOOL no_detach;
-	BOOL quiet;
-	BOOL verbose;
-	BOOL no_def_opts;
-	BOOL case_insensitive;
-	BOOL noatime;
-	BOOL relatime;
-	BOOL blkdev;
+	NTFS_BOOL ro;
+	NTFS_BOOL silent;
+	NTFS_BOOL force;
+	NTFS_BOOL debug;
+	NTFS_BOOL no_detach;
+	NTFS_BOOL quiet;
+	NTFS_BOOL verbose;
+	NTFS_BOOL no_def_opts;
+	NTFS_BOOL case_insensitive;
+	NTFS_BOOL noatime;
+	NTFS_BOOL relatime;
+	NTFS_BOOL blkdev;
 	char cached_path[PATH_MAX];
 	ntfs_inode *cached_ni;
 	ntfs_inode *root_ni;
@@ -263,7 +263,7 @@
  *
  * Return values:
  *	<0	Error occurred, return -errno;
- *	 0	No stream name, @*stream is not allocated and set to AT_UNNAMED.
+ *	 0	No stream name, @*stream is not allocated and set to NTFS_AT_UNNAMED.
  *	>0	Stream name length in unicode characters.
  */
 static int ntfs_fuse_parse_path(const char *org_path, char **path,
@@ -286,7 +286,7 @@
 		}
 	} else
 		*path = stream_name_mbs;
-	*stream_name = AT_UNNAMED;
+	*stream_name = NTFS_AT_UNNAMED;
 	return 0;
 }

@@ -376,10 +376,10 @@
 	stbuf->st_atime = ni->last_access_time;
 	stbuf->st_ctime = ni->last_mft_change_time;
 	stbuf->st_mtime = ni->last_data_change_time;
-	if (ni->mrec->flags & MFT_RECORD_IS_DIRECTORY && !stream_name_len) {
+	if (ni->mrec->flags & NTFS_MFT_RECORD_IS_DIRECTORY && !stream_name_len) {
 		/* Directory. */
 		stbuf->st_mode = S_IFDIR | (0777 & ~ctx->dmask);
-		na = ntfs_attr_open(ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
+		na = ntfs_attr_open(ni, NTFS_AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
 		if (na) {
 			stbuf->st_size = na->data_size;
 			stbuf->st_blocks = na->allocated_size >> 9;
@@ -393,7 +393,7 @@
 		/* Regular, data stream or Interix (INTX) file. */
 		stbuf->st_mode = S_IFREG;
 		stbuf->st_nlink = le16_to_cpu(ni->mrec->link_count);
-		na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, stream_name, stream_name_len);
 		if (!na) {
 			if (stream_name_len)
 				res = -ENOENT;
@@ -406,9 +406,9 @@
 		else
 			stbuf->st_blocks = 0;
 		stbuf->st_size = na->data_size;
-		if (ni->flags & FILE_ATTR_SYSTEM && !stream_name_len) {
+		if (ni->flags & NTFS_FILE_ATTR_SYSTEM && !stream_name_len) {
 			/* Check whether it's Interix FIFO or socket. */
-			if (!(ni->flags & FILE_ATTR_HIDDEN)) {
+			if (!(ni->flags & NTFS_FILE_ATTR_HIDDEN)) {
 				/* FIFO. */
 				if (na->data_size == 0)
 					stbuf->st_mode = S_IFIFO;
@@ -420,10 +420,10 @@
 			 * Check whether it's Interix symbolic link, block or
 			 * character device.
 			 */
-			if (na->data_size <= sizeof(INTX_FILE_TYPES) + sizeof(
+			if (na->data_size <= sizeof(NTFS_INTX_FILE_TYPES) + sizeof(
 					ntfschar) * MAX_PATH && na->data_size >
-					sizeof(INTX_FILE_TYPES)) {
-				INTX_FILE *intx_file;
+					sizeof(NTFS_INTX_FILE_TYPES)) {
+				NTFS_INTX_FILE *intx_file;

 				intx_file = ntfs_malloc(na->data_size);
 				if (!intx_file) {
@@ -438,25 +438,25 @@
 					ntfs_attr_close(na);
 					goto exit;
 				}
-				if (intx_file->magic == INTX_BLOCK_DEVICE &&
+				if (intx_file->magic == NTFS_INTX_BLOCK_DEVICE &&
 						na->data_size == offsetof(
-						INTX_FILE, device_end)) {
+						NTFS_INTX_FILE, device_end)) {
 					stbuf->st_mode = S_IFBLK;
 					stbuf->st_rdev = makedev(le64_to_cpu(
 							intx_file->major),
 							le64_to_cpu(
 							intx_file->minor));
 				}
-				if (intx_file->magic == INTX_CHARACTER_DEVICE &&
+				if (intx_file->magic == NTFS_INTX_CHARACTER_DEVICE &&
 						na->data_size == offsetof(
-						INTX_FILE, device_end)) {
+						NTFS_INTX_FILE, device_end)) {
 					stbuf->st_mode = S_IFCHR;
 					stbuf->st_rdev = makedev(le64_to_cpu(
 							intx_file->major),
 							le64_to_cpu(
 							intx_file->minor));
 				}
-				if (intx_file->magic == INTX_SYMBOLIC_LINK)
+				if (intx_file->magic == NTFS_INTX_SYMBOLIC_LINK)
 					stbuf->st_mode = S_IFLNK;
 				free(intx_file);
 			}
@@ -501,7 +501,7 @@
 	ntfschar *stream_name;
 	ntfs_inode *ni = NULL;
 	ntfs_attr *na = NULL;
-	INTX_FILE *intx_file = NULL;
+	NTFS_INTX_FILE *intx_file = NULL;
 	int stream_name_len, res = 0;

 	/* Get inode. */
@@ -518,20 +518,20 @@
 		goto exit;
 	}
 	/* Sanity checks. */
-	if (!(ni->flags & FILE_ATTR_SYSTEM)) {
+	if (!(ni->flags & NTFS_FILE_ATTR_SYSTEM)) {
 		res = -EINVAL;
 		goto exit;
 	}
-	na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		res = -errno;
 		goto exit;
 	}
-	if (na->data_size <= sizeof(INTX_FILE_TYPES)) {
+	if (na->data_size <= sizeof(NTFS_INTX_FILE_TYPES)) {
 		res = -EINVAL;
 		goto exit;
 	}
-	if (na->data_size > sizeof(INTX_FILE_TYPES) +
+	if (na->data_size > sizeof(NTFS_INTX_FILE_TYPES) +
 			sizeof(ntfschar) * MAX_PATH) {
 		res = -ENAMETOOLONG;
 		goto exit;
@@ -547,13 +547,13 @@
 		goto exit;
 	}
 	/* Sanity check. */
-	if (intx_file->magic != INTX_SYMBOLIC_LINK) {
+	if (intx_file->magic != NTFS_INTX_SYMBOLIC_LINK) {
 		res = -EINVAL;
 		goto exit;
 	}
 	/* Convert link from unicode to local encoding. */
 	if (ntfs_ucstombs(intx_file->target, (na->data_size -
-			offsetof(INTX_FILE, target)) / sizeof(ntfschar),
+			offsetof(NTFS_INTX_FILE, target)) / sizeof(ntfschar),
 			&buf, buf_size) < 0) {
 		res = -errno;
 		goto exit;
@@ -573,29 +573,29 @@

 static int ntfs_fuse_filler(ntfs_fuse_fill_context_t *fill_ctx,
 		const ntfschar *name, const int name_len, const int name_type,
-		const s64 pos __attribute__((unused)), const MFT_REF mref,
+		const s64 pos __attribute__((unused)), const NTFS_MFT_REF mref,
 		const unsigned dt_type __attribute__((unused)))
 {
 	char *filename = NULL;
 	int ret = 0;

-	if (name_type == FILE_NAME_DOS)
+	if (name_type == NTFS_FILE_NAME_DOS)
 		return 0;
 	if (ntfs_ucstombs(name, name_len, &filename, 0) < 0) {
 		ntfs_log_error("Skipping unrepresentable filename (inode %lld):"
-				" %s\n", MREF(mref), strerror(errno));
+				" %s\n", NTFS_MREF(mref), strerror(errno));
 		return 0;
 	}
 	if (ntfs_fuse_is_named_data_stream(filename)) {
 		ntfs_log_error("Unable to access '%s' (inode %lld) with "
 				"current named streams access interface.\n",
-				filename, MREF(mref));
+				filename, NTFS_MREF(mref));
 		free(filename);
 		return 0;
 	}
-	if (MREF(mref) == FILE_root || MREF(mref) >= FILE_first_user) {
+	if (NTFS_MREF(mref) == NTFS_FILE_root || NTFS_MREF(mref) >= NTFS_FILE_first_user) {
 		struct stat st = {
-			.st_ino = MREF(mref),
+			.st_ino = NTFS_MREF(mref),
 		};

 		if (dt_type == NTFS_DT_REG)
@@ -643,7 +643,7 @@
 		return stream_name_len;
 	ni = ntfs_fuse_cache_get_file(path);
 	if (ni) {
-		na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, stream_name, stream_name_len);
 		if (na) {
 			if (NAttrEncrypted(na) && !na->crypto)
 				res = -EACCES;
@@ -764,7 +764,7 @@
 		res = 0;
 		goto exit;
 	}
-	na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, stream_name, stream_name_len);
 	if (!na) {
 		res = -errno;
 		goto exit;
@@ -905,7 +905,7 @@
 		if (res)
 			return res;
 	}
-	if (ntfs_attr_add(ni, AT_DATA, stream_name, stream_name_len, NULL, 0))
+	if (ntfs_attr_add(ni, NTFS_AT_DATA, stream_name, stream_name_len, NULL, 0))
 		res = -errno;
 	if (_ni)
 		*_ni = ni;
@@ -942,7 +942,7 @@
 				stream_name_len, na ? &ni : NULL);
 	if (na && !res) {
 		if (ni) {
-			*na = ntfs_attr_open(ni, AT_DATA, stream_name,
+			*na = ntfs_attr_open(ni, NTFS_AT_DATA, stream_name,
 					stream_name_len);
 			if (!*na) {
 				ntfs_inode_close(ni);
@@ -1097,7 +1097,7 @@
 	ni = ntfs_pathname_to_inode(ctx->vol, NULL, path);
 	if (!ni)
 		return -errno;
-	na = ntfs_attr_open(ni, AT_DATA, stream_name, stream_name_len);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, stream_name, stream_name_len);
 	if (!na) {
 		res = -errno;
 		goto exit;
@@ -1215,7 +1215,7 @@
 {
 	ntfs_inode *ni;
 	ntfs_attr *na;
-	LCN lcn;
+	NTFS_LCN lcn;
 	int ret = 0, cl_per_bl = ctx->vol->cluster_size / blocksize;

 	if (blocksize > ctx->vol->cluster_size ||
@@ -1225,7 +1225,7 @@
 	ni = ntfs_pathname_to_inode(ctx->vol, NULL, path);
 	if (!ni)
 		return -errno;
-	na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!na) {
 		ret = -errno;
 		goto close_inode;
@@ -1239,7 +1239,7 @@

 	lcn = ntfs_attr_vcn_to_lcn(na, *idx / cl_per_bl);
 	if (lcn < 0) {
-		if (lcn == LCN_HOLE)
+		if (lcn == NTFS_LCN_HOLE)
 			ret = -EINVAL;
 		else
 			ret = -EIO;
@@ -1277,7 +1277,7 @@
 		ntfs_inode_close(ni);
 		goto exit;
 	}
-	while (!ntfs_attr_lookup(AT_DATA, NULL, 0, CASE_SENSITIVE,
+	while (!ntfs_attr_lookup(NTFS_AT_DATA, NULL, 0, NTFS_CASE_SENSITIVE,
 				0, NULL, 0, actx)) {
 		char *tmp_name = NULL;
 		int tmp_name_len;
@@ -1337,7 +1337,7 @@
 		ntfs_inode_close(ni);
 		goto exit;
 	}
-	while (!ntfs_attr_lookup(AT_DATA, NULL, 0, CASE_SENSITIVE,
+	while (!ntfs_attr_lookup(NTFS_AT_DATA, NULL, 0, NTFS_CASE_SENSITIVE,
 				0, NULL, 0, actx)) {
 		char *tmp_name = NULL;
 		int tmp_name_len;
@@ -1403,7 +1403,7 @@
 		res = -errno;
 		goto exit;
 	}
-	na = ntfs_attr_open(ni, AT_DATA, lename, lename_len);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, lename, lename_len);
 	if (!na) {
 		res = -ENODATA;
 		goto exit;
@@ -1447,7 +1447,7 @@
 		res = -errno;
 		goto exit;
 	}
-	na = ntfs_attr_open(ni, AT_DATA, lename, lename_len);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, lename, lename_len);
 	if (na && flags == XATTR_CREATE) {
 		res = -EEXIST;
 		goto exit;
@@ -1457,11 +1457,11 @@
 			res = -ENODATA;
 			goto exit;
 		}
-		if (ntfs_attr_add(ni, AT_DATA, lename, lename_len, NULL, 0)) {
+		if (ntfs_attr_add(ni, NTFS_AT_DATA, lename, lename_len, NULL, 0)) {
 			res = -errno;
 			goto exit;
 		}
-		na = ntfs_attr_open(ni, AT_DATA, lename, lename_len);
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, lename, lename_len);
 		if (!na) {
 			res = -errno;
 			goto exit;
@@ -1501,7 +1501,7 @@
 		res = -errno;
 		goto exit;
 	}
-	na = ntfs_attr_open(ni, AT_DATA, lename, lename_len);
+	na = ntfs_attr_open(ni, NTFS_AT_DATA, lename, lename_len);
 	if (!na) {
 		res = -ENODATA;
 		goto exit;
@@ -1803,7 +1803,7 @@
 		return -1;
 	}
 	ctx->vol = vol;
-	ctx->root_ni = ntfs_inode_open(vol, FILE_root);
+	ctx->root_ni = ntfs_inode_open(vol, NTFS_FILE_root);
 	return 0;
 }

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsmove.c ./ntfsprogs/ntfsmove.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsmove.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsmove.c	2007-10-06 16:48:06.000000000 +0200
@@ -37,16 +37,16 @@
 #include <string.h>
 #endif

-#include "types.h"
-#include "attrib.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
 #include "utils.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
-#include "bitmap.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
+#include "ntfs_bitmap.h"
 #include "ntfsmove.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfsmove";
 static struct options opts;
@@ -249,9 +249,9 @@
 #if 0

 /**
- * ntfs_debug_runlist_dump2 - Dump a runlist.
+ * ntfs_debug_runlist_dump2 - Dump a ntfs_runlist.
  */
-static int ntfs_debug_runlist_dump2(const runlist *rl, int abbr, char *prefix)
+static int ntfs_debug_runlist_dump2(const ntfs_runlist *rl, int abbr, char *prefix)
 {
 	//int abbr = 3;	/* abbreviate long lists */
 	int len = 0;
@@ -271,9 +271,9 @@
 	if (abbr)
 		for (len = 0; rl[len].length; len++) ;

-	ntfs_log_info("%s     VCN      LCN      len\n", prefix);
+	ntfs_log_info("%s     NTFS_VCN      NTFS_LCN      len\n", prefix);
 	for (i = 0; rl->length; i++, rl++) {
-		LCN lcn = rl->lcn;
+		NTFS_LCN lcn = rl->lcn;

 		total += rl->length;
 		if (abbr)
@@ -287,7 +287,7 @@
 		if (rl->vcn < -1)
 			res = -1;

-		if (lcn < (LCN)0) {
+		if (lcn < (NTFS_LCN)0) {
 			int j = -lcn - 1;

 			if ((j < 0) || (j > 4)) {
@@ -311,7 +311,7 @@
 /**
  * resize_nonres_attr
  */
-static int resize_nonres_attr(MFT_RECORD *m, ATTR_RECORD *a, const u32 new_size)
+static int resize_nonres_attr(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a, const u32 new_size)
 {
 	int this_attr;
 	int next_attr;
@@ -347,7 +347,7 @@
 /**
  * calc_attr_length
  */
-static int calc_attr_length(ATTR_RECORD *rec, int runlength)
+static int calc_attr_length(NTFS_ATTR_RECORD *rec, int runlength)
 {
 	int size;

@@ -382,7 +382,7 @@
 /**
  * find_unused
  */
-static runlist * find_unused(ntfs_volume *vol, s64 size, u64 loc
+static ntfs_runlist * find_unused(ntfs_volume *vol, s64 size, u64 loc
 	__attribute__((unused)), int flags __attribute__((unused)))
 {
 	const int bufsize = 8192;
@@ -393,7 +393,7 @@
 	int count = 0;
 	s64 start = 0;
 	int bit = 0;
-	runlist *res = NULL;
+	ntfs_runlist *res = NULL;

 	//ntfs_log_info("find_unused\n");
 	buffer = malloc(bufsize);
@@ -427,7 +427,7 @@
 						res[0].vcn    = 0;
 						res[0].lcn    = start;
 						res[0].length = size;
-						res[1].lcn    = LCN_ENOENT;
+						res[1].lcn    = NTFS_LCN_ENOENT;
 					}
 					goto done;
 				}
@@ -472,29 +472,29 @@
 		const_cpu_to_le16('d'), const_cpu_to_le16('r'), const_cpu_to_le16('\0')
 	};

-	ATTR_RECORD *rec;
-	FILE_NAME_ATTR *name;
+	NTFS_ATTR_RECORD *rec;
+	NTFS_FILE_NAME_ATTR *name;

 	if (utils_is_metadata(ino)) {
 		ntfs_log_error("metadata\n");
 		return 1;
 	}

-	rec = find_first_attribute(AT_ATTRIBUTE_LIST, ino->mrec);
+	rec = find_first_attribute(NTFS_AT_ATTRIBUTE_LIST, ino->mrec);
 	if (rec) {
 		ntfs_log_error("attribute list\n");
 		return 1;
 	}

-	rec = find_first_attribute(AT_FILE_NAME, ino->mrec);
+	rec = find_first_attribute(NTFS_AT_FILE_NAME, ino->mrec);
 	if (!rec) {
 		ntfs_log_error("extend inode\n");
 		return 1;
 	}

-	name = (FILE_NAME_ATTR*) ((u8*)rec + rec->value_offset);
+	name = (NTFS_FILE_NAME_ATTR*) ((u8*)rec + rec->value_offset);
 	if (ntfs_names_are_equal(ntldr, 5, name->file_name, name->file_name_length,
-		IGNORE_CASE, ino->vol->upcase, ino->vol->upcase_len)) {
+		NTFS_IGNORE_CASE, ino->vol->upcase, ino->vol->upcase_len)) {
 		ntfs_log_error("ntldr\n");
 		return 1;
 	}
@@ -506,7 +506,7 @@
 /**
  * bitmap_alloc
  */
-static int bitmap_alloc(ntfs_volume *vol, runlist_element *rl)
+static int bitmap_alloc(ntfs_volume *vol, ntfs_runlist_element *rl)
 {
 	int res;

@@ -524,7 +524,7 @@
 /**
  * bitmap_free
  */
-static int bitmap_free(ntfs_volume *vol, runlist_element *rl)
+static int bitmap_free(ntfs_volume *vol, ntfs_runlist_element *rl)
 {
 	int res;

@@ -542,7 +542,7 @@
 /**
  * data_copy
  */
-static int data_copy(ntfs_volume *vol, runlist_element *from, runlist_element *to)
+static int data_copy(ntfs_volume *vol, ntfs_runlist_element *from, ntfs_runlist_element *to)
 {
 	int i;
 	u8 *buffer;
@@ -595,8 +595,8 @@
  * copy data
  * deallocate old space
  */
-static s64 move_runlist(ntfs_volume *vol, runlist_element *from,
-	runlist_element *to)
+static s64 move_runlist(ntfs_volume *vol, ntfs_runlist_element *from,
+	ntfs_runlist_element *to)
 {
 	int i;

@@ -652,20 +652,20 @@
  * < 0  Error
  */

-// get size of runlist
+// get size of ntfs_runlist
 // find somewhere to put data
-// backup original runlist
+// backup original ntfs_runlist
 // move the data

-// got to get the runlist out of this function
+// got to get the ntfs_runlist out of this function
 //      requires a mrec arg, not an ino (ino->mrec will do for now)
-// check size of new runlist before allocating / moving
+// check size of new ntfs_runlist before allocating / moving
 // replace one datarun with another (by hand)
-static s64 move_datarun(ntfs_volume *vol, ntfs_inode *ino, ATTR_RECORD *rec,
-	runlist_element *run, u64 loc, int flags)
+static s64 move_datarun(ntfs_volume *vol, ntfs_inode *ino, NTFS_ATTR_RECORD *rec,
+	ntfs_runlist_element *run, u64 loc, int flags)
 {
-	runlist *from;
-	runlist *to;
+	ntfs_runlist *from;
+	ntfs_runlist *to;
 	int need_from;
 	int need_to;
 	int i;
@@ -680,7 +680,7 @@

 	to->vcn = run->vcn;

-	// copy original runlist
+	// copy original ntfs_runlist
 	from = ntfs_mapping_pairs_decompress(vol, rec, NULL);
 	if (!from) {
 		ntfs_log_info("!from\n");
@@ -752,13 +752,13 @@
  * = 0  Nothing to do
  * < 0  Error
  */
-static s64 move_attribute(ntfs_volume *vol, ntfs_inode *ino, ATTR_RECORD *rec,
+static s64 move_attribute(ntfs_volume *vol, ntfs_inode *ino, NTFS_ATTR_RECORD *rec,
 	u64 loc, int flags)
 {
 	int i;
 	s64 res;
 	s64 count = 0;
-	runlist *runs;
+	ntfs_runlist *runs;

 	// NTFS_MOVE_LOC_BEST : assess how much space this attribute will need,
 	// find that space and pass the location to our children.
@@ -772,9 +772,9 @@

 	//ntfs_debug_runlist_dump2(runs, 5, "\t");

-	//ntfs_log_info("             VCN     LCN     Length\n");
+	//ntfs_log_info("             NTFS_VCN     NTFS_LCN     Length\n");
 	for (i = 0; runs[i].length > 0; i++) {
-		if (runs[i].lcn == LCN_RL_NOT_MAPPED) {
+		if (runs[i].lcn == NTFS_LCN_RL_NOT_MAPPED) {
 			continue;
 		}

@@ -802,7 +802,7 @@
 {
 	char *buffer;
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *rec;
+	NTFS_ATTR_RECORD *rec;
 	s64 res;
 	s64 count = 0;

@@ -827,7 +827,7 @@

 	ctx = ntfs_attr_get_search_ctx(ino, NULL);

-	while ((rec = find_attribute(AT_UNUSED, ctx))) {
+	while ((rec = find_attribute(NTFS_AT_UNUSED, ctx))) {
 		utils_attr_get_name(vol, rec, buffer, MAX_PATH);
 		ntfs_log_info("\tAttribute 0x%02x %s is ", rec->type, buffer);

diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsmove.h ./ntfsprogs/ntfsmove.h
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsmove.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsmove.h	2007-10-06 16:48:07.000000000 +0200
@@ -24,7 +24,7 @@
 #ifndef _NTFSMOVE_H_
 #define _NTFSMOVE_H_

-#include "types.h"
+#include "ntfs_types.h"
 					/* Move files to */
 #define NTFS_MOVE_LOC_START	-1000	/*   the first available space */
 #define NTFS_MOVE_LOC_BEST	-1001	/*   place big enough for entire file */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsresize.c ./ntfsprogs/ntfsresize.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsresize.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsresize.c	2007-10-06 16:48:07.000000000 +0200
@@ -52,20 +52,20 @@
 #include <getopt.h>
 #endif

-#include "debug.h"
-#include "types.h"
-#include "support.h"
-#include "endians.h"
-#include "bootsect.h"
-#include "device.h"
-#include "attrib.h"
-#include "volume.h"
-#include "mft.h"
-#include "bitmap.h"
-#include "inode.h"
-#include "runlist.h"
+#include "ntfs_debug.h"
+#include "ntfs_types.h"
+#include "ntfs_support.h"
+#include "ntfs_endians.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_device.h"
+#include "ntfs_attrib.h"
+#include "ntfs_volume.h"
+#include "ntfs_mft.h"
+#include "ntfs_bitmap.h"
+#include "ntfs_inode.h"
+#include "ntfs_runlist.h"
 #include "utils.h"
-#include "version.h"
+#include "ntfs_version.h"

 static const char *EXEC_NAME = "ntfsresize";

@@ -155,7 +155,7 @@
 };

 struct llcn_t {
-	s64 lcn;	/* last used LCN for a "special" file/attr type */
+	s64 lcn;	/* last used NTFS_LCN for a "special" file/attr type */
 	s64 inode;	/* inode using it */
 };

@@ -176,17 +176,17 @@
 	ntfs_volume *vol;
 	ntfs_inode *ni;		     /* inode being processed */
 	s64 new_volume_size;	     /* in clusters; 0 = --info w/o --size */
-	MFT_REF mref;                /* mft reference */
-	MFT_RECORD *mrec;            /* mft record */
+	NTFS_MFT_REF mref;                /* mft reference */
+	NTFS_MFT_RECORD *mrec;            /* mft record */
 	ntfs_attr_search_ctx *ctx;   /* inode attribute being processed */
 	u64 relocations;	     /* num of clusters to relocate */
 	s64 inuse;		     /* num of clusters in use */
-	runlist mftmir_rl;	     /* $MFTMirr AT_DATA's new position */
-	s64 mftmir_old;		     /* $MFTMirr AT_DATA's old LCN */
+	ntfs_runlist mftmir_rl;	     /* $MFTMirr NTFS_AT_DATA's new position */
+	s64 mftmir_old;		     /* $MFTMirr NTFS_AT_DATA's old NTFS_LCN */
 	int dirty_inode;	     /* some inode data got relocated */
 	int shrink;		     /* shrink = 1, enlarge = 0 */
 	s64 badclusters;	     /* num of physically dead clusters */
-	VCN mft_highest_vcn;	     /* used for relocating the $MFT */
+	NTFS_VCN mft_highest_vcn;	     /* used for relocating the $MFT */
 	struct progress_bar progress;
 	struct bitmap lcn_bitmap;
 	/* Temporary statistics until all case is supported */
@@ -592,14 +592,14 @@
 	       "before real resizing!\n");
 }

-static void rl_set(runlist *rl, VCN vcn, LCN lcn, s64 len)
+static void rl_set(ntfs_runlist *rl, NTFS_VCN vcn, NTFS_LCN lcn, s64 len)
 {
 	rl->vcn = vcn;
 	rl->lcn = lcn;
 	rl->length = len;
 }

-static int rl_items(runlist *rl)
+static int rl_items(ntfs_runlist *rl)
 {
 	int i = 0;

@@ -609,14 +609,14 @@
 	return i;
 }

-static void dump_run(runlist_element *r)
+static void dump_run(ntfs_runlist_element *r)
 {
 	ntfs_log_verbose(" %8lld  %8lld (0x%08llx)  %lld\n", (long long)r->vcn,
 			 (long long)r->lcn, (long long)r->lcn,
 			 (long long)r->length);
 }

-static void dump_runlist(runlist *rl)
+static void dump_runlist(ntfs_runlist *rl)
 {
 	while (rl->length)
 		dump_run(rl++);
@@ -638,11 +638,11 @@
 	return bm_bsize;
 }

-static void collect_resize_constraints(ntfs_resize_t *resize, runlist *rl)
+static void collect_resize_constraints(ntfs_resize_t *resize, ntfs_runlist *rl)
 {
 	s64 inode, last_lcn;
-	ATTR_FLAGS flags;
-	ATTR_TYPES atype;
+	NTFS_ATTR_FLAGS flags;
+	NTFS_ATTR_TYPES atype;
 	struct llcn_t *llcn = NULL;
 	int ret, supported = 0;

@@ -658,41 +658,41 @@
 		return;
 	}

-	if (inode == FILE_Bitmap) {
+	if (inode == NTFS_FILE_Bitmap) {
 		llcn = &resize->last_lcn;
-		if (atype == AT_DATA && NInoAttrList(resize->ni))
+		if (atype == NTFS_AT_DATA && NInoAttrList(resize->ni))
 		    err_exit("Highly fragmented $Bitmap isn't supported yet.");

 		supported = 1;

-	} else if (inode == FILE_MFT) {
+	} else if (inode == NTFS_FILE_MFT) {
 		llcn = &resize->last_mft;
 		/*
-		 *  First run of $MFT AT_DATA isn't supported yet.
+		 *  First run of $MFT NTFS_AT_DATA isn't supported yet.
 		 */
-		if (atype != AT_DATA || rl->vcn)
+		if (atype != NTFS_AT_DATA || rl->vcn)
 			supported = 1;

 	} else if (NInoAttrList(resize->ni)) {
 		llcn = &resize->last_multi_mft;

-		if (inode != FILE_MFTMirr)
+		if (inode != NTFS_FILE_MFTMirr)
 			supported = 1;

-	} else if (flags & ATTR_IS_SPARSE) {
+	} else if (flags & NTFS_ATTR_IS_SPARSE) {
 		llcn = &resize->last_sparse;
 		supported = 1;

-	} else if (flags & ATTR_IS_COMPRESSED) {
+	} else if (flags & NTFS_ATTR_IS_COMPRESSED) {
 		llcn = &resize->last_compressed;
 		supported = 1;

-	} else if (inode == FILE_MFTMirr) {
+	} else if (inode == NTFS_FILE_MFTMirr) {
 		llcn = &resize->last_mftmir;
 		supported = 1;

 		/* Fragmented $MFTMirr DATA attribute isn't supported yet */
-		if (atype == AT_DATA)
+		if (atype == NTFS_AT_DATA)
 			if (rl[1].length != 0 || rl->vcn)
 				supported = 0;
 	} else {
@@ -713,10 +713,10 @@
 }


-static void collect_relocation_info(ntfs_resize_t *resize, runlist *rl)
+static void collect_relocation_info(ntfs_resize_t *resize, ntfs_runlist *rl)
 {
 	s64 lcn, lcn_length, start, len, inode;
-	s64 new_vol_size;	/* (last LCN on the volume) + 1 */
+	s64 new_vol_size;	/* (last NTFS_LCN on the volume) + 1 */

 	lcn = rl->lcn;
 	lcn_length = rl->length;
@@ -726,7 +726,7 @@
 	if (lcn + lcn_length <= new_vol_size)
 		return;

-	if (inode == FILE_Bitmap && resize->ctx->attr->type == AT_DATA)
+	if (inode == NTFS_FILE_Bitmap && resize->ctx->attr->type == NTFS_AT_DATA)
 		return;

 	start = lcn;
@@ -736,7 +736,7 @@
 		start = new_vol_size;
 		len = lcn_length - (new_vol_size - lcn);

-		if (!opt.info && (inode == FILE_MFTMirr)) {
+		if (!opt.info && (inode == NTFS_FILE_MFTMirr)) {
 			err_printf("$MFTMirr can't be split up yet. Please try "
 				   "a different size.\n");
 			print_advise(resize->vol, lcn + lcn_length - 1);
@@ -749,7 +749,7 @@
 	if (!opt.info || !resize->new_volume_size)
 		return;

-	printf("Relocation needed for inode %8lld attr 0x%x LCN 0x%08llx "
+	printf("Relocation needed for inode %8lld attr 0x%x NTFS_LCN 0x%08llx "
 			"length %6lld\n", (long long)inode,
 			(unsigned int)le32_to_cpu(resize->ctx->attr->type),
 			(unsigned long long)start, (long long)len);
@@ -767,8 +767,8 @@
 static void build_lcn_usage_bitmap(ntfs_volume *vol, ntfsck_t *fsck)
 {
 	s64 inode;
-	ATTR_RECORD *a;
-	runlist *rl;
+	NTFS_ATTR_RECORD *a;
+	ntfs_runlist *rl;
 	int i, j;
 	struct bitmap *lcn_bitmap = &fsck->lcn_bitmap;

@@ -791,13 +791,13 @@
 		s64 lcn = rl[i].lcn;
 		s64 lcn_length = rl[i].length;

-		/* CHECKME: LCN_RL_NOT_MAPPED check isn't needed */
-		if (lcn == LCN_HOLE || lcn == LCN_RL_NOT_MAPPED)
+		/* CHECKME: NTFS_LCN_RL_NOT_MAPPED check isn't needed */
+		if (lcn == NTFS_LCN_HOLE || lcn == NTFS_LCN_RL_NOT_MAPPED)
 			continue;

 		/* FIXME: ntfs_mapping_pairs_decompress should return error */
 		if (lcn < 0 || lcn_length <= 0)
-			err_exit("Corrupt runlist in inode %lld attr %x LCN "
+			err_exit("Corrupt ntfs_runlist in inode %lld attr %x NTFS_LCN "
 				 "%llx length %llx\n", inode,
 				 (unsigned int)le32_to_cpu(a->type), lcn,
 				 lcn_length);
@@ -832,7 +832,7 @@
 }


-static ntfs_attr_search_ctx *attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)
+static ntfs_attr_search_ctx *attr_get_search_ctx(ntfs_inode *ni, NTFS_MFT_RECORD *mrec)
 {
 	ntfs_attr_search_ctx *ret;

@@ -854,7 +854,7 @@
 		return -1;

 	while (!ntfs_attrs_walk(fsck->ctx)) {
-		if (fsck->ctx->attr->type == AT_END)
+		if (fsck->ctx->attr->type == NTFS_AT_END)
 			break;
 		build_lcn_usage_bitmap(vol, fsck);
 	}
@@ -1012,7 +1012,7 @@
 	for (; inode < nr_mft_records; inode++) {
 		progress_update(&progress, inode);

-		if ((ni = ntfs_inode_open(vol, (MFT_REF)inode)) == NULL) {
+		if ((ni = ntfs_inode_open(vol, (NTFS_MFT_REF)inode)) == NULL) {
 			/* FIXME: continue only if it make sense, e.g.
 			   MFT record not in use based on $MFT bitmap */
 			if (errno == EIO || errno == ENOENT)
@@ -1039,7 +1039,7 @@
 static void build_resize_constraints(ntfs_resize_t *resize)
 {
 	s64 i;
-	runlist *rl;
+	ntfs_runlist *rl;

 	if (!resize->ctx->attr->non_resident)
 		return;
@@ -1049,8 +1049,8 @@
 		perr_exit("ntfs_decompress_mapping_pairs");

 	for (i = 0; rl[i].length; i++) {
-		/* CHECKME: LCN_RL_NOT_MAPPED check isn't needed */
-		if (rl[i].lcn == LCN_HOLE || rl[i].lcn == LCN_RL_NOT_MAPPED)
+		/* CHECKME: NTFS_LCN_RL_NOT_MAPPED check isn't needed */
+		if (rl[i].lcn == NTFS_LCN_HOLE || rl[i].lcn == NTFS_LCN_RL_NOT_MAPPED)
 			continue;

 		collect_resize_constraints(resize, rl + i);
@@ -1066,7 +1066,7 @@
 		exit(1);

 	while (!ntfs_attrs_walk(resize->ctx)) {
-		if (resize->ctx->attr->type == AT_END)
+		if (resize->ctx->attr->type == NTFS_AT_END)
 			break;
 		build_resize_constraints(resize);
 	}
@@ -1086,7 +1086,7 @@

 	for (inode = 0; inode < nr_mft_records; inode++) {

-		ni = ntfs_inode_open(resize->vol, (MFT_REF)inode);
+		ni = ntfs_inode_open(resize->vol, (NTFS_MFT_REF)inode);
 		if (ni == NULL) {
 			if (errno == EIO || errno == ENOENT)
 				continue;
@@ -1104,30 +1104,30 @@
 	}
 }

-static void rl_fixup(runlist **rl)
+static void rl_fixup(ntfs_runlist **rl)
 {
-	runlist *tmp = *rl;
+	ntfs_runlist *tmp = *rl;

-	if (tmp->lcn == LCN_RL_NOT_MAPPED) {
+	if (tmp->lcn == NTFS_LCN_RL_NOT_MAPPED) {
 		s64 unmapped_len = tmp->length;

 		ntfs_log_verbose("Skip unmapped run at the beginning ...\n");

 		if (!tmp->length)
-			err_exit("Empty unmapped runlist! Please report!\n");
+			err_exit("Empty unmapped ntfs_runlist! Please report!\n");
 		(*rl)++;
 		for (tmp = *rl; tmp->length; tmp++)
 			tmp->vcn -= unmapped_len;
 	}

 	for (tmp = *rl; tmp->length; tmp++) {
-		if (tmp->lcn == LCN_RL_NOT_MAPPED) {
+		if (tmp->lcn == NTFS_LCN_RL_NOT_MAPPED) {
 			ntfs_log_verbose("Skip unmapped run at the end  ...\n");

 			if (tmp[1].length)
-				err_exit("Unmapped runlist in the middle! "
+				err_exit("Unmapped ntfs_runlist in the middle! "
 					 "Please report!\n");
-			tmp->lcn = LCN_ENOENT;
+			tmp->lcn = NTFS_LCN_ENOENT;
 			tmp->length = 0;
 		}
 	}
@@ -1135,11 +1135,11 @@

 static void replace_attribute_runlist(ntfs_volume *vol,
 				      ntfs_attr_search_ctx *ctx,
-				      runlist *rl)
+				      ntfs_runlist *rl)
 {
 	int mp_size, l;
 	void *mp;
-	ATTR_RECORD *a = ctx->attr;
+	NTFS_ATTR_RECORD *a = ctx->attr;

 	rl_fixup(&rl);

@@ -1219,19 +1219,19 @@
 		ntfs_bit_set(bm->bm, pos++, bit);
 }

-static void set_bitmap_clusters(struct bitmap *bm, runlist *rl, u8 bit)
+static void set_bitmap_clusters(struct bitmap *bm, ntfs_runlist *rl, u8 bit)
 {
 	for (; rl->length; rl++)
 		set_bitmap_range(bm, rl->lcn, rl->length, bit);
 }

-static void release_bitmap_clusters(struct bitmap *bm, runlist *rl)
+static void release_bitmap_clusters(struct bitmap *bm, ntfs_runlist *rl)
 {
 	max_free_cluster_range = 0;
 	set_bitmap_clusters(bm, rl, 0);
 }

-static void set_max_free_zone(s64 length, s64 end, runlist_element *rle)
+static void set_max_free_zone(s64 length, s64 end, ntfs_runlist_element *rle)
 {
 	if (length > rle->length) {
 		rle->lcn = end - length;
@@ -1240,7 +1240,7 @@
 }

 static int find_free_cluster(struct bitmap *bm,
-			     runlist_element *rle,
+			     ntfs_runlist_element *rle,
 			     s64 nr_vol_clusters,
 			     int hint)
 {
@@ -1296,13 +1296,13 @@
 	return 0;
 }

-static runlist *alloc_cluster(struct bitmap *bm,
+static ntfs_runlist *alloc_cluster(struct bitmap *bm,
 			      s64 items,
 			      s64 nr_vol_clusters,
 			      int hint)
 {
-	runlist_element rle;
-	runlist *rl = NULL;
+	ntfs_runlist_element rle;
+	ntfs_runlist *rl = NULL;
 	int rl_size, runs = 0;
 	s64 vcn = 0;

@@ -1319,8 +1319,8 @@
 		if (find_free_cluster(bm, &rle, nr_vol_clusters, hint) == -1)
 			return NULL;

-		rl_size = (runs + 2) * sizeof(runlist_element);
-		if (!(rl = (runlist *)realloc(rl, rl_size)))
+		rl_size = (runs + 2) * sizeof(ntfs_runlist_element);
+		if (!(rl = (ntfs_runlist *)realloc(rl, rl_size)))
 			return NULL;

 		rl_set(rl + runs, vcn, rle.lcn, rle.length);
@@ -1388,7 +1388,7 @@
  * Write an MFT Record back to the disk.  If the read-only command line option
  * was given, this function will do nothing.
  */
-static int write_mft_record(ntfs_volume *v, const MFT_REF mref, MFT_RECORD *buf)
+static int write_mft_record(ntfs_volume *v, const NTFS_MFT_REF mref, NTFS_MFT_RECORD *buf)
 {
 	if (ntfs_mft_record_write(v, mref, buf))
 		perr_exit("ntfs_mft_record_write");
@@ -1440,10 +1440,10 @@
 	}
 }

-static void relocate_clusters(ntfs_resize_t *r, runlist *dest_rl, s64 src_lcn)
+static void relocate_clusters(ntfs_resize_t *r, ntfs_runlist *dest_rl, s64 src_lcn)
 {
 	/* collect_shrink_constraints() ensured $MFTMir DATA is one run */
-	if (r->mref == FILE_MFTMirr && r->ctx->attr->type == AT_DATA) {
+	if (r->mref == NTFS_FILE_MFTMirr && r->ctx->attr->type == NTFS_AT_DATA) {
 		if (!r->mftmir_old) {
 			r->mftmir_rl.lcn = dest_rl->lcn;
 			r->mftmir_rl.length = dest_rl->length;
@@ -1456,16 +1456,16 @@
 		copy_clusters(r, dest_rl->lcn, src_lcn, dest_rl->length);
 }

-static void rl_split_run(runlist **rl, int run, s64 pos)
+static void rl_split_run(ntfs_runlist **rl, int run, s64 pos)
 {
-	runlist *rl_new, *rle_new, *rle;
+	ntfs_runlist *rl_new, *rle_new, *rle;
 	int items, new_size, size_head, size_tail;
 	s64 len_head, len_tail;

 	items = rl_items(*rl);
-	new_size = (items + 1) * sizeof(runlist_element);
-	size_head = run * sizeof(runlist_element);
-	size_tail = (items - run - 1) * sizeof(runlist_element);
+	new_size = (items + 1) * sizeof(ntfs_runlist_element);
+	size_head = run * sizeof(ntfs_runlist_element);
+	size_tail = (items - run - 1) * sizeof(ntfs_runlist_element);

 	rl_new = ntfs_malloc(new_size);
 	if (!rl_new)
@@ -1490,19 +1490,19 @@
 	*rl = rl_new;
 }

-static void rl_insert_at_run(runlist **rl, int run, runlist *ins)
+static void rl_insert_at_run(ntfs_runlist **rl, int run, ntfs_runlist *ins)
 {
 	int items, ins_items;
 	int new_size, size_tail;
-	runlist *rle;
+	ntfs_runlist *rle;
 	s64 vcn;

 	items  = rl_items(*rl);
 	ins_items = rl_items(ins) - 1;
-	new_size = ((items - 1) + ins_items) * sizeof(runlist_element);
-	size_tail = (items - run - 1) * sizeof(runlist_element);
+	new_size = ((items - 1) + ins_items) * sizeof(ntfs_runlist_element);
+	size_tail = (items - run - 1) * sizeof(ntfs_runlist_element);

-	if (!(*rl = (runlist *)realloc(*rl, new_size)))
+	if (!(*rl = (ntfs_runlist *)realloc(*rl, new_size)))
 		perr_exit("realloc");

 	rle = *rl + run;
@@ -1520,11 +1520,11 @@
 //	(*rl + run)->lcn = ins->lcn;
 }

-static void relocate_run(ntfs_resize_t *resize, runlist **rl, int run)
+static void relocate_run(ntfs_resize_t *resize, ntfs_runlist **rl, int run)
 {
 	s64 lcn, lcn_length;
-	s64 new_vol_size;	/* (last LCN on the volume) + 1 */
-	runlist *relocate_rl;	/* relocate runlist to relocate_rl */
+	s64 new_vol_size;	/* (last NTFS_LCN on the volume) + 1 */
+	ntfs_runlist *relocate_rl;	/* relocate ntfs_runlist to relocate_rl */
 	int hint;

 	lcn = (*rl + run)->lcn;
@@ -1539,7 +1539,7 @@
 		return;
 	}

-	hint = (resize->mref == FILE_MFTMirr) ? 1 : 0;
+	hint = (resize->mref == NTFS_FILE_MFTMirr) ? 1 : 0;
 	if (!(relocate_rl = alloc_cluster(&resize->lcn_bitmap, lcn_length,
 					  new_vol_size, hint)))
 		perr_exit("Cluster allocation failed for %llu:%lld",
@@ -1566,8 +1566,8 @@

 static void relocate_attribute(ntfs_resize_t *resize)
 {
-	ATTR_RECORD *a;
-	runlist *rl;
+	NTFS_ATTR_RECORD *a;
+	ntfs_runlist *rl;
 	int i;

 	a = resize->ctx->attr;
@@ -1582,12 +1582,12 @@
 		s64 lcn = rl[i].lcn;
 		s64 lcn_length = rl[i].length;

-		if (lcn == LCN_HOLE || lcn == LCN_RL_NOT_MAPPED)
+		if (lcn == NTFS_LCN_HOLE || lcn == NTFS_LCN_RL_NOT_MAPPED)
 			continue;

 		/* FIXME: ntfs_mapping_pairs_decompress should return error */
 		if (lcn < 0 || lcn_length <= 0)
-			err_exit("Corrupt runlist in MTF %llu attr %x LCN "
+			err_exit("Corrupt ntfs_runlist in MTF %llu attr %x NTFS_LCN "
 				 "%llx length %llx\n", resize->mref,
 				 (unsigned int)le32_to_cpu(a->type),
 				 lcn, lcn_length);
@@ -1605,14 +1605,14 @@

 static int is_mftdata(ntfs_resize_t *resize)
 {
-	if (resize->ctx->attr->type != AT_DATA)
+	if (resize->ctx->attr->type != NTFS_AT_DATA)
 		return 0;

 	if (resize->mref == 0)
 		return 1;

-	if (MREF_LE(resize->mrec->base_mft_record) == 0 &&
-	    MSEQNO_LE(resize->mrec->base_mft_record) != 0)
+	if (NTFS_MREF_LE(resize->mrec->base_mft_record) == 0 &&
+	    NTFS_MSEQNO_LE(resize->mrec->base_mft_record) != 0)
 		return 1;

 	return 0;
@@ -1620,8 +1620,8 @@

 static int handle_mftdata(ntfs_resize_t *resize, int do_mftdata)
 {
-	ATTR_RECORD *attr = resize->ctx->attr;
-	VCN highest_vcn, lowest_vcn;
+	NTFS_ATTR_RECORD *attr = resize->ctx->attr;
+	NTFS_VCN highest_vcn, lowest_vcn;

 	if (do_mftdata) {

@@ -1660,7 +1660,7 @@
 		exit(1);

 	while (!ntfs_attrs_walk(resize->ctx)) {
-		if (resize->ctx->attr->type == AT_END)
+		if (resize->ctx->attr->type == NTFS_AT_END)
 			break;

 		if (handle_mftdata(resize, do_mftdata) == 0)
@@ -1672,8 +1672,8 @@
 		else if (ret == 1)
 			continue;

-		if (resize->mref == FILE_Bitmap &&
-		    resize->ctx->attr->type == AT_DATA)
+		if (resize->mref == NTFS_FILE_Bitmap &&
+		    resize->ctx->attr->type == NTFS_AT_DATA)
 			continue;

 		relocate_attribute(resize);
@@ -1682,7 +1682,7 @@
 	ntfs_attr_put_search_ctx(resize->ctx);
 }

-static void relocate_inode(ntfs_resize_t *resize, MFT_REF mref, int do_mftdata)
+static void relocate_inode(ntfs_resize_t *resize, NTFS_MFT_REF mref, int do_mftdata)
 {
 	if (ntfs_file_record_read(resize->vol, mref, &resize->mrec, NULL)) {
 		/* FIXME: continue only if it make sense, e.g.
@@ -1692,7 +1692,7 @@
 		perr_exit("ntfs_file_record_record");
 	}

-	if (!(resize->mrec->flags & MFT_RECORD_IN_USE))
+	if (!(resize->mrec->flags & NTFS_MFT_RECORD_IN_USE))
 		return;

 	resize->mref = mref;
@@ -1711,8 +1711,8 @@
 static void relocate_inodes(ntfs_resize_t *resize)
 {
 	s64 nr_mft_records;
-	MFT_REF mref;
-	VCN highest_vcn;
+	NTFS_MFT_REF mref;
+	NTFS_VCN highest_vcn;

 	printf("Relocating needed data ...\n");

@@ -1726,7 +1726,7 @@
 	nr_mft_records = resize->vol->mft_na->initialized_size >>
 			resize->vol->mft_record_size_bits;

-	for (mref = 0; mref < (MFT_REF)nr_mft_records; mref++)
+	for (mref = 0; mref < (NTFS_MFT_REF)nr_mft_records; mref++)
 		relocate_inode(resize, mref, 0);

 	while (1) {
@@ -1785,47 +1785,47 @@
 }


-static void rl_expand(runlist **rl, const VCN last_vcn)
+static void rl_expand(ntfs_runlist **rl, const NTFS_VCN last_vcn)
 {
 	int len;
-	runlist *p = *rl;
+	ntfs_runlist *p = *rl;

 	len = rl_items(p) - 1;
 	if (len <= 0)
-		err_exit("rl_expand: bad runlist length: %d\n", len);
+		err_exit("rl_expand: bad ntfs_runlist length: %d\n", len);

 	if (p[len].vcn > last_vcn)
 		err_exit("rl_expand: length is already more than requested "
 			 "(%lld > %lld)\n", p[len].vcn, last_vcn);

-	if (p[len - 1].lcn == LCN_HOLE) {
+	if (p[len - 1].lcn == NTFS_LCN_HOLE) {

 		p[len - 1].length += last_vcn - p[len].vcn;
 		p[len].vcn = last_vcn;

 	} else if (p[len - 1].lcn >= 0) {

-		p = realloc(*rl, (++len + 1) * sizeof(runlist_element));
+		p = realloc(*rl, (++len + 1) * sizeof(ntfs_runlist_element));
 		if (!p)
 			perr_exit("rl_expand: realloc");

-		p[len - 1].lcn = LCN_HOLE;
+		p[len - 1].lcn = NTFS_LCN_HOLE;
 		p[len - 1].length = last_vcn - p[len - 1].vcn;
-		rl_set(p + len, last_vcn, LCN_ENOENT, 0LL);
+		rl_set(p + len, last_vcn, NTFS_LCN_ENOENT, 0LL);
 		*rl = p;

 	} else
-		err_exit("rl_expand: bad LCN: %lld\n", p[len - 1].lcn);
+		err_exit("rl_expand: bad NTFS_LCN: %lld\n", p[len - 1].lcn);
 }

-static void rl_truncate(runlist **rl, const VCN last_vcn)
+static void rl_truncate(ntfs_runlist **rl, const NTFS_VCN last_vcn)
 {
 	int len;
-	VCN vcn;
+	NTFS_VCN vcn;

 	len = rl_items(*rl) - 1;
 	if (len <= 0)
-		err_exit("rl_truncate: bad runlist length: %d\n", len);
+		err_exit("rl_truncate: bad ntfs_runlist length: %d\n", len);

 	vcn = (*rl)[len].vcn;

@@ -1859,8 +1859,8 @@
  */
 static void truncate_badclust_bad_attr(ntfs_resize_t *resize)
 {
-	ATTR_RECORD *a;
-	runlist *rl_bad;
+	NTFS_ATTR_RECORD *a;
+	ntfs_runlist *rl_bad;
 	s64 nr_clusters = resize->new_volume_size;
 	ntfs_volume *vol = resize->vol;

@@ -1890,12 +1890,12 @@
  * per cluster of the shrunken volume.  Also it must be a of 8 bytes in size.
  */
 static void realloc_bitmap_data_attr(ntfs_resize_t *resize,
-				     runlist **rl,
+				     ntfs_runlist **rl,
 				     s64 nr_bm_clusters)
 {
 	s64 i;
 	ntfs_volume *vol = resize->vol;
-	ATTR_RECORD *a = resize->ctx->attr;
+	NTFS_ATTR_RECORD *a = resize->ctx->attr;
 	s64 new_size = resize->new_volume_size;
 	struct bitmap *bm = &resize->lcn_bitmap;

@@ -1929,8 +1929,8 @@
  */
 static void truncate_bitmap_data_attr(ntfs_resize_t *resize)
 {
-	ATTR_RECORD *a;
-	runlist *rl;
+	NTFS_ATTR_RECORD *a;
+	ntfs_runlist *rl;
 	s64 bm_bsize, size;
 	s64 nr_bm_clusters;
 	ntfs_volume *vol = resize->vol;
@@ -1981,7 +1981,7 @@
  * (inode number).
  */
 static void lookup_data_attr(ntfs_volume *vol,
-			     MFT_REF mref,
+			     NTFS_MFT_REF mref,
 			     const char *aname,
 			     ntfs_attr_search_ctx **ctx)
 {
@@ -2000,7 +2000,7 @@
 		exit(1);
 	}

-	if (ntfs_attr_lookup(AT_DATA, ustr, len, 0, 0, NULL, 0, *ctx))
+	if (ntfs_attr_lookup(NTFS_AT_DATA, ustr, len, 0, 0, NULL, 0, *ctx))
 		perr_exit("ntfs_lookup_attr");

 	ntfs_ucsfree(ustr);
@@ -2010,12 +2010,12 @@
 {
 	ntfs_attr_search_ctx *ctx;
 	ntfs_inode *base_ni;
-	runlist *rl;
+	ntfs_runlist *rl;
 	s64 i, badclusters = 0;

 	ntfs_log_verbose("Checking for bad sectors ...\n");

-	lookup_data_attr(vol, FILE_BadClus, "$Bad", &ctx);
+	lookup_data_attr(vol, NTFS_FILE_BadClus, "$Bad", &ctx);

 	base_ni = ctx->base_ntfs_ino;
 	if (!base_ni)
@@ -2039,8 +2039,8 @@
 		perr_exit("Decompressing $BadClust:$Bad mapping pairs failed");

 	for (i = 0; rl[i].length; i++) {
-		/* CHECKME: LCN_RL_NOT_MAPPED check isn't needed */
-		if (rl[i].lcn == LCN_HOLE || rl[i].lcn == LCN_RL_NOT_MAPPED)
+		/* CHECKME: NTFS_LCN_RL_NOT_MAPPED check isn't needed */
+		if (rl[i].lcn == NTFS_LCN_HOLE || rl[i].lcn == NTFS_LCN_RL_NOT_MAPPED)
 			continue;

 		badclusters += rl[i].length;
@@ -2077,7 +2077,7 @@
 {
 	printf("Updating $BadClust file ...\n");

-	lookup_data_attr(resize->vol, FILE_BadClus, "$Bad", &resize->ctx);
+	lookup_data_attr(resize->vol, NTFS_FILE_BadClus, "$Bad", &resize->ctx);
 	/* FIXME: sanity_check_attr(ctx->attr); */
 	truncate_badclust_bad_attr(resize);

@@ -2097,7 +2097,7 @@
 {
 	printf("Updating $Bitmap file ...\n");

-	lookup_data_attr(resize->vol, FILE_Bitmap, NULL, &resize->ctx);
+	lookup_data_attr(resize->vol, NTFS_FILE_Bitmap, NULL, &resize->ctx);
 	truncate_bitmap_data_attr(resize);

 	if (write_mft_record(resize->vol, resize->ctx->ntfs_ino->mft_no,
@@ -2292,7 +2292,7 @@
 {
 	printf("Schedule chkdsk for NTFS consistency check at Windows boot "
 			"time ...\n");
-	vol->flags |= VOLUME_IS_DIRTY;
+	vol->flags |= NTFS_VOLUME_IS_DIRTY;
 	if (ntfs_volume_write_flags(vol, vol->flags))
 		perr_exit("Failed to set the volume dirty");
 	NVolSetWasDirty(vol);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfstruncate.c ./ntfsprogs/ntfstruncate.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfstruncate.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfstruncate.c	2007-10-06 16:48:07.000000000 +0200
@@ -58,20 +58,20 @@
 #	define LLONG_MAX 9223372036854775807LL
 #endif

-#include "types.h"
-#include "attrib.h"
-#include "inode.h"
-#include "layout.h"
-#include "volume.h"
+#include "ntfs_types.h"
+#include "ntfs_attrib.h"
+#include "ntfs_inode.h"
+#include "ntfs_layout.h"
+#include "ntfs_volume.h"
 #include "utils.h"
 #include "attrdef.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 const char *EXEC_NAME = "ntfstruncate";

 /* Need these global so ntfstruncate_exit can access them. */
-BOOL success = FALSE;
+NTFS_BOOL success = FALSE;

 char *dev_name;
 s64 inode;
@@ -84,7 +84,7 @@
 ntfs_inode *ni;
 ntfs_attr *na = NULL;

-ATTR_DEF *attr_defs;
+NTFS_ATTR_DEF *attr_defs;

 struct {
 				/* -h, print usage and exit. */
@@ -226,8 +226,8 @@
 	/* Get the attribute type, if specified. */
 	s = argv[optind++];
 	if (optind == argc) {
-		attr_type = AT_DATA;
-		attr_name = AT_UNNAMED;
+		attr_type = NTFS_AT_DATA;
+		attr_name = NTFS_AT_UNNAMED;
 		attr_name_len = 0;
 	} else {
 		unsigned long ul;
@@ -254,12 +254,12 @@
 			if (optind != argc)
 				usage();
 		} else {
-			attr_name = AT_UNNAMED;
+			attr_name = NTFS_AT_UNNAMED;
 			attr_name_len = 0;
 		}
 	}
 	ntfs_log_verbose("attribute type = 0x%x\n", (unsigned int)attr_type);
-	if (attr_name == AT_UNNAMED)
+	if (attr_name == NTFS_AT_UNNAMED)
 		ntfs_log_verbose("attribute name = \"\" (UNNAMED)\n");
 	else
 		ntfs_log_verbose("attribute name = \"%s\" (length %u Unicode "
@@ -306,7 +306,7 @@
 /**
  * dump_resident_attr_val
  */
-static void dump_resident_attr_val(ATTR_TYPES type, char *val, u32 val_len)
+static void dump_resident_attr_val(NTFS_ATTR_TYPES type, char *val, u32 val_len)
 {
 	const char *don_t_know = "Don't know what to do with this attribute "
 			"type yet.";
@@ -317,27 +317,27 @@
 	u32 u;

 	switch (type) {
-	case AT_STANDARD_INFORMATION:
+	case NTFS_AT_STANDARD_INFORMATION:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_ATTRIBUTE_LIST:
+	case NTFS_AT_ATTRIBUTE_LIST:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_FILE_NAME:
+	case NTFS_AT_FILE_NAME:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_OBJECT_ID:
+	case NTFS_AT_OBJECT_ID:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_SECURITY_DESCRIPTOR:
+	case NTFS_AT_SECURITY_DESCRIPTOR:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_VOLUME_NAME:
+	case NTFS_AT_VOLUME_NAME:
 		printf("Volume name length = %u\n", (unsigned int)val_len);
 		if (val_len) {
 			buf = calloc(1, val_len);
@@ -352,8 +352,8 @@
 			free(buf);
 		}
 		return;
-	case AT_VOLUME_INFORMATION:
-#define VOL_INF(x) ((VOLUME_INFORMATION *)(x))
+	case NTFS_AT_VOLUME_INFORMATION:
+#define VOL_INF(x) ((NTFS_VOLUME_INFORMATION *)(x))
 		printf("NTFS version %i.%i\n", VOL_INF(val)->major_ver,
 				VOL_INF(val)->minor_ver);
 		i = VOL_INF(val)->flags;
@@ -364,81 +364,81 @@
 			return;
 		}
 		j = 0;
-		if (i & VOLUME_MODIFIED_BY_CHKDSK) {
+		if (i & NTFS_VOLUME_MODIFIED_BY_CHKDSK) {
 			j = 1;
-			printf("VOLUME_MODIFIED_BY_CHKDSK");
+			printf("NTFS_VOLUME_MODIFIED_BY_CHKDSK");
 		}
-		if (i & VOLUME_REPAIR_OBJECT_ID) {
+		if (i & NTFS_VOLUME_REPAIR_OBJECT_ID) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_REPAIR_OBJECT_ID");
+			printf("NTFS_VOLUME_REPAIR_OBJECT_ID");
 		}
-		if (i & VOLUME_DELETE_USN_UNDERWAY) {
+		if (i & NTFS_VOLUME_DELETE_USN_UNDERWAY) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_DELETE_USN_UNDERWAY");
+			printf("NTFS_VOLUME_DELETE_USN_UNDERWAY");
 		}
-		if (i & VOLUME_MOUNTED_ON_NT4) {
+		if (i & NTFS_VOLUME_MOUNTED_ON_NT4) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_MOUNTED_ON_NT4");
+			printf("NTFS_VOLUME_MOUNTED_ON_NT4");
 		}
-		if (i & VOLUME_UPGRADE_ON_MOUNT) {
+		if (i & NTFS_VOLUME_UPGRADE_ON_MOUNT) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_UPGRADE_ON_MOUNT");
+			printf("NTFS_VOLUME_UPGRADE_ON_MOUNT");
 		}
-		if (i & VOLUME_RESIZE_LOG_FILE) {
+		if (i & NTFS_VOLUME_RESIZE_LOG_FILE) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_RESIZE_LOG_FILE");
+			printf("NTFS_VOLUME_RESIZE_LOG_FILE");
 		}
-		if (i & VOLUME_IS_DIRTY) {
+		if (i & NTFS_VOLUME_IS_DIRTY) {
 			if (j)
 				printf(" | ");
 			else
 				j = 0;
-			printf("VOLUME_IS_DIRTY");
+			printf("NTFS_VOLUME_IS_DIRTY");
 		}
 		printf("\n");
 		return;
-	case AT_DATA:
+	case NTFS_AT_DATA:
 		printf(skip, "DATA");
 		return;
-	case AT_INDEX_ROOT:
+	case NTFS_AT_INDEX_ROOT:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_INDEX_ALLOCATION:
+	case NTFS_AT_INDEX_ALLOCATION:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_BITMAP:
+	case NTFS_AT_BITMAP:
 		printf(skip, "BITMAP");
 		return;
-	case AT_REPARSE_POINT:
+	case NTFS_AT_REPARSE_POINT:
 		// TODO
 		printf("%s\n", todo);
 		return;
-	case AT_EA_INFORMATION:
+	case NTFS_AT_EA_INFORMATION:
 		// TODO
 		printf("%s\n", don_t_know);
 		return;
-	case AT_EA:
+	case NTFS_AT_EA:
 		// TODO
 		printf("%s\n", don_t_know);
 		return;
-	case AT_LOGGED_UTILITY_STREAM:
+	case NTFS_AT_LOGGED_UTILITY_STREAM:
 		// TODO
 		printf("%s\n", don_t_know);
 		return;
@@ -446,7 +446,7 @@
 		u = le32_to_cpu(type);
 		printf("Cannot display unknown %s defined attribute type 0x%x"
 				".\n", u >=
-				le32_to_cpu(AT_FIRST_USER_DEFINED_ATTRIBUTE) ?
+				le32_to_cpu(NTFS_AT_FIRST_USER_DEFINED_ATTRIBUTE) ?
 				"user" : "system", (unsigned int)u);
 	}
 }
@@ -454,7 +454,7 @@
 /**
  * dump_resident_attr
  */
-static void dump_resident_attr(ATTR_RECORD *a)
+static void dump_resident_attr(NTFS_ATTR_RECORD *a)
 {
 	int i;

@@ -466,10 +466,10 @@
 	printf("Resident flags = 0x%x: ", i);
 	if (!i)
 		printf("NONE\n");
-	else if (i & ~RESIDENT_ATTR_IS_INDEXED)
+	else if (i & ~NTFS_RESIDENT_ATTR_IS_INDEXED)
 		printf("UNKNOWN FLAG(S)\n");
 	else
-		printf("RESIDENT_ATTR_IS_INDEXED\n");
+		printf("NTFS_RESIDENT_ATTR_IS_INDEXED\n");
 	dump_resident_attr_val(a->type, (char*)a + le16_to_cpu(a->value_offset),
 			le32_to_cpu(a->value_length));
 }
@@ -487,16 +487,16 @@
 /**
  * dump_non_resident_attr
  */
-static void dump_non_resident_attr(ATTR_RECORD *a)
+static void dump_non_resident_attr(NTFS_ATTR_RECORD *a)
 {
 	s64 l;
 	int i;

 	l = sle64_to_cpu(a->lowest_vcn);
-	printf("Lowest VCN = %lli (0x%llx)\n", (long long)l,
+	printf("Lowest NTFS_VCN = %lli (0x%llx)\n", (long long)l,
 			(unsigned long long)l);
 	l = sle64_to_cpu(a->highest_vcn);
-	printf("Highest VCN = %lli (0x%llx)\n", (long long)l,
+	printf("Highest NTFS_VCN = %lli (0x%llx)\n", (long long)l,
 			(unsigned long long)l);
 	printf("Mapping pairs array offset = 0x%x\n",
 			le16_to_cpu(a->mapping_pairs_offset));
@@ -514,7 +514,7 @@
 	l = sle64_to_cpu(a->initialized_size);
 	printf("Initialized size = %lli (0x%llx)\n", (long long)l,
 			(unsigned long long)l);
-	if (a->flags & ATTR_COMPRESSION_MASK) {
+	if (a->flags & NTFS_ATTR_COMPRESSION_MASK) {
 		l = sle64_to_cpu(a->compressed_size);
 		printf("Compressed size = %lli (0x%llx)\n", (long long)l,
 				(unsigned long long)l);
@@ -526,7 +526,7 @@
 /**
  * dump_attr_record
  */
-static void dump_attr_record(MFT_RECORD *m, ATTR_RECORD *a)
+static void dump_attr_record(NTFS_MFT_RECORD *m, NTFS_ATTR_RECORD *a)
 {
 	unsigned int u;
 	char s[0x200];
@@ -534,9 +534,9 @@

 	printf("-- Beginning dump of attribute record at offset 0x%x. --\n",
 			(unsigned)((u8*)a - (u8*)m));
-	if (a->type == AT_END) {
+	if (a->type == NTFS_AT_END) {
 		printf("Attribute type = 0x%x ($END)\n",
-				(unsigned int)le32_to_cpu(AT_END));
+				(unsigned int)le32_to_cpu(NTFS_AT_END));
 		u = le32_to_cpu(a->length);
 		printf("Length of resident part = %u (0x%x)\n", u, u);
 		return;
@@ -584,12 +584,12 @@
 		printf("NONE");
 	else {
 		int first = TRUE;
-		if (u & ATTR_COMPRESSION_MASK) {
-			if (u & ATTR_IS_COMPRESSED) {
-				printf("ATTR_IS_COMPRESSED");
+		if (u & NTFS_ATTR_COMPRESSION_MASK) {
+			if (u & NTFS_ATTR_IS_COMPRESSED) {
+				printf("NTFS_ATTR_IS_COMPRESSED");
 				first = FALSE;
 			}
-			if ((u & ATTR_COMPRESSION_MASK) & ~ATTR_IS_COMPRESSED) {
+			if ((u & NTFS_ATTR_COMPRESSION_MASK) & ~NTFS_ATTR_IS_COMPRESSED) {
 				if (!first)
 					printf(" | ");
 				else
@@ -597,19 +597,19 @@
 				printf("ATTR_UNKNOWN_COMPRESSION");
 			}
 		}
-		if (u & ATTR_IS_ENCRYPTED) {
+		if (u & NTFS_ATTR_IS_ENCRYPTED) {
 			if (!first)
 				printf(" | ");
 			else
 				first = FALSE;
-			printf("ATTR_IS_ENCRYPTED");
+			printf("NTFS_ATTR_IS_ENCRYPTED");
 		}
-		if (u & ATTR_IS_SPARSE) {
+		if (u & NTFS_ATTR_IS_SPARSE) {
 			if (!first)
 				printf(" | ");
 			else
 				first = FALSE;
-			printf("ATTR_IS_SPARSE");
+			printf("NTFS_ATTR_IS_SPARSE");
 		}
 	}
 	printf("\n");
@@ -624,11 +624,11 @@
 /**
  * dump_mft_record
  */
-static void dump_mft_record(MFT_RECORD *m)
+static void dump_mft_record(NTFS_MFT_RECORD *m)
 {
-	ATTR_RECORD *a;
+	NTFS_ATTR_RECORD *a;
 	unsigned int u;
-	MFT_REF r;
+	NTFS_MFT_REF r;

 	printf("-- Beginning dump of mft record. --\n");
 	u = le32_to_cpu(m->magic);
@@ -645,12 +645,12 @@
 	u = le16_to_cpu(m->attrs_offset);
 	printf("First attribute offset = %u (0x%x)\n", u, u);
 	printf("Flags = %u: ", le16_to_cpu(m->flags));
-	if (m->flags & MFT_RECORD_IN_USE)
-		printf("MFT_RECORD_IN_USE");
+	if (m->flags & NTFS_MFT_RECORD_IN_USE)
+		printf("NTFS_MFT_RECORD_IN_USE");
 	else
 		printf("MFT_RECORD_NOT_IN_USE");
-	if (m->flags & MFT_RECORD_IS_DIRECTORY)
-		printf(" | MFT_RECORD_IS_DIRECTORY");
+	if (m->flags & NTFS_MFT_RECORD_IS_DIRECTORY)
+		printf(" | NTFS_MFT_RECORD_IS_DIRECTORY");
 	printf("\n");
 	u = le32_to_cpu(m->bytes_in_use);
 	printf("Bytes in use = %u (0x%x)\n", u, u);
@@ -659,17 +659,17 @@
 	r = le64_to_cpu(m->base_mft_record);
 	printf("Base mft record reference:\n\tMft record number = %llu\n\t"
 			"Sequence number = %u\n",
-			(unsigned long long)MREF(r), MSEQNO(r));
+			(unsigned long long)NTFS_MREF(r), NTFS_MSEQNO(r));
 	printf("Next attribute instance = %u\n",
 			le16_to_cpu(m->next_attr_instance));
-	a = (ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
+	a = (NTFS_ATTR_RECORD*)((char*)m + le16_to_cpu(m->attrs_offset));
 	printf("-- Beginning dump of attributes within mft record. --\n");
 	while ((char*)a < (char*)m + le32_to_cpu(m->bytes_in_use)) {
 		if (a->type == cpu_to_le32(attr_type))
 			dump_attr_record(m, a);
-		if (a->type == AT_END)
+		if (a->type == NTFS_AT_END)
 			break;
-		a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
+		a = (NTFS_ATTR_RECORD*)((char*)a + le32_to_cpu(a->length));
 	};
 	printf("-- End of attributes. --\n");
 }
@@ -716,7 +716,7 @@
 	 * Setup a default $AttrDef. FIXME: Should be reading this from the
 	 * volume itself, at ntfs_mount() time.
 	 */
-	attr_defs = (ATTR_DEF*)&attrdef_ntfs3x_array;
+	attr_defs = (NTFS_ATTR_DEF*)&attrdef_ntfs3x_array;

 	/* Parse command line options. */
 	parse_options(argc, argv);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsundelete.c ./ntfsprogs/ntfsundelete.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsundelete.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsundelete.c	2007-10-06 16:48:07.000000000 +0200
@@ -75,17 +75,17 @@
 #endif

 #include "ntfsundelete.h"
-#include "bootsect.h"
-#include "mft.h"
-#include "attrib.h"
-#include "layout.h"
-#include "inode.h"
-#include "device.h"
+#include "ntfs_bootsect.h"
+#include "ntfs_mft.h"
+#include "ntfs_attrib.h"
+#include "ntfs_layout.h"
+#include "ntfs_inode.h"
+#include "ntfs_device.h"
 #include "utils.h"
-#include "debug.h"
-#include "ntfstime.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_debug.h"
+#include "ntfs_time.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfsundelete";
 static const char *MFTFILE   = "mft";
@@ -721,13 +721,13 @@
  */
 static void free_file(struct ufile *file)
 {
-	struct list_head *item, *tmp;
+	struct ntfs_list_head *item, *tmp;

 	if (!file)
 		return;

-	list_for_each_safe(item, tmp, &file->name) { /* List of filenames */
-		struct filename *f = list_entry(item, struct filename, list);
+	ntfs_list_for_each_safe(item, tmp, &file->name) { /* List of filenames */
+		struct filename *f = ntfs_list_entry(item, struct filename, list);
 		ntfs_log_debug("freeing filename '%s'", f->name ? f->name :
 				NONE);
 		if (f->name)
@@ -741,14 +741,14 @@
 		free(f);
 	}

-	list_for_each_safe(item, tmp, &file->data) { /* List of data streams */
-		struct data *d = list_entry(item, struct data, list);
+	ntfs_list_for_each_safe(item, tmp, &file->data) { /* List of data streams */
+		struct data *d = ntfs_list_entry(item, struct data, list);
 		ntfs_log_debug("Freeing data stream '%s'.\n", d->name ?
 				d->name : UNNAMED);
 		if (d->name)
 			free(d->name);
-		if (d->runlist)
-			free(d->runlist);
+		if (d->ntfs_runlist)
+			free(d->ntfs_runlist);
 		free(d);
 	}

@@ -768,17 +768,17 @@
  * Return:	@rec's filename, either same name space as @name or lowest space.
  *		NULL if can't determine parenthood or on error.
  */
-static FILE_NAME_ATTR* verify_parent(struct filename* name, MFT_RECORD* rec)
+static NTFS_FILE_NAME_ATTR* verify_parent(struct filename* name, NTFS_MFT_RECORD* rec)
 {
-	ATTR_RECORD *attr30;
-	FILE_NAME_ATTR *filename_attr = NULL, *lowest_space_name = NULL;
+	NTFS_ATTR_RECORD *attr30;
+	NTFS_FILE_NAME_ATTR *filename_attr = NULL, *lowest_space_name = NULL;
 	ntfs_attr_search_ctx *ctx;
 	int found_same_space = 1;

 	if (!name || !rec)
 		return NULL;

-	if (!(rec->flags & MFT_RECORD_IS_DIRECTORY)) {
+	if (!(rec->flags & NTFS_MFT_RECORD_IS_DIRECTORY)) {
 		return NULL;
 	}

@@ -788,12 +788,12 @@
 		return NULL;
 	}

-	attr30 = find_attribute(AT_FILE_NAME, ctx);
+	attr30 = find_attribute(NTFS_AT_FILE_NAME, ctx);
 	if (!attr30) {
 		return NULL;
 	}

-	filename_attr = (FILE_NAME_ATTR*)((char*)attr30 + le16_to_cpu(attr30->value_offset));
+	filename_attr = (NTFS_FILE_NAME_ATTR*)((char*)attr30 + le16_to_cpu(attr30->value_offset));
 	/* if name is older than this dir -> can't determine */
 	if (ntfs2utc(filename_attr->creation_time) > name->date_c) {
 		return NULL;
@@ -803,8 +803,8 @@
 		found_same_space = 0;
 		lowest_space_name = filename_attr;

-		while (!found_same_space && (attr30 = find_attribute(AT_FILE_NAME, ctx))) {
-			filename_attr = (FILE_NAME_ATTR*)((char*)attr30 + le16_to_cpu(attr30->value_offset));
+		while (!found_same_space && (attr30 = find_attribute(NTFS_AT_FILE_NAME, ctx))) {
+			filename_attr = (NTFS_FILE_NAME_ATTR*)((char*)attr30 + le16_to_cpu(attr30->value_offset));

 			if (filename_attr->file_name_type == name->name_space) {
 				found_same_space = 1;
@@ -828,8 +828,8 @@
 static void get_parent_name(struct filename* name, ntfs_volume* vol)
 {
 	ntfs_attr* mft_data;
-	MFT_RECORD* rec;
-	FILE_NAME_ATTR* filename_attr;
+	NTFS_MFT_RECORD* rec;
+	NTFS_FILE_NAME_ATTR* filename_attr;
 	long long inode_num;

 	if (!name || !vol)
@@ -842,11 +842,11 @@
 		return;
 	}

-	mft_data = ntfs_attr_open(vol->mft_ni, AT_DATA, AT_UNNAMED, 0);
+	mft_data = ntfs_attr_open(vol->mft_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!mft_data) {
 		ntfs_log_perror("ERROR: Couldn't open $MFT/$DATA");
 	} else {
-		inode_num = MREF_LE(name->parent_mref);
+		inode_num = NTFS_MREF_LE(name->parent_mref);

 		if (ntfs_attr_pread(mft_data, vol->mft_record_size * inode_num,
 					vol->mft_record_size, rec) < 1) {
@@ -896,8 +896,8 @@
  */
 static int get_filenames(struct ufile *file, ntfs_volume* vol)
 {
-	ATTR_RECORD *rec;
-	FILE_NAME_ATTR *attr;
+	NTFS_ATTR_RECORD *rec;
+	NTFS_FILE_NAME_ATTR *attr;
 	ntfs_attr_search_ctx *ctx;
 	struct filename *name;
 	int count = 0;
@@ -910,9 +910,9 @@
 	if (!ctx)
 		return -1;

-	while ((rec = find_attribute(AT_FILE_NAME, ctx))) {
+	while ((rec = find_attribute(NTFS_AT_FILE_NAME, ctx))) {
 		/* We know this will always be resident. */
-		attr = (FILE_NAME_ATTR *)((char *)rec +
+		attr = (NTFS_FILE_NAME_ATTR *)((char *)rec +
 				le16_to_cpu(rec->value_offset));

 		name = calloc(1, sizeof(*name));
@@ -957,7 +957,7 @@
 		file->max_size = max(file->max_size, name->size_alloc);
 		file->max_size = max(file->max_size, name->size_data);

-		list_add_tail(&name->list, &file->name);
+		ntfs_list_add_tail(&name->list, &file->name);
 		count++;
 	}

@@ -983,7 +983,7 @@
  */
 static int get_data(struct ufile *file, ntfs_volume *vol)
 {
-	ATTR_RECORD *rec;
+	NTFS_ATTR_RECORD *rec;
 	ntfs_attr_search_ctx *ctx;
 	int count = 0;
 	struct data *data;
@@ -995,7 +995,7 @@
 	if (!ctx)
 		return -1;

-	while ((rec = find_attribute(AT_DATA, ctx))) {
+	while ((rec = find_attribute(NTFS_AT_DATA, ctx))) {
 		data = calloc(1, sizeof(*data));
 		if (!data) {
 			ntfs_log_error("ERROR: Couldn't allocate memory in "
@@ -1005,8 +1005,8 @@
 		}

 		data->resident   = !rec->non_resident;
-		data->compressed = (rec->flags & ATTR_IS_COMPRESSED) ? 1 : 0;
-		data->encrypted  = (rec->flags & ATTR_IS_ENCRYPTED) ? 1 : 0;
+		data->compressed = (rec->flags & NTFS_ATTR_IS_COMPRESSED) ? 1 : 0;
+		data->encrypted  = (rec->flags & NTFS_ATTR_IS_ENCRYPTED) ? 1 : 0;

 		if (rec->name_length) {
 			data->uname = (ntfschar *)((char *)rec +
@@ -1031,15 +1031,15 @@
 			data->size_vcn   = sle64_to_cpu(rec->highest_vcn) + 1;
 		}

-		data->runlist = ntfs_mapping_pairs_decompress(vol, rec, NULL);
-		if (!data->runlist) {
+		data->ntfs_runlist = ntfs_mapping_pairs_decompress(vol, rec, NULL);
+		if (!data->ntfs_runlist) {
 			ntfs_log_debug("Couldn't decompress the data runs.\n");
 		}

 		file->max_size = max(file->max_size, data->size_data);
 		file->max_size = max(file->max_size, data->size_init);

-		list_add_tail(&data->list, &file->data);
+		ntfs_list_add_tail(&data->list, &file->data);
 		count++;
 	}

@@ -1061,7 +1061,7 @@
  */
 static struct ufile * read_record(ntfs_volume *vol, long long record)
 {
-	ATTR_RECORD *attr10, *attr20, *attr90;
+	NTFS_ATTR_RECORD *attr10, *attr20, *attr90;
 	struct ufile *file;
 	ntfs_attr *mft;

@@ -1074,8 +1074,8 @@
 		return NULL;
 	}

-	INIT_LIST_HEAD(&file->name);
-	INIT_LIST_HEAD(&file->data);
+	NTFS_INIT_LIST_HEAD(&file->name);
+	NTFS_INIT_LIST_HEAD(&file->data);
 	file->inode = record;

 	file->mft = malloc(vol->mft_record_size);
@@ -1085,7 +1085,7 @@
 		return NULL;
 	}

-	mft = ntfs_attr_open(vol->mft_ni, AT_DATA, AT_UNNAMED, 0);
+	mft = ntfs_attr_open(vol->mft_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!mft) {
 		ntfs_log_perror("ERROR: Couldn't open $MFT/$DATA");
 		free_file(file);
@@ -1102,16 +1102,16 @@
 	ntfs_attr_close(mft);
 	mft = NULL;

-	attr10 = find_first_attribute(AT_STANDARD_INFORMATION,	file->mft);
-	attr20 = find_first_attribute(AT_ATTRIBUTE_LIST,	file->mft);
-	attr90 = find_first_attribute(AT_INDEX_ROOT,		file->mft);
+	attr10 = find_first_attribute(NTFS_AT_STANDARD_INFORMATION,	file->mft);
+	attr20 = find_first_attribute(NTFS_AT_ATTRIBUTE_LIST,	file->mft);
+	attr90 = find_first_attribute(NTFS_AT_INDEX_ROOT,		file->mft);

 	ntfs_log_debug("Attributes present: %s %s %s.\n", attr10?"0x10":"",
 			attr20?"0x20":"", attr90?"0x90":"");

 	if (attr10) {
-		STANDARD_INFORMATION *si;
-		si = (STANDARD_INFORMATION *) ((char *) attr10 + le16_to_cpu(attr10->value_offset));
+		NTFS_STANDARD_INFORMATION *si;
+		si = (NTFS_STANDARD_INFORMATION *) ((char *) attr10 + le16_to_cpu(attr10->value_offset));
 		file->date = ntfs2utc(si->last_data_change_time);
 	}

@@ -1154,8 +1154,8 @@
  */
 static int calc_percentage(struct ufile *file, ntfs_volume *vol)
 {
-	runlist_element *rl = NULL;
-	struct list_head *pos;
+	ntfs_runlist_element *rl = NULL;
+	struct ntfs_list_head *pos;
 	struct data *data;
 	long long i, j;
 	long long start, end;
@@ -1170,13 +1170,13 @@
 		return 0;
 	}

-	if (list_empty(&file->data)) {
+	if (ntfs_list_empty(&file->data)) {
 		ntfs_log_verbose("File has no data streams.\n");
 		return 0;
 	}

-	list_for_each(pos, &file->data) {
-		data  = list_entry(pos, struct data, list);
+	ntfs_list_for_each(pos, &file->data) {
+		data  = ntfs_list_entry(pos, struct data, list);
 		clusters_inuse = 0;
 		clusters_free  = 0;

@@ -1200,20 +1200,20 @@
 			continue;
 		}

-		rl = data->runlist;
+		rl = data->ntfs_runlist;
 		if (!rl) {
-			ntfs_log_verbose("File has no runlist, hence no data."
+			ntfs_log_verbose("File has no ntfs_runlist, hence no data."
 					"\n");
 			continue;
 		}

 		if (rl[0].length <= 0) {
-			ntfs_log_verbose("File has an empty runlist, hence no "
+			ntfs_log_verbose("File has an empty ntfs_runlist, hence no "
 					"data.\n");
 			continue;
 		}

-		if (rl[0].lcn == LCN_RL_NOT_MAPPED) { /* extended mft record */
+		if (rl[0].lcn == NTFS_LCN_RL_NOT_MAPPED) { /* extended mft record */
 			ntfs_log_verbose("Missing segment at beginning, %lld "
 					"clusters\n", (long long)rl[0].length);
 			clusters_inuse += rl[0].length;
@@ -1221,7 +1221,7 @@
 		}

 		for (i = 0; rl[i].length > 0; i++) {
-			if (rl[i].lcn == LCN_RL_NOT_MAPPED) {
+			if (rl[i].lcn == NTFS_LCN_RL_NOT_MAPPED) {
 				ntfs_log_verbose("Missing segment at end, %lld "
 						"clusters\n",
 						(long long)rl[i].length);
@@ -1229,7 +1229,7 @@
 				continue;
 			}

-			if (rl[i].lcn == LCN_HOLE) {
+			if (rl[i].lcn == NTFS_LCN_HOLE) {
 				clusters_free += rl[i].length;
 				continue;
 			}
@@ -1281,7 +1281,7 @@
 {
 	char buffer[20];
 	const char *name;
-	struct list_head *item;
+	struct ntfs_list_head *item;
 	int i;

 	if (!file)
@@ -1295,8 +1295,8 @@
 	if (file->attr_list)
 		ntfs_log_quiet("Metadata may span more than one MFT record\n");

-	list_for_each(item, &file->name) {
-		struct filename *f = list_entry(item, struct filename, list);
+	ntfs_list_for_each(item, &file->name) {
+		struct filename *f = ntfs_list_entry(item, struct filename, list);

 		if (f->name)
 			name = f->name;
@@ -1305,21 +1305,21 @@

 		ntfs_log_quiet("Filename: (%d) %s\n", f->name_space, f->name);
 		ntfs_log_quiet("File Flags: ");
-		if (f->flags & FILE_ATTR_SYSTEM)
+		if (f->flags & NTFS_FILE_ATTR_SYSTEM)
 			ntfs_log_quiet("System ");
-		if (f->flags & FILE_ATTR_DIRECTORY)
+		if (f->flags & NTFS_FILE_ATTR_DIRECTORY)
 			ntfs_log_quiet("Directory ");
-		if (f->flags & FILE_ATTR_SPARSE_FILE)
+		if (f->flags & NTFS_FILE_ATTR_SPARSE_FILE)
 			ntfs_log_quiet("Sparse ");
-		if (f->flags & FILE_ATTR_REPARSE_POINT)
+		if (f->flags & NTFS_FILE_ATTR_REPARSE_POINT)
 			ntfs_log_quiet("Reparse ");
-		if (f->flags & FILE_ATTR_COMPRESSED)
+		if (f->flags & NTFS_FILE_ATTR_COMPRESSED)
 			ntfs_log_quiet("Compressed ");
-		if (f->flags & FILE_ATTR_ENCRYPTED)
+		if (f->flags & NTFS_FILE_ATTR_ENCRYPTED)
 			ntfs_log_quiet("Encrypted ");
-		if (!(f->flags & (FILE_ATTR_SYSTEM | FILE_ATTR_DIRECTORY |
-		    FILE_ATTR_SPARSE_FILE | FILE_ATTR_REPARSE_POINT |
-		    FILE_ATTR_COMPRESSED | FILE_ATTR_ENCRYPTED))) {
+		if (!(f->flags & (NTFS_FILE_ATTR_SYSTEM | NTFS_FILE_ATTR_DIRECTORY |
+		    NTFS_FILE_ATTR_SPARSE_FILE | NTFS_FILE_ATTR_REPARSE_POINT |
+		    NTFS_FILE_ATTR_COMPRESSED | NTFS_FILE_ATTR_ENCRYPTED))) {
 			ntfs_log_quiet("%s", NONE);
 		}

@@ -1348,8 +1348,8 @@
 	}

 	ntfs_log_quiet("Data Streams:\n");
-	list_for_each(item, &file->data) {
-		struct data *d = list_entry(item, struct data, list);
+	ntfs_list_for_each(item, &file->data) {
+		struct data *d = ntfs_list_entry(item, struct data, list);
 		ntfs_log_quiet("Name: %s\n", (d->name) ? d->name : UNNAMED);
 		ntfs_log_quiet("Flags: ");
 		if (d->resident)   ntfs_log_quiet("Resident\n");
@@ -1366,13 +1366,13 @@
 		ntfs_log_quiet("Size vcn: %lld\n", d->size_vcn);

 		ntfs_log_quiet("Data runs:\n");
-		if ((!d->runlist) || (d->runlist[0].length <= 0)) {
+		if ((!d->ntfs_runlist) || (d->ntfs_runlist[0].length <= 0)) {
 			ntfs_log_quiet("    None\n");
 		} else {
-			for (i = 0; d->runlist[i].length > 0; i++) {
+			for (i = 0; d->ntfs_runlist[i].length > 0; i++) {
 				ntfs_log_quiet("    %lld @ %lld\n",
-						(long long)d->runlist[i].length,
-						(long long)d->runlist[i].lcn);
+						(long long)d->ntfs_runlist[i].length,
+						(long long)d->ntfs_runlist[i].lcn);
 			}
 		}

@@ -1409,7 +1409,7 @@
 static void list_record(struct ufile *file)
 {
 	char buffer[20];
-	struct list_head *item;
+	struct ntfs_list_head *item;
 	const char *name = NULL;
 	long long size = 0;
 	int percent = 0;
@@ -1426,8 +1426,8 @@
 	else
 		flagd = 'F';

-	list_for_each(item, &file->data) {
-		struct data *d = list_entry(item, struct data, list);
+	ntfs_list_for_each(item, &file->data) {
+		struct data *d = ntfs_list_entry(item, struct data, list);

 		if (!d->name) {
 			if (d->resident)
@@ -1470,14 +1470,14 @@
  */
 static int name_match(regex_t *re, struct ufile *file)
 {
-	struct list_head *item;
+	struct ntfs_list_head *item;
 	int result;

 	if (!re || !file)
 		return 0;

-	list_for_each(item, &file->name) {
-		struct filename *f = list_entry(item, struct filename, list);
+	ntfs_list_for_each(item, &file->name) {
+		struct filename *f = ntfs_list_entry(item, struct filename, list);

 		if (!f->name)
 			continue;
@@ -1655,8 +1655,8 @@
 	struct ufile *file;
 	int i, j;
 	long long start, end;
-	runlist_element *rl;
-	struct list_head *item;
+	ntfs_runlist_element *rl;
+	struct ntfs_list_head *item;
 	int fd = -1;
 	long long k;
 	int result = 0;
@@ -1692,7 +1692,7 @@
 	 * list_record(). Otherwise, when undeleting, a file will always be
 	 * listed as 0% recoverable even if successfully undeleted. +mabs
 	 */
-	if (file->mft->flags & MFT_RECORD_IN_USE) {
+	if (file->mft->flags & NTFS_MFT_RECORD_IN_USE) {
 		ntfs_log_error("Record is in use by the mft\n");
 		if (!opts.force) {
 			free(buffer);
@@ -1707,13 +1707,13 @@
 		goto free;
 	}

-	if (list_empty(&file->data)) {
+	if (ntfs_list_empty(&file->data)) {
 		ntfs_log_quiet("File has no data.  There is nothing to recover.\n");
 		goto free;
 	}

-	list_for_each(item, &file->data) {
-		struct data *d = list_entry(item, struct data, list);
+	ntfs_list_for_each(item, &file->data) {
+		struct data *d = ntfs_list_entry(item, struct data, list);

 		if (opts.output)
 				name = opts.output;
@@ -1740,14 +1740,14 @@
 			}
 			fd = -1;
 		} else {
-			rl = d->runlist;
+			rl = d->ntfs_runlist;
 			if (!rl) {
-				ntfs_log_verbose("File has no runlist, hence no data.\n");
+				ntfs_log_verbose("File has no ntfs_runlist, hence no data.\n");
 				continue;
 			}

 			if (rl[0].length <= 0) {
-				ntfs_log_verbose("File has an empty runlist, hence no data.\n");
+				ntfs_log_verbose("File has an empty ntfs_runlist, hence no data.\n");
 				continue;
 			}

@@ -1757,7 +1757,7 @@
 				goto free;
 			}

-			if (rl[0].lcn == LCN_RL_NOT_MAPPED) {	/* extended mft record */
+			if (rl[0].lcn == NTFS_LCN_RL_NOT_MAPPED) {	/* extended mft record */
 				ntfs_log_verbose("Missing segment at beginning, %lld "
 						"clusters.\n",
 						(long long)rl[0].length);
@@ -1774,7 +1774,7 @@
 			cluster_count = 0LL;
 			for (i = 0; rl[i].length > 0; i++) {

-				if (rl[i].lcn == LCN_RL_NOT_MAPPED) {
+				if (rl[i].lcn == NTFS_LCN_RL_NOT_MAPPED) {
 					ntfs_log_verbose("Missing segment at end, "
 							"%lld clusters.\n",
 							(long long)rl[i].length);
@@ -1790,7 +1790,7 @@
 					continue;
 				}

-				if (rl[i].lcn == LCN_HOLE) {
+				if (rl[i].lcn == NTFS_LCN_HOLE) {
 					ntfs_log_verbose("File has a sparse section.\n");
 					memset(buffer, 0, bufsize);
 					for (k = 0; k < rl[k].length * vol->cluster_size; k += bufsize) {
@@ -1904,7 +1904,7 @@
 	if (!vol)
 		return -1;

-	attr = ntfs_attr_open(vol->mft_ni, AT_BITMAP, AT_UNNAMED, 0);
+	attr = ntfs_attr_open(vol->mft_ni, NTFS_AT_BITMAP, NTFS_AT_UNNAMED, 0);
 	if (!attr) {
 		ntfs_log_perror("ERROR: Couldn't open $MFT/$BITMAP");
 		return -1;
@@ -2036,7 +2036,7 @@
 		return 1;
 	}

-	mft = ntfs_attr_open(vol->mft_ni, AT_DATA, AT_UNNAMED, 0);
+	mft = ntfs_attr_open(vol->mft_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 	if (!mft) {
 		ntfs_log_perror("Couldn't open $MFT/$DATA");
 		goto free;
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfsundelete.h ./ntfsprogs/ntfsundelete.h
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfsundelete.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfsundelete.h	2007-10-06 16:48:05.000000000 +0200
@@ -25,9 +25,9 @@
 #ifndef _NTFSUNDELETE_H_
 #define _NTFSUNDELETE_H_

-#include "types.h"
-#include "list.h"
-#include "runlist.h"
+#include "ntfs_types.h"
+#include "ntfs_list.h"
+#include "ntfs_runlist.h"

 enum optmode {
 	MODE_NONE = 0,
@@ -61,24 +61,24 @@
 };

 struct filename {
-	struct list_head list;		/* Previous/Next links */
+	struct ntfs_list_head list;		/* Previous/Next links */
 	ntfschar	*uname;		/* Filename in unicode */
 	int		 uname_len;	/* and its length */
 	long long	 size_alloc;	/* Allocated size (multiple of cluster size) */
 	long long	 size_data;	/* Actual size of data */
-	FILE_ATTR_FLAGS	 flags;
+	NTFS_FILE_ATTR_FLAGS	 flags;
 	time_t		 date_c;	/* Time created */
 	time_t		 date_a;	/*	altered */
 	time_t		 date_m;	/*	mft record changed */
 	time_t		 date_r;	/*	read */
 	char		*name;		/* Filename in current locale */
-	FILE_NAME_TYPE_FLAGS name_space;
-	leMFT_REF	 parent_mref;
+	NTFS_FILE_NAME_TYPE_FLAGS name_space;
+	NTFS_leMFT_REF	 parent_mref;
 	char		*parent_name;
 };

 struct data {
-	struct list_head list;		/* Previous/Next links */
+	struct ntfs_list_head list;		/* Previous/Next links */
 	char		*name;		/* Stream name in current locale */
 	ntfschar	*uname;		/* Unicode stream name */
 	int		 uname_len;	/* and its length */
@@ -88,8 +88,8 @@
 	long long	 size_alloc;	/* Allocated size (multiple of cluster size) */
 	long long	 size_data;	/* Actual size of data */
 	long long	 size_init;	/* Initialised size, may be less than data size */
-	long long	 size_vcn;	/* Highest VCN in the data runs */
-	runlist_element *runlist;	/* Decoded data runs */
+	long long	 size_vcn;	/* Highest NTFS_VCN in the data runs */
+	ntfs_runlist_element *ntfs_runlist;	/* Decoded data runs */
 	int		 percent;	/* Amount potentially recoverable */
 	void		*data;		/* If resident, a pointer to the data */
 };
@@ -97,14 +97,14 @@
 struct ufile {
 	long long	 inode;		/* MFT record number */
 	time_t		 date;		/* Last modification date/time */
-	struct list_head name;		/* A list of filenames */
-	struct list_head data;		/* A list of data streams */
+	struct ntfs_list_head name;		/* A list of filenames */
+	struct ntfs_list_head data;		/* A list of data streams */
 	char		*pref_name;	/* Preferred filename */
 	char		*pref_pname;	/*	     parent filename */
 	long long	 max_size;	/* Largest size we find */
 	int		 attr_list;	/* MFT record may be one of many */
 	int		 directory;	/* MFT record represents a directory */
-	MFT_RECORD	*mft;		/* Raw MFT record */
+	NTFS_MFT_RECORD	*mft;		/* Raw MFT record */
 };

 #endif /* _NTFSUNDELETE_H_ */
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfswipe.c ./ntfsprogs/ntfswipe.c
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfswipe.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfswipe.c	2007-10-06 16:48:05.000000000 +0200
@@ -48,14 +48,14 @@
 #endif

 #include "ntfswipe.h"
-#include "types.h"
-#include "volume.h"
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
 #include "utils.h"
-#include "debug.h"
-#include "dir.h"
-#include "mst.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
+#include "ntfs_mst.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 static const char *EXEC_NAME = "ntfswipe";
 static struct options opts;
@@ -445,20 +445,20 @@
 	unsigned char *buf;
 	s64 size, offset, ret, wiped = 0;
 	u16 block_size;
-	VCN cur_vcn = 0;
-	runlist *rlc = na->rl;
+	NTFS_VCN cur_vcn = 0;
+	ntfs_runlist *rlc = na->rl;
 	s64 cu_mask = na->compression_block_clusters - 1;

 	while (rlc->length) {
 		cur_vcn += rlc->length;
 		if ((cur_vcn & cu_mask) ||
-			(((rlc + 1)->length) && (rlc->lcn != LCN_HOLE))) {
+			(((rlc + 1)->length) && (rlc->lcn != NTFS_LCN_HOLE))) {
 			rlc++;
 			continue;
 		}

-		if (rlc->lcn == LCN_HOLE) {
-			runlist *rlt;
+		if (rlc->lcn == NTFS_LCN_HOLE) {
+			ntfs_runlist *rlt;

 			offset = cur_vcn - rlc->length;
 			if (offset == (offset & (~cu_mask))) {
@@ -468,7 +468,7 @@
 			offset = (offset & (~cu_mask))
 						<< vol->cluster_size_bits;
 			rlt = rlc;
-			while ((rlt - 1)->lcn == LCN_HOLE) rlt--;
+			while ((rlt - 1)->lcn == NTFS_LCN_HOLE) rlt--;
 			while (1) {
 				ret = ntfs_rl_pread(vol, na->rl,
 						offset, 2, &block_size);
@@ -620,7 +620,7 @@
 			goto close_inode;
 		}

-		na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0);
+		na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 		if (!na) {
 			ntfs_log_verbose("Couldn't open $DATA attribute\n");
 			goto close_inode;
@@ -633,7 +633,7 @@

 		if (ntfs_attr_map_whole_runlist(na)) {
 			ntfs_log_verbose("Internal error\n");
-			ntfs_log_error("Can't map runlist (inode %lld)\n", inode_num);
+			ntfs_log_error("Can't map ntfs_runlist (inode %lld)\n", inode_num);
 			goto close_attr;
 		}

@@ -797,11 +797,11 @@
 }

 /**
- * wipe_index_allocation - Wipe $INDEX_ALLOCATION attribute
+ * wipe_index_allocation - Wipe $NTFS_INDEX_ALLOCATION attribute
  * @vol:		An ntfs volume obtained from ntfs_mount
  * @byte:		Overwrite with this value
  * @act:		Wipe, test or info
- * @naa:		Opened ntfs $INDEX_ALLOCATION attribute
+ * @naa:		Opened ntfs $NTFS_INDEX_ALLOCATION attribute
  * @nab:		Opened ntfs $BITMAP attribute
  * @indx_record_size:	Size of INDX record
  *
@@ -851,7 +851,7 @@
 	while (offset < naa->allocated_size) {
 		mask = 1 << obit;
 		if (bitmap[obyte] & mask) {
-			INDEX_ALLOCATION *indx;
+			NTFS_INDEX_ALLOCATION *indx;

 			s64 ret = ntfs_rl_pread(vol, naa->rl,
 					offset, indx_record_size, buf);
@@ -862,7 +862,7 @@
 				goto free_buf;
 			}

-			indx = (INDEX_ALLOCATION *) buf;
+			indx = (NTFS_INDEX_ALLOCATION *) buf;
 			if (ntfs_mst_post_read_fixup((NTFS_RECORD *)buf,
 								indx_record_size))
 				ntfs_log_error("damaged fs: mst_post_read_fixup failed");
@@ -917,8 +917,8 @@
 }

 /**
- * get_indx_record_size - determine size of INDX record from $INDEX_ROOT
- * @nar:	Opened ntfs $INDEX_ROOT attribute
+ * get_indx_record_size - determine size of INDX record from $NTFS_INDEX_ROOT
+ * @nar:	Opened ntfs $NTFS_INDEX_ROOT attribute
  *
  * Return: >0  Success, return INDX record size
  *          0  Error, something went wrong
@@ -991,50 +991,50 @@
 			goto close_inode;
 		}

-		naa = ntfs_attr_open(ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
+		naa = ntfs_attr_open(ni, NTFS_AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
 		if (!naa) {
 			if (opts.verbose > 2)
-				ntfs_log_verbose("Couldn't open $INDEX_ALLOCATION\n");
+				ntfs_log_verbose("Couldn't open $NTFS_INDEX_ALLOCATION\n");
 			else
 				ntfs_log_verbose("\r");
 			goto close_inode;
 		}

 		if (!NAttrNonResident(naa)) {
-			ntfs_log_verbose("Resident $INDEX_ALLOCATION\n");
-			ntfs_log_error("damaged fs: Resident $INDEX_ALLOCATION "
+			ntfs_log_verbose("Resident $NTFS_INDEX_ALLOCATION\n");
+			ntfs_log_error("damaged fs: Resident $NTFS_INDEX_ALLOCATION "
 					"(inode %lld)\n", inode_num);
 			goto close_attr_allocation;
 		}

 		if (ntfs_attr_map_whole_runlist(naa)) {
 			ntfs_log_verbose("Internal error\n");
-			ntfs_log_error("Can't map runlist for $INDEX_ALLOCATION "
+			ntfs_log_error("Can't map ntfs_runlist for $NTFS_INDEX_ALLOCATION "
 					"(inode %lld)\n", inode_num);
 			goto close_attr_allocation;
 		}

-		nab = ntfs_attr_open(ni, AT_BITMAP, NTFS_INDEX_I30, 4);
+		nab = ntfs_attr_open(ni, NTFS_AT_BITMAP, NTFS_INDEX_I30, 4);
 		if (!nab) {
 			ntfs_log_verbose("Couldn't open $BITMAP\n");
-			ntfs_log_error("damaged fs: $INDEX_ALLOCATION is present, "
+			ntfs_log_error("damaged fs: $NTFS_INDEX_ALLOCATION is present, "
 					"but we can't open $BITMAP with same "
 					"name (inode %lld)\n", inode_num);
 			goto close_attr_allocation;
 		}

-		nar = ntfs_attr_open(ni, AT_INDEX_ROOT, NTFS_INDEX_I30, 4);
+		nar = ntfs_attr_open(ni, NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4);
 		if (!nar) {
-			ntfs_log_verbose("Couldn't open $INDEX_ROOT\n");
-			ntfs_log_error("damaged fs: $INDEX_ALLOCATION is present, but "
-					"we can't open $INDEX_ROOT with same name"
+			ntfs_log_verbose("Couldn't open $NTFS_INDEX_ROOT\n");
+			ntfs_log_error("damaged fs: $NTFS_INDEX_ALLOCATION is present, but "
+					"we can't open $NTFS_INDEX_ROOT with same name"
 					" (inode %lld)\n", inode_num);
 			goto close_attr_bitmap;
 		}

 		if (NAttrNonResident(nar)) {
-			ntfs_log_verbose("Not resident $INDEX_ROOT\n");
-			ntfs_log_error("damaged fs: Not resident $INDEX_ROOT "
+			ntfs_log_verbose("Not resident $NTFS_INDEX_ROOT\n");
+			ntfs_log_error("damaged fs: Not resident $NTFS_INDEX_ROOT "
 					"(inode %lld)\n", inode_num);
 			goto close_attr_root;
 		}
@@ -1088,7 +1088,7 @@
 	__attribute__((unused)))
 {
 	const int NTFS_BUF_SIZE2 = 8192;
-	//FIXME(?): We might need to zero the LSN field of every single mft
+	//FIXME(?): We might need to zero the NTFS_LSN field of every single mft
 	//record as well. (But, first try without doing that and see what
 	//happens, since chkdsk might pickup the pieces and do it for us...)
 	ntfs_inode *ni;
@@ -1105,13 +1105,13 @@

 	//ntfs_log_quiet("wipe_logfile(not implemented) 0x%02x\n", byte);

-	if ((ni = ntfs_inode_open(vol, FILE_LogFile)) == NULL) {
-		ntfs_log_debug("Failed to open inode FILE_LogFile.\n");
+	if ((ni = ntfs_inode_open(vol, NTFS_FILE_LogFile)) == NULL) {
+		ntfs_log_debug("Failed to open inode NTFS_FILE_LogFile.\n");
 		return -1;
 	}

-	if ((na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0)) == NULL) {
-		ntfs_log_debug("Failed to open $FILE_LogFile/$DATA.\n");
+	if ((na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0)) == NULL) {
+		ntfs_log_debug("Failed to open $NTFS_FILE_LogFile/$DATA.\n");
 		goto error_exit;
 	}

@@ -1216,7 +1216,7 @@
 		return 0;
 	}

-	if ((na = ntfs_attr_open(ni, AT_DATA, AT_UNNAMED, 0)) == NULL) {
+	if ((na = ntfs_attr_open(ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0)) == NULL) {
 		ntfs_log_debug("Failed to open pagefile.sys/$DATA.\n");
 		goto error_exit;
 	}
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/ntfswipe.h ./ntfsprogs/ntfswipe.h
--- ../ntfsprogs-2.0.0/ntfsprogs/ntfswipe.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/ntfswipe.h	2007-10-06 16:48:05.000000000 +0200
@@ -24,7 +24,7 @@
 #ifndef _NTFSWIPE_H_
 #define _NTFSWIPE_H_

-#include "types.h"
+#include "ntfs_types.h"

 enum action {
 	act_info,
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/sd.c ./ntfsprogs/sd.c
--- ../ntfsprogs-2.0.0/ntfsprogs/sd.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/sd.c	2007-10-06 16:48:06.000000000 +0200
@@ -1,5 +1,5 @@
-#include "types.h"
-#include "layout.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
 #include "sd.h"

 /**
@@ -22,10 +22,10 @@
 void init_system_file_sd(int sys_file_no, u8 **sd_val, int *sd_val_len)
 {
 	static u8 sd_array[0x68];
-	SECURITY_DESCRIPTOR_RELATIVE *sd;
-	ACL *acl;
-	ACCESS_ALLOWED_ACE *aa_ace;
-	SID *sid;
+	NTFS_SECURITY_DESCRIPTOR_RELATIVE *sd;
+	NTFS_ACL *acl;
+	NTFS_ACCESS_ALLOWED_ACE *aa_ace;
+	NTFS_SID *sid;

 	if (sys_file_no < 0) {
 		*sd_val = NULL;
@@ -33,10 +33,10 @@
 		return;
 	}
 	*sd_val = sd_array;
-	sd = (SECURITY_DESCRIPTOR_RELATIVE*)&sd_array;
+	sd = (NTFS_SECURITY_DESCRIPTOR_RELATIVE*)&sd_array;
 	sd->revision = 1;
 	sd->alignment = 0;
-	sd->control = SE_SELF_RELATIVE | SE_DACL_PRESENT;
+	sd->control = NTFS_SE_SELF_RELATIVE | NTFS_SE_DACL_PRESENT;
 	*sd_val_len = 0x64;
 	sd->owner = const_cpu_to_le32(0x48);
 	sd->group = const_cpu_to_le32(0x54);
@@ -46,31 +46,31 @@
 	 * Now at offset 0x14, as specified in the security descriptor, we have
 	 * the DACL.
 	 */
-	acl = (ACL*)((char*)sd + le32_to_cpu(sd->dacl));
+	acl = (NTFS_ACL*)((char*)sd + le32_to_cpu(sd->dacl));
 	acl->revision = 2;
 	acl->alignment1 = 0;
 	acl->size = const_cpu_to_le16(0x34);
 	acl->ace_count = const_cpu_to_le16(2);
 	acl->alignment2 = const_cpu_to_le16(0);
 	/*
-	 * Now at offset 0x1c, just after the DACL's ACL, we have the first
+	 * Now at offset 0x1c, just after the DACL's NTFS_ACL, we have the first
 	 * ACE of the DACL. The type of the ACE is access allowed.
 	 */
-	aa_ace = (ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(ACL));
-	aa_ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	aa_ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(NTFS_ACL));
+	aa_ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	aa_ace->flags = 0;
 	aa_ace->size = const_cpu_to_le16(0x14);
 	switch (sys_file_no) {
-	case FILE_AttrDef:
-	case FILE_Boot:
-		aa_ace->mask = SYNCHRONIZE | STANDARD_RIGHTS_READ |
-			FILE_READ_ATTRIBUTES | FILE_READ_EA | FILE_READ_DATA;
+	case NTFS_FILE_AttrDef:
+	case NTFS_FILE_Boot:
+		aa_ace->mask = NTFS_SYNCHRONIZE | NTFS_STANDARD_RIGHTS_READ |
+			NTFS_FILE_READ_ATTRIBUTES | NTFS_FILE_READ_EA | NTFS_FILE_READ_DATA;
 		break;
 	default:
-		aa_ace->mask = SYNCHRONIZE | STANDARD_RIGHTS_WRITE |
-			FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |
-			FILE_WRITE_EA | FILE_READ_EA | FILE_APPEND_DATA |
-			FILE_WRITE_DATA | FILE_READ_DATA;
+		aa_ace->mask = NTFS_SYNCHRONIZE | NTFS_STANDARD_RIGHTS_WRITE |
+			NTFS_FILE_WRITE_ATTRIBUTES | NTFS_FILE_READ_ATTRIBUTES |
+			NTFS_FILE_WRITE_EA | NTFS_FILE_READ_EA | NTFS_FILE_APPEND_DATA |
+			NTFS_FILE_WRITE_DATA | NTFS_FILE_READ_DATA;
 		break;
 	}
 	aa_ace->sid.revision = 1;
@@ -80,40 +80,40 @@
 	aa_ace->sid.identifier_authority.value[2] = 0;
 	aa_ace->sid.identifier_authority.value[3] = 0;
 	aa_ace->sid.identifier_authority.value[4] = 0;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	aa_ace->sid.identifier_authority.value[5] = 5;
 	aa_ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+			const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);
 	/*
 	 * Now at offset 0x30 within security descriptor, just after the first
 	 * ACE of the DACL. All system files, except the root directory, have
 	 * a second ACE.
 	 */
 	/* The second ACE of the DACL. Type is access allowed. */
-	aa_ace = (ACCESS_ALLOWED_ACE*)((char*)aa_ace +
+	aa_ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)aa_ace +
 			le16_to_cpu(aa_ace->size));
-	aa_ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	aa_ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	aa_ace->flags = 0;
 	aa_ace->size = const_cpu_to_le16(0x18);
 	/* Only $AttrDef and $Boot behave differently to everything else. */
 	switch (sys_file_no) {
-	case FILE_AttrDef:
-	case FILE_Boot:
-		aa_ace->mask = SYNCHRONIZE | STANDARD_RIGHTS_READ |
-				FILE_READ_ATTRIBUTES | FILE_READ_EA |
-				FILE_READ_DATA;
+	case NTFS_FILE_AttrDef:
+	case NTFS_FILE_Boot:
+		aa_ace->mask = NTFS_SYNCHRONIZE | NTFS_STANDARD_RIGHTS_READ |
+				NTFS_FILE_READ_ATTRIBUTES | NTFS_FILE_READ_EA |
+				NTFS_FILE_READ_DATA;
 		break;
 	default:
-		aa_ace->mask = SYNCHRONIZE | STANDARD_RIGHTS_READ |
-				FILE_WRITE_ATTRIBUTES |
-				FILE_READ_ATTRIBUTES | FILE_WRITE_EA |
-				FILE_READ_EA | FILE_APPEND_DATA |
-				FILE_WRITE_DATA | FILE_READ_DATA;
+		aa_ace->mask = NTFS_SYNCHRONIZE | NTFS_STANDARD_RIGHTS_READ |
+				NTFS_FILE_WRITE_ATTRIBUTES |
+				NTFS_FILE_READ_ATTRIBUTES | NTFS_FILE_WRITE_EA |
+				NTFS_FILE_READ_EA | NTFS_FILE_APPEND_DATA |
+				NTFS_FILE_WRITE_DATA | NTFS_FILE_READ_DATA;
 		break;
 	}
 	aa_ace->sid.revision = 1;
 	aa_ace->sid.sub_authority_count = 2;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	aa_ace->sid.identifier_authority.value[0] = 0;
 	aa_ace->sid.identifier_authority.value[1] = 0;
 	aa_ace->sid.identifier_authority.value[2] = 0;
@@ -121,40 +121,40 @@
 	aa_ace->sid.identifier_authority.value[4] = 0;
 	aa_ace->sid.identifier_authority.value[5] = 5;
 	aa_ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	aa_ace->sid.sub_authority[1] =
-			const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+			const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
 	/*
 	 * Now at offset 0x48 into the security descriptor, as specified in the
-	 * security descriptor, we now have the owner SID.
+	 * security descriptor, we now have the owner NTFS_SID.
 	 */
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->owner));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->owner));
 	sid->revision = 1;
 	sid->sub_authority_count = 1;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
 	sid->identifier_authority.value[3] = 0;
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
-	sid->sub_authority[0] = const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+	sid->sub_authority[0] = const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);
 	/*
 	 * Now at offset 0x54 into the security descriptor, as specified in the
-	 * security descriptor, we have the group SID.
+	 * security descriptor, we have the group NTFS_SID.
 	 */
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->group));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->group));
 	sid->revision = 1;
 	sid->sub_authority_count = 2;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
 	sid->identifier_authority.value[3] = 0;
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
-	sid->sub_authority[0] = const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
-	sid->sub_authority[1] = const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+	sid->sub_authority[0] = const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
+	sid->sub_authority[1] = const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
 }

 /**
@@ -167,46 +167,46 @@
  */
 void init_root_sd(u8 **sd_val, int *sd_val_len)
 {
-	SECURITY_DESCRIPTOR_RELATIVE *sd;
-	ACL *acl;
-	ACCESS_ALLOWED_ACE *ace;
-	SID *sid;
+	NTFS_SECURITY_DESCRIPTOR_RELATIVE *sd;
+	NTFS_ACL *acl;
+	NTFS_ACCESS_ALLOWED_ACE *ace;
+	NTFS_SID *sid;

 	static char sd_array[0x102c];
 	*sd_val_len = 0x102c;
 	*sd_val = (u8*)&sd_array;

 	//security descriptor relative
-	sd = (SECURITY_DESCRIPTOR_RELATIVE*)sd_array;
-	sd->revision = SECURITY_DESCRIPTOR_REVISION;
+	sd = (NTFS_SECURITY_DESCRIPTOR_RELATIVE*)sd_array;
+	sd->revision = NTFS_SECURITY_DESCRIPTOR_REVISION;
 	sd->alignment = 0;
-	sd->control = SE_SELF_RELATIVE | SE_DACL_PRESENT;
+	sd->control = NTFS_SE_SELF_RELATIVE | NTFS_SE_DACL_PRESENT;
 	sd->owner = const_cpu_to_le32(0x1014);
 	sd->group = const_cpu_to_le32(0x1020);
 	sd->sacl = 0;
-	sd->dacl = const_cpu_to_le32(sizeof(SECURITY_DESCRIPTOR_RELATIVE));
+	sd->dacl = const_cpu_to_le32(sizeof(NTFS_SECURITY_DESCRIPTOR_RELATIVE));

 	//acl
-	acl = (ACL*)((u8*)sd + sizeof(SECURITY_DESCRIPTOR_RELATIVE));
-	acl->revision = ACL_REVISION;
+	acl = (NTFS_ACL*)((u8*)sd + sizeof(NTFS_SECURITY_DESCRIPTOR_RELATIVE));
+	acl->revision = NTFS_ACL_REVISION;
 	acl->alignment1 = 0;
 	acl->size = const_cpu_to_le16(0x1000);
 	acl->ace_count = const_cpu_to_le16(0x08);
 	acl->alignment2 = 0;

 	//ace1
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)acl + sizeof(ACL));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)acl + sizeof(NTFS_ACL));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	ace->flags = 0;
 	ace->size = const_cpu_to_le16(0x18);
-	ace->mask = STANDARD_RIGHTS_ALL | FILE_WRITE_ATTRIBUTES |
-			 FILE_LIST_DIRECTORY | FILE_WRITE_DATA |
-			 FILE_ADD_SUBDIRECTORY | FILE_READ_EA | FILE_WRITE_EA |
-			 FILE_TRAVERSE | FILE_DELETE_CHILD |
-			 FILE_READ_ATTRIBUTES;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_STANDARD_RIGHTS_ALL | NTFS_FILE_WRITE_ATTRIBUTES |
+			 NTFS_FILE_LIST_DIRECTORY | NTFS_FILE_WRITE_DATA |
+			 NTFS_FILE_ADD_SUBDIRECTORY | NTFS_FILE_READ_EA | NTFS_FILE_WRITE_EA |
+			 NTFS_FILE_TRAVERSE | NTFS_FILE_DELETE_CHILD |
+			 NTFS_FILE_READ_ATTRIBUTES;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -214,19 +214,19 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
-	ace->sid.sub_authority[1] = const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
+	ace->sid.sub_authority[1] = const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	//ace2
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
-	ace->flags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE |
-			INHERIT_ONLY_ACE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
+	ace->flags = NTFS_OBJECT_INHERIT_ACE | NTFS_CONTAINER_INHERIT_ACE |
+			NTFS_INHERIT_ONLY_ACE;
 	ace->size = const_cpu_to_le16(0x18);
-	ace->mask = GENERIC_ALL;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_GENERIC_ALL;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -234,22 +234,22 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
-	ace->sid.sub_authority[1] = const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
+	ace->sid.sub_authority[1] = const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	//ace3
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	ace->flags = 0;
 	ace->size = const_cpu_to_le16(0x14);
-	ace->mask = STANDARD_RIGHTS_ALL | FILE_WRITE_ATTRIBUTES |
-			 FILE_LIST_DIRECTORY | FILE_WRITE_DATA |
-			 FILE_ADD_SUBDIRECTORY | FILE_READ_EA | FILE_WRITE_EA |
-			 FILE_TRAVERSE | FILE_DELETE_CHILD |
-			 FILE_READ_ATTRIBUTES;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_STANDARD_RIGHTS_ALL | NTFS_FILE_WRITE_ATTRIBUTES |
+			 NTFS_FILE_LIST_DIRECTORY | NTFS_FILE_WRITE_DATA |
+			 NTFS_FILE_ADD_SUBDIRECTORY | NTFS_FILE_READ_EA | NTFS_FILE_WRITE_EA |
+			 NTFS_FILE_TRAVERSE | NTFS_FILE_DELETE_CHILD |
+			 NTFS_FILE_READ_ATTRIBUTES;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -257,18 +257,18 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+			const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);

 	//ace4
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
-	ace->flags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE |
-			INHERIT_ONLY_ACE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
+	ace->flags = NTFS_OBJECT_INHERIT_ACE | NTFS_CONTAINER_INHERIT_ACE |
+			NTFS_INHERIT_ONLY_ACE;
 	ace->size = const_cpu_to_le16(0x14);
-	ace->mask = GENERIC_ALL;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_GENERIC_ALL;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -276,21 +276,21 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+			const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);

 	//ace5
-	ace = (ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	ace->flags = 0;
 	ace->size = const_cpu_to_le16(0x14);
-	ace->mask = SYNCHRONIZE | READ_CONTROL | DELETE |
-			FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES |
-			FILE_TRAVERSE | FILE_WRITE_EA | FILE_READ_EA |
-			FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE |
-			FILE_LIST_DIRECTORY;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_SYNCHRONIZE | NTFS_READ_CONTROL | NTFS_DELETE |
+			NTFS_FILE_WRITE_ATTRIBUTES | NTFS_FILE_READ_ATTRIBUTES |
+			NTFS_FILE_TRAVERSE | NTFS_FILE_WRITE_EA | NTFS_FILE_READ_EA |
+			NTFS_FILE_ADD_SUBDIRECTORY | NTFS_FILE_ADD_FILE |
+			NTFS_FILE_LIST_DIRECTORY;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -298,18 +298,18 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_AUTHENTICATED_USER_RID);
+			const_cpu_to_le32(NTFS_SECURITY_AUTHENTICATED_USER_RID);

 	//ace6
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
-	ace->flags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE |
-			INHERIT_ONLY_ACE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
+	ace->flags = NTFS_OBJECT_INHERIT_ACE | NTFS_CONTAINER_INHERIT_ACE |
+			NTFS_INHERIT_ONLY_ACE;
 	ace->size = const_cpu_to_le16(0x14);
-	ace->mask = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_GENERIC_READ | NTFS_GENERIC_WRITE | NTFS_GENERIC_EXECUTE | NTFS_DELETE;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -317,18 +317,18 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_AUTHENTICATED_USER_RID);
+			const_cpu_to_le32(NTFS_SECURITY_AUTHENTICATED_USER_RID);

 	//ace7
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
 	ace->flags = 0;
 	ace->size = const_cpu_to_le16(0x18);
-	ace->mask = SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |
-			FILE_TRAVERSE | FILE_READ_EA | FILE_LIST_DIRECTORY;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_SYNCHRONIZE | NTFS_READ_CONTROL | NTFS_FILE_READ_ATTRIBUTES |
+			NTFS_FILE_TRAVERSE | NTFS_FILE_READ_EA | NTFS_FILE_LIST_DIRECTORY;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -336,19 +336,19 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
-	ace->sid.sub_authority[1] = const_cpu_to_le32(DOMAIN_ALIAS_RID_USERS);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
+	ace->sid.sub_authority[1] = const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_USERS);

 	//ace8
-	ace = (ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
-	ace->type = ACCESS_ALLOWED_ACE_TYPE;
-	ace->flags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE |
-			INHERIT_ONLY_ACE;
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((u8*)ace + le16_to_cpu(ace->size));
+	ace->type = NTFS_ACCESS_ALLOWED_ACE_TYPE;
+	ace->flags = NTFS_OBJECT_INHERIT_ACE | NTFS_CONTAINER_INHERIT_ACE |
+			NTFS_INHERIT_ONLY_ACE;
 	ace->size = const_cpu_to_le16(0x18);
-	ace->mask = GENERIC_READ | GENERIC_EXECUTE;
-	ace->sid.revision = SID_REVISION;
+	ace->mask = NTFS_GENERIC_READ | NTFS_GENERIC_EXECUTE;
+	ace->sid.revision = NTFS_SID_REVISION;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -356,34 +356,34 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
-	ace->sid.sub_authority[1] = const_cpu_to_le32(DOMAIN_ALIAS_RID_USERS);
+			const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
+	ace->sid.sub_authority[1] = const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_USERS);

 	//owner sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->owner));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->owner));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
 	sid->identifier_authority.value[3] = 0;
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
-	sid->sub_authority[0] = const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+	sid->sub_authority[0] = const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);

 	//group sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->group));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->group));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
 	sid->identifier_authority.value[3] = 0;
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
-	sid->sub_authority[0] = const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+	sid->sub_authority[0] = const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);
 }

 /**
@@ -396,34 +396,34 @@
  */
 void init_secure_sds(char *sd_val)
 {
-	SECURITY_DESCRIPTOR_HEADER *sds;
-	SECURITY_DESCRIPTOR_RELATIVE *sd;
-	ACL *acl;
-	ACCESS_ALLOWED_ACE *ace;
-	SID *sid;
+	NTFS_SECURITY_DESCRIPTOR_HEADER *sds;
+	NTFS_SECURITY_DESCRIPTOR_RELATIVE *sd;
+	NTFS_ACL *acl;
+	NTFS_ACCESS_ALLOWED_ACE *ace;
+	NTFS_SID *sid;

 /*
  * security descriptor #1
  */
 	//header
-	sds = (SECURITY_DESCRIPTOR_HEADER*)((char*)sd_val);
+	sds = (NTFS_SECURITY_DESCRIPTOR_HEADER*)((char*)sd_val);
 	sds->hash = const_cpu_to_le32(0xF80312F0);
 	sds->security_id = const_cpu_to_le32(0x0100);
 	sds->offset = const_cpu_to_le64(0x00);
 	sds->length = const_cpu_to_le32(0x7C);
 	//security descriptor relative
-	sd = (SECURITY_DESCRIPTOR_RELATIVE*)((char*)sds +
-			sizeof(SECURITY_DESCRIPTOR_HEADER));
+	sd = (NTFS_SECURITY_DESCRIPTOR_RELATIVE*)((char*)sds +
+			sizeof(NTFS_SECURITY_DESCRIPTOR_HEADER));
 	sd->revision = 0x01;
 	sd->alignment = 0x00;
-	sd->control = SE_SELF_RELATIVE | SE_DACL_PRESENT;
+	sd->control = NTFS_SE_SELF_RELATIVE | NTFS_SE_DACL_PRESENT;
 	sd->owner = const_cpu_to_le32(0x48);
 	sd->group = const_cpu_to_le32(0x58);
 	sd->sacl = const_cpu_to_le32(0x00);
 	sd->dacl = const_cpu_to_le32(0x14);

 	//acl
-	acl = (ACL*)((char*)sd + sizeof(SECURITY_DESCRIPTOR_RELATIVE));
+	acl = (NTFS_ACL*)((char*)sd + sizeof(NTFS_SECURITY_DESCRIPTOR_RELATIVE));
 	acl->revision = 0x02;
 	acl->alignment1 = 0x00;
 	acl->size = const_cpu_to_le16(0x34);
@@ -431,14 +431,14 @@
 	acl->alignment2 = 0x00;

 	//ace1
-	ace = (ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(ACL));
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(NTFS_ACL));
 	ace->type = 0x00;
 	ace->flags = 0x00;
 	ace->size = const_cpu_to_le16(0x14);
 	ace->mask = const_cpu_to_le32(0x120089);
 	ace->sid.revision = 0x01;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -446,16 +446,16 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-			const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+			const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);
 	//ace2
-	ace = (ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
 	ace->type = 0x00;
 	ace->flags = 0x00;
 	ace->size = const_cpu_to_le16(0x18);
 	ace->mask = const_cpu_to_le32(0x120089);
 	ace->sid.revision = 0x01;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -463,15 +463,15 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	ace->sid.sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	//owner sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->owner));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->owner));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
@@ -479,14 +479,14 @@
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
 	sid->sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	sid->sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
 	//group sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->group));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->group));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
@@ -494,32 +494,32 @@
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
 	sid->sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	sid->sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);
 /*
  * security descriptor #2
  */
 	//header
-	sds = (SECURITY_DESCRIPTOR_HEADER*)((char*)sd_val + 0x80);
+	sds = (NTFS_SECURITY_DESCRIPTOR_HEADER*)((char*)sd_val + 0x80);
 	sds->hash = const_cpu_to_le32(0xB32451);
 	sds->security_id = const_cpu_to_le32(0x0101);
 	sds->offset = const_cpu_to_le64(0x80);
 	sds->length = const_cpu_to_le32(0x7C);

 	//security descriptor relative
-	sd = (SECURITY_DESCRIPTOR_RELATIVE*)((char*)sds +
-		 sizeof(SECURITY_DESCRIPTOR_HEADER));
+	sd = (NTFS_SECURITY_DESCRIPTOR_RELATIVE*)((char*)sds +
+		 sizeof(NTFS_SECURITY_DESCRIPTOR_HEADER));
 	sd->revision = 0x01;
 	sd->alignment = 0x00;
-	sd->control = SE_SELF_RELATIVE | SE_DACL_PRESENT;
+	sd->control = NTFS_SE_SELF_RELATIVE | NTFS_SE_DACL_PRESENT;
 	sd->owner = const_cpu_to_le32(0x48);
 	sd->group = const_cpu_to_le32(0x58);
 	sd->sacl = const_cpu_to_le32(0x00);
 	sd->dacl = const_cpu_to_le32(0x14);

 	//acl
-	acl = (ACL*)((char*)sd + sizeof(SECURITY_DESCRIPTOR_RELATIVE));
+	acl = (NTFS_ACL*)((char*)sd + sizeof(NTFS_SECURITY_DESCRIPTOR_RELATIVE));
 	acl->revision = 0x02;
 	acl->alignment1 = 0x00;
 	acl->size = const_cpu_to_le16(0x34);
@@ -527,14 +527,14 @@
 	acl->alignment2 = 0x00;

 	//ace1
-	ace = (ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(ACL));
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(NTFS_ACL));
 	ace->type = 0x00;
 	ace->flags = 0x00;
 	ace->size = const_cpu_to_le16(0x14);
 	ace->mask = const_cpu_to_le32(0x12019F);
 	ace->sid.revision = 0x01;
 	ace->sid.sub_authority_count = 0x01;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -542,16 +542,16 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-		const_cpu_to_le32(SECURITY_LOCAL_SYSTEM_RID);
+		const_cpu_to_le32(NTFS_SECURITY_LOCAL_SYSTEM_RID);
 	//ace2
-	ace = (ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
+	ace = (NTFS_ACCESS_ALLOWED_ACE*)((char*)ace + le16_to_cpu(ace->size));
 	ace->type = 0x00;
 	ace->flags = 0x00;
 	ace->size = const_cpu_to_le16(0x18);
 	ace->mask = const_cpu_to_le32(0x12019F);
 	ace->sid.revision = 0x01;
 	ace->sid.sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	ace->sid.identifier_authority.value[0] = 0;
 	ace->sid.identifier_authority.value[1] = 0;
 	ace->sid.identifier_authority.value[2] = 0;
@@ -559,15 +559,15 @@
 	ace->sid.identifier_authority.value[4] = 0;
 	ace->sid.identifier_authority.value[5] = 5;
 	ace->sid.sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	ace->sid.sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	//owner sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->owner));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->owner));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
@@ -575,15 +575,15 @@
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
 	sid->sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	sid->sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	//group sid
-	sid = (SID*)((char*)sd + le32_to_cpu(sd->group));
+	sid = (NTFS_SID*)((char*)sd + le32_to_cpu(sd->group));
 	sid->revision = 0x01;
 	sid->sub_authority_count = 0x02;
-	/* SECURITY_NT_SID_AUTHORITY (S-1-5) */
+	/* NTFS_SECURITY_NT_SID_AUTHORITY (S-1-5) */
 	sid->identifier_authority.value[0] = 0;
 	sid->identifier_authority.value[1] = 0;
 	sid->identifier_authority.value[2] = 0;
@@ -591,9 +591,9 @@
 	sid->identifier_authority.value[4] = 0;
 	sid->identifier_authority.value[5] = 5;
 	sid->sub_authority[0] =
-		const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);
+		const_cpu_to_le32(NTFS_SECURITY_BUILTIN_DOMAIN_RID);
 	sid->sub_authority[1] =
-		const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);
+		const_cpu_to_le32(NTFS_DOMAIN_ALIAS_RID_ADMINS);

 	return;
 }
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/sd.h ./ntfsprogs/sd.h
--- ../ntfsprogs-2.0.0/ntfsprogs/sd.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/sd.h	2007-10-06 16:48:06.000000000 +0200
@@ -1,7 +1,7 @@
 #ifndef _NTFS_SD_H_
 #define _NTFS_SD_H_

-#include "types.h"
+#include "ntfs_types.h"

 void init_system_file_sd(int sys_file_no, u8 **sd_val, int *sd_val_len);
 void init_root_sd(u8 **sd_val, int *sd_val_len);
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/utils.c ./ntfsprogs/utils.c
--- ../ntfsprogs-2.0.0/ntfsprogs/utils.c	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/utils.c	2007-10-06 16:48:06.000000000 +0200
@@ -66,12 +66,12 @@
 #endif

 #include "utils.h"
-#include "types.h"
-#include "volume.h"
-#include "debug.h"
-#include "dir.h"
-#include "version.h"
-#include "logging.h"
+#include "ntfs_types.h"
+#include "ntfs_volume.h"
+#include "ntfs_debug.h"
+#include "ntfs_dir.h"
+#include "ntfs_version.h"
+#include "ntfs_logging.h"

 const char *ntfs_bugs = "Developers' email address: "NTFS_DEV_LIST"\n";
 const char *ntfs_home = "Linux NTFS homepage: http://www.linux-ntfs.org\n";
@@ -270,7 +270,7 @@
  * Return:  1  Success
  *	    0  Error, the string was malformed
  */
-int utils_parse_size(const char *value, s64 *size, BOOL scale)
+int utils_parse_size(const char *value, s64 *size, NTFS_BOOL scale)
 {
 	long long result;
 	char *suffix = NULL;
@@ -330,7 +330,7 @@
  * Return:  1  Success, a valid string was found
  *	    0  Error, the string was not a valid range
  */
-int utils_parse_range(const char *string, s64 *start, s64 *finish, BOOL scale)
+int utils_parse_range(const char *string, s64 *start, s64 *finish, NTFS_BOOL scale)
 {
 	s64 a, b;
 	char *middle;
@@ -370,7 +370,7 @@

 /**
  * find_attribute - Find an attribute of the given type
- * @type:  An attribute type, e.g. AT_FILE_NAME
+ * @type:  An attribute type, e.g. NTFS_AT_FILE_NAME
  * @ctx:   A search context, created using ntfs_get_attr_search_ctx
  *
  * Using the search context to keep track, find the first/next occurrence of a
@@ -382,7 +382,7 @@
  * Return:  Pointer  Success, an attribute was found
  *	    NULL     Error, no matching attributes were found
  */
-ATTR_RECORD * find_attribute(const ATTR_TYPES type, ntfs_attr_search_ctx *ctx)
+NTFS_ATTR_RECORD * find_attribute(const NTFS_ATTR_TYPES type, ntfs_attr_search_ctx *ctx)
 {
 	if (!ctx) {
 		errno = EINVAL;
@@ -400,7 +400,7 @@

 /**
  * find_first_attribute - Find the first attribute of a given type
- * @type:  An attribute type, e.g. AT_FILE_NAME
+ * @type:  An attribute type, e.g. NTFS_AT_FILE_NAME
  * @mft:   A buffer containing a raw MFT record
  *
  * Search through a raw MFT record for an attribute of a given type.
@@ -412,10 +412,10 @@
  * Return:  Pointer  Success, an attribute was found
  *	    NULL     Error, no matching attributes were found
  */
-ATTR_RECORD * find_first_attribute(const ATTR_TYPES type, MFT_RECORD *mft)
+NTFS_ATTR_RECORD * find_first_attribute(const NTFS_ATTR_TYPES type, NTFS_MFT_RECORD *mft)
 {
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *rec;
+	NTFS_ATTR_RECORD *rec;

 	if (!mft) {
 		errno = EINVAL;
@@ -456,10 +456,10 @@

 	ntfs_volume *vol;
 	ntfs_attr_search_ctx *ctx;
-	ATTR_RECORD *rec;
-	FILE_NAME_ATTR *attr;
+	NTFS_ATTR_RECORD *rec;
+	NTFS_FILE_NAME_ATTR *attr;
 	int name_space;
-	MFT_REF parent = FILE_root;
+	NTFS_MFT_REF parent = NTFS_FILE_root;
 	char *names[max_path + 1];// XXX ntfs_malloc? and make max bigger?
 	int i, len, offset = 0;

@@ -484,9 +484,9 @@
 		//ntfs_log_debug("i = %d, inode = %p (%lld)\n", i, inode, inode->mft_no);

 		name_space = 4;
-		while ((rec = find_attribute(AT_FILE_NAME, ctx))) {
+		while ((rec = find_attribute(NTFS_AT_FILE_NAME, ctx))) {
 			/* We know this will always be resident. */
-			attr = (FILE_NAME_ATTR *) ((char *) rec + le16_to_cpu(rec->value_offset));
+			attr = (NTFS_FILE_NAME_ATTR *) ((char *) rec + le16_to_cpu(rec->value_offset));

 			if (attr->file_name_type > name_space) { //XXX find the ...
 				continue;
@@ -513,7 +513,7 @@
 			}

 			//ntfs_log_debug("names[%d] %s\n", i, names[i]);
-			//ntfs_log_debug("parent = %lld\n", MREF(parent));
+			//ntfs_log_debug("parent = %lld\n", NTFS_MREF(parent));
 		}

 		ntfs_attr_put_search_ctx(ctx);
@@ -521,7 +521,7 @@
 		if (i > 0)			/* Don't close the original inode */
 			ntfs_inode_close(inode);

-		if (MREF(parent) == FILE_root) {	/* The root directory, stop. */
+		if (NTFS_MREF(parent) == NTFS_FILE_root) {	/* The root directory, stop. */
 			//ntfs_log_debug("inode 5\n");
 			break;
 		}
@@ -529,7 +529,7 @@
 		inode = ntfs_inode_open(vol, parent);
 		if (!inode) {
 			ntfs_log_error("Couldn't open inode %llu.\n",
-					(unsigned long long)MREF(parent));
+					(unsigned long long)NTFS_MREF(parent));
 			break;
 		}
 	}
@@ -567,11 +567,11 @@
 /**
  * utils_attr_get_name
  */
-int utils_attr_get_name(ntfs_volume *vol, ATTR_RECORD *attr, char *buffer, int bufsize)
+int utils_attr_get_name(ntfs_volume *vol, NTFS_ATTR_RECORD *attr, char *buffer, int bufsize)
 {
 	int len, namelen;
 	char *name;
-	ATTR_DEF *attrdef;
+	NTFS_ATTR_DEF *attrdef;

 	// flags: attr, name, or both
 	if (!attr || !buffer) {
@@ -664,7 +664,7 @@
 	/* Does lcn lie in the section of $Bitmap we already have cached? */
 	if ((lcn < bmplcn) || (lcn >= (bmplcn + (sizeof(buffer) << 3)))) {
 		ntfs_log_debug("Bit lies outside cache.\n");
-		attr = ntfs_attr_open(vol->lcnbmp_ni, AT_DATA, AT_UNNAMED, 0);
+		attr = ntfs_attr_open(vol->lcnbmp_ni, NTFS_AT_DATA, NTFS_AT_UNNAMED, 0);
 		if (!attr) {
 			ntfs_log_perror("Couldn't open $Bitmap");
 			return -1;
@@ -711,7 +711,7 @@
  *	    0  MFT Record is unused
  *	   -1  Error occurred
  */
-int utils_mftrec_in_use(ntfs_volume *vol, MFT_REF mref)
+int utils_mftrec_in_use(ntfs_volume *vol, NTFS_MFT_REF mref)
 {
 	static u8 buffer[512];
 	static s64 bmpmref = -sizeof(buffer) - 1; /* Which bit of $BITMAP is in the buffer */
@@ -725,7 +725,7 @@
 	}

 	/* Does mref lie in the section of $Bitmap we already have cached? */
-	if (((s64)MREF(mref) < bmpmref) || ((s64)MREF(mref) >= (bmpmref +
+	if (((s64)NTFS_MREF(mref) < bmpmref) || ((s64)NTFS_MREF(mref) >= (bmpmref +
 			(sizeof(buffer) << 3)))) {
 		ntfs_log_debug("Bit lies outside cache.\n");

@@ -753,11 +753,11 @@
  */
 static int __metadata(ntfs_volume *vol, u64 num)
 {
-	if (num <= FILE_UpCase)
+	if (num <= NTFS_FILE_UpCase)
 		return 1;
 	if (!vol)
 		return -1;
-	if ((vol->major_ver == 3) && (num == FILE_Extend))
+	if ((vol->major_ver == 3) && (num == NTFS_FILE_Extend))
 		return 1;

 	return 0;
@@ -778,9 +778,9 @@
 int utils_is_metadata(ntfs_inode *inode)
 {
 	ntfs_volume *vol;
-	ATTR_RECORD *rec;
-	FILE_NAME_ATTR *attr;
-	MFT_RECORD *file;
+	NTFS_ATTR_RECORD *rec;
+	NTFS_FILE_NAME_ATTR *attr;
+	NTFS_MFT_RECORD *file;
 	u64 num;

 	if (!inode) {
@@ -798,21 +798,21 @@

 	file = inode->mrec;
 	if (file && (file->base_mft_record != 0)) {
-		num = MREF_LE(file->base_mft_record);
+		num = NTFS_MREF_LE(file->base_mft_record);
 		if (__metadata(vol, num) == 1)
 			return 1;
 	}
 	file = inode->mrec;

-	rec = find_first_attribute(AT_FILE_NAME, inode->mrec);
+	rec = find_first_attribute(NTFS_AT_FILE_NAME, inode->mrec);
 	if (!rec)
 		return -1;

 	/* We know this will always be resident. */
-	attr = (FILE_NAME_ATTR *)((char *)rec + le16_to_cpu(rec->value_offset));
+	attr = (NTFS_FILE_NAME_ATTR *)((char *)rec + le16_to_cpu(rec->value_offset));

-	num = MREF_LE(attr->parent_directory);
-	if ((num != FILE_root) && (__metadata(vol, num) == 1))
+	num = NTFS_MREF_LE(attr->parent_directory);
+	if ((num != NTFS_FILE_root) && (__metadata(vol, num) == 1))
 		return 1;

 	return 0;
@@ -923,9 +923,9 @@
 int mft_next_record(struct mft_search_ctx *ctx)
 {
 	s64 nr_mft_records;
-	ATTR_RECORD *attr10 = NULL;
-	ATTR_RECORD *attr20 = NULL;
-	ATTR_RECORD *attr80 = NULL;
+	NTFS_ATTR_RECORD *attr10 = NULL;
+	NTFS_ATTR_RECORD *attr20 = NULL;
+	NTFS_ATTR_RECORD *attr80 = NULL;
 	ntfs_attr_search_ctx *attr_ctx;

 	if (!ctx) {
@@ -945,7 +945,7 @@
 		int in_use;

 		ctx->flags_match = 0;
-		in_use = utils_mftrec_in_use(ctx->vol, (MFT_REF) ctx->mft_num);
+		in_use = utils_mftrec_in_use(ctx->vol, (NTFS_MFT_REF) ctx->mft_num);
 		if (in_use == -1) {
 			ntfs_log_error("Error reading inode %llu.  Aborting.\n",
 					(unsigned long long)ctx->mft_num);
@@ -955,16 +955,16 @@
 		if (in_use) {
 			ctx->flags_match |= FEMR_IN_USE;

-			ctx->inode = ntfs_inode_open(ctx->vol, (MFT_REF) ctx->mft_num);
+			ctx->inode = ntfs_inode_open(ctx->vol, (NTFS_MFT_REF) ctx->mft_num);
 			if (ctx->inode == NULL) {
 				ntfs_log_error("Error reading inode %llu.\n", (unsigned
 						long long) ctx->mft_num);
 				continue;
 			}

-			attr10 = find_first_attribute(AT_STANDARD_INFORMATION, ctx->inode->mrec);
-			attr20 = find_first_attribute(AT_ATTRIBUTE_LIST,       ctx->inode->mrec);
-			attr80 = find_first_attribute(AT_DATA, ctx->inode->mrec);
+			attr10 = find_first_attribute(NTFS_AT_STANDARD_INFORMATION, ctx->inode->mrec);
+			attr20 = find_first_attribute(NTFS_AT_ATTRIBUTE_LIST,       ctx->inode->mrec);
+			attr80 = find_first_attribute(NTFS_AT_DATA, ctx->inode->mrec);

 			if (attr10)
 				ctx->flags_match |= FEMR_BASE_RECORD;
@@ -980,7 +980,7 @@
 			if (ctx->flags_search & FEMR_DIR) {
 				attr_ctx = ntfs_attr_get_search_ctx(ctx->inode, NULL);
 				if (attr_ctx) {
-					if (ntfs_attr_lookup(AT_INDEX_ROOT, NTFS_INDEX_I30, 4, 0, 0, NULL, 0, attr_ctx) == 0)
+					if (ntfs_attr_lookup(NTFS_AT_INDEX_ROOT, NTFS_INDEX_I30, 4, 0, 0, NULL, 0, attr_ctx) == 0)
 						ctx->flags_match |= FEMR_DIR;

 					ntfs_attr_put_search_ctx(attr_ctx);
@@ -1018,8 +1018,8 @@
 				return -1;
 			}

-			mft = ntfs_attr_open(ctx->vol->mft_ni, AT_DATA,
-					AT_UNNAMED, 0);
+			mft = ntfs_attr_open(ctx->vol->mft_ni, NTFS_AT_DATA,
+					NTFS_AT_UNNAMED, 0);
 			if (!mft) {
 				ntfs_log_perror("Couldn't open $MFT/$DATA");
 				// free / close
diff -uraN -x 'configu*' -x 'Change*' -x '*.m4' -x '*doc*' -x '*test*' -x '*TODO*' -x '*autom4te*' ../ntfsprogs-2.0.0/ntfsprogs/utils.h ./ntfsprogs/utils.h
--- ../ntfsprogs-2.0.0/ntfsprogs/utils.h	2007-09-19 18:51:09.000000000 +0200
+++ ./ntfsprogs/utils.h	2007-10-06 16:48:06.000000000 +0200
@@ -27,9 +27,9 @@

 #include "config.h"

-#include "types.h"
-#include "layout.h"
-#include "volume.h"
+#include "ntfs_types.h"
+#include "ntfs_layout.h"
+#include "ntfs_volume.h"

 #ifdef HAVE_ERRNO_H
 #include <errno.h>
@@ -43,17 +43,17 @@
 extern const char *ntfs_gpl;

 int utils_set_locale(void);
-int utils_parse_size(const char *value, s64 *size, BOOL scale);
-int utils_parse_range(const char *string, s64 *start, s64 *finish, BOOL scale);
+int utils_parse_size(const char *value, s64 *size, NTFS_BOOL scale);
+int utils_parse_range(const char *string, s64 *start, s64 *finish, NTFS_BOOL scale);
 int utils_inode_get_name(ntfs_inode *inode, char *buffer, int bufsize);
-int utils_attr_get_name(ntfs_volume *vol, ATTR_RECORD *attr, char *buffer, int bufsize);
+int utils_attr_get_name(ntfs_volume *vol, NTFS_ATTR_RECORD *attr, char *buffer, int bufsize);
 int utils_cluster_in_use(ntfs_volume *vol, long long lcn);
-int utils_mftrec_in_use(ntfs_volume *vol, MFT_REF mref);
+int utils_mftrec_in_use(ntfs_volume *vol, NTFS_MFT_REF mref);
 int utils_is_metadata(ntfs_inode *inode);
 void utils_dump_mem(void *buf, int start, int length, int flags);

-ATTR_RECORD * find_attribute(const ATTR_TYPES type, ntfs_attr_search_ctx *ctx);
-ATTR_RECORD * find_first_attribute(const ATTR_TYPES type, MFT_RECORD *mft);
+NTFS_ATTR_RECORD * find_attribute(const NTFS_ATTR_TYPES type, ntfs_attr_search_ctx *ctx);
+NTFS_ATTR_RECORD * find_first_attribute(const NTFS_ATTR_TYPES type, NTFS_MFT_RECORD *mft);

 int utils_valid_device(const char *name, int force);
 ntfs_volume * utils_mount_volume(const char *device, ntfs_mount_flags flags);
@@ -65,7 +65,7 @@
 #define FEMR_IN_USE		(1 << 0)
 #define FEMR_NOT_IN_USE		(1 << 1)
 #define FEMR_FILE		(1 << 2)		// $DATA
-#define FEMR_DIR		(1 << 3)		// $INDEX_ROOT, "$I30"
+#define FEMR_DIR		(1 << 3)		// $NTFS_INDEX_ROOT, "$I30"
 #define FEMR_METADATA		(1 << 4)
 #define FEMR_NOT_METADATA	(1 << 5)
 #define FEMR_BASE_RECORD	(1 << 6)
--- ../ntfsprogs-2.0.0/configure.ac	2007-09-26 21:48:52.000000000 +0200
+++ ./configure.ac	2007-10-06 16:48:48.000000000 +0200
@@ -169,7 +169,7 @@
 PKG_PROG_PKG_CONFIG
 
 # Libraries often install their metadata .pc files in directories not searched
-# by pkg-config. Let's workaround this. 
+# by pkg-config. Let's workaround this.
 export PKG_CONFIG_PATH=${PKG_CONFIG_PATH}:/usr/lib/pkgconfig:/opt/gnome/lib/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig:$prefix/lib/pkgconfig:/opt/gnome/share/pkgconfig:/usr/local/share/pkgconfig
 
 # Enable large file support.
@@ -357,7 +357,7 @@
 	endian.h byteswap.h sys/byteorder.h sys/endian.h sys/param.h \
 	sys/ioctl.h sys/mount.h sys/stat.h sys/types.h sys/vfs.h \
 	sys/statvfs.h sys/sysmacros.h linux/major.h linux/fd.h linux/hdreg.h \
-	machine/endian.h windows.h syslog.h pwd.h])
+	machine/endian.h windows.h syslog.h pwd.h sys/cdefs.h])
 
 # Checks for typedefs, structures, and compiler characteristics.
 AC_HEADER_STDBOOL
